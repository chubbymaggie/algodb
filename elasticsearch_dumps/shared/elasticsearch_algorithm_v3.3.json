[
{"_index":"throwtable","_type":"algorithm","_id":"medical-algorithm","_score":0,"_source":{"description":"A medical algorithm is any computation, formula, statistical survey, nomogram, or look-up table, useful in healthcare. Medical algorithms include decision tree approaches to healthcare treatment (e.g., if symptoms A, B, and C are evident, then use treatment X) and also less clear-cut tools aimed at reducing or defining uncertainty.","alt_names":["- Algorithm (medical) :","- Medical algorithm :","-> Read more about Medical algorithm","...more on Wikipedia about Algorithm (medical)","...more on Wikipedia about Medical algorithm","Algorithm (medical)","Algorithm (medical); it is used under the","Algorithm_(medical)","As long as you do exactly what we","Diagnostic algorithm","Lekárske algoritmus","Lääketieteellinen algoritmi","Lékařské algoritmus","Medical Algorithm","Medical Algorithm Wikipedia","Medical algoritem","Medical algorithm","Medical algorithm - Wikipedia :: The free encyclopedia","Medical algorithm - Wikipedia, the free encyclopedia","Medical algorithm Wikipedia the free encyclopedia","Medical algorithm; it is used under the","Medical algorithms","Medical algorithms; it is used under the","Medical algoritm","Medical algoritmo","Medical algoritms","Medical algorytm","Medical algorytmu","Medical-Algorithmus","Medical_algorithm","Medicinos algoritmas","Medicinsk algoritm","Medicinsk algoritme","Medicinska algoritm","Medicīnas algoritms","Medische algoritme","Medisinsk algoritme","Medisinsk algoritmen","Medizinische Algorithmus","Metge algorisme","Mjekësi algorithm","Médico algoritmo","Orvosi algoritmus","Orvosi algoritmust","Tıbbi algoritması","Wikipedia Medical algorithm","Wikipedia article Algorithm (medical)","Wikipedia article Medical algorithm","Wikipedia article Medical algorithms","Wikipedia article Medical_algorithm","Wikipedia article on Algorithm (medical)","Wikipedia entry for Medical algorithm","Wikipedia: Medical algorithm","Wikipedia:Medical_algorithms","algorisme de Medicina","algoritam Medical","algoritam Medicinska","algoritem Medical","algorithm mjekësore","algorithme médicale","algoritm medical","algoritma Medis","algoritma medis","algoritme de Medicina","algoritme mjekësore","algoritmi medicale","algoritmi mediku","algoritmo de Medicina","algoritmo medica","algoritmos médica","algoritmu Mediku","algorytm medyczne","các thuật toán y tế","diagnostic algorithm","en.wikipedia.org/...Medical_algorithm","en.wikipedia.org/wiki/Algorithm_(medical)","http://en.wikipedia.org/wiki/Algorithm_%28medical%29","http://en.wikipedia.org/wiki/Medical_algorithm","l'algorithme médical","lekarza algorytmów","lekárske algoritmy","les algorithmes médicaux","lääketieteen algoritmeja","medical algorithm","medical algorithm for assessment and treatment of overweight","medical algorithm wikipedia the free encyclopedia","medical algorithms","medical computer algorithm","medicinos algoritmai","medicinska algoritmer","medicinske algoritme","medikal na algorithm","medische algoritmen","medizinische Algorithmen","scoring systems","y tế thuật toán","ιατρικούς αλγόριθμους","Медицинска алгоритам","Медицински алгоритам","Медицински алгоритъм","Медицинский алгоритм","Медичний алгоритм","медицински алгоритми","медицинский алгоритм","медичний алгоритм","медичних алгоритмів","אלגוריתם רפואי","אלגוריתמים רפואי","الخوارزمية الطبية","خوارزميات الطبية","خوارزمية الطبية","चिकित्सा एल्गोरिथ्म","चिकित्सा एल्गोरिदम","ขั้นตอนวิธีการการแพทย์","ขั้นตอนวิธีการทางการแพทย์","ขั้นตอนวิธีการแพทย์","のアルゴリズムは、ヘルスケア","医疗算法","医療アルゴリズム","医療アルゴリズムを","의료 알고리즘을"],"name":"Medical algorithm","categories":["Algorithms","All articles that may contain original research","All articles to be expanded","Articles needing translation from Russian Wikipedia","Articles that may contain original research from October 2007","Articles to be expanded from September 2015","Health informatics","Knowledge representation"],"tag_line":"A medical algorithm is any computation, formula, statistical survey, nomogram, or look-up table, useful in healthcare."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bareiss-algorithm","_score":0,"_source":{"description":"In mathematics, the Bareiss algorithm, named after Erwin Bareiss, is an algorithm to calculate the determinant or the echelon form of a matrix with integer entries using only integer arithmetic; any divisions that are performed are guaranteed to be exact (there is no remainder). The method can also be used to compute the determinant of matrices with (approximated) real entries, avoiding the introduction any round-off errors beyond those already present in the input.\nDuring the execution of Bareiss algorithm, every integer that is computed is the determinant of a submatrix of the input matrix. This allows, using Hadamard inequality, to bound the size of these integers. Otherwise, Bareiss algorithm may be viewed as a variant of Gaussian elimination and needs roughly the same number of arithmetic operations.\nIt follows that, for an n × n matrix of maximum (absolute) value 2L for each entry, the Bareiss algorithm runs in O(n3) elementary operations with an O(n n/2 2nL) bound on the absolute value of intermediate values needed. Its computational complexity is thus O(n5L2 (log(n)2 + L2)) when using elementary arithmetic or O(n4L (log(n) + L) log(log(n) + L))) by using fast multiplication.\nThe general Bareiss algorithm is distinct from the Bareiss algorithm for Toeplitz matrices.","alt_names":["A 1 = 2 - 1 - 3 1 3 0","Bareiss Algorithm","Bareiss algorithm","Bareiss algorithm - Wikipedia :: The free encyclopedia","Bareiss algorithm - Wikipedia, the free encyclopedia","Bareiss's Algorithm","Ingeniero Montante","M?todo Montante - Wikipedia, la enciclopedia libre","Metodo Montante","Montante's method","Montante's method - Wikipedia, the free ...","Montante's method - Wikipedia, the free encyclopedia","Mtante's method","Mtodo Mtante la enciclopedia libre","Método Montante","Método Montante - Wikipedia, la enciclopedia libre","Wikipedia Método Montante","Wikipedia article Bareiss Algorithm","Wikipedia article Bareiss algorithm","Wikipedia article Montante's method","Wikipedia article Метод Монтанте","Wikipedia entry for Bareiss algorithm","artículo de Wikipedia Metodo Montante","en.wikipedia.org/wiki/Bareiss_algorithm","en.wikipedia.org/wiki/Montante%27s_method","es:Método Montante","http://en.wikipedia.org/wiki/Bareiss_algorithm","http://en.wikipedia.org/wiki/Bareiss_algorithm.","http://en.wikipedia.org/wiki/Montante%27s_method","http://es.wikipedia.org/wiki/M%C3%A9todo_Montante","http://pl.wikipedia.org/wiki/Algorytm_Bareissa","алгоритъма на Bareiss"],"name":"Bareiss algorithm","categories":["Algorithms and data structures stubs","All stub articles","Computer algebra","Computer science stubs","Determinants","Exchange algorithms","Numerical linear algebra"],"tag_line":"In mathematics, the Bareiss algorithm, named after Erwin Bareiss, is an algorithm to calculate the determinant or the echelon form of a matrix with integer entries using only integer arithmetic; any divisions that are performed are guaranteed to be exact (there is no remainder)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"the-algorithm-auction","_score":0,"_source":{"description":"The Algorithm Auction is the world’s first auction of computer algorithms. Created by Ruse Laboratories, the initial auction featured seven lots and was held at the Cooper Hewitt, Smithsonian Design Museum on March 27, 2015.\nFive lots were physical representations of famous code or algorithms, including a signed, handwritten copy of the original Hello, World! C program by its creator Brian Kernighan on dot-matrix printer paper, a printed copy of 5,000 lines of Assembly code comprising the earliest known version of Turtle Graphics, signed by its creator Hal Abelson, a necktie containing the six-line qrpff algorithm capable of decrypting content on a commercially produced DVD video disc, and a pair of drawings representing OKCupid’s original Compatibility Calculation algorithm, signed by the company founders. The qrpff lot sold for $2,500.\nTwo other lots were “living algorithms,” including a set of JavaScript tools for building applications that are accessible to the visually impaired and the other is for a program that converts lines of software code into music. Winning bidders received, along with artifacts related to the algorithms, a full intellectual property license to use, modify, or open-source the code. All lots were sold, with Hello World receiving the most bids.\nExhibited alongside the auction lots were a facsimile of the Plimpton 322 tablet on loan from Columbia University, and Nigella, an art-world facing computer virus named after Nigella Lawson and created by cypherpunk and hacktavist Richard Jones.\nSebastian Chan, Director of Digital & Emerging Media at the Cooper–Hewitt, attended the event remotely from Milan, Italy via a Beam Pro telepresence robot.","alt_names":[],"name":"The Algorithm Auction","categories":["2015 in computer science","Algorithms","Visual arts"],"tag_line":"The Algorithm Auction is the world’s first auction of computer algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"kinodynamic-planning","_score":0,"_source":{"description":"In robotics and motion planning, kinodynamic planning is a class of problems for which velocity, acceleration, and force/torque bounds must be satisfied, together with kinematic constraints such as avoiding obstacles. The term was coined by Bruce Donald, Pat Xavier, John Canny, and John Reif. Donald et al. developed the first polynomial-time approximation schemes (PTAS) for the problem. By providing a provably polynomial-time ε-approximation algorithm, they resolved a long-standing open problem in optimal control. Their first paper considered time-optimal control (\"fastest path\") of a point mass under Newtonian dynamics, amidst polygonal (2D) or polyhedral (3D) obstacles, subject to state bounds on position, velocity, and acceleration. Later they extended the technique to many other cases, for example, to 3D open-chain kinematic robots under full Lagrangian dynamics. More recently, many practical heuristic algorithms based on stochastic optimization and iterative sampling were developed, by a wide range of authors, to address the kinodynamic planning problem. These techniques for kinodynamic planning have been shown to work well in practice. However, none of these heuristic techniques can guarantee the optimality of the computed solution (i.e., they have no performance guarantees), and none can be mathematically proven to be faster than the original PTAS algorithms (i.e., none have a provably lower computational complexity).","alt_names":["Kinodynamic planning","Kinodynamic planning - Wikipedia, the free encyclopedia","Kinodynamic_planning","Wikipedia article Kinodynamic planning","Wikipedia entry for Kinodynamic planning","http://en.wikipedia.org/wiki/Kinodynamic_planning","http://th.wikipedia.org/wiki/Kinodynamic_planning"],"name":"Kinodynamic planning","categories":["Algorithms","Automated planning and scheduling","Robot control","Robot kinematics"],"tag_line":"In robotics and motion planning, kinodynamic planning is a class of problems for which velocity, acceleration, and force/torque bounds must be satisfied, together with kinematic constraints such as avoiding obstacles."}}
,{"_index":"throwtable","_type":"algorithm","_id":"out-of-core-algorithm","_score":0,"_source":{"description":"Out-of-core or external memory algorithms are algorithms that are designed to process data that is too large to fit into a computer's main memory at one time. Such algorithms must be optimized to efficiently fetch and access data stored in slow bulk memory such as hard drives or tape drives.\nA typical example is geographic information systems, especially digital elevation models, where the full data set easily exceeds several gigabytes or even terabytes of data.\nThis notion naturally extends to a network connecting a data server to a treatment or visualization workstation. Popular mass-of-data based web applications such as google-Map or google-Earth enter this topic.\nThis extends beyond general purpose CPUs, and also includes GPU computing as well as classical digital signal processing. In GPGPU based computing where powerful graphics cards (GPUs) with little memory (compared to the more familiar system memory which is most often referred to simply as RAM) and slow CPU to GPU memory transfer (when compared to computation bandwidth).","alt_names":["External memory algorithm","External memory algorithm; it is used under the","I/O algorithm","Out of core algorithm","Out-of-core","Out-of-core algorithm","Out-of-core algorithm - Wikipedia, the free encyclopedia","Wikipedia article External memory algorithm","Wikipedia article Out-of-core","Wikipedia article Out-of-core algorithm","Wikipedia article Out-of-core algoritme","Wikipedia article on External memory algorithm","Wikipedia article on Out-of-core","Wikipedia entry for Out-of-core algorithm","efficient memory management","external memory algorithm","external memory algorithms","http://en.wikipedia.org/wiki/External_memory_algorithm","http://en.wikipedia.org/wiki/Out-of-core","http://en.wikipedia.org/wiki/Out-of-core_algorithm","nce, see http://en.wikipedia.org/","or out-of-cor","out of core","out of core algorithm","out-of-cor","out-of-core","out-of-core implementation"],"name":"Out-of-core algorithm","categories":["Algorithms","Algorithms and data structures stubs","All stub articles","Computer science stubs"],"tag_line":"Out-of-core or external memory algorithms are algorithms that are designed to process data that is too large to fit into a computer's main memory at one time."}}
,{"_index":"throwtable","_type":"algorithm","_id":"chinese-whispers-(clustering-method)","_score":0,"_source":{"description":"Chinese Whispers is a clustering method used in network science named after the famous whispering game. Clustering methods are basically used to identify communities of nodes or links in a given network. This algorithm was designed by Chris Biemann and Sven Teresinak in 2005. The name comes from the fact that the process can be modeled as a separation of communities where the nodes send the same type of information to each other.\nChinese Whispers is a hard partitioning, randomized, flat clustering (no hierarchical relations between clusters) method. The random property means that running the process on the same network several times can lead to different results, while because of hard partitioning one node can only belong to one cluster at a given moment. The original algorithm is applicable to undirected, weighted and unweighted graphs. Chinese Whispers is time linear which means that it is extremely fast even if the number of nodes and links are very high in the network.","alt_names":[],"name":"Chinese Whispers (clustering method)","categories":["Algorithms","All orphaned articles","Orphaned articles from June 2015"],"tag_line":"Chinese Whispers is a clustering method used in network science named after the famous whispering game."}}
,{"_index":"throwtable","_type":"algorithm","_id":"randomized-rounding","_score":0,"_source":{"description":"Within computer science and operations research, many combinatorial optimization problems are computationally intractable to solve exactly (to optimality). Many such problems do admit fast (polynomial time) approximation algorithms—that is, algorithms that are guaranteed to return an approximately optimal solution given any input.\nRandomized rounding (Raghavan & Tompson 1987) is a widely used approach for designing and analyzing such approximation algorithms. The basic idea is to use the probabilistic method to convert an optimal solution of a relaxation of the problem into an approximately optimal solution to the original problem.","alt_names":["Randomized rounding","Randomized rounding - Wikipedia, the free encyclopedia","Randomized rounding Wikipedia the free encyclopedia","Wikipedia article Randomized rounding","c2b034333e20823cfa72f99bad9b ...","http://en.wikipedia.org/wiki/Randomized rounding","http://en.wikipedia.org/wiki/Randomized_rounding","randomized rounding","yago-res:Randomized rounding"],"name":"Randomized rounding","categories":["Algorithms","All Wikipedia articles needing clarification","Pages using duplicate arguments in template calls","Probabilistic arguments","Wikipedia articles needing clarification from May 2010"],"tag_line":"Within computer science and operations research, many combinatorial optimization problems are computationally intractable to solve exactly (to optimality)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hybrid-algorithm","_score":0,"_source":{"description":"A hybrid algorithm is an algorithm that combines two or more other algorithms that solve the same problem, either choosing one (depending on the data), or switching between them over the course of the algorithm. This is generally done to combine desired features of each, so that the overall algorithm is better than the individual components.\n\"Hybrid algorithm\" does not refer to simply combining multiple algorithms to solve a different problem – many algorithms can be considered as combinations of simpler pieces – but only to combining algorithms that solve the same problem, but differ in other characteristics, notably performance.","alt_names":["hybrid algorithm"],"name":"Hybrid algorithm","categories":["Algorithms","All articles lacking sources","Articles lacking sources from May 2014"],"tag_line":"A hybrid algorithm is an algorithm that combines two or more other algorithms that solve the same problem, either choosing one (depending on the data), or switching between them over the course of the algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"edgerank","_score":0,"_source":{"description":"EdgeRank is the name commonly given to the algorithm that Facebook uses to determine what articles should be displayed in a user's News Feed. As of 2011, Facebook has stopped using the \"EdgeRank\" term internally to refer to its News Feed ranking algorithm, and in 2013, uses an algorithm that takes more than 100,000 factors into account in addition to EdgeRank's three.","alt_names":[],"name":"EdgeRank","categories":["Algorithms","All stub articles","CS1 errors: external links","Facebook","World Wide Web stubs"],"tag_line":"EdgeRank is the name commonly given to the algorithm that Facebook uses to determine what articles should be displayed in a user's News Feed."}}
,{"_index":"throwtable","_type":"algorithm","_id":"algorithmics","_score":0,"_source":{"description":"Algorithmics is the science of algorithms. It includes algorithm design, the art of building a procedure which can solve efficiently a specific problem or a class of problem, algorithmic complexity theory, the study of estimating the hardness of problems by studying the properties of algorithm that solves them, or algorithm analysis, the science of studying the properties of a problem, such as quantifying resources in time and memory space needed by this algorithm to solve this problem.","alt_names":[],"name":"Algorithmics","categories":["Algorithms"],"tag_line":"Algorithmics is the science of algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pseudocode","_score":0,"_source":{"description":"Pseudo code is an informal high-level description of the operating principle of a computer program or other algorithm.\nIt uses the structural conventions of a programming language, but is intended for human reading rather than machine reading. Pseudocode typically omits details that are essential for machine understanding of the algorithm, such as variable declarations, system-specific code and some subroutines. The programming language is augmented with natural language description details, where convenient, or with compact mathematical notation. The purpose of using pseudocode is that it is easier for people to understand than conventional programming language code, and that it is an efficient and environment-independent description of the key principles of an algorithm. It is commonly used in textbooks and scientific publications that are documenting various algorithms, and also in planning of computer program development, for sketching out the structure of the program before the actual coding takes place.\nNo standard for pseudocode syntax exists, as a program in pseudocode is not an executable program. Pseudocode resembles, but should not be confused with skeleton programs which can be compiled without errors. Flowcharts, drakon-charts and Unified Modeling Language (UML) charts can be thought of as a graphical alternative to pseudocode, but are more spacious on paper.\n\n","alt_names":["pseudo-language","pseudo code","Pseudocode","pseudocode","псевдокода","псевдокоде","维基百科(Wikipedia)","pseudokod","псевдокод","伪代码","pseudo-code","pseudokodzie","擬似コードを","psuedocode","pseudocodice","Pseudo code","Pseudocódigo","Pseudo-Code","Pseudo-code","擬似コード","Pseudo Code","pseudocódigo","(6) - pseudokód (wiki)","- Pseudo code :","- Pseudocode :","-> Leggi tutto l'articolo su 'Pseudocodice'","-> Read the article about 'Pseudocode'",". Pseudocódigo","...Wikipedia Pseudocodice","...Wikipedia Pseudocódigo","...Wikipedia Pseudokod","...Wikipedia Pseudolinguaggio","...mehr auf Wikipedia über Pseudocode","...more on Wikipedia about Pseudocode","1 Definición de datos del Pseudocódigo","1. Pseudocode - Wikipedia, the free encyclopedia","2 Definición de estructuras de control","2 Funciones y operaciones","2 Sintaksis","2.1 Secuencial","2.2 Selectiva","2.3 Iterativa","3 Definición de estructuras de control","3 El anidamiento","3 Examples of pseudocode","3 Mathematical style pseudocode","3.1 Secuencial","3.2 Selectiva","3.2.1 Selectiva doble (alternativa)","3.2.2 Selectiva múltiple","3.2.3 Selectiva múltiple-Casos","3.3 Iterativa","3.3.1 Bucle mientras","3.3.2 Bucle repetir","3.3.3 Bucle para","3.3.4 Bucle para cada","3.4 El anidamiento","4 Compilation","4 Desarrollo de algoritmos","4 Machine compilation of pseudo-code style languages","4.1 Natural language grammar in programming languages","4.2 Mathematical programming languages","4.3 Alternative forms of pseudocode","5 Funciones y procedimientos","6 Ventajas de utilizar un Pseudocódigo a un","9. Definición de pseudocódigo.","< Apunte IMPORTANTE Pseudocódigo >","<<-- pseudocodigo -->>","<http://de.wikipedia.org/wiki/Pseudocode","A definition of Pseudocode from Wikipedia","Definicion de pseudocodigo1","Definición de estructuras de control","Definition of Psuedocode","Haz Clic Aquí Para Ver PseudoCodigo (Wikipedia)","Importancia de la estructuras selectivas","Introduce pseudocode.","Kode palsu","Kode palsu - Wikipedia bahasa Indonesia, ensiklopedia bebas","Kode palsu :: Wikipedia Bahasa Indonesia","Learn about Pseudocode>>>","Machine compilation ...","Machine compilation of pse...","Machine compilation or interpretation","Mathematical style ...","Mathematical style pseudoco...","Mathematical style pseudocode","More on Pseudo-codes","Mã giả - Wikipedia tiếng Việt","Nocão de Pseudocódigo (Wikipedia em Português)","Outro link","PSEUDOCODIGO","PSEUDOKODA","Pesquise por pseudocódigo na Wikipedia!","Portugues Estruturado","PsedoCode","Pseudkod","Pseudo Code definition at Wikipedia","Pseudo code definition","Pseudo códigos","Pseudo-code - Wikip?dia","Pseudo-code - Wikipédia","Pseudo-código","Pseudo-linguagem","Pseudoc digo Wikipedia la enciclopedia libre","Pseudoc?digo - Wikip?dia, a enciclop?dia livre","Pseudoc?digo - Wikipedia, la enciclopedia libre","Pseudoc?digo ? Wikip?dia, a enciclop?dia livre","Pseudocigo","Pseudoco - Wikipedia, la enciclopedia libre","Pseudocode (Wikipedia)","Pseudocode - Mã giả","Pseudocode - Simple English Wikipedia, the free encyclopedia","Pseudocode - Wikipedia","Pseudocode - Wikipedia, the free ...","Pseudocode - Wikipedia, the free encyclopedia","Pseudocode ? Wikipedia","Pseudocode Definition","Pseudocode Definition.","Pseudocode Wikipedia","Pseudocode Wikipedia the free encyclopedia","Pseudocode article in Wikipedia","Pseudocode bei der wikipedia","Pseudocode definition","Pseudocode definition from wikipedia","Pseudocode example [wikipedia]","Pseudocode in","Pseudocode in Wikipedia Nederland zoeken","Pseudocode on Wikipedia","Pseudocode on wikipedia.org","Pseudocode |","Pseudocode – Wikipedia","Pseudocode, the free encyclopedia - Wikipedia","Pseudocode-Beschreibung auf Wikipedia","Pseudocode: Examples of pseudocode","Pseudocode; it is used under the","Pseudocode?","Pseudocodi","Pseudocodice","Pseudocodice - Wikipedia","Pseudocodigo y estructuras condicionales","Pseudocodigo y estructuras de control","Pseudocoding","PseudocÃ³digo - Wikipedia, la enciclopedia libre","Pseudocódigo (Wikipedia)","Pseudocódigo - Wikipedia","Pseudocódigo - Wikipedia, la enciclopedia libre","Pseudocódigo - Wikipédia, a enciclopédia livre","Pseudocódigo archivo","Pseudocódigo en Wikipedia","Pseudocódigo – Wikipédia","Pseudocódigo – Wikipédia, a enciclopédia livre","Pseudocódigos","Pseudokielinen","Pseudokod","Pseudokod - Wikipedia","Pseudokod enligt Wikipedia","Pseudokod – Wikipedia, wolna encyklopedia","Pseudokode","Pseudokode bei der wikipedia","Pseudokoodi","Pseudokoodilla","Pseudokoodina","Pseudokód","Pseuducode","Psevdokoda","Psudocode","Psuedo-Code","Psuedocode","Psuodo Code","Pszeudok d Wikip dia","Pszeudokód","Regras para pseudocódigo","Selectiva doble","Source Wikipedia.org Arcticle - Pseudocode","Sözde kod","Sözde kod - Vikipedi","Tema de fundamentos de programación","Ventajas de utilizar un Pseudocódigo a un diagrama","Verbete Pseudocode Wikipedia","Vikipedi'deki Pseudocode","Vikipedi'deki Sözde kod","What does Psedocode Mean? Read about it....","What is pseudocode","Wiki - Pseudocode","Wiki: Pseudocode","Wikipedia (Pseudocode)","Wikipedia - Pseudocode","Wikipedia Pseudocódigo","Wikipedia article Kode palsu","Wikipedia article Pseudo-code","Wikipedia article Pseudocode","Wikipedia article Pseudocódigo","Wikipedia article Pseudokod","Wikipedia article Pseudokode","Wikipedia article Psevdokoda","Wikipedia article Psuedocode","Wikipedia article Pszeudokód","Wikipedia article Sözde kod","Wikipedia article about Pseudocode","Wikipedia article about pseudocode","Wikipedia article on Pseudo code","Wikipedia article on Pseudocode","Wikipedia article on Pseudocódigo","Wikipedia article on Psuedocode","Wikipedia article Программа жобасының тілі","Wikipedia article รหัสเทียม","Wikipedia artikel Pseudocode","Wikipedia entry for Pseudocode","Wikipedia l'articolo Pseudolinguaggio","Wikipedia on Pseudocode","Wikipedia te entrega otros enlaces","Wikipedia-Artikel Pseudocode","Wikipedia-Artikel Pseudokode","Wikipedia-Seite zu 'Pseudocode'","Wikipedia. Pseudocode","Wikipedia.org: Псевдокод_(язык_описания_алгоритмов)","Wikipedia: Pseudocode","Wikipedia:Pseudocode","Wikipedia:Pseudocodice","Wikipediabeschreibung Pseudocode","Wikipediaで「擬似コード」を調べる","[6] Pseudocode","a pseudo code","algoritmo (Pseudocódigo)","article Pseudocode","article on pseudocode","artigo da Wikipédia Pseudocódigo","artículo de Wikipedia Pseudocodigo","artículo de Wikipedia Pseudocódigo","artículo de Wikipedia Seudolenguaje informático","ca:Pseudocodi","condición SI","cs:Pseudokód","de.wikipedia.org/wiki/Pseudocode","de:Pseudocode","diagramas de","ease Tambien en Aqui","el:Ψευδοκώδικας","en.wikipedia.org/Pseudocode","en.wikipedia.org/wiki/Pseudocode","es:PseudocÃģdigo","es:Pseudocódigo","fa:شبهکد","falso código","far from pseudo code","fi:Pseudokoodi","fr:Pseudo-code","giả mã","gl:Pseudocódigo","he:פסאודו קוד","he:פסידו-קוד","http://ca.wikipedia.org/wiki/Pseudocodi","http://cs.wikipedia.org/wiki/Pseudok%C3%B3d","http://cs.wikipedia.org/wiki/Pseudokód","http://de.wikipedia.org/wiki/Pseudocode","http://de.wikipedia.org/wiki/Pseudocode)","http://el.wikipedia.org/wiki/Ψευδοκώδικας","http://em.wikipedia.org/wiki/Pseudocode","http://en.wikipedia....eudocode#Syntax","http://en.wikipedia....iki/Pseudo-code","http://en.wikipedia....wiki/Pseudocode","http://en.wikipedia....wiki/Psuedocode","http://en.wikipedia.org/wiki/Pseudo-code","http://en.wikipedia.org/wiki/Pseudo_code","http://en.wikipedia.org/wiki/Pseudoc..._of_pseudocode","http://en.wikipedia.org/wiki/Pseudocode","http://en.wikipedia.org/wiki/Pseudocode →","http://en.wikipedia.org/wiki/Pseudocode# Syntax","http://en.wikipedia.org/wiki/Pseudocode#Examples","http://en.wikipedia.org/wiki/Pseudocode#Examples_of_pseudocode","http://en.wikipedia.org/wiki/Pseudocode#Syntax","http://en.wikipedia.org/wiki/Pseudocode#…","http://en.wikipedia.org/wiki/Pseudocode.","http://en.wikipedia.org/wiki/Psuedocode","http://es....%C3%B3digo","http://es.wikipedia....eudoc%C3%B3digo","http://es.wikipedia.org/wiki/Pseudoc%C3%...","http://es.wikipedia.org/wiki/Pseudoc%C3%B3digo","http://es.wikipedia.org/wiki/Pseudoc%C3%…","http://es.wikipedia.org/wiki/Pseudocodigo","http://es.wikipedia.org/wiki/Pseudocodig…","http://es.wikipedia.org/wiki/Pseudocódigo","http://es.wikipedia.org/wiki/Pseudocódig…","http://fi.wikipedia.org/wiki/Pseudokoodi","http://fr.wikipedia.org/wiki/Pseudo-code","http://hu.wikipedia.org/wiki/pszeudokód","http://id.wikipedia.org/wiki/Kode_palsu","http://id.wikipedia.org/wiki/Pseudocode","http://it.wikipedia.org/wiki/Pseudocodice","http://nl.wikipedia.org/wiki/Pseudocode","http://no.wikipedia.org/wiki/Pseudokode","http://pl.wikipedia.org/wiki/Pseudokod","http://pt.wikipedia.org/wiki/Pseudoc%C3%B3digo","http://pt.wikipedia.org/wiki/Pseudoc%C3%…","http://pt.wikipedia.org/wiki/Pseudocódigo","http://ru.wikipedia.org/wiki/Псевдокод_(язык_описания_алгоритмов)","http://sv.wikipedia.org/wiki/Pseudokod","http://tr.wikipedia.org/wiki/S%C3%B6zde_kod","http://tr.wikipedia.org/wiki/s%c3%b6zde_kod","http://vi.wikipedia.org/wiki/M%C3%A3_gi","http://vi.wikipedia.org/wiki/Mã_giả","http://www.de.wikipedia.org/wiki/Pseudocode","hu:Pszeudokód","id:Kode palsu","it:Pseudocodice","ja:擬似コード","ko:의사코드","l'article de Wikipédia Pseudo-code","l'article de Wikipédia Pseudocode","langue pseudo-","leer esto.","more about pseudocode","mã giả","n Pseudocode","n pseudocode:","nl:Pseudocode","no:Pseudokode","pl:Pseudokod","pseduocode","pseido","pseudo codes","pseudo código","pseudo koda","pseudo kode","pseudo-coded","pseudo-codes","pseudo-codice","pseudo-código","pseudo-código resumido","pseudo-cógido","pseudo-langue","pseudo-linguagem","pseudocod","pseudocode is a term","pseudocode is as simple as it can get","pseudocode softwares","pseudocode wikipedia the free encyclopedia","pseudocode,","pseudocode.","pseudocodes","pseudocodi","pseudocodifica","pseudocodificación","pseudocodigo","pseudocodigos","pseudocodul","pseudocodului","pseudocone","pseudocódigo,","pseudocódigos","pseudokodem","pseudokodom","pseudokodą","pseudokoodia","pseudokoodina","pseudokód","pseudolinguaggio","pseudoprogrammeertaal","psevdokodi","psudo kode","psudocode","psuedokoden","pszeudokóddal","pt:Pseudocódigo","ro:Limbaj pseudocod","ru:Псевдокод (язык описания алгоритмов)","s Pseudocode","s pseudocod","seudo código","seudocode d","seudocodigos","simple:Pseudocode","sl:Psevdokoda","sr:Псеудокод","sv:Pseudokod","th:รหัสเทียม","the wikipedia entry on pseudo-code","the wikipedia page about pseudo code","tr:Sözde kod","ttp://en.wikipedia.org/wiki/Pseudocode.","uk:Псевдокод","vi:Mã giả","wikipedia article on pseudocode","without a programming language","zh:伪代码","~pseudocoding","Ψευδοκώδικας","Ψευδοκώδικας(Pseudocode)","ВИКИПЕДИЯ: ПСЕВДОКОД","Википедии статью Псевдокод (язык описания алгоритмов)","Вот здесь глянь","Псевдокод","Псевдокод (язык описания алгоритмов)","почитайте описание в Википедии","програмчилж","псевдокода.","בפסודו קוד","ויקיפדיה - 'פסאודו קוד'","לא שגיתי","פסאודו קוד – ויקיפדיה","פסאודו-קוד","شبهکد","شبهکد - ویکیپدیا","شبهکد - ویکیپدیا - Wikipedia","شثِ کذ","۲ گرامر","۲.۱ مثال ها","۳ شبه کد ریاضی گونه","۴ کامپایل ماشین یا تفسیر","۵ زبان های برنامه نویسی ریاضی","รหัสเทียม","“Pseudocode - Wikipedia, the free encyclopedia”, en.wikipedia.org","„pseudokodzie”)","「擬似コード」をWikipediaで調べる","ウィキペディアの記事 擬似コード","ウィキペディア：疑似 (擬似) コード","伪代码- 维基百科，自由的百科全书","伪码","偽代碼","偽代碼- 維基百科，自由的百科全書","偽碼","擬似コード - Wikipedia","擬似ｺｰﾄﾞ-wikipedia","疑似コード","疑似コードがなにかはwikiを読んでいただければすぐわかると思います","維基百科的文章“ 伪代码”","維基百科的文章“ 虛擬碼”","维基百科的文章“ 伪代码”","维基百科的文章“ 虛擬碼”","虚拟码","虛擬碼","虛擬碼（pseudocode）","슈도코드","위키 피 디아 문서 슈도코드","의사 코드","의사코드"],"name":"Pseudocode","categories":["Algorithm description languages","All articles lacking sources","Articles lacking sources from October 2012","Articles with example pseudocode","Source code"],"tag_line":"Pseudo code is an informal high-level description of the operating principle of a computer program or other algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"polynomial-time-approximation-scheme","_score":0,"_source":{"description":"In computer science, a polynomial-time approximation scheme (PTAS) is a type of approximation algorithm for optimization problems (most often, NP-hard optimization problems).\nA PTAS is an algorithm which takes an instance of an optimization problem and a parameter ε > 0 and, in polynomial time, produces a solution that is within a factor 1 + ε of being optimal (or 1 - ε for maximization problems). For example, for the Euclidean traveling salesman problem, a PTAS would produce a tour with length at most (1 + ε)L, with L being the length of the shortest tour.\nThe running time of a PTAS is required to be polynomial in n for every fixed ε but can be different for different ε. Thus an algorithm running in time O(n1/ε) or even O(nexp(1/ε)) counts as a PTAS.","alt_names":["- FPTAS :","...Wikipedia W pełni wielomianowy schemat aproksymacji","...Wikipedia Wielomianowy schemat aproksymacji","FPRAS","FPTAS","FPTAS; it is used under the","Fully polynomial-time approximation scheme","Fully polynomial-time randomized approximation scheme","Learn about Polynomial-time approximation scheme>>>","Polynomial time approximation scheme","Polynomial-time approximati","Polynomial-time approximation scheme","Polynomial-time approximation scheme - Wikipedia :: The free encyclopedia","Polynomial-time approximation scheme - Wikipedia, the free","Polynomial-time approximation scheme - Wikipedia, the free ...","Polynomial-time approximation scheme - Wikipedia, the free ... ...","Polynomial-time approximation scheme - Wikipedia, the free encyclopedia","Polynomial-time approximation scheme: Variants","Polynomial-time approximation schemes","Polynomial-time randomized approximation scheme","W pełni wielomianowy schemat aproksymacji","W pełni wielomianowy schemat aproksymacji – Wikipedia, wolna ...","What variants of Fully polynomial time approximation scheme","Wielomianowy schemat aproksymacji","Wielomianowy schemat aproksymacji – Wikipedia, wolna encyklopedia","Wikipedia article FPRAS","Wikipedia article FPTAS","Wikipedia article Polynomial time approximation scheme","Wikipedia article Polynomial-time approximation scheme","Wikipedia article on FPTAS","Wikipedia article on Polynomial-time approximation scheme","Wikipedia article 다항 시간 근사 해법","Wikipedia entry for Polynomial-time approximation scheme","en.wikipedia.org/wiki/Polynomial-time_approximation_scheme","fully polynomial approximation scheme","fully polynomial approximation scheme (FPTAS)","fully polynomial randomized approximation scheme","fully polynomial time randomised approximation scheme (FPRAS)","fully polynomial-time approximation scheme","fully polynomial-time randomized approximation scheme","fully-polynomial-time randomized approximation scheme","http://en.wikipedia.org/wiki/FPTAS","http://en.wikipedia.org/wiki/Polynomial-time_approximation_scheme","http://en.wikipedia.org/wiki/Polynomial_time_approximation_scheme","http://pl.wikipedia.org/wiki/W_pe%C5%82ni_wielomianowy_schemat_aproksymacji","http://pl.wikipedia.org/wiki/W_pe%C5%82ni_wielomianowy_shemat_aproksymacji","http://pl.wikipedia.org/wiki/Wielomianowy_schemat_aproksymacji","http://pl.wikipedia.org/wiki/Wielomianowy_shemat_aproksymacji","ko:PTAS","pl:PTAS","polynomial approximation scheme","polynomial time approximation scheme","polynomial time approximation scheme (PTAS)","polynomial time approximation schemes","polynomial-time approximation scheme","polynomial-time approximation scheme (PTAS)","polynomial-time approximation schemes","다항 시간 근사 해법","위키 피 디아 문서 PTAS","위키 피 디아 문서 다항 시간 근사 해법"],"name":"Polynomial-time approximation scheme","categories":["Approximation algorithms","Complexity classes"],"tag_line":"In computer science, a polynomial-time approximation scheme (PTAS) is a type of approximation algorithm for optimization problems (most often, NP-hard optimization problems)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pidgin-code","_score":0,"_source":{"description":"In computer programming, pidgin code is a mixture of several programming languages in the same program, or pseudocode that is a mixture of a programming language with natural language descriptions. Hence the name: the mixture is a programming language analogous to a pidgin in natural languages.\nIn numerical computation, mathematical style pseudocode is sometimes called pidgin code, for example pidgin ALGOL (the origin of the concept), pidgin Fortran, pidgin BASIC, pidgin Pascal, and pidgin C. It is a compact and often informal notation that blends syntax taken from a conventional programming language with mathematical notation, typically using set theory and matrix operations, and perhaps also natural language descriptions.\nIt can be understood by a wide range of mathematically trained people, and is used as a way to describe algorithms where the control structure is made explicit at a rather high level of detail, while some data structures are still left at an abstract level, independent of any specific programming language.\nNormally non-ASCII typesetting is used for the mathematical equations, for example by means of TeX or MathML markup, or proprietary Formula editor formats.\nThese are examples of articles that contain mathematical style pseudo code:","alt_names":["-> Read more about Pidgin code","...more on Wikipedia about Pidgin Algol","C like language","Learn about Pidgin code>>>","Pidgin Algol","Pidgin code","Pidgin code - Wikipedia, the free encyclopedia","Pidgin code Wikipedia the free encyclopedia","Pidgin_code","Pidgincode","Wikipedia article Pidgin code","Wikipedia article Pidgincode","Wikipedia article on Pidgin code","Wikipedia article on Pidgincode","Wikipedia entry for Pidgin code","http://en.wikipedia.org/wiki/Pidgin_Algol","http://en.wikipedia.org/wiki/Pidgin_code","pidgin code"],"name":"Pidgin code","categories":["Algorithm description languages","All articles lacking sources","All stub articles","Articles lacking sources from June 2009","Programming language topic stubs"],"tag_line":"In computer programming, pidgin code is a mixture of several programming languages in the same program, or pseudocode that is a mixture of a programming language with natural language descriptions."}}
,{"_index":"throwtable","_type":"algorithm","_id":"smith–waterman-algorithm","_score":0,"_source":{"description":"The Smith–Waterman algorithm performs local sequence alignment; that is, for determining similar regions between two strings or nucleotide or protein sequences. Instead of looking at the total sequence, the Smith–Waterman algorithm compares segments of all possible lengths and optimizes the similarity measure.\nThe algorithm was first proposed by Temple F. Smith and Michael S. Waterman in 1981. Like the Needleman–Wunsch algorithm, of which it is a variation, Smith–Waterman is a dynamic programming algorithm. As such, it has the desirable property that it is guaranteed to find the optimal local alignment with respect to the scoring system being used (which includes the substitution matrix and the gap-scoring scheme). The main difference to the Needleman–Wunsch algorithm is that negative scoring matrix cells are set to zero, which renders the (thus positively scoring) local alignments visible. Backtracking starts at the highest scoring matrix cell and proceeds until a cell with score zero is encountered, yielding the highest scoring local alignment. One does not actually implement the algorithm as described because improved alternatives are now available that have better scaling (Gotoh, 1982)  and are more accurate (Altschul and Erickson, 1986).","alt_names":[],"name":"Smith–Waterman algorithm","categories":["All articles with dead external links","All articles with unsourced statements","Articles with dead external links from October 2010","Articles with unsourced statements from November 2011","Bioinformatics algorithms","Computational phylogenetics","Dynamic programming","Sequence alignment algorithms"],"tag_line":"The Smith–Waterman algorithm performs local sequence alignment; that is, for determining similar regions between two strings or nucleotide or protein sequences."}}
,{"_index":"throwtable","_type":"algorithm","_id":"chromosome-(genetic-algorithm)","_score":0,"_source":{"description":"In genetic algorithms, a chromosome (also sometimes called a genotype) is a set of parameters which define a proposed solution to the problem that the genetic algorithm is trying to solve. The set of all solutions is known as the population. The chromosome is often represented as a binary string, although a wide variety of other data structures are also used.","alt_names":["-> Read more about Chromosome (genetic algorithm)","...mehr auf Wikipedia über Genom (genetischer Algorithmus)","...more on Wikipedia about Chromosome (genetic algorithm)","Chromosom,","Chromosome (Genetic Algorithm)","Chromosome (genetic algorithm)","Chromosome (genetic algorithm) - Wikipedia, the free encyclopedia","Chromosome (genetic algorithm) - Wikipedia, the free encyclopedia ...","Chromosome (genetic algorithm) on wikipedia.org","Chromosome genetic algorithm","Chromosome genetic algorithm Wikipedia the free encyclopedia","Chromosome_(genetic_algorithm)","Cromosoma (algorisme genètic)","Genom (genetischer Algorithmus)","Genom (genetischer Algorithmus) - Wikipedia","Genom (genetischer Algorithmus) – ...","Genom (genetischer Algorithmus) – Wikipedia","Genom_(genetischer_Algorithmus)","Genome (genetic algorithm)","Wikipedia : Chromosome","Wikipedia article Chromosome (genetic algorithm)","Wikipedia article Chromosome_(genetic_algorithm)","Wikipedia article Genome (genetic algorithm)","Wikipedia article about Chromosome (genetic algorithm)","Wikipedia article on Genome (genetic algorithm)","Wikipedia-Artikel Genom (genetischer Algorithmus)","Wikipedia-Seite zu 'Genom (genetischer Algorithmus)'","chromosome (genetic algorithm)","chromosomes o","d chromosomes","en.wikipedia.org/wiki/Chromosome_(genetic_algorithm)","http://de.wikipedia.org/wiki/Genom_(genetischer_Algorithmus)","http://en.wikipedia.org/wiki/Chromos...c_algorithm%29","http://en.wikipedia.org/wiki/Chromosome_%28genetic_algorithm%29","http://en.wikipedia.org/wiki/Chromosome_(genetic_algorithm)","http://es.wikipedia.org/wiki/Cromosoma_(computaci%C3","m chromosomes","r chromosomes)","s of data and instructions, although a wide","хромосомы,","کروموزوم (الگوریتم ژنتیک)","کروموزوم (الگوریتم ژنتیک) - ویکیپدیا","کروموزوم الگوریتم ژنتیک","염색체를"],"name":"Chromosome (genetic algorithm)","categories":["Genetic algorithms","Pages using citations with accessdate and no URL"],"tag_line":"In genetic algorithms, a chromosome (also sometimes called a genotype) is a set of parameters which define a proposed solution to the problem that the genetic algorithm is trying to solve."}}
,{"_index":"throwtable","_type":"algorithm","_id":"christofides-algorithm","_score":0,"_source":{"description":"The goal of the Christofides approximation algorithm (named after Nicos Christofides) is to find a solution to the instances of the traveling salesman problem where the edge weights satisfy the triangle inequality. Let  be an instance of TSP, i.e.  is a complete graph on the set  of vertices with weight function  assigning a nonnegative real weight to every edge of .","alt_names":["Christofides heuristic","- Christofides algorithm :","3/2-approksimaatioalgoritmiksi","Algorithmus von Christofides","Chri tofide algorithm Wikipedia the free encyclopedia","Christofides Algorithm","Christofides Algorithm (wikipedia)","Christofides algorithm","Christofides algorithm - Wikipedia :: The free encyclopedia","Christofides algorithm - Wikipedia, the free encyclopedia","Christofides algorithm by Wikipedia","Christofides' Algorithm","Christofides' algorithm","Christofides' heuristic","Christofides's 1.5 approx to metric TSP","Christofides-Heuristik","Christofides-Heuristik (Wiki)","Christofides-Heuristik ? Wikipedia","Christofides-Heuristik – Wikipedia","TSP+Triangle inequality: Christofides algorithm","Wikipedia article Christofides heuristic","Wikipedia-Artikel Christofides-Heuristik","Wikipedia-Seite zu 'Christofides-Heuristik'","de:Christofides-Heuristik","favorite TSP approximator","http://de.wikipedia.org/wiki/Christofide","http://de.wikipedia.org/wiki/Christofides-Heuristik","http://en.wikipedia.org/wiki/Christofides_algorithm","w ( A ) ≥ w ( T )"],"name":"Christofides algorithm","categories":["Approximation algorithms","Graph algorithms","Spanning tree","Travelling salesman problem"],"tag_line":"The goal of the Christofides approximation algorithm (named after Nicos Christofides) is to find a solution to the instances of the traveling salesman problem where the edge weights satisfy the triangle inequality."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bidimensionality","_score":0,"_source":{"description":"Bidimensionality theory characterizes a broad range of graph problems (bidimensional) that admit efficient approximate, fixed-parameter or kernel solutions in a broad range of graphs. These graph classes include planar graphs, map graphs, bounded-genus graphs and graphs excluding any fixed minor. In particular, bidimensionality theory builds on the graph minor theory of Robertson and Seymour by extending the mathematical results and building new algorithmic tools. The theory was introduced in the work of Demaine, Fomin, Hajiaghayi, and Thilikos, for which the authors received the Nerode Prize in 2015.\n\n","alt_names":["Bidimensionality","Bidimensionality - Wikipedia, the free encyclopedia","Bidimensionality Wikipedia the free encyclopedia","Bidimensionality Wikipedia, the free ...","Bidimensionality from Wikipedia","Bidimensionality in Wikipedia","Wikipedia article Bidimensionality","bidimensionality","http://en.wikipedia.org/wiki/Bidimensionality"],"name":"Bidimensionality","categories":["Analysis of algorithms","Approximation algorithms","Graph minor theory","Parameterized complexity"],"tag_line":"Bidimensionality theory characterizes a broad range of graph problems (bidimensional) that admit efficient approximate, fixed-parameter or kernel solutions in a broad range of graphs."}}
,{"_index":"throwtable","_type":"algorithm","_id":"approximation-preserving-reduction","_score":0,"_source":{"description":"In computability theory and computational complexity theory, especially the study of approximation algorithms, an approximation-preserving reduction is an algorithm for transforming one optimization problem into another problem, such that the distance of solutions from optimal is preserved to some degree. Approximation-preserving reductions are a subset of more general reductions in complexity theory; the difference is that approximation-preserving reductions usually make statements on approximation problems or optimization problems, as opposed to decision problems.\nIntuitively, problem A is reducible to problem B via an approximation-preserving reduction if, given an instance of problem A and a (possibly approximate) solver for problem B, one can convert the instance of problem A into an instance of problem B, apply the solver for problem B, and recover a solution for problem A that also has some guarantee of approximation.","alt_names":[],"name":"Approximation-preserving reduction","categories":["Approximation algorithms","Computational complexity theory","Structural complexity theory"],"tag_line":"In computability theory and computational complexity theory, especially the study of approximation algorithms, an approximation-preserving reduction is an algorithm for transforming one optimization problem into another problem, such that the distance of solutions from optimal is preserved to some degree."}}
,{"_index":"throwtable","_type":"algorithm","_id":"genetic-programming","_score":0,"_source":{"description":"In artificial intelligence, genetic programming (GP) is an evolutionary algorithm-based methodology inspired by biological evolution to find computer programs that perform a user-defined task. Essentially GP is a set of instructions and a fitness function to measure how well a computer has performed a task. It is a specialization of genetic algorithms (GA) where each individual is a computer program. It is a machine learning technique used to optimize a population of computer programs according to a fitness landscape determined by a program's ability to perform a given computational task.","alt_names":["Genetic Program","l'article français de Wikipedia","genetic programming","'genetic programming'","(genetic programming)","(no) http://en.wikipedia.org/wiki/Genetic_programming","- Genetic programming :","- Symbolic Regression :","-> Read the article about 'Genetic programming'","...Wikipedia Programowanie genetyczne","...mehr auf Wikipedia über Genetische Programmierung","...more on Wikipedia about Genetic programming","1 Chromosome representation","2 Chromosome representation","2 Genetic operators","2.2 Mutation","3 Genetic operators","3 Meta-Genetic Programming","3.2 Mutation","4 Meta-Genetic Programming","A programação genética","Aufbau der DNA","Chromosome representation","Does anyone know of some good resources online","En savoir plus sur la programmation génétique","GA7tree","GENETIC PROGRAMMING","GP at Wikipedia","GP from Wikipedia","Genetic Programing","Genetic Programmin","Genetic Programming","Genetic Programming (GP)","Genetic Programming - Wikipedia","Genetic Programming - Wikipedia definition","Genetic Programming ...","Genetic Programming Algorithm","Genetic Programming Algorithms","Genetic Programming Wikipedia The Free Encyclopedia","Genetic Programming in a Nutshell","Genetic Programming system","Genetic Programming; it is used under the","Genetic Programs","Genetic programing","Genetic programming","Genetic programming - Wikipedia","Genetic programming - Wikipedia :: The free encyclopedia","Genetic programming - Wikipedia, the free encyclopedia","Genetic programming - Wikipedia,...","Genetic programming Wikipedia the free encyclopedia","Genetic programming Wikipedia the free encyclopedia - result","Genetic programming from Wikipedia","Genetic programming, Wikipedia","Genetic programming.","Genetic programming:","Genetic programming; it is used under the","Genetic_programming","Genetically Programmed Engineering","Genetické programování","Genetické programování - Wikipedie","Genetické programování - Wikipedie, otevřená encyklopedie","Genetische Programmierung","Genetische Programmierung ? Wikipedia","Genetische Programmierung – Wikipedia","Genetisk Programmering","Genetisk programmering","Genetiska algoritmer","Genetsko programiranje","Getting Ready to Run Genetic Programming","Implementaties","In artificial intelligence, genetic programming (GP) is an","Lập trình di truyền","Meta-Genetic Programming","Programació genètica","Programación Genética","Programación genética","Programación genética - Wikipedia, la enciclopedia libre","Programação Genética","Programação genética","Programação genética - Wikipédia, a enciclopédia livre","Programação genética – Wikipédia, a enciclopédia livre","Programmation Génétique","Programmation génétique","Programmation génétique - Wikipédia","Programmazione Genetica","Programmazione Genetica:","Programmazione genetica","Programmazione genetica - Wikipedia","Programowanie genetyczne","Read More genetic programming wikipedia the free encyclopedia","Read about Symbolic Regression on Wikipedia","Representation, Initialisation and Operators in Tree-based GP","Symbolic Regression","Symbolic regression","The Wikipedia GP page (scroll to the bottom","They are . . .","WIKI: Genetic Programming","Web:Genetic programming - Wikipedia, the free encyclopedia","Wiki on Genetic Programming","Wikipedia - 'Genetic Programming'","Wikipedia : 遺伝的プログラミング","Wikipedia Article on Genetic Programming","Wikipedia article Genetic_programming","Wikipedia article Programación genética","Wikipedia article Programação genética","Wikipedia article Symbolic Regression","Wikipedia article on Symbolic Regression","Wikipedia article on genetic programming","Wikipedia definition of Genetic Programming","Wikipedia entry for Genetic programming","Wikipedia entry for genetic programming","Wikipedia l'articolo Programmazione genetica","Wikipedia on Genetic Programming","Wikipedia's definition of Genetic Programming","Wikipedia's introduction to Genetic Programming","Wikipedia-Artikel Genetic programming","Wikipedia-Artikel Genetische Programmierung","Wikipedia-Seite zu 'Genetische Programmierung'","Wikipedia.jp:遺伝的プログラミング","Wikipedia: Genetic_programming","Wikipedia: Genetische_Programmierung","Wikipedia:Genetic programming","Wikipedia:Genetic_programming","Wikipedia:Programmazione_genetica","Wikipedia:genetic programming","Wikipediaで「遺伝的プログラミング」を調べる","Wikipédia artigo Programação Genética","Wikipédia artigo Programação genética","Yepski.","[Wikipedia Genetic Programming]","[wikipedia]遺伝的プログラミング","a quick overview of genetic programming here","artigo da Wikipédia Programação genética","artículo de Wikipedia Programacion genetica","artículo de Wikipedia Programación genética","automatic evolution of computer programs","ca:Programació genètica","cs:Genetické programování","de:Genetische Programmierung","die genetische Programmierung","discussions and demonstrations of GP you'll encounter","en.wikipedia.org/...Genetic_programming","en.wikipedia.org/wiki/Genetic_programmin...","en.wikipedia.org/wiki/Genetic_programming","en.wikipedia.org/wiki/Genetic_pr…","en.wikipedia.org/wiki/genetic_programming","en.wikipedia.org/​wiki/​Genetic_programming","en:Genetic Programming","es:Programación genética","evolutionary (genetic) programming","evolve their own programming","evolving actual computer programs","fr:Programmation génétique","g-p Wikipedia","geneettistä ohjelmointia","genetic program evolver","genetic programing","genetic programming (GP)","genetic programming a","genetic programming method","genetic programming techniques","genetic programming wikipedia the free encyclopedia","genetic programming.","genetic representation of the solution domain","genetic-programming","genetic_programming","genetické programování","genetické programování.","genetického programování","genetik programlama","genetiko programming","genetinį programavimą","genetische Programmierung","genetische programmering","genetischer Programmierung","genetisk programmering","genetiske programmering","genetycznego programowania","genéticamente programadas","gramma-based or genetic programming techniques.","here see yourself","http://cs.wikipedia.org/wiki/Genetick%C3%A9_programov","http://de.wikipedia.org/wiki/Genetic_programming","http://de.wikipedia.org/wiki/Genetische_Programmierung","http://em.wikipedia.org/wiki/Genetic_programming","http://en.wikipedia.org/wiki/Genetic programming","http://en.wikipedia.org/wiki/Genetic%5Fprogramming","http://en.wikipedia.org/wiki/Genetic..._Tree-based_GP","http://en.wikipedia.org/wiki/Genetic_Programm...","http://en.wikipedia.org/wiki/Genetic_Programming","http://en.wikipedia.org/wiki/Genetic_Programming#External_links","http://en.wikipedia.org/wiki/Genetic_programm...","http://en.wikipedia.org/wiki/Genetic_programming","http://en.wikipedia.org/wiki/Genetic_programming#External_links","http://en.wikipedia.org/wiki/Genetic_programming#Implementations","http://en.wikipedia.org/wiki/Genetic_pro…","http://en.wikipedia.org/wiki/Symbolic_Regression","http://en.wikipedia.org/wiki/Symbolic_Regression#Implementations","http://en.wikipedia.org/wiki/Symbolic_Regression.","http://en.wikipedia.org/wiki/genetic_**programming","http://en.wikipedia.org/wiki/genetic_programming","http://fr.wikipedia.org/wiki/Program...A9n%C3","http://fr.wikipedia.org/wiki/Programmation_g%C3%A9n","http://it.wikipedia.org/wiki/Programmazione_genetica","http://j.mp/ejLwhO","http://ja.wikipedia.org/wiki/遺伝的プログラミング","http://pl.wikipedia.org/wiki/Programowanie_genetyczne","http://sl.wikipedia.org/wiki/Genetsko_programiranje","http://sv.wikipedia.org/wiki/Genetisk_programmering#Genetisk_algoritm","http://tinyurl.com/6g4e2q","intensely intelligent (artificially)","it:Programmazione genetica","ja:遺伝的プログラミング","ko:유전 프로그래밍","la programación genética","la programmation génétique","la programmazione","la programmazione genetica","lập trình di truyền","metagenetically","nd genetic programming","pemrograman genetik","pl:Programowanie genetyczne","produced by genetic programming","programació genètica","programación genética","programação genética","programelor genetice","programmation génétique","programmazione genetica","programmazione genetica (GP)","programming by induction","programowania genetycznego","programowaniem genetycznym","pt:Programação genética","regressão simbólica","rogramación genética","ru:Генетическое программирование","ru:Генетическое_программирование","sl:Genetsko programiranje","start reading about GP","sv:Genetisk programmering","symbolic regression","symbolisk regression","they can evolve.","tree programs","what they appear to be using","wiki 遺伝プログラミング","wiki/Genetic_programming","wikipedia / programmation génétique","wikipedia page dedicated to GP","wikipedia:Genetic Programming","zas tak zle to nebude","zh:遗传编程","Генетическое программирование","генетическим программированием","генетического программирования","генетическое программирование","генетическом программировании","генетическому программированию","জেনেটিক প্রোগ্রামিং","การเขียนโปรแกรมทางพันธุกรรม","โปรแกรม ทาง พันธุกรรม","「遺伝的プログラミング」をWikipediaで調べる","ウィキペディアの記事 遺伝的プログラミング","使用遗传编程","遗传程序","遗传程序设计","遗传编程","遗传编程- 维基百科，自由的百科全书","遗传规划","遺伝的プログラミング","遺伝的プログラミング - Wikipedia","遺伝的プログラミングは、","遺伝的ﾌﾟﾛｸﾞﾗﾐﾝｸﾞ","遺傳程序","遺傳程序設計","遺傳編程","위키 피 디아 문서 유전 프로그래밍","유전 프로그래밍","유전자 프로그래밍","유전자 프로그래밍은","유전자가 프로그래밍하려면"],"name":"Genetic programming","categories":["All articles with unsourced statements","Articles with unsourced statements from December 2014","CS1 Italian-language sources (it)","Evolutionary algorithms","Genetic algorithms","Genetic programming","Mathematical optimization","Operations research","Wikipedia articles with BNF identifiers","Wikipedia articles with LCCN identifiers"],"tag_line":"In artificial intelligence, genetic programming (GP) is an evolutionary algorithm-based methodology inspired by biological evolution to find computer programs that perform a user-defined task."}}
,{"_index":"throwtable","_type":"algorithm","_id":"neuroevolution-of-augmenting-topologies","_score":0,"_source":{"description":"NeuroEvolution of Augmenting Topologies (NEAT) is a genetic algorithm for the generation of evolving artificial neural networks (a neuroevolution technique) developed by Ken Stanley in 2002 while at The University of Texas at Austin. It alters both the weighting parameters and structures of networks, attempting to find a balance between the fitness of evolved solutions and their diversity. It is based on applying three key techniques: tracking genes with history markers to allow crossover among topologies, applying speciation (the evolution of species) to preserve innovations, and developing topologies incrementally from simple initial structures (\"complexifying\").","alt_names":["- NeuroEvolution of Augmenting Topologies :","-> Read the article about 'Neuroevolution of augmenting topologies","Extensions to NEAT","NEAT (Neuro evolution of augmenting topologies)","NEAT algorithm","NEAT on Wikipedia","Neuro-Evolution of Augmenting Topologies","NeuroEvolution Aumentare di topologie","NeuroEvolution by Augmented Topologies","NeuroEvolution của augmenting topo","NeuroEvolution d'augmenter topologies","NeuroEvolution dari menambah Topologi","NeuroEvolution de aumentar Topologias","NeuroEvolution of Augmented Topologies","NeuroEvolution of Augmented Topologies - Wikipedia, the free encyclopedia","NeuroEvolution of Augmenting ...","NeuroEvolution of Augmenting Topologies","NeuroEvolution of Augmenting Topologies (NEAT)","NeuroEvolution vermehren Topologien","NeuroEvolution как усилить топологий","NeuroEvolution ของ Augmenting Topologies","NeuroEvolution充實拓撲","Neuroevoluti of augmenting topologies the free ...","Neuroevolution Of Augmenting Topologies","Neuroevolution of augmenting topologies","Neuroevolution of augmenting topologies (NEAT)","Neuroevolution of augmenting topologies - Wikipedia, the free","Neuroevolution of augmenting topologies - Wikipedia, the free ...","Neuroevolution of augmenting topologies - Wikipedia, the free ... ...","Neuroevolution of augmenting topologies - Wikipedia, the free encyclopedia","Neuroevolution of augmenting topologies - Wikipedia, the free.","Neuroevolution of augmenting topologies »","This implementation of NEAT is considered the conventional","What is a NeuroEvolution of Augmenting Topologies","Wikipedia article NeuroEvolution by Augmented Topologies","Wikipedia article NeuroEvolution of Augmenting Topologies","Wikipedia article NeuroEvolution_of_Augmenting_Topologies","Wikipedia article Neuroevolution of augmenting topologies","Wikipedia entry for Neuroevolution of augmenting topologies","cgNEAT","en.wikipedia.org/wiki/Neuroevolution_of_augmenting","en:NeuroEvolution of Augmenting Topologies","http://en.wikipedia....ting_Topologies","http://en.wikipedia....ting_topologies","http://en.wikipedia.org/wiki/NeuroEvolu ... Topologies","http://en.wikipedia.org/wiki/NeuroEvolut","http://en.wikipedia.org/wiki/NeuroEvolut...Topologies","http://en.wikipedia.org/wiki/NeuroEvolution_by_Augmented_Topologies","http://en.wikipedia.org/wiki/NeuroEvolution_of_Augmented_Topologies","http://en.wikipedia.org/wiki/NeuroEvolution_of_Augmenting_Topologies","http://en.wikipedia.org/wiki/Neuroev...ing_topologies","http://en.wikipedia.org/wiki/Neuroevolu ... topologies","http://en.wikipedia.org/wiki/Neuroevolution_of_...","http://en.wikipedia.org/wiki/Neuroevolution_of_augmenting_topologies","http://en.wikipedia.org/wiki/Neuroevoluti…","http://en.wikipedia.org/wiki/Neuroevolut…","neuroevolución de aumentar topologías","rtNEAT","генерация новых объектов на основе ИИ","トポロジの増強計画のNeuroEvolution","拓扑NeuroEvolution充实","토폴로지 화시켰다의 NeuroEvolution입니다"],"name":"Neuroevolution of augmenting topologies","categories":["Artificial neural networks","Evolutionary algorithms","Evolutionary computation","Genetic algorithms"],"tag_line":"NeuroEvolution of Augmenting Topologies (NEAT) is a genetic algorithm for the generation of evolving artificial neural networks (a neuroevolution technique) developed by Ken Stanley in 2002 while at The University of Texas at Austin."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fletcher's-checksum","_score":0,"_source":{"description":"The Fletcher checksum is an algorithm for computing a position-dependent checksum devised by John G. Fletcher (1934-2012) at Lawrence Livermore Labs in the late 1970s. The objective of the Fletcher checksum was to provide error-detection properties approaching those of a cyclic redundancy check but with the lower computational effort associated with summation techniques.\n\n","alt_names":["Fletcher's checksum","Fletcher's checksum - Wikipedia, the free encyclopedia","- Fletcher's checksum :","- Fletcher-16 :","- Fletcher-32 :","-> Read more about Fletcher's checksum","-> Read the article about 'Fletcher's checksum'","...more on Wikipedia about Fletcher's checksum","2. Implementation (Fletcher algrothim)","Fletcher 16 checksum algorithm","Fletcher Checksum","Fletcher Prüfsumme","Fletcher checksum","Fletcher er checksum","Fletcher%27s_checksum","Fletcher's checksum - Wikipedia :: The free encyclopedia","Fletcher's checksum - Wikipedia the free encyclopedia","Fletcher's checksum - Wikipedia, the free ...","Fletcher's_checksum","Fletcher-16","Fletcher-2","Fletcher-32","Fletcher-4","Fletcher-based","Fletcher32","Fletcherova metóda","Wikipedia article Fletcher's checksum","Wikipedia article about Fletcher-16","Wikipedia article about Fletcher-32","Wikipedia: Fletcher's checksum","de controlesom Fletcher","en.wikipedia.org/wiki/Fletcher's_checksum","fletcher checksum","fletcher-16","fletcher-4","fletcher-8","http://en.wikipedia.org/wiki/Fletcher%27s_...m","http://en.wikipedia.org/wiki/Fletcher%27s_checksum","http://en.wikipedia.org/wiki/Fletcher%27s_checksum#Fletcher","http://en.wikipedia.org/wiki/Fletcher's_checksum","http://en.wikipedia.org/wiki/Fletcher-16","http://en.wikipedia.org/wiki/Fletcher-32","kontrolní součet Fletchera","plet™her9s yƒs ™he™ksumA","w kontrolnej Fletcher","метод контрольной суммы Флетчера","גם זו פונקציית hash","फ्लेचर","“Fletcher's checksum - Wikipedia, the free encyclopedia”, en.wikipedia","弗莱彻的校验"],"name":"Fletcher's checksum","categories":["All articles with unsourced statements","Articles with unsourced statements from May 2012","Checksum algorithms"],"tag_line":"The Fletcher checksum is an algorithm for computing a position-dependent checksum devised by John G. Fletcher (1934-2012) at Lawrence Livermore Labs in the late 1970s."}}
,{"_index":"throwtable","_type":"algorithm","_id":"holland's-schema-theorem","_score":0,"_source":{"description":"Holland's schema theorem, also called the fundamental theorem of genetic algorithms, is widely taken to be the foundation for explanations of the power of genetic algorithms. It says that short, low-order schemata with above-average fitness increase exponentially in successive generations. The theorem was proposed by John Holland in the 1970s.\nA schema is a template that identifies a subset of strings with similarities at certain string positions. Schemata are a special case of cylinder sets, and hence form a topological space.\n\n","alt_names":["Holland's schema theorem","Holland's Schema Theorem","(wiki/ru) Теорема_схем","- Holland's schema theorem :","Die letzten beiden Formeln zeigen, dass Schemata mit","Holland&#39;s schema theorem - Wikipedia, the free","Holland's Schema Theorem.","Holland's schema theorem - Wikipedia, the free encyclopedia","Holland's_schema_theorem","Holland's_schema_theorem [Wikipedia]","Schema Theorem","Schemasatz","Source Wikipedia.org Arcticle - Holland's schema theorem","The Schema Theorem","What is the description of Schema theory?","Wikipedia article Holland's Schema Theorem","Wikipedia article Holland's schema theorem","Wikipedia article about Holland's schema theorem","Wikipedia-Artikel Schemasatz","Wikipedia-Seite zu 'Schemasatz'","en.wikipedia.org/wiki/Holland's_schema_theorem","http://de.wikipedia.org/wiki/Schemasatz","http://en.Liarpedia.org/wiki/Holland%27s_schema_theorem","http://en.wikipedia.org/wiki/Holland%27s_Schema_Theorem","http://en.wikipedia.org/wiki/Holland%27s_sche...","http://en.wikipedia.org/wiki/Holland%27s_schema_theorem","http://en.wikipedia.org/wiki/Holland's_Schema_Theorem","http://en.wikipedia.org/wiki/Holland's_schema_theorem","m ( H , t + 1 ) ≥ m ( H , t ) f","schema theorem","the schema theorem","Теорема схем","теоремы схем"],"name":"Holland's schema theorem","categories":["Genetic algorithms","Theorems in discrete mathematics"],"tag_line":"Holland's schema theorem, also called the fundamental theorem of genetic algorithms, is widely taken to be the foundation for explanations of the power of genetic algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"calendrical-calculation","_score":0,"_source":{"description":"A calendrical calculation is a calculation concerning calendar dates. Calendrical calculations can be considered an area of applied mathematics. Calendrical calculation is one of the five major Savant syndrome characteristics. Some examples of calendrical calculations:\nConverting a Julian or Gregorian calendar date to its Julian day number and vice versa (see the section on calculation in that article for details).\nThe number of days between two dates, which is simply the difference in their Julian day numbers.\nThe date of a religious holiday, like Easter (the calculation is known as Computus) or Passover, for a given year.\nConverting a date between different calendars. For instance, dates in the Gregorian calendar can be converted to dates in the Islamic calendar with the Kuwaiti algorithm.\nCalculating the day of the week.","alt_names":["Calendar math","Calendrical calculation","Calendrical calculation - Wikipedia, the free encyclopedia","Calendrical calculation; it is used under the","Calendrical_calculation","Suggested: calendrical calculation","Wikipedia (Calendrical calculation)","Wikipedia article Calendar math","Wikipedia article Calendrical calculation","Wikipedia entry for Calendrical calculation","calendrical calculation","calendrical calculations","http://en.wikipedia.org/wiki/Calendar_math","http://en.wikipedia.org/wiki/Calendrical","http://en.wikipedia.org/wiki/Calendrical_calculation"],"name":"Calendrical calculation","categories":["All stub articles","Applied mathematics stubs","Calendar algorithms"],"tag_line":"A calendrical calculation is a calculation concerning calendar dates."}}
,{"_index":"throwtable","_type":"algorithm","_id":"defining-length","_score":0,"_source":{"description":"In genetic algorithms and genetic programming defining length L(H) is the maximum distance between two defining symbols (that is symbols that have a fixed value as opposed to symbols that can take any value, commonly denoted as # or *) in schema H. In tree GP schemata, L(H) is the number of links in the minimum tree fragment including all the non-= symbols within a schema H.\n^ \"Foundations of Genetic Programming\". UCL UK. Retrieved 13 July 2010.","alt_names":["-> Read more about Defining length","-> Read the article about 'Defining length'","Defining Length","Defining length","Defining length - Wikipedia :: The free encyclopedia","Defining length - Wikipedia, the free encyclopedia","Wikipedia article Defining Length","Wikipedia article Defining length","Wikipedia article Defining_length","Wikipedia article on Defining length","Wikipedia entry for Defining length","defining length","http://en.wikipedia.org/wiki/Defining_le","http://en.wikipedia.org/wiki/Defining_length"],"name":"Defining length","categories":["All articles needing expert attention","All articles that are too technical","All stub articles","Articles needing expert attention from August 2011","Computer science stubs","Genetic algorithms","Use dmy dates from August 2011","Wikipedia articles that are too technical from August 2011"],"tag_line":"In genetic algorithms and genetic programming defining length L(H) is the maximum distance between two defining symbols (that is symbols that have a fixed value as opposed to symbols that can take any value, commonly denoted as # or *) in schema H. In tree GP schemata, L(H) is the number of links in the minimum tree fragment including all the non-= symbols within a schema H.\n^ \"Foundations of Genetic Programming\"."}}
,{"_index":"throwtable","_type":"algorithm","_id":"population-based-incremental-learning","_score":0,"_source":{"description":"In computer science and machine learning, population-based incremental learning (PBIL) is an optimization algorithm, and an estimation of distribution algorithm. This is a type of genetic algorithm where the genotype of an entire population (probability vector) is evolved rather than individual members. The algorithm is proposed by Shumeet Baluja in 1994. The algorithm is simpler than a standard genetic algorithm, and in many cases leads to better results than a standard genetic algorithm.","alt_names":["Genotype representation","PBIL - Wikipedia","PIBL","Population based incremental learning","Population-based Incremental Learning","Population-based incremental learning","Population-based incremental learning - Wikipedia","Population-based incremental learning - Wikipedia, the free ...","Population-based incremental learning - Wikipedia, the free ... ...","Population-based incremental learning - Wikipedia, the free encyclopedia","Population-based incremental learning.","Population-based_incremental_learning","What is algorithm of Population based incremental learning","Wikipedia article Population-based incremental learning","Wikipediaで「PBIL」を調べる","en:Population-based incremental learning","http://en.wikipedia.org/wiki/Population-","http://en.wikipedia.org/wiki/Population-based_incremental_ learning&oldid","http://en.wikipedia.org/wiki/Population-based_incremental_learning","http://ja.wikipedia.org/wiki/Population-based_incremental_learning","population-based incremental learning","yago-res:Population-based incremental learning"],"name":"Population-based incremental learning","categories":["Articles with example Java code","Genetic algorithms"],"tag_line":"In computer science and machine learning, population-based incremental learning (PBIL) is an optimization algorithm, and an estimation of distribution algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"premature-convergence","_score":0,"_source":{"description":"In genetic algorithms, the term of premature convergence means that a population for an optimization problem converged too early, resulting in being suboptimal. In this context, the parental solutions, through the aid of genetic operators, are not able to generate offsprings that are superior to their parents. Premature convergence can happen in case of loss of genetic variation (every individual in the population is identical, see convergence).","alt_names":["...more on Wikipedia about Premature convergence","Convergencia prematura","Convergencia prematura - Wikipedia, la enciclopedia libre","Premature convergence","Premature convergence - Wikipedia, the free encyclopedia","Premature convergence by Wikipedia","Wikipedia article ''Premature convergence''","Wikipedia article Convergencia prematura","Wikipedia article Premature convergence","Wikipedia article on Convergencia prematura","Wikipedia entry for Premature convergence","artículo de Wikipedia Convergencia prematura","convergencia prematura","es:Convergencia prematura","http://en.wikipedia.org/wiki/Premature_c","http://en.wikipedia.org/wiki/Premature_convergence","http://es.wikipedia.org/wiki/Convergencia_prematura","premature convergence"],"name":"Premature convergence","categories":["All stub articles","Evolution stubs","Evolutionary biology","Genetic algorithms"],"tag_line":"In genetic algorithms, the term of premature convergence means that a population for an optimization problem converged too early, resulting in being suboptimal."}}
,{"_index":"throwtable","_type":"algorithm","_id":"breadth-first-search","_score":0,"_source":{"description":"Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key') and explores the neighbor nodes first, before moving to the next level neighbors.\nBFS was invented in the late 1950s by E. F. Moore, who used it to find the shortest path out of a maze, and discovered independently by C. Y. Lee as a wire routing algorithm (published 1961).","alt_names":["Breadth-First","breadth-first traversal","breadth first search","Breadth First Search","breadth-first","Breitensuche","Breadth-first search","'Breadth first'","(BFS)","(BSF,","(Breath First Search)","(http://en.wikipedia.org/wiki/Breadth-first_search)","*Algoritmo de busca em largura (*BFS)",", prima ricerca in ampiezza.","- Breadth first search :","- Breadth-first search :","- Breadth-first traversal :","-> Read the article about 'Breadth-first search'","-Primera Transversal Manga (Wikipedia)","-Primera búsqueda en amplitud","-Primo attraversamento in ampiezza (Wikipedia)","-first Ricerca in ampiezza","-lần đầu tiên tìm kiếm rộng","-prima ricerca in ampiezza?",". BFS","...Wikipedia Algorithme de parcours en largeur","...Wikipedia Busca em largura","...Wikipedia Búsqueda en anchura","...Wikipedia Przeszukiwanie wszerz","...mehr auf Wikipedia über Breitendurchlauf","...mehr auf Wikipedia über Breitensuche","...more on Wikipedia about Breadth-first search","1作法","2 Algorithm (informal)","2.1 Java Implementation","2.1C 的实作","2.2C++ 的实作","2实作方法","3.1 Space complexity","3.1空间复杂度","3.2 Time complexity","3.2时间复杂度","3.3 Completeness","3.3.1 Proof of completeness","3.3完全性","3.4 Optimality","3.4最佳解","3特性","4.1 Finding connected components","4.1 Space complexity","4.1寻找连接元件","4.2 Breadth-first search","4.2 Testing bipartiteness","4.2 Time complexity","4.2测试是否二分图","4.3 Completeness","4.3.1 Proof of completeness","4.3应用于电脑游戏中平面网格","4.4 Optimality","4.5 Bias towards nodes of high degree","4广度优先搜索算法的应用","5.1 Finding connected components","5.2 Testing bipartiteness","5Fsearch% http://en.wikipedia.org/wiki/Breadth-first","6. Breadth-first search - Wikipedia, the free encyclopedia","7外部连接","Algorithme de parcours en largeur","Algorithme de parcours en largeur - Wikip?dia","Algorithme de parcours en largeur - Wikipédia","Algoritmo de B@Ãº em largura (BFS)","Algoritmo de búsqueda en anchura (BFS)","Anwendungen für Breitensuche","Applications of BFS","B?squeda en anchura - Wikipedia, la enciclopedia libre","BFS (Breadh First Search)","BFS (Breadth-First Search)","BFS (Breadth-First search)","BFS (Breitensuche)","BFS (Recherche largeur d'abord)","BFS (breadth-first search) algorithm","BFS (breedte eerst zoeken)","BFS (busca primeira largura)","BFS (búsqueda de anchura)","BFS (luas pencarian pertama)","BFS (ricerca ampiezza prima)","BFS (tìm kiếm đầu tiên chiều rộng)","BFS (šířka prohledávání)","BFS (ширина первого поиска)","BFS (ширина первой поиска)","BFS (กว้าง ค้นหา แรก)","BFS man, not DFS.","BFS manner","BFS na Wikipedii","BFS search","BFS wiki","BFS wiki page","BFS является одним из самых основных алгоритмов, составляющих","BFS – wikipedia","BFS 廣度搜索","BFS(breadth first search)","BFS(breadth-first search，廣度優先搜尋)","BFSは","BFS（幅優先探索）","BFS（广度优先搜索）","BFT (breadth-first traversal)","BSFは","Boca clássico-primeiro","Breadth First","Breadth First Search (BFS)","Breadth First Search Algorithm","Breadth First Search BFS","Breadth First Search Wiki","Breadth First Search algorithm","Breadth First Search.","Breadth First search","Breadth first Search","Breadth first recursion","Breadth first search","Breadth first search Wikipedia the free encyclopedia","Breadth first search Wikipedia the free encyclopedia - result","Breadth-First Search","Breadth-First Search (BFS)","Breadth-First Search.","Breadth-First Traversal","Breadth-First Traversal (Wikipedia)","Breadth-First search","Breadth-First-Search","Breadth-candidato First Search.","Breadth-first","Breadth-first Search","Breadth-first Search Algorithm","Breadth-first and Depth-first search","Breadth-first order","Breadth-first search (BFS)","Breadth-first search - Wikip...","Breadth-first search - Wikipedia","Breadth-first search - Wikipedia :: The free encyclopedia","Breadth-first search - Wikipedia, the free encyclopedia","Breadth-first search - Wikipedia, the free encyclopedia ...","Breadth-first search @ Wikipedia","Breadth-first search algorithm","Breadth-first search by Wikipedia","Breadth-first search from Wikipedia","Breadth-first search – Wikipedia","Breadth-first search.","Breadth-first search; it is used under the","Breadth-first searching (BFS)","Breadth-first searching(BFS)","Breadth-first sorting","Breadth-first start","Breadth-first traversal","Breadth-first-search","Breadth-first_search","Breadth-đầu tiên tìm kiếm","Breath First Search","Breath First Search (BFS)","Breath-First Search","Breath-First-Search","Breath-first Search","Breath-first-search (BFS)","BreathFirst","Bredd-först sökning","Bredd-först-sökning","Bredde First","Bredde første søgning","Bredde-First Search","Bredde-Første Traversal (Wikipedia)","Bredde-fÃ¸rst-sÃ¸k - Wikipedia","Bredde-først søgning","Bredde-først-søk","Breedte First","Breedte eerste zoekopdracht","Breedte-Eerste Traversal (Wikipedia)","Breedte-eerst zoeken","Breedte-eerst zoeken - Wikipedia","Breite ersten Suche","Breite-first-search-Algorithmus","Breite-zuerst-Suche","Breitensuche (BFS),","Breitensuche - Wikipedia","Breitensuche ? Wikipedia","Breitensuche Traversal (Wikipedia)","Breitensuche Wikipedia","Breitensuche in","Breitensuche â€“ Wikipedia","Breitensuche – Wikipedia","Breitensuche?","Broadcast Search","Busca em Largura","Busca em extensão ou largura","Busca em largura","Busca em largura (BFS)","Busca em largura - Wikipédia, a enciclopédia livre","Busca em largura – Wikipédia","Busca em largura – Wikipédia, a enciclopédia livre","Busqueda en anchura","Busquedas en anchura","Búsqueda en","Búsqueda en anchura","Búsqueda en anchura (BFS)","Búsqueda en anchura - Wikipedia, la enciclopedia libre","Búsqueda primero en amplitud","Cerca en amplada","DFS, BFS, stb.","De sesiones de la búsqueda Manga","En largeur d'abord chercher","Kaluwangan-unang paghahanap","La búsqueda en amplitud","Largeur classique-First","Larghezza di ricerca Primo","Learn about Breadth-first search>>>","Leveyssuuntaisella haulla","Mais informação sobre um BFS.","Manga clásico-candidato Primera Consulta.","Paieška į plotį","Pesquisa em Largura na Wikipedia","Prehľadávanie do šírky","Primera extensión de la búsqueda","Prohledavaní do šířky","Prohledávání do Å¡íÅ™ky","Prohledávání do šířky","Prohledávání do šířky - Wikipedie","Przeszukiwanie wszerz","Przeszukiwanie wszerz ? Wikipedia, wolna encyklopedia","Przeszukiwanie wszerz – Wikipedia, wolna encyklopedia","Read More breadthfirst search wikipedia the free encyclopedia","Recorregut en amplada","Szerokość First Search","Uniforme Kostensuche","Uniforme Kostensuche - Wikipedia","Visita breadth-first","W.414 Wikipedia: Breadth-first search","W: Breadth-first search","What are applications of Breadth first search?","What is algorithm of Breadth-first search?","Width-first search","Wikipedia (Breadth-first search)","Wikipedia (Busca em largura)","Wikipedia : Breadth-first Search","Wikipedia BFS o recorrido en anchura","Wikipedia Breitensuche","Wikipedia Búsqueda en anchura","Wikipedia article Algorithme de parcours en largeur","Wikipedia article Breadth first search","Wikipedia article Breadth-first search","Wikipedia article Breadth-first traversal","Wikipedia article Breadth-first_search","Wikipedia article Breitensuche","Wikipedia article Busca em largura","Wikipedia article Búsqueda en anchura","Wikipedia article on Breadth first search","Wikipedia article on Breadth-first search","Wikipedia article on Breadth-first traversal","Wikipedia article on Búsqueda en anchura","Wikipedia article on Primero en anchura","Wikipedia article Пошук у ширину","Wikipedia article אלגוריתם חיפוש לרוחב","Wikipedia artikel Breedte-eerst zoeken","Wikipedia entry for Breadth-first search","Wikipedia l'articolo Breadth-first search","Wikipedia l'articolo Visita in ampiezza","Wikipedia-Artikel Breitendurchlauf","Wikipedia-Artikel Breitensuche","Wikipedia-Artikel Uniforme Kostensuche","Wikipedia-Seite zu 'Breitensuche'","Wikipedia-Seite: Breitensuche","Wikipedia: Bredde-først søk","Wikipedia: Breitensuche","Wikipedia: Parcurgere în lățime","Wikipedia: breadth-first search","Wikipedia:Breadth-first_search","Wikipedia:Visita_in_ampiezza","Wikipediaで「幅優先探索」を調べる","Wikipédia artigo BFS","Wikipédia artigo Bfs","Wikipédie: Breadth-first search","Wszerz Traversal (Wikipedia)","[7] Breadth-first search","[E.1] http://en.wikipedia.org/wiki/Breadth","algorithm on Wikipedia","algorithme de parcours en largeur","ampiezza della ricerca","ampiezza prima","ampiezza prima ricerca","amplitud de la primera búsqueda","amplitud de sesiones","amplitud de sesiones de la búsqueda","amplitud del primer","amplitud primera búsqueda","amplitude primeira","ancho de sesiones de la búsqueda","ancho primero","anchura","artigo da Wikipédia Busca em largura","artículo de Wikipedia Busqueda en anchura","artículo de Wikipedia Búsqueda en anchura","artículo de Wikipedia Primero en anchura","breadth first","breadth first algorithm","breadth first searc","breadth first search wikipedia the free encyclopedia","breadth first search.","breadth first searches","breadth first traversal","breadth first traversal f","breadth first traversal order","breadth first w","breadth-fir","breadth-first graph traversal","breadth-first order","breadth-first recursion","breadth-first searc","breadth-first search","breadth-first search (BFS)","breadth-first search algorithm","breadth-first search,","breadth-first search.","breadth-first search?","breadth-first searches","breadth-first searching","breadth-first traveral","breadth-first traversal of data","breadth-first traversal of graphs","breadth-first tree search","breadth-first-algoritmo","breadth-first-search","breadth-first-search.","breadth-frist search","breadthFirstSearch","breadthfirst","breath-first search","breath-first search, BFS)去遍历一个树结构。广度优先搜索的典型实现是使用队列(queue)。其伪代码如下","breath-first-searching","breath-fist search algorithm","bredde først søk","bredde første søgning","bredde-først","bredde-først søgning","bredde-først søgning.","bredde-først søgning?","bredden første søgning","breedte eerst zoeken","breedte eerste","breedte eerste zoekopdracht","breedte-eerst","breedte-eerst zoeken","breedte-eerst zoeken.","bsqueda en anchura wikipedia la enciclopedia libre","busca em","busca em largura","búsqueda en amplitud de sesiones","búsqueda en anchura","búsqueda primero en amplitud","bề dày","bề rộng tìm kiếm đầu tiên","bề rộng-lần đầu tiên tìm kiếm (BFS","bề rộng-thuật","ca:Cerca en amplada","cle: http://en.wikipedia.org/wiki/","cs:Prohledávání do šířky","de breedte-eerst zoeken?","de breedte-first","de sesiones de la búsqueda amplitud?","de.wikipedia.org/wiki/Breitensuche","de:Breitensuche","do šířky","en largeur d'abord","en largeur d'algorithme de recherche de premier","en.wikipedia.org/...Breadth-first_search","en.wikipedia.org/wiki/Breadth-first_s...","en.wikipedia.org/wiki/Breadth-first_search","en.wikipedia.org/wiki/Breadth-first_traversal","en:Breadth-first search","es:Búsqueda en anchura","external image 300px-Breadth-first-tree.svg.png","fa:الگوریتم جستجوی اول سطح","fa:جستجوی سطح اول","fr:Algorithme de parcours en largeur","h. http://en.wikipedia.org/wiki/","has exponential space complexity","he:אלגוריתם חיפוש לרוחב","http://cs.wikipedia.org/wiki/BFS","http://de.wikipedia.org/wiki/Br eitensuche","http://de.wikipedia.org/wiki/Breitendurchlauf","http://de.wikipedia.org/wiki/Breitensuch","http://de.wikipedia.org/wiki/Breitensuche","http://de.wikipedia.org/wiki/Uniforme_Kostensuche","http://en.wikipedia.org/wiki/Breadth-","http://en.wikipedia.org/wiki/Breadth-f","http://en.wikipedia.org/wiki/Breadth-fi ... 28inform","http://en.wikipedia.org/wiki/Breadth-fi ... nformal","http://en.wikipedia.org/wiki/Breadth-fir","http://en.wikipedia.org/wiki/Breadth-fir...","http://en.wikipedia.org/wiki/Breadth-fir..._implementation","http://en.wikipedia.org/wiki/Breadth-first search","http://en.wikipedia.org/wiki/Breadth-first% 5Fsearch","http://en.wikipedia.org/wiki/Breadth-first%5Fsearch","http://en.wikipedia.org/wiki/Breadth-first..._","http://en.wikipedia.org/wiki/Breadth-first...pace_Complexity","http://en.wikipedia.org/wiki/Breadth-first_se...","http://en.wikipedia.org/wiki/Breadth-first_search","http://en.wikipedia.org/wiki/Breadth-first_search#Algorithm_","http://en.wikipedia.org/wiki/Breadth-first_search#C","http://en.wikipedia.org/wiki/Breadth-first_search#How_it_works","http://en.wikipedia.org/wiki/Breadth-first_search#Java_Implementation","http://en.wikipedia.org/wiki/Breadth-first_search#Pseudocode","http://en.wikipedia.org/wiki/Breadth-first_search#Testing_bipartiteness","http://en.wikipedia.org/wiki/Breadth-first_search.","http://en.wikipedia.org/wiki/Breadth-first_search을","http://en.wikipedia.org/wiki/Breadth-first_traversal","http://en.wikipedia.org/wiki/Breadth-first_traversal.","http://en.wikipedia.org/wiki/Breadth-first％5Fsearch","http://en.wikipedia.org/wiki/Breadth-first％の","http://en.wikipedia.org/wiki/Breadth-fir…","http://en.wikipedia.org/wiki/Breadth....28informal.29","http://en.wikipedia.org/wiki/Breadth...cations_of_BFS","http://en.wikipedia.org/wiki/Breadth...implementation","http://en.wikipedia.org/wiki/Breadth...ithm_.28inform","http://en.wikipedia.org/wiki/Breadth_first_search","http://en.wikipedia.org/wiki/Breadth_first_search#Applications_of_BFS","http://en.wikipedia.org/wiki/Breadth_fir…","http://en.wikipedia.org/wiki/Breadth−first_search","http://en.wikipedia.org/wiki/Breadth−first_search#Algorithm_","http://es.wikipedia.org/wiki/B%C3%BAsqueda_en_anchura","http://es.wikipedia.org/wiki/Busqueda_en_anchura","http://es.wikipedia.org/wiki/Búsqueda_en_anchura","http://fa.wikipedia.org/wiki/الگوریتم_جستجوی_اول_سطح","http://fr.wikipedia.org/wiki/Al...urs_en_largeur","http://fr.wikipedia.org/wiki/Algorit...urs_en_largeur","http://fr.wikipedia.org/wiki/Algorithme_...en_largeur","http://fr.wikipedia.org/wiki/Algorithme_de_parcours_en_largeur","http://fr.wikipedia.org/wiki/Breadth_First_Search","http://he.wikipedia.org/wiki/BFS","http://he.wikipedia.org/wiki/אלגוריתם_חיפוש_לרוחב","http://it.wikipedia.org/wiki/Breadth-first_search","http://it.wikipedia.org/wiki/Breadth-fir…","http://it.wikipedia.org/wiki/Visita_in_ampiezza","http://nl.wikipedia.org/wiki/Breedte-eerst_zoeken","http://pl.wikipedia....ukiwanie_wszerz","http://pl.wikipedia.org/wiki/Przeszukiwanie_wszerz","http://pl.wikipedia.org/wiki/Przeszukiwanie_wszerz#Algorytm","http://pl.wikipedia.org/wiki/Pżeszukiwanie_wszeż","http://pt.wikipedia....usca_em_largura","http://pt.wikipedia.org/wiki/BFS","http://pt.wikipedia.org/wiki/Busca_em_largura","http://ru.wikipedia.org/wiki/%CF%EE%E8","http://ru.wikipedia.org/wiki/Поиск_в_ширину","http://zh.wikipedia.org/zh-cn/BFS","in ampiezza","in ampiezza cercare innanzitutto","informal breadth-first algorithm","it:Breadth-first search","ja:幅優先探索","kaluwangan unang paghahanap","kaluwangan-Unang Search","ko:너비 우선 탐색","ko:넓이 우선 탐색","la búsqueda primero en amplitud","lebarnya pencarian pertama","lebarnya-first-search","lt:Paieška į plotį","manga primera búsqueda","najpierw wszerz","nl:Breedte-eerst zoeken","no:Bredde-først-søk","o Búsqueda en","paiešką į plotį","parallel search algorithm","parcourir ton graphe","parcours en largeur","pertama pencarian luas","pierwszym Szerokość wyszukiwania","pl:Przeszukiwanie wszerz","prehľadávanie do šírky","première recherche étendue","prima ricerca in ampiezza","primeira busca em largura","primeira pesquisa de abrangência","primer amplitud","primer búsqueda en amplitud","primero en amplitud de la búsqueda","primero la búsqueda en amplitud?","primo ampiezza","prioridad a la amplitud de la búsqueda","prohledávání do šířky","przeszukiwania wszerz","przeszukiwanie wszerz","przeszukiwać wszerz","pt:Busca em largura","r búsqueda en anchura","readth-first search","recherche en largeur d'abord (BFS)","recherche en largeur et unième","recorrido en anchura","requires additional storage","ricerca breadth-First","ricerca breadth-first","ricerca in ampiezza","ricerca in ampiezza primo","ricerca prima in profondità","ru:Поиск в ширину","sv:Bredd-först-sökning","szerokość pierwszego wyszukiwania","szerokość pierwszy wyszukiwania","szélességi gráfbejárás","the Wikipedia page on breadth-first traversal","traversal graph","uk:Пошук у ширину","w:Breadth-first search","when running BFS on the","wikipedia page for a breadth first search","wikipedia:幅優先探索","wikipedia幅優先探索","wp:Breadth-first search","wszerz","wszerz wyszukiwania?","zh:广度优先搜索","å¹¿åº¦ä¼˜å…ˆæ œç´¢","å¹…å„ªå…ˆæŽ¢ç´¢","į plotį","Šíře First Search","Šíře-nejprve hledat","Šířka-First Search","Šířka-První Traversal (Wikipedia)","šíře první hledání","šíře-nejprve hledat","šíře-nejprve hledat?","šířka prvním hledání","šířky hledání","В ширину Traversal (Википедия)","Й иид ЛЛ вКл д Кгж Лл Л","Поиск в ширину","Поиск в ширину (BFS),","Поиск в ширину (BFS, Breadth-First Search)","Поиск в ширину — Википедия","Пошук в ширину","Пошук у ширину","Пошук у ширину — Вікіпедія","Ширина Первый поиск","Ширина первого поиска","Ширина первой","алгоритм поиска в ширину","в ширину","в ширину-поиск","обхождане в ширина","поиск в ширину","поиск в ширину?","поиска в ширину","поиском в ширину","түвшний нэвтрэлт","у ширину","ширина первого","ширина первого поиска","широта поиска в","אלגוריתם BFS","אלגוריתם חיפוש לרוחב","אלגוריתם חיפוש לרוחב – ויקיפדיה","ויקיפדיה - 'אלגוריתם חיפוש לרוחב'","ויקיפדיה - אלגוריתם חיפוש לרוחב","חיפוש BFS בגרף","الگوریتم جستجوی اول سطح","الگوریتم جستجوی اول سطح - ویکیپدیا","جستجوی سطح اول","هنا تفاصيل أكثر ..","चौड़ाई की पहली खोज","चौड़ाई पहले खोज","चौड़ाई-प्रथम चंक्रमण (विकिपीडिया)","बीएफएस","বি.এফ.এস.","กว้าง search แรก","กว้าง-First","กว้าง-แรก","ความ กว้าง การ ค้นหา แรก","ความ กว้าง การ ค้นหา แรก (BFS)","แรกค้นหากว้าง","“Breitensuche”","“breadth-first”","、幅優先の検索","、幅優先の検索ですか？","、幅優先の検索を","「幅優先探索」をWikipediaで調べる","のBFS","のBFS（幅優先検索）","幅、最初の検索","幅優先","幅優先探索","幅優先探索 - Wikipedia","幅優先探索 – Wikipedia","幅優先探索(Breadth first search)","幅優先探索-wikipedia","幅優先探索を","幅優先検索","幅優先検索 （BFS）","幅優先検索（クロツラヘラサギ）","幅優先縦断ウィキペディア（Wikipedia）』","广度优先","广度优先搜索","广度优先搜索(","广度优先搜索（BFS） ，","广度优先搜索（矿渣）","广度优先搜索？","广度优先遍历（维基百科）","廣度優先尋訪（breadth-first traversal）","廣度優先搜尋(Breadth-First search，BFS)","廣度優先搜索","廣度優先搜索- 維基百科，自由的百科全書","廣度優先搜索（礦渣）","最初の検索を行います。","最初の検索）","横型探索法 (幅優先探索法) breadth-first search","矿渣（广度优先搜索）","礦渣","礦渣（廣度優先搜索）","維基百科的文章“ 广度优先搜索”","维基百科的文章“ 广度优先搜索”","边防军","黑脸琵鹭（广度优先搜索）","광범 - 먼저 검색을","광범위한 첫 검색","광범위한 첫 번째 검색","광범위한 첫 찾기 (대금)로","광범위한 첫번째 검색","광범위한 최초 검색","너비 우선 탐색","너비 우선 탐색 위키백과, 우리 모두의백과사전","너비 우선 탐색(BFS)","넓이 우선 탐색","대금 (광범위한 첫 번째 검색)","을 http://en.wikipedia.org/wiki/Breadth_first_search","（BSF、DSF","（http://en.wikipedia.org/wiki/Breadth-first_search","（http://en.wikipedia.org/wiki/Breadth-first_search）"],"name":"Breadth-first search","categories":["All articles needing additional references","Articles needing additional references from April 2012","Commons category with local link same as on Wikidata","Graph algorithms","Search algorithms"],"tag_line":"Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures."}}
,{"_index":"throwtable","_type":"algorithm","_id":"job-shop-scheduling","_score":0,"_source":{"description":"Job shop scheduling (or job-shop problem) is an optimization problem in computer science and operations research in which ideal jobs are assigned to resources at particular times. The most basic version is as follows:\nWe are given n jobs J1, J2, ..., Jn of varying sizes, which need to be scheduled on m identical machines, while trying to minimize the makespan. The makespan is the total length of the schedule (that is, when all the jobs have finished processing). Nowadays, the problem is presented as an online problem (dynamic scheduling), that is, each job is presented, and the online algorithm needs to make a decision about that job before the next job is presented.\nThis problem is one of the best known online problems, and was the first problem for which competitive analysis was presented, by Graham in 1966. Best problem instances for basic model with makespan objective are due to Taillard.","alt_names":[],"name":"Job shop scheduling","categories":["Combinatorial optimization","Mathematical optimization","Operations research","Optimization algorithms and methods","Pages using citations with accessdate and no URL","Wikipedia articles needing context from October 2009"],"tag_line":"Job shop scheduling (or job-shop problem) is an optimization problem in computer science and operations research in which ideal jobs are assigned to resources at particular times."}}
,{"_index":"throwtable","_type":"algorithm","_id":"alpha–beta-pruning","_score":0,"_source":{"description":"Alpha–beta pruning is a search algorithm that seeks to decrease the number of nodes that are evaluated by the minimax algorithm in its search tree. It is an adversarial search algorithm used commonly for machine playing of two-player games (Tic-tac-toe, Chess, Go, etc.). It stops completely evaluating a move when at least one possibility has been found that proves the move to be worse than a previously examined move. Such moves need not be evaluated further. When applied to a standard minimax tree, it returns the same move as minimax would, but prunes away branches that cannot possibly influence the final decision.\n\n","alt_names":[],"name":"Alpha–beta pruning","categories":["All articles with dead external links","Articles with dead external links from September 2010","Articles with example pseudocode","Articles with inconsistent citation formats","CS1 errors: dates","Game artificial intelligence","Graph algorithms","Optimization algorithms and methods","Search algorithms"],"tag_line":"Alpha–beta pruning is a search algorithm that seeks to decrease the number of nodes that are evaluated by the minimax algorithm in its search tree."}}
,{"_index":"throwtable","_type":"algorithm","_id":"robinson–schensted–knuth-correspondence","_score":0,"_source":{"description":"In mathematics, the Robinson–Schensted–Knuth correspondence, also referred to as the RSK correspondence or RSK algorithm, is a combinatorial bijection between matrices A with non-negative integer entries and pairs (P,Q) of semistandard Young tableaux of equal shape, whose size equals the sum of the entries of A. More precisely the weight of P is given by the column sums of A, and the weight of Q by its row sums. It is a generalization of the Robinson–Schensted correspondence, in the sense that taking A to be a permutation matrix, the pair (P,Q) will be the pair of standard tableaux associated to the permutation under the Robinson–Schensted correspondence.\nThe Robinson–Schensted–Knuth correspondence extends many of the remarkable properties of the Robinson–Schensted correspondence, notably its symmetry: transposition of the matrix A results in interchange of the tableaux P,Q.","alt_names":[],"name":"Robinson–Schensted–Knuth correspondence","categories":["Algebraic combinatorics","Combinatorial algorithms","Permutations","Symmetric functions"],"tag_line":"In mathematics, the Robinson–Schensted–Knuth correspondence, also referred to as the RSK correspondence or RSK algorithm, is a combinatorial bijection between matrices A with non-negative integer entries and pairs (P,Q) of semistandard Young tableaux of equal shape, whose size equals the sum of the entries of A."}}
,{"_index":"throwtable","_type":"algorithm","_id":"loopless-algorithm","_score":0,"_source":{"description":"In computational combinatorics, a loopless algorithm or loopless imperative algorithm is an imperative algorithm that generates successive combinatorial objects, such as partitions, permutations, and combinations, in constant time and the first object in linear time. The objects must be immediately available in simple form without requiring any additional steps.\nA loopless functional algorithm is a functional algorithm takes the form unfoldr step • prolog where step takes constant time and prolog takes linear time in the size of the input. The standard function unfoldr is a right-associative Bird unfold.","alt_names":["Loopless algorithm","Loopless algorithm - Wikipedia, the free encyclopedia","Loopless algorithm Wikipedia, the ...","Wikipedia article Loopless algorithm","Wikipedia entry for Loopless algorithm","http://en.wikipedia.org/wiki/Loopless_algorithm"],"name":"Loopless algorithm","categories":["All stub articles","Combinatorial algorithms","Combinatorics stubs"],"tag_line":"In computational combinatorics, a loopless algorithm or loopless imperative algorithm is an imperative algorithm that generates successive combinatorial objects, such as partitions, permutations, and combinations, in constant time and the first object in linear time."}}
,{"_index":"throwtable","_type":"algorithm","_id":"chaitin's-algorithm","_score":0,"_source":{"description":"Chaitin's algorithm is a bottom-up, graph coloring register allocation algorithm that uses cost/degree as its spill metric. It is named after its designer, Gregory Chaitin. Chaitin's algorithm was the first register allocation algorithm that made use of coloring of the interference graph for both register allocations and spilling.\nChaitin's algorithm was presented on the 1982 SIGPLAN Symposium on Compiler Construction, and published in the symposium proceedings. It was extension of an earlier 1981 paper on the use of graph coloring for register allocation. Chaitin's algorithm formed the basis of a large section of research into register allocators.","alt_names":["Chaitin's algorithm","Chaitin's algorithm - Wikipedia, the free ...","Chaitin's algorithm - Wikipedia, the free encyclopedia","Chaitin's algorithm by Wikipedia","Wikipedia article ''Chaitin's algorithm''","Wikipedia article Chaitin algorithm","Wikipedia article Chaitin's algorithm","http://en.wikipedia.org/wiki/Chaitin%27s_algorithm","http://en.wikipedia.org/wiki/Chaitin's_algorithm"],"name":"Chaitin's algorithm","categories":["Graph algorithms"],"tag_line":"Chaitin's algorithm is a bottom-up, graph coloring register allocation algorithm that uses cost/degree as its spill metric."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lin–kernighan-heuristic","_score":0,"_source":{"description":"This article is about the heuristic for the travelling salesman problem. For a heuristic algorithm for the graph partitioning problem, see Kernighan–Lin algorithm.\nIn combinatorial optimization, Lin–Kernighan is one of the best heuristics for solving the travelling salesman problem. Briefly, it involves swapping pairs of sub-tours to make a new tour. It is a generalization of 2-opt and 3-opt. 2-opt and 3-opt work by switching two or three paths to make the tour shorter. Lin–Kernighan is adaptive and at each step decides how many paths between cities need to be switched to find a shorter tour.\n\n","alt_names":[],"name":"Lin–Kernighan heuristic","categories":["Algorithms and data structures stubs","All stub articles","Applied mathematics stubs","Combinatorial algorithms","Combinatorial optimization","Computer science stubs","Heuristic algorithms","Travelling salesman problem"],"tag_line":"This article is about the heuristic for the travelling salesman problem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"iso-7064","_score":0,"_source":{"description":"ISO 7064 define algorithms for calculating check digit characters.","alt_names":["ISO 7064"],"name":"ISO 7064","categories":["All stub articles","Checksum algorithms","Computing stubs","Error detection and correction","ISO standards"],"tag_line":"ISO 7064 define algorithms for calculating check digit characters."}}
,{"_index":"throwtable","_type":"algorithm","_id":"d*","_score":0,"_source":{"description":"D* (pronounced \"D star\") is any one of the following three related incremental search algorithms:\nThe original D*, by Anthony Stentz, is an informed incremental search algorithm.\nFocused D* is an informed incremental heuristic search algorithm by Anthony Stentz that combines ideas of A* and the original D*. Focused D* resulted from a further development of the original D*.\nD* Lite is an incremental heuristic search algorithm by Sven Koenig and Maxim Likhachev that builds on LPA*, an incremental heuristic search algorithm that combines ideas of A* and Dynamic SWSF-FP.\nAll three search algorithms solve the same assumption-based path planning problems, including planning with the freespace assumption, where a robot has to navigate to given goal coordinates in unknown terrain. It makes assumptions about the unknown part of the terrain (for example: that it contains no obstacles) and finds a shortest path from its current coordinates to the goal coordinates under these assumptions. The robot then follows the path. When it observes new map information (such as previously unknown obstacles), it adds the information to its map and, if necessary, replans a new shortest path from its current coordinates to the given goal coordinates. It repeats the process until it reaches the goal coordinates or determines that the goal coordinates cannot be reached. When traversing unknown terrain, new obstacles may be discovered frequently, so this replanning needs to be fast. Incremental (heuristic) search algorithms speed up searches for sequences of similar search problems by using experience with the previous problems to speed up the search for the current one. Assuming the goal coordinates do not change, all three search algorithms are more efficient than repeated A* searches.\nD* and its variants have been widely used for mobile robot and autonomous vehicle navigation. Current systems are typically based on D* Lite rather than the original D* or Focused D*. In fact, even Stentz's lab uses D* Lite rather than D* in some implementations. Such navigation systems include a prototype system tested on the Mars rovers Opportunity and Spirit and the navigation system of the winning entry in the DARPA Urban Challenge, both developed at Carnegie Mellon University.\nThe original D* was introduced by Anthony Stentz in 1994. The name D* comes from the term \"Dynamic A*\", because the algorithm behaves like A* except that the arc costs can change as the algorithm runs.","alt_names":[],"name":"D*","categories":["Graph algorithms","Robot control","Search algorithms"],"tag_line":"D* (pronounced \"D star\") is any one of the following three related incremental search algorithms:\nThe original D*, by Anthony Stentz, is an informed incremental search algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"push–relabel-maximum-flow-algorithm","_score":0,"_source":{"description":"In mathematical optimization, the push–relabel algorithm (alternatively, preflow–push algorithm) is an algorithm for computing maximum flows. The name \"push–relabel\" comes from the two basic operations used in the algorithm. Throughout its execution, the algorithm maintains a \"preflow\" and gradually converts it into a maximum flow by moving flow locally between neighboring vertices using push operations under the guidance of an admissible network maintained by relabel operations. In comparison, the Ford–Fulkerson algorithm performs global augmentations that send flow following paths from the source all the way to the sink.\nThe push–relabel algorithm is considered one of the most efficient maximum flow algorithms. The generic algorithm has a strongly polynomial O(V2E) time complexity, which is asymptotically more efficient than the O(VE2) Edmonds–Karp algorithm. Specific variants of the algorithms achieve even lower time complexities. The variant based on the highest label vertex selection rule has O(V2√E) time complexity and is generally regarded as the benchmark for maximum flow algorithms. Subcubic O(VE log (V2/E)) time complexity can be achieved using dynamic trees, although in practice it is less efficient.\nThe push–relabel algorithm has been extended to compute minimum cost flows. The idea of distance labels has led to a more efficient augmenting path algorithm, which in turn can be incorporated back into the push–relabel algorithm to create a variant with even higher empirical performance.","alt_names":[],"name":"Push–relabel maximum flow algorithm","categories":["Graph algorithms","Network flow"],"tag_line":"In mathematical optimization, the push–relabel algorithm (alternatively, preflow–push algorithm) is an algorithm for computing maximum flows."}}
,{"_index":"throwtable","_type":"algorithm","_id":"iterative-deepening-a*","_score":0,"_source":{"description":"Iterative deepening A* (IDA*) is a graph traversal and path search algorithm that can find the shortest path between a designated start node and any member of a set of goal nodes in a weighted graph. It is a variant of iterative deepening depth-first search that borrows the idea to use a heuristic function to evaluate the remaining cost to get to the goal from the A* search algorithm. Since it is a depth-first search algorithm, its memory usage is lower than in A*, but unlike ordinary iterative deepening search, it concentrates on exploring the most promising nodes and thus doesn't go to the same depth everywhere in the search tree. Unlike A*, IDA* doesn't utilize dynamic programming and therefore often ends up exploring the same nodes many times.\nWhile the standard iterative deepening depth-first search uses search depth as the cutoff for each iteration, the IDA* uses the more informative  where  is the cost to travel from the root to node  and  is a problem-specific heuristic estimate of the cost to travel from  to the solution. As in A*, the heuristic has to have particular properties to guarantee optimality (shortest paths); see Properties, below.\nApplications of IDA* are found in such problems as planning. The algorithm was first described by Richard Korf in 1985.","alt_names":[],"name":"Iterative deepening A*","categories":["All articles needing expert attention","All articles that are too technical","Articles needing expert attention from November 2009","Articles with example pseudocode","Game artificial intelligence","Graph algorithms","Routing algorithms","Search algorithms","Wikipedia articles that are too technical from November 2009"],"tag_line":"Iterative deepening A* (IDA*) is a graph traversal and path search algorithm that can find the shortest path between a designated start node and any member of a set of goal nodes in a weighted graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"suurballe's-algorithm","_score":0,"_source":{"description":"In theoretical computer science and network routing, Suurballe's algorithm is an algorithm for finding two disjoint paths in a nonnegatively-weighted directed graph, so that both paths connect the same pair of vertices and have minimum total length. The algorithm was conceived by John W. Suurballe and published in 1974. The main idea of Suurballe's algorithm is to use Dijkstra's algorithm to find one path, to modify the weights of the graph edges, and then to run Dijkstra's algorithm a second time. The modification to the weights is similar to the weight modification in Johnson's algorithm, and preserves the non-negativity of the weights while allowing the second instance of Dijkstra's algorithm to find the correct second path.\nThe objective is strongly related to that of minimum cost flow algorithms, where in this case there are two units of \"flow\" and nodes have unit \"capacity\".","alt_names":["- Suurballe's algorithm :","Suurballe&#39;s algorithm - Wikipedia, the free encyclopedia","Suurballe's algorithm","Suurballe's algorithm - Wikipedia, the free ...","Suurballe's algorithm - Wikipedia, the free encyclopedia","Suurballe's algorithm by Wikipedia","Suurballe's_algorithm","Wikipedia article Suurballe's algorithm","http://en.wikipedia.org/wiki/Suurballe%27s_algorithm"],"name":"Suurballe's algorithm","categories":["Graph algorithms","Routing algorithms"],"tag_line":"In theoretical computer science and network routing, Suurballe's algorithm is an algorithm for finding two disjoint paths in a nonnegatively-weighted directed graph, so that both paths connect the same pair of vertices and have minimum total length."}}
,{"_index":"throwtable","_type":"algorithm","_id":"tarjan's-off-line-lowest-common-ancestors-algorithm","_score":0,"_source":{"description":"In computer science, Tarjan's off-line lowest common ancestors algorithm is an algorithm for computing lowest common ancestors for pairs of nodes in a tree, based on the union-find data structure. The lowest common ancestor of two nodes d and e in a rooted tree T is the node g that is an ancestor of both d and e and that has the greatest depth in T. It is named after Robert Tarjan, who discovered the technique in 1979. Tarjan's algorithm is an offline algorithm; that is, unlike other lowest common ancestor algorithms, it requires that all pairs of nodes for which the lowest common ancestor is desired must be specified in advance. The simplest version of the algorithm uses the union-find data structure, which unlike other lowest common ancestor data structures can take more than constant time per operation when the number of pairs of nodes is similar in magnitude to the number of nodes. A later refinement by Gabow & Tarjan (1983) speeds the algorithm up to linear time.","alt_names":[],"name":"Tarjan's off-line lowest common ancestors algorithm","categories":["Graph algorithms"],"tag_line":"In computer science, Tarjan's off-line lowest common ancestors algorithm is an algorithm for computing lowest common ancestors for pairs of nodes in a tree, based on the union-find data structure."}}
,{"_index":"throwtable","_type":"algorithm","_id":"junction-tree-algorithm","_score":0,"_source":{"description":"The junction tree algorithm (also known as 'Clique Tree') is a method used in machine learning to extract marginalization in general graphs. In essence, it entails performing belief propagation on a modified graph called a junction tree. The basic premise is to eliminate cycles by clustering them into single nodes.","alt_names":["Junction Tree Algorithm in Wikipedia","Junction tree algorithm","Junction tree algorithm - Wikipedia :: The free encyclopedia","Junction tree algorithm - Wikipedia, the free encyclopedia","Junction tree algorithm - Wikipedia, the free encyclopedia ...","Junction tree algorithm by Wikipedia","Junction tree算法","Wikipedia (Junction tree algorithm)","Wikipedia article Junction tree algorithm","Wikipedia article Junction-tree algorithm","Wikipedia entry for Junction tree algorithm","Wikipedia: Junction Tree Alg","en.wikipedia.org/wiki/Junction_tree_algorithm","http://en.wikipedia.org/wiki/Junction_tr","http://en.wikipedia.org/wiki/Junction_tree_algorithm","junction tree algorithm","junction trees","junction-tree","yago-res:Junction tree algorithm"],"name":"Junction tree algorithm","categories":["All articles to be expanded","All articles with empty sections","All stub articles","Articles to be expanded from November 2010","Articles with empty sections from November 2010","Artificial intelligence stubs","Bayesian networks","Graph algorithms"],"tag_line":"The junction tree algorithm (also known as 'Clique Tree') is a method used in machine learning to extract marginalization in general graphs."}}
,{"_index":"throwtable","_type":"algorithm","_id":"force-directed-graph-drawing","_score":0,"_source":{"description":"Force-directed graph drawing algorithms are a class of algorithms for drawing graphs in an aesthetically pleasing way. Their purpose is to position the nodes of a graph in two-dimensional or three-dimensional space so that all the edges are of more or less equal length and there are as few crossing edges as possible, by assigning forces among the set of edges and the set of nodes, based on their relative positions, and then using these forces either to simulate the motion of the edges and nodes or to minimize their energy.\nWhile graph drawing can be a difficult problem, force-directed algorithms, being physical simulations, usually require no special knowledge about graph theory such as planarity.","alt_names":[],"name":"Force-directed graph drawing","categories":["Articles with example pseudocode","Graph algorithms","Graph drawing","Pages containing cite templates with deprecated parameters"],"tag_line":"Force-directed graph drawing algorithms are a class of algorithms for drawing graphs in an aesthetically pleasing way."}}
,{"_index":"throwtable","_type":"algorithm","_id":"havel–hakimi-algorithm","_score":0,"_source":{"description":"The Havel–Hakimi algorithm is an algorithm in graph theory solving the graph realization problem, i.e. the question if there exists for a finite list of nonnegative integers a simple graph such that its degree sequence is exactly this list. For a positive answer the list of integers is called graphic. The algorithm constructs a special solution if one exists or proves that one cannot find a positive answer. This construction is based on a recursive algorithm. The algorithm was published by Havel (1955), and later by Hakimi (1962).","alt_names":[],"name":"Havel–Hakimi algorithm","categories":["CS1 Czech-language sources (cs)","Graph algorithms"],"tag_line":"The Havel–Hakimi algorithm is an algorithm in graph theory solving the graph realization problem, i.e."}}
,{"_index":"throwtable","_type":"algorithm","_id":"courcelle's-theorem","_score":0,"_source":{"description":"In the study of graph algorithms, Courcelle's theorem is the statement that every graph property definable in the monadic second-order logic of graphs can be decided in linear time on graphs of bounded treewidth. The result was first proved by Bruno Courcelle in 1990 and independently rediscovered by Borie, Parker & Tovey (1992). It is considered the archetype of algorithmic meta-theorems.","alt_names":[],"name":"Courcelle's theorem","categories":["Graph algorithms","Graph minor theory","Metatheorems"],"tag_line":"In the study of graph algorithms, Courcelle's theorem is the statement that every graph property definable in the monadic second-order logic of graphs can be decided in linear time on graphs of bounded treewidth."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sorting-algorithm","_score":0,"_source":{"description":"A sorting algorithm is an algorithm that puts elements of a list in a certain order. The most-used orders are numerical order and lexicographical order. Efficient sorting is important for optimizing the use of other algorithms (such as search and merge algorithms) which require input data to be in sorted lists; it is also often useful for canonicalizing data and for producing human-readable output. More formally, the output must satisfy two conditions:\nThe output is in nondecreasing order (each element is no smaller than the previous element according to the desired total order);\nThe output is a permutation (reordering) of the input.\nFurther, the data is often taken to be in an array, which allows random access, rather than a list, which only allows sequential access, though often algorithms can be applied with suitable modification to either type of data.\nSince the dawn of computing, the sorting problem has attracted a great deal of research, perhaps due to the complexity of solving it efficiently despite its simple, familiar statement. For example, bubble sort was analyzed as early as 1956. A fundamental limit of comparison sorting algorithms is that they require linearithmic time – O(n log n) – in the worst case, though better performance is possible on real-world data (such as almost-sorted data), and algorithms not based on comparisons, such as counting sort, can have better performance. Although many consider sorting a solved problem – asymptotically optimal algorithms have been known since the mid-20th century – useful new algorithms are still being invented, with the now widely used Timsort dating to 2002, and the library sort being first published in 2006.\nSorting algorithms are prevalent in introductory computer science classes, where the abundance of algorithms for the problem provides a gentle introduction to a variety of core algorithm concepts, such as big O notation, divide and conquer algorithms, data structures such as heaps and binary trees, randomized algorithms, best, worst and average case analysis, time-space tradeoffs, and upper and lower bounds.\n\n","alt_names":["Sorting algorithm - Wikipedia","Sıralama algoritmaları","stable algorithms","http://zh.wikipedia.org/zh/%E6%8E%92","Stabile","Wikipedia has a nice table","sort algorithms","sorted lists","sortowanie","정렬","нестабильный","sorting algorithm","stabiler","Алгоритмы сортировки","sortieralgorithmen","http://es.wikipedia.org/wiki/Algoritmos_…","sortowania","Comparison of algorithms","Sortieralgorithmen","stable sort","sorting algorithms","Sorting Algorithms","排序","ソート","Sortierverfahren","Sorting algorithm","&Oscr; n","&Oscr; n log n","'Insertion Sort'","(ordenación,","(ordenação,","(ordinamento,","(pemilahan,","(phân loại,","(sortieren,","(stable so","(tri,","(сортировка,","(เรียง ลำดับ,","- Kereső algoritmusok","- Rendező algoritmusok","- Sorting algorithm :","- Stable sort :","-> Leggi tutto l'articolo su 'Algoritmo di ordinamento","-> Read the article about 'Sorting algorithm'",". Надо также представлять, что такое","...Wikipedia Algorithme de tri","...Wikipedia Algoritmo de ordenamiento","...Wikipedia Algoritmo de ordenação","...Wikipedia Algoritmo di ordinamento","...Wikipedia Sortering","...Wikipedia Sorteringsalgoritm","...Wikipedia Sortowanie","...Wikipedia Tri stable","...mehr auf Wikipedia über Sortierverfahren","...mehr auf Wikipedia über Stabiles Sortierverfahren","...more on Wikipedia about Sorting algorithm","/関数を並べ替える方法","08b0042dc2d29e154b67c ...","1.1 Stability","1.1 비교 정렬","1.2 안정 정렬과 불안정 정렬","1.3 제자리 정렬","1.4 온라인 정렬","2 Comparison of algorithms","2 Estabilidad","2 List of sorting algorithms","2 Table of sorting algorithms","2 排列算法列表","2 정렬 알고리즘의 목록","2.1 Stable","2.1 稳定的","2.1 穩定的","2.1 안정 정렬","2.2 Unstable","2.2 不稳定","2.2 不穩定","2.2 불안정 정렬","2.3 不实用的排序算法","2.3 不實用的排序算法","2/11/06:ALGORITMI D'0RDINAMENTO(cliccate qui","20 אלגוריתמים שימושיים","220px-Bubblesort-edited.png","28087fab7257e9f24f6f78e64c ...","3 Inefficient/humorous sorts","3 Lista de algoritmos de ordenamiento","3 Summaries of popular sorting algorithms","3 Summaries of some popular sorting algorithms","3 Summaries of the popular sorting algorithms","3 排序的算法","3.1 Bubble sort","3.1 插入排序","3.10 Bucket sort","3.11 Radix sort","3.12 Distribution sort","3.13 Timsort","3.2 Insertion sort","3.2 Selection sort","3.2 冒泡排序","3.3 Insertion sort","3.3 Shell sort","3.3 选择排序","3.4 Merge sort","3.4 Shell sort","3.4 快速排序","3.5 Comb sort","3.5 Heapsort","3.5 Merge sort","3.5 堆排序","3.6 Heapsort","3.6 Merge sort","3.6 Quicksort","3.6 Radix sort","3.6 外部排序","3.7 Heapsort","3.7 Quicksort","3.7 Radix sort","3.8 Bucket sort","3.8 Quicksort","3.9 Counting Sort","3.9 Radix sort","4 Graphical representations","4 Memory usage patterns and index sorting","4 Summaries of popular sorting algorithms","4 平均时间复杂度","4.1 Bubble sort","4.10 Distribution sort","4.2 Insertion sort","4.3 Shell sort","4.4 Merge sort","4.5 Heapsort","4.6 Quicksort","4.7 Counting Sort","4.8 Bucket sort","4.9 Radix sort","5 Graphical representations","5 Inefficient/humorous sorts","5 Memory usage patterns and index sorting","5 实际测试结果","5Falgorithmsをhttp://en.wikipedia.org/wiki/Sorting","5Falgorithmをhttp://en.wikipedia.org/wiki/Sorting","9fb7de5820bc661e7cab9281ea68ee ...","<a href=http://en.wikipedia.org/wiki/Sorting_algorithm","A Wikipedia article on sorting","A good overview of Sorting Algorithms","Algo de tri","Algorithme de tri","Algorithme de tri - Wikip","Algorithme de tri - Wikip?dia","Algorithme de tri - Wikipédia","Algorithme de tri - Wikipédia http://fr.wikipedia.org","Algorithme de tri - Wikipédia à bulle • par sélection","Algorithmen Blase, Quicksort","Algorithmes de trie","Algorithmes de tris","Algorithmus zum Sortieren","Algoritma Sıralama -","Algoritmi Ordinamento","Algoritmi di SORT","Algoritmi di Sort(ordinamento)","Algoritmi di ordinamento","Algoritmi sortiranja (Wikipedia)","Algoritmo de ordenamiento","Algoritmo de ordenamiento - Wikipedia, la enciclopedia libre","Algoritmo de ordenação","Algoritmo de ordenação - Wikipedia","Algoritmo de ordenação - Wikipédia, a enciclopédia livre","Algoritmo de ordenação – Wikipédia, a enciclopédia livre","Algoritmo di ordinamento","Algoritmo di ordinamento - Wikipedia","Algoritmo di ordinamento:","Algoritmo_de_ordenação","Algoritmos de Ordanamiento (Wiki)","Algoritmos de Ordenamiento","Algoritmos de Ordenamientos","Algoritmos de Ordenação","Algoritmos de ordenación","Algoritmos de ordenação","Algoritmos de ordenação:","Algoritmus triedenia","Algorítmo de ordenação","Algorítmos de ordenamiento","Algorîtmayê rêzkerdişî","Big-O Analysis","Big-O of Sorting Algorithms","Bookmark this page.","Bubble sort - O(1) auxiliary","Comece por aqui","Comparaison algorithmes de tri","Comparison of Sorting Algorithms","Comparison of Sorting Algorithms - Wiki","Comparison of sorting algorithms","Counting Sort - O(n + k)","Datu šķirošanas algoritmi","DeWikipedia:Stabiles_Sortierverfahren","Definicion y conceptos sobre ordenamiento","Di ordinamento","Distribution sort","Encyclopedia: Sorting algorithm","Flettesortering","Für das topologische Sortieren gibt es Algorithmen, deren","Giải thuật sắp xếp","Heapsort - Θ(n) total, Θ(1) auxiliary","Here you can check sorting algorithms","Here's the Wiki article about common sorts","I see a new one on the list","Ideal behavior for a sort is O(n","In computer science, a sorting algorithm is an","Inefficient/h...","Infos zu Sortierverfahren","Insertion sort - О(n) total, O(1) auxiliary","It needs to be sorted","Know more about Sorting Algorithms...","Kompleksitet av sorterings algoritmer","Komplexitaetsuebersicht","Lajittelualgoritmi","Lajittelualgoritmi – Wikipedia","Learn about Sorting algorithm>>>","Learn more about stable algorithms.","Les algorithmes de tri","Les algorithmes de tri sur Wikipedia","List of sorting algorithms","Lista de algoritmos de ordenamiento","Many other Sorting Algorithms","Merge sort - Θ(n) auxiliary","More on sorting from Wikipedia","More sorting Algorithm","Méthode de tri","Métodos de Ordenação","Métodos de ordenamiento","Not to be unfounded","O(n log n) algorithms","O(n log² n)","O(n) algorithms","O(n*log(n))","Order of Complexity of Sorting Algorithms","Ordinamento","Ordinamento di dati","Pick a sorting algorithm and implement it","Pierwszy z wyników z Google spod podanego przez","Prezentare teoretica a algoritmilor de sortare","Prezentare teoretice a algoritmilor de sortare","Quicksort - Θ(n)","Radix sort - O(kN)","Read More About sorting algorithm - wikipedia the free","Read More About sorting algorithm wikipedia the free","Read More sorting algorithm wikipedia the free encyclopedia","Refresh Basics - Sorting Algorithms","Rendezés (programozás)","Rendezés (programozás) - Wikipédia","Rikiavimo algoritmų sudėtingumas","Röðunarreiknirit","Rūšiavimo algoritmas tiesinėje duomenų struktūroje","S?ralama algoritmas? - Vikipedi","Screenshot http://en.wikipedia.org/wiki/Sorting_algorithm","Selection Sort Algorithm","Shell sort - O(n)","Siehe auch z.B. hier...","Siralama algoritmasi - Vikipedi","Sobre algorismes d'ordenació","Sort (computing)","Sort Algorithms","Sort algorithm","Sort algorithms","Sort stability","Sort the numerators","Sorted array","Sorted list","Sorteer-algoritme","Sorteeralgoritme","Sorteeralgoritme - Wikipedia","Sortering Algoritme","Sorteringsalgoritm","Sorteringsalgoritme","Sorteringsalgoritme - Wikipedia","Sorteringsalgoritmer","Sortier-","Sortier-Algorithmus","Sortier-Algorithmus - Wikipedia","Sortieralgorithmen - Wikipedia","Sortieralgorithmen - allg.","Sortieralgorithmen bei Wikipdia","Sortieralgorithmen bei Wikipedia","Sortieralgorithmen im Vergleich","Sortieralgorithmus","Sortierverfahren (Wiki)","Sortierverfahren (Wikipedia)","Sortierverfahren (deutsche Wikipedia)","Sortierverfahren ? Wikipedia","Sortierverfahren @ wikipedia.de","Sortierverfahren â€“ Wikipedia","Sortierverfahren – Wikipedia","Sortierverfahren#Vergleichsbasiertes Sortieren","Sortierverfahren->Sektion 1","Sortierverfahren: QuickSort","Sortimisalgoritm - Vikipeedi...","Sorting (Wikipedia)","Sorting - oldal","Sorting Algorithm","Sorting Algorithm (Wikipedia)","Sorting Algorithm - Wikipedia","Sorting Algorithm - Wikipedia, The Free Encyclopedia","Sorting Algorithm Wiki","Sorting Algorithm Wiki.","Sorting Algorithm Wikipedia The Free Encyclopedia","Sorting Algorithm from The WikiPedia","Sorting Algorithm na Wikipédia em inglês","Sorting Algorithms (Wikipedia)","Sorting Algorithms - a sorting algorithm is an algorithm","Sorting Algorithms Wiki","Sorting Algorithms Wikipedia entry","Sorting Algorithms in Wikipedia","Sorting Algorithms in general","Sorting Algorithms on Wikipedia","Sorting Algorithms page","Sorting Alogrithms @ Wikipedia","Sorting Demo: http://www.cs.ubc.ca/spider","Sorting Types","Sorting algorithm (englische Wikipedia)","Sorting algorithm (wikipedia.org) [ http://en.wikipedia.org","Sorting algorithm - Selection sort","Sorting algorithm - Wikiped...","Sorting algorithm - Wikipedia :: The free encyclopedia","Sorting algorithm - Wikipedia, the free enc","Sorting algorithm - Wikipedia, the free encycloped","Sorting algorithm - Wikipedia, the free encyclopedia","Sorting algorithm - Wikipedia, the free encyclopedia El-Es","Sorting algorithm - Wikipedia, the free encyclopediaFrom Wikipedia","Sorting algorithm @ Wikipedia","Sorting algorithm Wikipedia the free encyclopedia","Sorting algorithm#Classification|Classifications of sorting algorithms","Sorting algorithm- , the free encyclopedia","Sorting algorithm.","Sorting algorithm: List of sorting algorithms","Sorting algorithm: Merge sort","Sorting algorithm: Quicksort","Sorting algorithm; it is used under the","Sorting algorithms","Sorting algorithms at Wikepedia","Sorting algorithms by Wikipedia","Sorting algorithms: comparison","Sorting algori…","Sorting takes O(n log n)","Sorting wiki","Sorting_algorithm","Sorting_algorithm#Comparison_of_algorithms","Sortowanie","Sortowanie - Wikipedia, wolna encyklopedia","Sortowanie â�“ Wikipedia, wolna encyklopedia","Sortowanie – Wikipedia, wolna encyklopedia","Sortowanie.","Stabil (Sortierverfahren)","Stabil (Sortierverfahren) - Wikipedia","Stabil_(Sortierverfahren) bei der wikipedia","Stabiles Sortierverfahren","Stabiles_Sortierverfahren","Stabiles_Sortierverfahren bei der wikipedia","Stability of a sorting algorithm","Stabilität (Sortierverfahren)","Stabilität (Sortierverfahren) - Wikipedia","Stabilität (Sortierverfahren) ? Wikipedia","Stabilität (Sortierverfahren) – Wikipedia","Stabilus rikiavimo algoritmas","Stable sort","Stable sorting","Stable vs. Unstable","Stable,","Stranica 8:","Summaries of popular ...","Summaries of popular sorting algorithms","Summaries of some popular sorting algorithms","Summaries of...","Summary of popular sorting algorithms","Survey of Sorting Algorithms","SÄ±ralama algoritmasÄ± - Vikipedi","Sıralama algoritması","Sıralama algoritması - Vikipedi","Table of in-place and not-in-place","Table of in-place and not-in-place algorithms","Thumbnail of screenshot of Sorting algorithm - Wikipedia, the","Thuật toán sắp xếp","Thuật toán sắp xếp – Wikipedia tiếng Việt","Triediaci algoritmus","Triediaci algoritmus - WikipÃ©dia","Trumpi aprašymai","Tutaj masz opis najpopularniejszych metod sortowania","Třídění","Tải","Utfg","Various array sorting algorithms","Vergleich von Sortieralgorithmen","Vergleich von Sortiersalgorithmen","Vários algoritmos","Wann ist ein Sortieralgorithmus stabil?","What is classification for Comparison of sorting algorithms","What is classification for Sort algorithms","What is classification of Comparison of sorting algorithms","Wiki Links to Sorts","Wiki Sorting Algorithm","Wiki Sorting Algorithms","Wiki link to popular sorting algorithms","Wiki ソート","Wiki's Sort Algorithms Complexity","WikiPedia:Sorting_algorithm","Wikipedia (Algoritmo de ordenação)","Wikipedia - Algoritmi de sortare","Wikipedia - Sorting Algorithm","Wikipedia - Sorting Algorithms","Wikipedia - Sorting algorithm","Wikipedia - Stabilität (Sortierverfahren)","Wikipedia - sortowanie","Wikipedia Page on Sorting Algorithms","Wikipedia Sortierung Eintrag","Wikipedia Sorting","Wikipedia Sorting Algorithm Entry","Wikipedia Sorting Algorithm Page","Wikipedia Sorting Algorithms","Wikipedia article Algorithme de tri","Wikipedia article Algoritmo de ordenamiento","Wikipedia article Algoritmo de ordenação","Wikipedia article Algoritmo di ordinamento","Wikipedia article Algorîtmayê rêzkerdişî","Wikipedia article Röðunarreiknirit","Wikipedia article Sorted array","Wikipedia article Sorteringsalgoritme","Wikipedia article Sortierverfahren","Wikipedia article Stabilität (Sortierverfahren)","Wikipedia article Stable sort","Wikipedia article Zortéieralgorithmus","Wikipedia article for sorting algorithms","Wikipedia article on Algoritmo de ordenamiento","Wikipedia article on Sorting algorithm","Wikipedia article on Sorting algorithms","Wikipedia article on Stable sort","Wikipedia article Řadicí algoritmus","Wikipedia article Мәліметтерді сұрыптау","Wikipedia article Ойыркалымаш","Wikipedia article Տեսակավորման ալգորիթմ","Wikipedia article מיון (מדעי המחשב)","Wikipedia article الگوریتم مرتبسازی","Wikipedia article خوارزميات الترتيب","Wikipedia article ขั้นตอนวิธีการเรียงลำดับ","Wikipedia article 정렬 알고리즘","Wikipedia artikel Sorteer-algoritme","Wikipedia artikel Sorteeralgoritme","Wikipedia artiklen for sortering algoritmer","Wikipedia entry Sorting Algorithm","Wikipedia entry for Sorting algorithm","Wikipedia entry for sorting algorithms","Wikipedia ha una bella tabella","Wikipedia hat einen schönen Tisch","Wikipedia heeft een leuke tafel","Wikipedia is the sort of the algorithm","Wikipedia l'articolo Algoritmi di ordinamento","Wikipedia ma ładny tabeli","Wikipedia om sortering","Wikipedia on sorting algorithms","Wikipedia page of sorting algorithms","Wikipedia page on sorting","Wikipedia sorteren neem","Wikipedia sortering post","Wikipedia sorting entry","Wikipedia tiene una buena mesa","Wikipedia zu Sortieralgorithmen","Wikipedia über Sortierverfahren (mit Übersicht und Beweis der","Wikipedia におけるソートの解説","Wikipedia のソートの項目","Wikipedia ソート","Wikipedia 的排序算法比较","Wikipedia's Sorting Algorithm","Wikipedia's Sorting Algorithm page","Wikipedia's Sorting Algorithms","Wikipedia's article on Sorting Algorithms","Wikipedia's section on sorting algorithms","Wikipedia, algoritmos de ordenamiento","Wikipedia-Artikel Sortieralgorithmen","Wikipedia-Artikel Sortieralgorithmus","Wikipedia-Artikel Sortierverfahren","Wikipedia-Artikel Stabil (Sortierverfahren)","Wikipedia-Artikel Stabiles Sortierverfahren","Wikipedia-Artikel zu Sortieralgorithmen","Wikipedia-Artikel zum Thema Sortierverfahren zu lesen","Wikipedia-Seite zu 'Sortieralgorithmen'","Wikipedia-Seite zu 'Sortieralgorithmus'","Wikipedia-Seite zu 'Sortierverfahren'","Wikipedia-Seite zu 'Stabil (Sortierverfahren)'","Wikipedia-Seite zu 'Stabiles Sortierverfahren'","Wikipedia-Seite zu 'Stabilität (Sortierverfahren)'","Wikipedia-Seite über das Sortieren","Wikipedia-artikel voor het sorteren van algoritmen","Wikipedia/Sorting algorithm","Wikipedia: Sortieralgorithmen","Wikipedia: Sortierverfahren","Wikipedia: Sorting Algorithm","Wikipedia: Sorting Algorithm (kap.8-12)","Wikipedia: Sorting algorithm","Wikipedia:Algoritmo_di_ordinamento","Wikipedia:ソーティング","Wikipediaのソート","Wikipediaのソートアルゴリズムの項","Wikipedia的排序算法比较","Wikipédia : Les algorithmes de tri","Wikipédia artigo Algoritmo de ordenação","Wikipédia artigo Ordenação de vector","Xem Tại Đây","Zort ieralgorithmus Wikipedia","Zortéieralgorithmus – Wikipedia","[/url][url=http://vi.wikipedia.org/wiki/Thu","[Komplexitätsübersicht]","a handy Wikipedia primer","a list of sorting algorithms","a method/function to sort","actual official term","algorismes d'ordenació","algorithm for sorting","algorithme de tri","algorithmes de tri","algorithmes de tri généraux","algorithms bubble, quicksort","algoritma pengurutan.","algoritma penyortiran","algoritma sorting","algoritma2 sorting","algoritmi d'ordinamento","algoritmi di Ordinamento, cioè algoritmi di Sort","algoritmi di ordinamento","algoritmi di ordinamento.","algoritmilor de sortare","algoritmo de ordenación","algoritmo de ordenamiento","algoritmo de ordenaçao","algoritmo de ordenação","algoritmo di ordinamento","algoritmos de burbuja, quicksort","algoritmos de ordenacion","algoritmos de ordenación","algoritmos de ordenamiento","algoritmos de ordenar dados","algoritmos de ordenação","algoritmos de ordenação.","algoritmos para ordenar","algoritmos para ordenação","algoritmov za urejanje podatkov","algoritmus třídění","algoritmů řazení","algorytm sortujący","algorytmów sortowania","algorítimos de ordenação","algorítmo de ordenação","alle sorteeralgoritmes die je maar wil","any of the well known sorting algorithms","ar:خوارزميات الترتيب","array sorted","article « Algorithme de tri » sur wikipédia","articolo di Wikipedia per algoritmi di ordinamento","artigo da Wikipédia Algoritmo de ordenação","artykuł na Wikipedii algorytmy","artículo de Wikipedia Algoritmo de ordenación","artículo de Wikipedia Algoritmo de ordenamiento","artículo de Wikipedia Algoritmos de ordenación","artículo de Wikipedia Algoritmos de ordenamiento","artículo de Wikipedia para la clasificación de algoritmos","as efficiently as possible","baf25e538aa9389eab2cd1a8c4189e ...","bekannte Beziehung für den Aufwand","best cases","brief descriptions","bubble algorithms, quicksort,","bất kỳ cũng được biết đến các thuật","check this page.","classificação estável","comparación de los algoritmos de clasificación","comparison of sorting algorithms","comparisons of their speeds","complexity of sorting","computer sorting algorithms","could have done worse","cs:Řadicí algoritmus","cualquiera de los conocidos algoritmos de ordenación.","các thuật toán phân loại.","d'algorithmes de tri.","da:Sorteringsalgoritme","de forma estable","de stabiliteit","de tri algorithme","de.wikipedia.org/...Sortierverfahren","de.wikipedia.org/wik...les_Sortierverfahren","de.wikipedia.org/wiki/Sortieralgorithmen","de.wikipedia.org/wiki/Sortieralgorithmus","de.wikipedia.org/wiki/Sortierverfahren","de.wikipedia.org/wiki/Sortierverfahren#Nicht-vergleichsbasiertes_Sortieren","de.wikipedia.org/wiki/Stabil_(Sortierverfahren)","de:Sortierverfahren","di ordinamento","different kinds of sorting algorithms","disk sort","distribution sorting","e sorting algorith","een methode / functie om te sorteren","eine Methode / Funktion zu sortieren","eine der","en metode / funktion til at sortere","en place","en.wikipedia.org/...Sorting_algorithm","en.wikipedia.org/...Stable_sort","en.wikipedia.org/wiki/Sort_(computing)","en.wikipedia.org/wiki/Sorti...","en.wikipedia.org/wiki/Sorting algorithm","en.wikipedia.org/wiki/Sorting_algorit...","en.wikipedia.org/wiki/Sorting_algorithm","en.wikipedia.org/wiki/Sorting_algorithm#Stability","en.wikipedia.org/wiki/Sorting_algorithms","en.wikipedia.org/wiki/Stable_sort#Stability","en:Sorting_algorithm","entrada de clasificación Wikipedia","ery possible type seems already to have been","es.wikipedia.org/wiki/Algoritmo_de_ordenamiento","es:Algoritmo de ordenamiento","estáveis","et:Sortimisalgoritm","fa.wikipedia.org/...%80%8C%D8%B3%D8","fa:الگوریتم مرتبسازی","fi:Lajittelualgoritmi","fin oversikt over kompleksiteten av de fleste sorteringsalgoritmene","forklaring her","fr.wikipedia.org/wiki/Algorithme_de_tri","fr:Algorithme de tri","fr:Algorithme_de_tri","halaman wikipedia menyortir","he:מיון (מדעי המחשב)","healthy-sorting algorithm wikipedia the encyclopedia","het sorteren van algoritmen","http://cs.wikipedia.org/wiki/%C5%98adic%C3","http://cs.wikipedia.org/wiki/Algoritmus_%C5%99azen","http://cs.wikipedia.org/wiki/Algoritmus_řazení","http://de.wikipedia.org/wiki/So rtieralgorithmus","http://de.wikipedia.org/wiki/So rtierverfahren","http://de.wikipedia.org/wiki/Sortier...rtes_Sortieren","http://de.wikipedia.org/wiki/Sortieralgorithmen","http://de.wikipedia.org/wiki/Sortieralgorithmus","http://de.wikipedia.org/wiki/Sortierverf","http://de.wikipedia.org/wiki/Sortierverfah","http://de.wikipedia.org/wiki/Sortierverfahren","http://de.wikipedia.org/wiki/Sortierverfahren#Beweis_der_unteren...","http://de.wikipedia.org/wiki/Sortierverfahren#Beweis_der_unteren_Schranke_f.C3","http://de.wikipedia.org/wiki/Sortierverfahren#Vergleichsbasiertes_Sortieren","http://de.wikipedia.org/wiki/Sortierverfahren#Weblinks","http://de.wikipedia.org/wiki/Sortierverf…","http://de.wikipedia.org/wiki/Stabil_...erverfahren%29","http://de.wikipedia.org/wiki/Stabiles_So","http://de.wikipedia.org/wiki/Stabiles_Sortierverfahren","http://en.wikipedia....rting_algorithm","http://en.wikipedia....ting_algorithms","http://en.wikipedia.org/ wiki/ Sorting_algorithms","http://en.wikipedia.org/wiki/Sorted_array","http://en.wikipedia.org/wiki/Sorti [...] algorithms","http://en.wikipedia.org/wiki/Sorting 5Falgorithm% #% Comparación","http://en.wikipedia.org/wiki/Sorting% 5Falgorithm","http://en.wikipedia.org/wiki/Sorting% 5Falgorithm # Comparación","http://en.wikipedia.org/wiki/Sorting% 5Falgorithm # Porównanie","http://en.wikipedia.org/wiki/Sorting% 5Falgorithm # Sammenligning","http://en.wikipedia.org/wiki/Sorting% 5Falgorithm # Vergelijking","http://en.wikipedia.org/wiki/Sorting% 5Falgorithm #% 5Fof","http://en.wikipedia.org/wiki/Sorting%5Falgorithm","http://en.wikipedia.org/wiki/Sorting%5Falgorithm#Comparison","http://en.wikipedia.org/wiki/Sorting...Classification","http://en.wikipedia.org/wiki/Sorting..._index_sorting","http://en.wikipedia.org/wiki/Sorting..._of_algorithms","http://en.wikipedia.org/wiki/Sorting...ing_algorithms","http://en.wikipedia.org/wiki/Sorting...ithm#Quicksort","http://en.wikipedia.org/wiki/Sorting...ithm#Stability","http://en.wikipedia.org/wiki/Sorting...thm#Radix_sort","http://en.wikipedia.org/wiki/Sorting_al ... #Quicksort","http://en.wikipedia.org/wiki/Sorting_al ... #Stability","http://en.wikipedia.org/wiki/Sorting_al ... Merge_sort","http://en.wikipedia.org/wiki/Sorting_al … algorithms","http://en.wikipedia.org/wiki/Sorting_alg","http://en.wikipedia.org/wiki/Sorting_alg orithm#Comparison_of_algorithms","http://en.wikipedia.org/wiki/Sorting_alg orithm#Summaries_of_popular_sorting_algo","http://en.wikipedia.org/wiki/Sorting_alg...","http://en.wikipedia.org/wiki/Sorting_algor...ting_algorithms","http://en.wikipedia.org/wiki/Sorting_algorith m#Radix_sort","http://en.wikipedia.org/wiki/Sorting_algorith...","http://en.wikipedia.org/wiki/Sorting_algorithm","http://en.wikipedia.org/wiki/Sorting_algorithm # Comparison_of_algorithms","http://en.wikipedia.org/wiki/Sorting_algorithm # Estabilidad","http://en.wikipedia.org/wiki/Sorting_algorithm h","http://en.wikipedia.org/wiki/Sorting_algorithm#Bubble_sort","http://en.wikipedia.org/wiki/Sorting_algorithm#Classification","http://en.wikipedia.org/wiki/Sorting_algorithm#Classification...","http://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of[..]","http://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms","http://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms.","http://en.wikipedia.org/wiki/Sorting_algorithm#Counting_Sort","http://en.wikipedia.org/wiki/Sorting_algorithm#Graphical_representations","http://en.wikipedia.org/wiki/Sorting_algorithm#Insertion_sort","http://en.wikipedia.org/wiki/Sorting_algorithm#List_of_sorting_algorithms","http://en.wikipedia.org/wiki/Sorting_algorithm#List_of_sorting_algorithms=","http://en.wikipedia.org/wiki/Sorting_algorithm#Merge_sort","http://en.wikipedia.org/wiki/Sorting_algorithm#Quicksort","http://en.wikipedia.org/wiki/Sorting_algorithm#Radix_sort","http://en.wikipedia.org/wiki/Sorting_algorithm#Selection_sort","http://en.wikipedia.org/wiki/Sorting_algorithm#Shell_sort","http://en.wikipedia.org/wiki/Sorting_algorithm#Stability","http://en.wikipedia.org/wiki/Sorting_algorithm#Stability>","http://en.wikipedia.org/wiki/Sorting_algorithm#Summaries_of_[..]","http://en.wikipedia.org/wiki/Sorting_algorithm#Summaries_of_p","http://en.wikipedia.org/wiki/Sorting_algorithm#Summaries_of_popular_so rting_algorithms","http://en.wikipedia.org/wiki/Sorting_algorithm#Summaries_of_popular_sorting_algo...","http://en.wikipedia.org/wiki/Sorting_algorithm#Summaries_of_popular_sorting_algorithms","http://en.wikipedia.org/wiki/Sorting_algorithm#Summaries_of_popular_sorting_algorithms).","http://en.wikipedia.org/wiki/Sorting_algorithm(...)","http://en.wikipedia.org/wiki/Sorting_algorithm.","http://en.wikipedia.org/wiki/Sorting_algorithmfor","http://en.wikipedia.org/wiki/Sorting_algorithms","http://en.wikipedia.org/wiki/Sorting_algorithms#List_of_sorting_algorithms","http://en.wikipedia.org/wiki/Sorting_algorithms#Summaries_of_popular_sorting_algorithms","http://en.wikipedia.org/wiki/Sorting_algorithms.","http://en.wikipedia.org/wiki/Sorting_algorithm。","http://en.wikipedia.org/wiki/Sorting_algorithmを","http://en.wikipedia.org/wiki/Sorting_algorithm에서","http://en.wikipedia.org/wiki/Sorting_algorithm을","http://en.wikipedia.org/wiki/Sorting_algorithm＃安定性","http://en.wikipedia.org/wiki/Sorting_algÃƒÆ'Ã†â","http://en.wikipedia.org/wiki/Sorting_alg…","http://en.wikipedia.org/wiki/Sorting％5Falgorithm","http://en.wikipedia.org/wiki/Stable_sort","http://en.wikipedia.org/wiki/Stable_sort#Classification","http://en.wikipedia.org/wiki/Stable_sort#Comparison_of_algorithms","http://en.wikipedia.org/wiki/Stable_sort#List_of_sorting_algorithms","http://en.wikipedia.org/wiki/Stable_sort#Stability","http://en.wikipedia.org/wiki/Stable_sort#Stability&gt","http://en.wikipedia.org/wiki/Stable_sort#Stability)","http://en.wikipedia.org/wiki/Stable_sort#Stable","http://en.wikipedia.org/wiki/sorting_alg...","http://es.wikipedia....de_ordenamiento","http://es.wikipedia.org/wiki/Algoritmo_de_ordenaci%C3%B3n","http://es.wikipedia.org/wiki/Algoritmo_de_ordenamiento","http://es.wikipedia.org/wiki/Algoritmos_de_ordenamiento","http://et.wikipedia.org/wiki/Sortimisalgoritm","http://fr.wikipedia....gorithme_de_tri","http://fr.wikipedia.org/wiki/Algor [...] mes_de_tri","http://fr.wikipedia.org/wiki/Algorit..._tris_en_place","http://fr.wikipedia.org/wiki/Algorithme … mes_de_tri","http://fr.wikipedia.org/wiki/Algorithme_...s_en_place","http://fr.wikipedia.org/wiki/Algorithme_de_tri","http://fr.wikipedia.org/wiki/Algorithme_de_tri#Comparaison_des_algorithmes_de_tris_en_place","http://fr.wikipedia.org/wiki/Algorithme_de_tri#Complexit.C3","http://fr.wikipedia.org/wiki/Algorithme_de_tri#Exemples_d.27a","http://fr.wikipedia.org/wiki/Algorithme_de_tri#Tris_par_compa...","http://fr.wikipedia.org/wiki/Algorithme_de_tri(...)","http://fr.wikipedia.org/wiki/M%C3%A9thode_de_tri","http://fr.wikipedia.org/wiki/Méthode_de_tri","http://hu.wikipedia.org/wiki/Rendez%C3%A9s_","http://is.wikipedia.org/wiki/R%C3%B6","http://it.wikipedia.org/wiki/Algori...","http://it.wikipedia.org/wiki/Algorit...di_ordinamento","http://it.wikipedia.org/wiki/Algoritmi_d…","http://it.wikipedia.org/wiki/Algoritmo_ ... rdinamento","http://it.wikipedia.org/wiki/Algoritmo_di_ordinamento","http://it.wikipedia.org/wiki/Algoritmo_di_ordinamento#Elenco_degli_algoritmi_di_ordinamento","http://ja.wikipedia.org/wiki/ソート","http://ja.wikipedia.org/wiki/ソート#.E6.AF","http://ko.wikipedia.org/wiki/정렬_알고리즘","http://ku.wikipedia.org/wiki/Algor%C3%AEtmay","http://lb.wikipedia.org/wiki/Sort%C3%A9ierprozedur_","http://lt.wikipedia.org/wiki/Rikiavimo_algoritmas","http://lt.wikipedia.org/wiki/Stabilus_r%C5%AB","http://nl.wikipedia.org/wiki/Sorteer-algoritme","http://nl.wikipedia.org/wiki/Sorteeralgoritme","http://no.wikipedia.org/wiki/Sorteringsalgoritme","http://pl.wikipedia....wiki/Sortowanie","http://pl.wikipedia.org/wiki/Algorytmy_sortowania","http://pl.wikipedia.org/wiki/Sortowanie","http://pl.wikipedia.org/wiki/Sortowanie#Przyk.C5","http://pl.wikipedia.org/wiki/Sortowanie#Stabilne","http://pt.wikipedia....3%A3o_de_vector","http://pt.wikipedia....enação_de_vetor","http://pt.wikipedia....mo_de_ordenação","http://pt.wikipedia.org/wiki/Algorit...A3o_de_vetores","http://pt.wikipedia.org/wiki/Algorit...a%C3","http://pt.wikipedia.org/wiki/Algoritmo_ ... %A7%C3","http://pt.wikipedia.org/wiki/Algoritmo_de_...na%C3","http://pt.wikipedia.org/wiki/Algoritmo_de_ordena%C3%A7","http://pt.wikipedia.org/wiki/Algoritmo_de_ordenação","http://pt.wikipedia.org/wiki/Ordena%...%A3o_de_vector","http://pt.wikipedia.org/wiki/Ordena%C3%A","http://ru.wikipedia....ритм_сортировки","http://ru.wikipedia.org/wiki/Алгоритм_со...","http://ru.wikipedia.org/wiki/Алгоритм_сортировки","http://ru.wikipedia.org/wiki/Алгоритмы_сортировки","http://ru.wikipedia.org/wiki/Сортировки","http://sl.wikipedia.org/wiki/Algoritmi_za_urejanje_podatkov","http://sv.wikipedia.org/wiki/Sorteringsalgoritm","http://th.wikipedia.org/wiki/ขั้นตอนวิธีการเรียงลำดับ","http://tr.wikipedia.org/wiki/S%C4%B1ralama_algoritmas","http://tr.wikipedia.org/wiki/Sıralama_algoritması","http://vi.wikipedia.org/wiki/Thu%E1%...Fp_x","http://vi.wikipedia.org/wiki/Thuật_toán_sắp_xếp","http://www.es.wikipedia.org/wiki/Algoritmo_de_orde...","http://zh.wikipedia.org/wiki/%25E6%258E%2592","http://zh.wikipedia.org/wiki/排序算法","http://zh.wikipedia.org/zh-cn/排序算法","https://fr.wikipedia.org/wiki/Algorithme_de_tri","hu:Rendezés (programozás)","hy:Տեսակավորման ալգորիթմ","instabiles Sortierverfahren","is steady","is:Röðunarreiknirit","it:Algoritmo di ordinamento","ja:ソート","järjestämiseen","kk:Мәліметтерді сұрыптау","ko:정렬 알고리즘","ku:Algorîtmayê rêzkerdişî","l'article de Wikipédia Algorithme de tri","l'un des algorithmes de tri bien connu","la estabilidad","la stabilità","lajittelualgoritmeista","lb:Zortéieralgorithmus","les algorithmes de tri","lgoritimo de ordenação","lgoritmo de ordenação d","list of sort algorithms","list of sorting algorithms","lista di algoritmi di ordinamento","lista mahdollisimman nopeasti järjesteltyä","listado de algoritmos de ordenación","los algoritmos de clasificación.","lots of sort algorithms available","lt:Rikiavimo algoritmas","lv:Datu šķirošanas algoritmi","major sorting types","many algorithm available","method of sortin","method of sorting","metod sortowania","metody / funkcji do sortowania","mhr:Ойыркалымаш","mhtiroglA gnitroS","more on stable sorting","méthode quadratique","métodos de ordenamiento","n algoritem za urejanje podatkov","na Wikipedii článek","nice page on Wiki","nih gan, ane bantu","nl:Sorteeralgoritme","no comparativos","no:Sorteringsalgoritme","no:Sorteringsalgoritme#Boblesortering","no:Sorteringsalgoritme#Innstikksortering","no:Sorteringsalgoritme#Quick sort","no:Sorteringsalgoritme#Radix-sortering","non stable","not-stable","některý z dobře známé třídicí algoritmy","odpowiedni","ordenación estable","ordinamento non stabile","ordinamento stabile","ort t","orted","ortieralgorithmen","orting Algorithms Wiki","other sorting algorithms","page de wikipedia sur le tri","pagina Wikipedia dedicata acestui subiect","pagina di Wikipedia per l'ordinamento","pl:Sortowanie","popular sorting algorithms","preglednico na Wikipediji","problema da ordenação","problema de ordenar","pt.wikipedia.org/wiki/Algoritmo_de_ordena%C3%A7%C3","pt:Algoritmo de ordenação","página da Wikipedia sobre a triagem","página de Wikipedia sobre la clasificación","página de la wikipedia en la clasificación","põhjalik artikkel","qualquer um dos bem conhecidos algoritmos de classificação","quelques'un","read the real stuff in Wikipedia","recursive sorting algorithm","rendez©#S","rendezési módszert","rendező algoritmus","rikiavimo algoritmų","rting algorithm,","ru.wikipedia.org/wiki/Алгоритм_сортировки","ru:Алгоритм сортировки","rūšiavimo uždavinys","salah satu algoritma sorting yang terkenal.","simple sorting algorithms","since ideal sorting is O(n)","sk:Triediaci algoritmus","sl:Algoritmi za urejanje podatkov","sort elements in an array","sort operation","sort routines","sort, the MSD radix sort algorithm does not","sorted array","sorteda","sorteer-algoritme","sorteer-algoritmen","sorteeralgoritme","sorteergang","sortere","sortering algoritmer","sorteringsalgoritme","sorteringsalgoritmen","sorteringsalgoritmer","sortin algorithms","sorting algorith","sorting algorithm - Wikipedia, the free encyclopedia","sorting algorithm overview","sorting algorithm wikipedia the free encyclopedia","sorting algorithm,","sorting algorithms at Wikipedia","sorting algorithms in wikipedia","sorting algorithms.","sorting algoritma","sorting algoritms","sorting in wikipedia","sorting lists","sorting method","sorting methods","sorting problem","sorting records","sortowania stabilnego","square algorithm","stabiele soort","stabiele sorteren","stabil rendezés","stabil sortera","stabile Sortierung","stabilen Sortieralgorithmus","stabilen Sortierverfahren","stabiles Sortierverfahren","stabilnego","stabilnie","stabilność","stabilny","stabilny sortowania","stabilní","stabilní řazení","stabilně","stabilumą","stable search algorithm","stable sor","stable sorting","stable sorting algorithm","stable sorting algorithms","stable sorting algorithms maintain the relative order of","stable sorting-algorithm","stable sorts","stably","stably sorted","sv:Sorteringsalgoritm","sıralama algoritmasıdır","sắp xếp","ta:வரிசையாக்கப் படிமுறை","th:ขั้นตอนวิธีการเรียงลำดับ","the Wikipedia page for sorting algorithms","the article on sorting algorithms","the complexity of sorting algorithms","the way sorting is done","the wikipedia page about them","there are many new sorts for you!","there are many ways to do it","this varies a lot depending on what you","thuật toán sắp xếp","tr:Sıralama algoritması","trang wikipedia về phân loại","tri stable","tri sur place","tris linéaires O(n) pour des cas particuliers","ttp://en.wikipedia.org/wiki/Sorting_algorithm","ttp://en.wikipedia.org/wiki/Stable_sort","typical cost","typical sort","técnicas de ordenamiento","třídicí algoritmus","třídících algoritmů","třídění Wikipedia vstup","třídění algoritmy","uk:Алгоритм сортування","un metodo / funzione per ordinare","un método / función para ordenar","una qualsiasi delle algoritmi di ordinamento conosciuto bene","uno dei ben noti algoritmi di ordinamento.","unstable sort","unstable sorting algorithm","v: sıralama algoritması","vakaa lajitella","van een van de bekende sorteeralgoritmes","vergleichsbasierten Sortierverfahren","vi:Thuật toán sắp xếp","vide uma lista com métodos de ordenação","voce di ordinamento Wikipedia","voorhanden op Wikipedia","w: sorting algorithm","wiki on sorting algorithms","wiki page on sorting algorithms","wikipedia - sorting algorithms","wikipedia page for sorting","wikipedia page on sorting","wikipedia 排序","wikipedia's Sorting Algorithm article.","wikipedia's comparison of sorting algorithms","wikipedia.org/wiki/sorteeralgoritme","wikipedia.pl/sortowanie","wikipedia:Sorting algorithm","wikipedia:ソート","wiki关于常用排序算法的对比","worst case time complexity","wybranym algorytmem","x*log(x) time","zh:排序算法","|Sorting algorithm","Ð Ð»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼ Ñ Ð¾Ñ","článek na Wikipedii třídící algoritmy","Řadicí algoritmus","Řadicí algoritmus - Wikipedie","Řadicí algoritmus - Wikipedie, otevřená encyklopedie","Řadící algoritmy na Wikipedii","řadicí algoritmus","řadicího algoritmu","řadící algoritmy","αλγορίθμων ταξινόμησης","Алгоритм Пратта","Алгоритм сортировки","Алгоритм сортировки - Wikipedia","Алгоритм сортировки — Википедия","Алгоритм сортування","Алгоритм устойчив","Алгоритм_сортировки","Алгоритмы сортировок на Википедии","Без дополнительной памяти","Википедии статью Алгоритм сортировки","Википедии статью Устойчивая сортировка","Википедия статьи для алгоритмов сортировки","Материал из Википедии есть хороший стол","Още за четене","Различные алгоритмы сортировки","Список алгоритмов сортировки","Ссылка на перечень сортировок.","Стабильная сортировка","Стабільне сортування","Статья на английской википедии, где собраны ссылки на","Статья на википедии, где собраны ссылки на различные","Статья на русской википедии, где собраны ссылки на","Устойчивая","Устойчивая сортировка","алгоритм сортировки","алгоритм сортування","алгоритми за сортиране","алгоритми за сортирање","алгоритми со-","алгоритми сор-","алгоритми сортування","алгоритмов сортировки","алгоритмов сортировки.","алгоритмом сортировки","алгоритмы сортировки","алгоритмы сортировки на Википедии","алгоритмы сортировки.","алгоритмы сортировок","алгоритмів сортування","алгоритъм за сортиране","в Википедии куча таких алгоритмов дана","дохуя","квадратичный алгоритм","любой из известных алгоритмов сортировки","любой из известных алгоритмов сортировки.","метода / функции для сортировки","методы сортировки","множества различных сортировок","на странице Википедия сортировка","не быть голословным","неустойчивых","отсортировать","сортировка массива","сортировки Википедии","сравнении разных методов сортировки","стабилно","стабильная сортировка","стабильно","стабильное рода","стабильной","стабильной рода","стабильным рода","стабильных","строгую сортировку","устойчивая сортировка","устойчивой сортировкой","этих алгоритмов","ויקיפדיה - 'מיון (מדעי המחשב)'","מיון (מדעי המחשב)","מיון (מדעי המחשב) – ויקיפדיה","מיון יציב","מיון מדעי המחשב","الگوريتم ادغامي","الگوریتم مرتبسازی","الگوریتم مرتبسازی - ویکیپدیا","الگوریتم های شبیه سازی در ویکی پدیا","الگوریتم های مرتب سازی","الگوریتم های مرتب سازی در ویکی پدیا","الگوریتمهای مرتبسازی","تصنيف مستقر","جدول محاسبه زمان و حافظه","خوارزميات الترتيب","خوارزمية الفرز -- ويكيبيديا","فکر نکنم کاملتر از این پیدا کنید!!!!","مرتبسازی","مرتبسازی شِل","من هنا الصفحة","می توانید از کد زیر استفاده کنید و","و البته مقایسه الگوریتمها به زبان فارسی : در","۱ طبقهبندی","۱۰ مرتب سازی ادغامی","۱۱ مرتب سازی درجی","۱۲ فهرست الگوریتمهای مرتبسازی","۱۲ مرتب سازی بوگو","۱۳ فهرست الگوریتمهای مرتبسازی","۱۳ پاورقی","۲ مرتب سازی حبابی","۳ مرتب سازی انتخابی","۴ مرتب سازی درجی","۵ مرتب سازی پایهای (مبنایی)","۶ bucket sort","۸ مرتب سازی شل","۹ مرتب سازی سریع","एक तरीका है / समारोह के लिए तरह","छंटनी एल्गोरिथ्म - विकिपीडिया","வரிசையாக்கப் படிமுறை","กลไก การ เรียง ลำดับ","ขั้นตอนวิธีการเรียงลำดับ","ขั้นตอนวิธีการเรียงลำดับ - วิกิพีเดีย","ขั้นตอนวิธีก�¸²รเรี•งลำดับ - วิกิพีเดี•","ต้องอ่านวิกิประเภทการจัดเรียงข้อมูล","หน้า วิ กิ พี เดีย ใน การ เรียง","ใด ๆ ชื่อเสียง เรียง ลำดับ อั ลก อริ","Ở đây.............","“algoritmos de ordenamiento”","“… in computer science and mathematics, a sorting algorithm","→ Статья «Алгоритм сортировки»","∙ Sorting algorithm - Wikip...","、安定した","、安定したソートを","「ソート」についてWikipediaで調査","「ソート」をWikipediaで調べる","「ソート」をWikiで調べる","「整列」をWikipediaで調べる","そーと - Wikipedia","のソートアルゴリズム","の比較を","よく知られたソートのアルゴリズムのいずれかを","アルゴリズムを並べ替え","アルゴリズムバブル、クイック","ウィキペディアのソート項目を","ウィキペディアの記事 整列アルゴリズム","ウィキペディア：ソート","ソ〖ト","ソーティング","ソーティング・プログラム","ソーティング即ち並べ替え","ソート - Wikipedia","ソート -wikipedia","ソート – Wikipedia","ソートについての続きを読む(Wikipedia)。","ソートのアルゴリズムを","ソートの頁","ソートアルゴリズム","ソートアルゴリズムについては、この記事はウィキペディア","・ソート関数一覧","一个方法/函数来排序","並べ替えで","並べ替えアルゴリズム","任何众所周知的排序算法","任何的算法，也是著名的排序","任何眾所周知的排序算法","关于排序","参考資料のページを見よ","各排序法實測時間整理表(維基百科)","安定した","安定して","安定的","已知的","平均計算量がクイックソートと同じアルゴリズムは他にもたくさんある","排序(sorting)","排序演算法","排序演算法(sorting algorithm)","排序演算法- 維基百科，自由的百科全書","排序演算法（sorting algorithm）","排序算法","排序算法- Wikipedia","排序算法- 维基百科,自由的百科全书","排序算法- 维基百科，自由的百科全书","排序算法定义","整列","整列アルゴリズム","整列アルゴリズム - Wikipedia","整列ｱﾙｺﾞﾘｽﾞﾑ-wikipedia","方法ソート行われる","昇順","泡沫算法，快速排序","稳定性","稳定排序","稳定的","稳定的排序","穩定性","穩定排序","算法泡沫，快速排序","維基百科~Sorting algorithm","維基百科的文章“ 排序”","維基百科的文章“ 排序算法”","維基百科網頁排序","維基百科～Sorting_algorithm","维基百科文章的排序算法","维基百科有一个很好的表","维基百科条目排序","维基百科的排序算法比较","维基百科的文章“ 排序”","维基百科页面排序","降順","두번째","불안정 정렬","불안정정렬","안정 정렬","안정하냐 불안정하냐","어떤의","위키 피 디아 문서 불안정 정렬","위키 피 디아 문서 정렬","위키 피 디아 문서 정렬 알고리즘","위키 피 디아의 항목은","정렬 알고리즘","정렬 알고리즘 - 위키백과, 우리 모두의 백과사전","정렬 알고리즘 항목","정렬 알고리즘을","정렬에이","ﺍﻟﮕﻮﺭﯾﺘﻤﻬﺎﯼ ﻣﺮﺗﺒﺴﺎﺯﯼ","ｿｰﾄ-wikipedia"],"name":"Sorting algorithm","categories":["All accuracy disputes","All articles lacking in-text citations","All articles with specifically marked weasel-worded phrases","Articles lacking in-text citations from September 2009","Articles with disputed statements from November 2015","Articles with specifically marked weasel-worded phrases from September 2015","Commons category with local link same as on Wikidata","Data processing","Sorting algorithms"],"tag_line":"A sorting algorithm is an algorithm that puts elements of a list in a certain order."}}
,{"_index":"throwtable","_type":"algorithm","_id":"quicksort","_score":0,"_source":{"description":"Quicksort (sometimes called partition-exchange sort) is an efficient sorting algorithm, serving as a systematic method for placing the elements of an array in order. Developed by Tony Hoare in 1959, with his work published in 1961, it is still a commonly used algorithm for sorting. When implemented well, it can be about two or three times faster than its main competitors, merge sort and heapsort.\nQuicksort is a comparison sort, meaning that it can sort items of any type for which a \"less-than\" relation (formally, a total order) is defined. In efficient implementations it is not a stable sort, meaning that the relative order of equal sort items is not preserved. Quicksort can operate in-place on an array, requiring small additional amounts of memory to perform the sorting.\nMathematical analysis of quicksort shows that, on average, the algorithm takes O(n log n) comparisons to sort n items. In the worst case, it makes O(n2) comparisons, though this behavior is rare.","alt_names":["Randomized Quicksort","QuickSort","Quick sort","Quicksort","quicksort","'QuickSort'","(Quicksort","(http://en.wikipedia.org/wiki/Quicksort","(standard) quicksort","- Qsort :","- Quick sort :","- Quicksort :","-> Leggi l'articolo completo su Quicksort","-> Leggi tutto l'articolo su 'Quicksort'","-> Read the article about 'Quicksort'",". http://en.wikipedia.org/wiki/Quicksort","...Wikipedia Quicksort","...Wikipedia Sortowanie szybkie","...Wikipedia Tri rapide","...mehr auf Wikipedia über Quicksort","...more on Wikipedia about Quicksort","1 Zasada","1.2 Quick Sort Algorithm","1962: Quicksort algorithms for sorting","2 Złożoność","2.1 Parallelizations","2.1 Przypadek optymistyczny","2.2 Przypadek przeciętny","2.3 Przypadek pesymistyczny","3 Formal analysis","3 Usprawnienia algorytmu","3.1 Randomized quicksort expected complexity","3.1 Wybór elementu","3.2 Average complexity","3.2 Ograniczenie rekursji","3.3 Quicksort w miejscu","3.3 Space complexity","3.4 Drobne fragmenty","3.5 Gwarancja złożoności","4 Przykładowe implementacje","4 Selection-based pivoting","4.1 Pascal","4.2 SML","4.3 ANSI C","6 Comparison with other sorting algorithms","7. Quicksort",": http://en.wikipedia.org/wiki/Quicksort,","@ 퀵 정렬","A very nice overview of Quicksort","Ako funguje QuickSort?","Algorisme d'ordenació ràpida","Algoritmo QuickSort","Angleška wikipedia: Quicksort","Animacja szybkiego sortowania","Artikel Quicksort","Artikkel Wikipedia (English)","Balanced quicksort","C QSort функции","C funkce qsort","C função qsort","C language implementation of QuickSort","C qsort Funktion","C qsort fonction","C qsort functie","C समारोह qsort","C-funktionen qsort","Category:各地汉语","Choice of pivot","Cのqsort関数","Definición de Quicksort más completo","El algoritmo de quicksort","El algoritmo de quicksort .","El algoritmo de quicksort.","Encyclopedia: Quicksort","External quicksort","External quicksort: The same as regular quicksort except","Figura muestra como funciona el algoritmo QuickSort","Funkce Quicksort grafické znázornění a vysvětlení funkčnosti","Genaue Erklärung zu Quicksort bei Wikipedia... (sehr gut","Gerandomiseerde quicksort","Greitojo rikiavimo","Greitojo rikiavimo algoritmas – Vikipedija","Gwarancja złożoności","Gyorsrendezés","Gyorsrendezés (Wiki link)","Gyorsrendezés - Wikipédia","History of Quicksort - Wikipedia, the free encyclopedia","Hitro urejanje","Hitro urejanje(Quick sort)","Hoare er quicksort","Hoare je quicksort","Hoare's Quicksort","Hoare's quicksort","Hoares Quicksort","Hoareさんのクイック","Hoare의 quicksort","Hızlı Sıralama","Hızlı sıralama","Hızlı sıralama - Vikipedi","Information And Example","Le quickSort","Le tri rapide","Learn about Quicksort>>>","Leggi come funziona","Mehr zum Quicksort bei Wikipedia...","Mixing Methods","Ordenación Quicksort","Ordenamiento Quicksort","Ordenamiento rápido","Ordenar rápido","Partition sort","Pesquisar quicksort na Wikipedia Portugal","Pikalajittelu","Pikalajittelu – Wikipedia","Przykłady implementacji qsort w różnych językach","Pseudocode von Wikipedia","QSORT","QSort","QUICK SORT","QUICKSORT","Qsort","Qsort (C Standard Library)","Qsort (C standard library)","Qsort (Стандартна бібліотека С) — Вікіпедія","Qsort - Wikipedia, the free encyclopedia","Qsort on wikipedia.org","Qsort в Википедии","Qsort в википедии","Qsort; it is used under the","Qucksort Wikipedia","Quick Sort","Quick Sort - A quick average O(n lg","Quick Sort Demo","Quick Sort algorithm","Quick Sort algorithm in the wikipedia","Quick Sort 항목","Quick Sort.","Quick Sort:","Quick classificar","Quick sort ()a.k.a. Partition Sort","Quick sort(Wikipedia)","Quick sort:n","Quick sort; it is used under the","Quick เรียงลำดับ","Quick-Sort","Quick-Sort - Wikipedia","Quick-Sort bei der wikipedia","QuickSort - Wikipedia","QuickSort Algorithm","QuickSort At Wikipedia","QuickSort algorithm","QuickSort at Wikipedia (DE)","QuickSort at Wikipedia (EN)","QuickSort bei Wikipedia (DE)","QuickSort bei Wikipedia (EN)","QuickSort et mergesort","QuickSort in Action","QuickSort information","QuickSort na české wikipedii","QuickSort na české wikipedii soubor","QuickSort on Wikipedia","QuickSort sorting algorithm","QuickSort w Wikipedii","QuickSort()","QuickSort-Algorithmus","QuickSorter","QuickSorts","Quicksort (Wikipedia)","Quicksort (via a post by @rand) http://tinyurl","Quicksort (위키백과)","Quicksort - O(NlogN)","Quicksort - Randomized quicksort expected complexity","Quicksort - Vikipediya","Quicksort - Viquipèdia","Quicksort - Wikipedia","Quicksort - Wikipedia, The Free Encyclopedia","Quicksort - Wikipedia, la enciclopedia libre","Quicksort - Wikipedia, the ...","Quicksort - Wikipedia, the free encyclopedia","Quicksort - Wikipedia, the free encyclopedia 1","Quicksort - Wikipedia, the free encyclopediaHe developed the","Quicksort - Wikipedia, the free encyclopediaThere is a","Quicksort - Wikipedie","Quicksort - wikipedia","Quicksort -- วิกิพีเดีย","Quicksort ? Wikipedia","Quicksort @ wikipedia","Quicksort Algorithm","Quicksort Algorithmus","Quicksort Artikel","Quicksort Complexity","Quicksort Vikipediya","Quicksort Wikipedia","Quicksort Wikipedia la enciclopedia libre","Quicksort Wikipedia the free encyclopedia","Quicksort Wikipediaartikel","Quicksort [...] is not a stable sort.","Quicksort [Wikipedia]","Quicksort a MergeSort","Quicksort algorithm","Quicksort and MergeSort","Quicksort and MergeSort.","Quicksort article","Quicksort article on Wikipedia","Quicksort artikel","Quicksort artiklen","Quicksort at MergeSort","Quicksort auf Wikipedia","Quicksort bei Wikipedia (deutsch)","Quicksort bei Wikipedia (englisch)","Quicksort bei der wikipedia","Quicksort bei wikipedia.de","Quicksort dan MergeSort","Quicksort description and code samples.","Quicksort di wikipedia","Quicksort e Mergesort","Quicksort en Wikipedia","Quicksort en la wikipedia","Quicksort i MergeSort","Quicksort implementations","Quicksort in C#","Quicksort in Wikipedia","Quicksort is O(nlogn) to O(n 2","Quicksort is pretty easy to parallelize","Quicksort l'article","Quicksort method","Quicksort na Wikipédia","Quicksort on Wikipedia","Quicksort on wikipedia","Quicksort su Wikipedia","Quicksort su wikipedia","Quicksort sur Wikipédia","Quicksort und MergeSort","Quicksort visualization","Quicksort y mergesort","Quicksort |","Quicksort â€“ Wikipedia","Quicksort และ MergeSort","Quicksort ในวิกิพีเดีย","Quicksort – Wikipedia","Quicksort – Wikipedia, the free encyclopedia","Quicksort – Wikipédia, a enciclopédia livre","Quicksort 위키백과","Quicksort#Algorithm partition operation","Quicksort,","Quicksort-Algorithmus","Quicksort-Algorithmus i","Quicksort-Wikipedia","Quicksort.","Quicksort. De Wikipedia, la enciclopedia libre. Saltar a","Quicksort:","Quicksort: Algorithm","Quicksort: Comparison with other sorting algorithms","Quicksort: Formal analysis","Quicksort: History","Quicksort: Selection-based pivoting","Quicksort; it is used under the","Quicksort?","Quicksort算法","Quicksort를","Quicksort의","Randomiseret quicksort","Randomized quicksort","Read More About quicksort wikipedia the free encyclopedia","Read More quicksort wikipedia la enciclopedia libre","Read More quicksort wikipedia the free encyclopedia","Rápida tipo","Schonmal bei Wikipedia reingeschaut","Sedgesort","Sedwick's method of choosing the pivot","Selection-Based Pivoting section of Wikipedia's Quicksort article","Selection-based pivoting","Simple quicksort algorithm","Snarröðun","Snarröðun - Wikipedia, frjálsa alfræðiritið","Sortieralgorithmus Quicksort","Sorting_quicksort_anim.gif","Sortowanie szybkie","Sortowanie szybkie – Wikipedia, wolna encyklopedia","Sortowanie szybkie:","Sortowanie_szybkie","Source Wikipedia.org Arcticle - Quicksort","Sve o algoritmu","Sắp xếp nhanh","Sắp xếp nhanh (Wikipedia)","Sắp xếp nhanh trên wikipedia","Sắp xếp nhanh và MergeSort","Sắp xếp nhanh.","Sắp xếp nhanh?","The Quick Sort","The Quick Sort Algorithm","The Wikipedia article on Quicksort","There is no guarantee that qsort will use","This is the best I can do, sorry","Tri rapide","Tri rapide (C)","Tri rapide - Wikip?dia","Tri rapide - Wikipédia","Trie Rapide","Técnicas de elección del pivote","Több a quicksortról","Usually items equal to the pivot end up","Veja mais sobre o algorítmo","What is algorithm of Quick Sort?","What is algorithm of Quicksort?","Wiki - Quicksort","Wiki Quick Sort","Wiki-quicksort.png http://de.wikipedia.org/wiki","Wiki: Quick Sort","Wiki: Быстрая сортировка","WikiPedia entry on Quicksort","WikiPedia:Quicksort","WikiPeja:クイックソート","Wikipedia (english Version)","Wikipedia - Quicksort","Wikipedia -> Quicksort","Wikipedia QuickSort","Wikipedia Quicksort","Wikipedia Quicksort en anglais","Wikipedia Quicksort page","Wikipedia animated demo","Wikipedia article Hızlı sıralama","Wikipedia article Qsort","Wikipedia article Qsort (C Standard Library)","Wikipedia article Qsort (C standard library)","Wikipedia article Quick sort","Wikipedia article QuickSort","Wikipedia article Quicksort","Wikipedia article Snarröðun","Wikipedia article Sortowanie szybkie","Wikipedia article Tri rapide","Wikipedia article about Quicksort","Wikipedia article about quicksort","Wikipedia article on Ordenamiento rápido","Wikipedia article on Qsort","Wikipedia article on Quick sort","Wikipedia article on Quicksort","Wikipedia article qsort","Wikipedia article Արագ տեսակավորում","Wikipedia article কুইক সর্ট","Wikipedia artikel Quicksort","Wikipedia discussion of Quicksort","Wikipedia entry for Qsort (C standard library)","Wikipedia entry for Quick sort","Wikipedia entry for Quicksort","Wikipedia entry on quicksort","Wikipedia entry with extended discussion and alternatives (C","Wikipedia l'articolo Partition sort","Wikipedia l'articolo Quicksort","Wikipedia on Quick sort","Wikipedia on quick sort","Wikipedia optagelse på Quicksort","Wikipedia page on Quicksort","Wikipedia – Quicksort","Wikipedia クイックソート","Wikipedia's Quicksort","Wikipedia's Quicksort page","Wikipedia, Quicksort","Wikipedia-Artikel Quick-Sort","Wikipedia-Artikel Quicksort","Wikipedia-Artikel zu Quicksort","Wikipedia-Artikel, die Sie","Wikipedia-Seite zu 'Quicksort'","Wikipedia/Quicksort","Wikipedia: Quicksort","Wikipedia: Quicksort.","Wikipedia: Sortowanie_szybkie","Wikipedia:Quicksort","Wikipedia:クイックソート","Wikipediaeintrag Quicksort","Wikipedia「クイックソート」","Wikipediaで「クイックソート」を調べる","WikipediaのQuicksort","WikipediaのQuicksortの項","Wikipediaのクイックソートのページ","Wikipedia上给出的","Wikipedia给出的","Wikipedia의 Quick Sort의 정의","Wikipédia artigo Quick sort","Wikipédia artigo Quicksort","Wikpedia entry on QuickSort","[11] qsort() (C Standard Library)","[11] qsort()(C Standard Library)","[QuickSort]","[Quicksort]","a bit of recursion","a bit trickier","abbondanti trattazioni","algorithm quick sort","algorithme de tri rapide (Quicksort)","algoritma za hitro sortiranje","algoritmo Quicksort","algoritmo de ordenamiento quicksort","algoritmo de ordenação quick sort","algoritmo di ordinamento quicksort","algoritmu quicksort třídění","algorytm sortowania","algorytmu sortowania quicksort","another quicksort","aptly-named quicksort","ar:ترتيب سريع","articolo Quicksort","articolo correlato wikipedia","artigo Quicksort","artigo da Wikipédia Quicksort","artikel Quicksort","artykuł Quicksort","artículo de Wikipedia Ordenamiento rápido","artículo de Wikipedia Quicksort","artículo de la Wikipedia relacionados","average complexity of O(n^2)","average complexity section","average time quicksort","balanced quicksort","bardziej wyrafinowane metody","basic algorithm","battling with this","bg:Бързо сортиране","bn:কুইক সর্ট","ca:Quicksort","canonical example of a QuickSort in Haskell","caso pessimo di quicksort","cepat seperti","cepat-jenis","classificação rápida.","comparison with other sorting algorithms","cs:Quicksort","của Hoare quicksort","d8c024cd57b9d73097c60c48f781cd ...","de C-functie qsort","de ordenamiento rápido.","de quicksort Hoare","de.wikipedia.org/Quicksort","de.wikipedia.org/wiki/Q...ng_in_Pascal_und_Delphi","de.wikipedia.org/wiki/Quicksort","de.wikipedia.org/wiki/Quicksort#Kenngr","de:Quicksort","degenerates to O(n^2) way too easily","di ordinamento rapido","di wikipedia,","e Tri rapide","e http://fr.wikipedia.org/wiki/Quicksort","el Quicksort","el artículo Quicksort","en la wikipedia,","en.wikipedia.org/.../Quicksort","en.wikipedia.org/Quick_sort","en.wikipedia.org/Quicksort","en.wikipedia.org/wiki/Qsort_%28C_Standard_Library%29","en.wikipedia.org/wiki/Quick_sort","en.wikipedia.org/wiki/Quicksort","en.wikipedia.org/wiki/Quicksort#Algorithm","en.wikipedia.org/wiki/Quicksort#Average_complexity","en.wikipedia.org/wiki/Quicksort#Complex_version","en.wikipedia.org/wiki/Quicksort#In-place_version","en:Quicksort","en:quicksort","entsprechend diesem Pseudocode","es.wikipedia.org/wiki/Quicksort","es:Quicksort","especie rápida","espèces rapide","espécies de rápido","expected worse-case running time of randomized quicksort","external image Sorting_quicksort_anim.gif","external quicksort","fa:مرتبسازی سریع","fast espèces","fi.wikipedia.org/wiki/Pikalajittelu","fi:Pikalajittelu","fr:Tri rapide","funzione C qsort","funzione qsort C","gearmann: クイックソート - Wikipedia","gerandomiseerde versie van het algoritme","gerelateerde wikipedia artikel","greitojo rūšiavimo (quicksort) algoritmo","grunnleggende trinnene","gyorsrendezés","gyorsrendezéssel","he:מיון מהיר","here, scroll to Version with in-place partition","hitro urejanje","http---zh.wikipedia.org-wiki-%E5%BF%AB","http://cs.wikipedia.org/wiki/Quicksort","http://de.wikipedia.org/wiki/Qu icksort","http://de.wikipedia.org/wiki/Quickso...s.2C_rechts","http://de.wikipedia.org/wiki/Quicksort","http://de.wikipedia.org/wiki/Quicksort#1._Variante","http://de.wikipedia.org/wiki/Quicksort#C","http://de.wikipedia.org/wiki/Quicksort#Delphi","http://de.wikipedia.org/wiki/Quicksort#Delphi.2FPascal","http://de.wikipedia.org/wiki/Quicksort#Laufzeit","http://de.wikipedia.org/wiki/Quicksort#Pseudocode","http://de.wikipedia.org/wiki/Quicksort#Struktogramm","http://de.wikipedia.org/wiki/Quicksort#Visual_Basic_6","http://de.wikipedia.org/wiki/Quicksort#Weitere_Sortierverfahren","http://en.wikipedia..../Quicksort#Java","http://en.wikipedia....cted_complexity","http://en.wikipedia....ksort#Algorithm","http://en.wikipedia....wiki/Quick_sort","http://en.wikipedia.org/wiki/Qsort","http://en.wikipedia.org/wiki/Qsort#S...mplementations","http://en.wikipedia.org/wiki/Qsort_%28C_standard_library%29","http://en.wikipedia.org/wiki/Qsort_(C_Standard_Library)","http://en.wikipedia.org/wiki/Qsort_(C_standard_library)","http://en.wikipedia.org/wiki/Quick_sort","http://en.wikipedia.org/wiki/Quick_sort#Average_complexity","http://en.wikipedia.org/wiki/Quick_sort#Sample_implementations","http://en.wikipedia.org/wiki/Quick_sort#…","http://en.wikipedia.org/wiki/Quick_sort.","http://en.wikipedia.org/wiki/Quicks...","http://en.wikipedia.org/wiki/Quicks...rage_complexity","http://en.wikipedia.org/wiki/Quicks...terative_version","http://en.wikipedia.org/wiki/Quicksor","http://en.wikipedia.org/wiki/Quicksort","http://en.wikipedia.org/wiki/Quicksort Quicksort","http://en.wikipedia.org/wiki/Quicksort contains an","http://en.wikipedia.org/wiki/Quicksort# ... d_pivoting","http://en.wikipedia.org/wiki/Quicksort#Algori...","http://en.wikipedia.org/wiki/Quicksort#Algorithm","http://en.wikipedia.org/wiki/Quicksort#Average_complexity","http://en.wikipedia.org/wiki/Quicksort#C","http://en.wikipedia.org/wiki/Quicksort#C.2B","http://en.wikipedia.org/wiki/Quicksort#Choice...","http://en.wikipedia.org/wiki/Quicksort#Choice_of_pivot","http://en.wikipedia.org/wiki/Quicksort#Complex_version","http://en.wikipedia.org/wiki/Quicksort#Formal_analysis","http://en.wikipedia.org/wiki/Quicksort#History","http://en.wikipedia.org/wiki/Quicksort#In-place_version","http://en.wikipedia.org/wiki/Quicksort#Iterative_version","http://en.wikipedia.org/wiki/Quicksort#Optimizations","http://en.wikipedia.org/wiki/Quicksort#Parallelization","http://en.wikipedia.org/wiki/Quicksort#Parallelization.","http://en.wikipedia.org/wiki/Quicksort#Parallelizations","http://en.wikipedia.org/wiki/Quicksort#Parallelizations.","http://en.wikipedia.org/wiki/Quicksort#Performance_and_algorithm_details","http://en.wikipedia.org/wiki/Quicksort#Performance_details","http://en.wikipedia.org/wiki/Quicksort#Randomized_quicksort_expected_complexity","http://en.wikipedia.org/wiki/Quicksort#R…","http://en.wikipedia.org/wiki/Quicksort#Selection-based_pivoting","http://en.wikipedia.org/wiki/Quicksort#Simple_version","http://en.wikipedia.org/wiki/Quicksort#S…","http://en.wikipedia.org/wiki/Quicksort#The_algorithm","http://en.wikipedia.org/wiki/Quicksort#Using_different_algorithms_for_small_lists","http://en.wikipedia.org/wiki/Quicksort#Version_with_in-place_partition","http://en.wikipedia.org/wiki/Quicksort#V…","http://en.wikipedia.org/wiki/Quicksort)","http://en.wikipedia.org/wiki/Quicksort.","http://en.wikipedia.org/wiki/Quicksortを","http://en.wikipedia.org/wiki/Quicksort을","http://en.wikipedia.org/wiki/quicksor","http://en.wikipedia.org/wi​ki/Quicksort","http://es.wikipedia.org/wiki/Quicksort","http://es.wikipedia.org/wiki/Quicksort#I…","http://es.wikipedia.org/wiki/Quicksort#O…","http://fi.wikipedia.org/wiki/Pikalajittelu","http://fr.wikipedia.org/wiki/Quicksort","http://fr.wikipedia.org/wiki/Tri_ra","http://fr.wikipedia.org/wiki/Tri_rapide","http://hu.wikipedia.org/wiki/Gyorsrendez%C3%A9s","http://hu.wikipedia.org/wiki/gyorsrendezés","http://hu.wikipedia.org/wiki/quicksort","http://it.wikipedia.org/wiki/Quick_sort","http://it.wikipedia.org/wiki/Quickso...sort_iterativo","http://it.wikipedia.org/wiki/Quicksort","http://it.wikipedia.org/wiki/Quicksort#C.2B","http://it.wikipedia.org/wiki/Quicksort#Quicksort_iterativo","http://j.mp/dqoJ6W","http://ja.wikipedia.org/wiki/クイックソート","http://ko.wikipedia.org/wiki/%ED%80%B5_","http://lt.wikipedia.org/wiki/Greitoj...imo_algoritmas","http://myurlspace.com/leonardomack/AlgOrdenacao","http://nl.wikipedia.org/wiki/Quicksort","http://pl.wikipedia...._szybkie#Pascal","http://pl.wikipedia....towanie_szybkie","http://pl.wikipedia.org/w...szybkie#C.2B","http://pl.wikipedia.org/wiki/Quicksort","http://pl.wikipedia.org/wiki/Sortowanie_szybkie","http://pl.wikipedia.org/wiki/Sortowanie_szybkie#C.2B","http://pt.wikipedia....cksort#Assembly","http://pt.wikipedia.org/wiki/Quick_sort","http://pt.wikipedia.org/wiki/Quick_sort#Java","http://pt.wikipedia.org/wiki/Quick_sort#O_algoritmo","http://pt.wikipedia.org/wiki/Quicksort","http://pt.wikipedia.org/wiki/Quicksort#Assembly","http://pt.wikipedia.org/wiki/Quicksort#C","http://pt.wikipedia.org/wiki/Quicksort#Java","http://ro.wikipedia.org/wiki/Quicksort","http://ru.wikipedia.org/wiki/Qsort","http://ru.wikipedia.org/wiki/Quicksort","http://ru.wikipedia.org/wiki/Quicksort#.D0....B8","http://ru.wikipedia.org/wiki/Quicksort#Java.2FC","http://ru.wikipedia.org/wiki/Quicksort#Pascal","http://ru.wikipedia.org/wiki/Быстрая_сор...","http://ru.wikipedia.org/wiki/Быстрая_сортировка","http://sk.wikipedia.org/wiki/Quicksort","http://sl.wikipedia.org/wiki/Hitro_urejanje","http://sr.wikipedia.org/wiki/%...%D0%BA%D1","http://sv.wikipedia.org/wiki/Quicksort","http://uz.wikipedia.org/wiki/Quicksort#Java","http://vi.wikipedia.org/wiki/Sắp_xếp_nhanh","http://www.de.wikipedia.org/wiki/Quicksort","http://zh.wikipedia.org/wiki/快速排序","http://zh.wikipedia.org/zh-cn/快速排序","http://zh.wikipedia.org/zh-tw/% E5% BF","http://zh.wikipedia.org/zh-tw/快速排序","hu:Gyorsrendezés","hurtig slags","hurtigt sortere","hy:Արագ տեսակավորում","hızlı sıralama","il quicksort Hoare","implementaciones del Quicksort,","implementaçao do quicksort","inklusive C","is:Snarröðun","it uses logarithmic space","it:Quicksort","ja:クイックソート","już ktoś to zapewne zrobił (drugi kod)","kichor","ko:퀵 정렬","kvikksort","l'article de Wikipédia Quicksort","la entrada de Wikipedia sobre Quicksort","la fonction qsort C","la función qsort C","la ordenación rápida","le tri rapide","le tri rapide?","leer como funciona quicksort","lt:Greitojo rikiavimo algoritmas","lv:Ātrās kārtošanas algoritms","multikey quicksort","método QuickSort","método rápido","nhanh sắp xếp","nl:Quicksort","o quicksort Hoare","ordenación rápida","ordenamiento quicksort","ordenamiento rápido","ordinamento quicksort","ordinamento rapido","ordinamento veloce.","ort Simulation","parallel quicksort","pikalajittelulle","pl.wikipedia.org/wiki/Quicksort","pl.wikipedia.org/wiki/Sortowanie_szybkie","pl:Sortowanie szybkie","pt:Quicksort","q sort","qSort algorithm","qsort","qsort (C Standard Library)","qsort (быстрая сортировка Хоара)","qsort - Wikipedia, the free encyclopedia","qsort C Standard Library","qsort Wikipedia the free encyclopedia","qsort()","qsort@wikipedia","quick sort","quick sort algorithm","quick sort algorithm.","quick sort technique","quick sorteren","quick-sort","quick-sort algoritma za urejanje","quick-sorted","quick_sort","quickly sorted","quicksort aleatorios","quicksort algorithm","quicksort algorithm.","quicksort algoritme","quicksort algoritmus","quicksort e mergesort","quicksort has N^2 performance for bad pivot","quicksort implementations","quicksort in Wikipedia Nederland zoeken","quicksort optimization","quicksort parallelization","quicksort sorteer-algoritme","quicksort sorting algorithm","quicksort छँटाई एल्गोरिथ्म","quicksort,","quicksort.","quicksort?","quicksorting","quicksorts","quicksort을","quicksort의","randomiseret version af algoritmen","randomisierte Quicksort","randomisierten Version des Algorithmus","randomized quick sort","randomized quicksort","randomized version of the algorithm","randomizovaných verzi algoritmu","rapide Quick Sort","rapide de tri","rapide tri","rapide « Quick Sort »","rapide “Quick Sort”","relaterede Wikipedia-artiklen","ro:Quicksort","ru:Быстрая сортировка","rychlého řazení","rys3","rápida tipo","rápido especie","rápido tipo","schau nochmal bei Wikipedia","schnell sortieren","schnelle Art","schnellen Sorte","semacam Cepat","sk:Quicksort","sl:Hitro urejanje","snel soorten","snelle soort","snelle soorten","sort data","sort quick","sorting routine","sortowania szybkiego","sortowanie szybkie","související wikipedia článek","specie a rapido","specie veloce","splet3","sr:Квиксорт","su wikipedia,","sur wikipedia,","sv:Quicksort","swithrynd","szybkie sortowanie","szybkiego sortowania","sắp xếp nhanh","sắp xếp nhanh chóng.","t http://de.wikipedia.org/wiki/Quicksort","t http://en.wikipedia.org/wiki/Quick_sort","tessek","the C function qsort","the English Wikipedia page for Quicksort","the Java alternative","the QuickSort algorithm","the Quicksort algorithm","the Quicksort wikipedia article","the Wikipedia entry on Quicksort","the complexity of QuickSort algorithm","the wikipedia algorithm","this quicksort pseudocode","three short sentences","tipo rapido","tipo rápido","to quicksort Hoare","tp://cs.wikipedia.org/wiki/Quicksort","tp://en.wikipedia.org/wiki/Quicksort","tr:Hızlı sıralama","tri rapide","tri rapide.","trên wikipedia,","ttp://de.wikipedia.org/wiki/Quicksort","ttp://en.wikipedia.org/wiki/Quicksort","ttp://en.wikipedia.org/wiki/Quicksort)","třeba z wikipedie","uick sort","uk:Qsort_(Стандартна_бібліотека_С)","uk:Швидке сортування","une aide ici","uz:Quicksort","versione randomizzato dell'algoritmo","versión del algoritmo aleatorio","very few people have to implement sorting functions","vi.wikipedia.org/wiki/S%E1%BA%AFp_x","vi:Sắp xếp nhanh","visit wikipedia entry for Quicksort","voce di Wikipedia su Quicksort","voir Tri rapide","w:Быстрая сортировка","w:クイックソート","wejścia w Wikipedii Quicksort","wiki on quicksort","wiki page Quick Sort","wikipedia article on quicksort","wikipedia entry for quicksort","wikipedia page on quick sort","wikipedia quicksort entry","wikipedia 上","wikipedia's article (http://en.wikipedia.org/wiki/Quicksort","wikipedia/Быстрая_сортировка","wikipedia: quicksort","wikipedia:quicksort","wikipedia:クイックソート","wikipediani uz bulimida quick sort","with high probability","wp:Quicksort","zh:快速排序","związane z artykułu w Wikipedii","|quicksort","|qwicksort","«Quicksort»","» Quicksort","» Ð±Ñ‹Ñ•Ñ‚Ñ€Ð¾Ð¹ Ñ•Ð¾Ñ","» í€µì†ŒíŠ¸","» Бързо сортиране","» быстрой сортировки","» 퀵소트","ç qsort函数","Ātrās kārtošanas algoritms","článek Quicksort","Θ n p log n p","Более подробно по-английски.","Бързо сортиране","Быстрая сортировка","Быстрая сортировка (Wikipedia)","Быстрая сортировка в Википедии","Быстрая сортировка на Википедии","Быстрая сортировка реализация на разных языках","Быстрая сортировка — Википедия","Быстрая сортировка.","Быстрая_сортировка","Быстрой сортировки","Быструю сортировку (Quicksort)","В википедии по-русски.","Википедии статью Qsort","Википедии статью Quicksort","Википедии статью Быстрая сортировка","Википедия: Быстрая сортировка","Описание QSort в Википедии","Читайте/изучайте...","Швидке сортування","алгоритм быстрой сортировки","алгоритма быстрой сортировки","алгоритма сортировки быстрой сортировки","бстрая сортировка","бързо сортиране","бързо сортиране на Хоор","быстрая сортировка","быстрая сортировка Хоара","быстрая сортировка и слияние","быстрого видов","быстрой сортировки","быстрой сортировки Sort","быстрой сортировки Хоара","быстрой сортировки?","быстрой сортировкой","быструю ли сортировку","быструю сортировку","быструю сортировку Хоара","быстрым методом","быстрых видов","в быстрой сортировки Хоара","метод Чарльза Хоара","найти легко","описание сортировки Хоара в Википедии","по быстрой сортировки Хоара","рандомизированных версию алгоритма","связанные статьи Википедии","сортировка методом Хоара","сортировку за O(n log n)","статью быстрая сортировка","три коротких предложения","хорошо разжёвана","швидке сортування","швидкого сортування","Արագ տեսակավորում","ויקיפדיה - 'מיון מהיר'","מיון מהיר","מיון מהיר – ויקיפדיה","الگوریتم مرتبسازی سریع","ترتيب سريع","ترتيباً","سریع","كويكسورت","مرتبساز سریع","مرتبسازی سریع","مرتبسازی سریع - ویکیپدیا","مرتبسازی سریع/quick sort","۱ پیاده سازی","۱.۱ پیادهسازی به زبان سیپلاس","۱.۲ پیادهسازی به زبان پاسکال","۲ پیاده سازی به صورت تصادفی","۳ پیاده سازی صنعتی","۴ زمان اجرا","संबंधित विकिपीडिया लेख","কুইক সর্ট","ของ quicksort Hoare","จัด เรียง อย่าง รวดเร็ว.","เรียงลำดับอย่างรวดเร็ว","ใน วิ กิ พี เดีย","“Quicksort”","“быструю сортировку”","“快速排序”","→ Статья «Быстрая сортировка»","∙ Quicksort - Wikipedia, la...","∙ Quicksort - Wikipedia, th...","、wikipediaで","、クイックソートの","、配列","、高速の種","「クイックソート」をWikipediaで調べる","『クイックソート』の解説","に関連するWikipediaの記事を","のためのチェック","のクイック。","の高速種","アルゴリズムのランダム化されたバージョン","エントリをクイックソートウィキペディア","クィックソート","クイックを","クイックウィキペディア（Wikipedia）","クイックソート","クイックソート (wikipediaへのリンク)","クイックソート - Wikipedia","クイックソート- Wikipedia","クイックソート-Wikipedia","クイックソートとマージ","クイックソートとマージソート","クイックソートについてはwikiを見てみて下さい。","クイックソートの","クイックソートのソートアルゴリズム","クイックソートの記事","クイックソートの詳しい説明はこちらへ","クイックソートは","クイックソートを","クイックソートウィキペディアに","クイック・ソート","ランダム化クイックソート","使用快速","其他的排序算法，可参见： http://en.wikipedia.org/wiki/Sorting_algorithm","可能性が","在C函数qsort","在維基百科中","对快速排序Wikipedia条目","彗星qsort函数","快排算法","快种","快速排序","快速排序 - Wikipedia","快速排序 - 维基百科，自由的百科全书","快速排序(quick sort)","快速排序- 维基百科，自由的百科全书","快速排序– Wikipedia","快速排序发(Quick Sort)","快速排序和归并","快速排序和歸併","快速排序在維基百科","快速排序在维基百科","快速排序法","快速排序法(quicksort)","快速排序的排序算法","快速排序的文章","快速排序算法图解","快速排序（Quicksort）算法","快速排序（維基百科）","快速排序（维基百科）","快速排序： Quick Sort","排序快速","文章快速排序","有关维基百科的文章","算法随机版本","素直なクイックソート","維基百科的文章“ 快速排序”","維基百科～Qsort_(C_standard_library)","維基百科～Quicksort","维基百科上的文章快速排序","良く知られたピボット選択方法","转载自Wikipedia","随机快速排序","霍尔的快速排序","霍爾的快速排序","빠른 정렬","빠른 종류는","용의자Quicksort 및 MergeSort","위키 피 디아 문서 빠른 정렬","위키 피 디아 문서 퀵 정렬","위키백과-퀵 정렬","퀵 정렬","퀵 정렬 - 위키백과, 우리 모두의 백과사전","퀵소트 wikipedia","퀵정렬 자세히보기","ｸｲｯｸｿｰﾄ-wikipedia"],"name":"Quicksort","categories":["1961 in science","Accuracy disputes from August 2015","Accuracy disputes from July 2015","Articles with example pseudocode","Comparison sorts","Pages with DOIs inactive since 2015","Sorting algorithms","Use dmy dates from January 2012"],"tag_line":"Quicksort (sometimes called partition-exchange sort) is an efficient sorting algorithm, serving as a systematic method for placing the elements of an array in order."}}
,{"_index":"throwtable","_type":"algorithm","_id":"7z","_score":0,"_source":{"description":"7z is a compressed archive file format that supports several different data compression, encryption and pre-processing algorithms. The 7z format initially appeared as implemented by the 7-Zip archiver. The 7-Zip program is publicly available under the terms of the GNU Lesser General Public License. The LZMA SDK 4.62 was placed in the public domain in December 2008. The latest stable version of 7-Zip and LZMA SDK is version 15.12.\nThe 7z file format specification is distributed with 7-Zip's source code. The specification can be found in plain text format in the 'doc' sub-directory of the source code distribution.","alt_names":[".7z","http://ja.wikipedia.org/wiki/7z","7z","7-zip format","z7","7Z","*.7z","- .7z :","- 7Z :","- 7z :","...Wikipedia 7Z","...Wikipedia 7z","...mehr auf Wikipedia über 7z","...more on Wikipedia about 7z",".7Z",".7z - Wikipedia",".7z : LZMA アルゴリズムを使用する 7Zip ファイル形式です。GNU LGPL 規約に従うオープンソースのファイル形式です",".7z format",".7z; it is used under the","1 Features and enhancements","1 特色与高性能","1.1 Compression method filters","1.1 加密","1.2 Pre-processing filters","1.4 Limitations","2 压缩","256.000 mal nacheinander","3 算法的实现","3. 7z - Wikipedia, the free encyclopedia","4 打开工具","4. 7z - Wikipedia, the free encyclopedia","7 z","7 زد","7-Zip-Archive","7Z -tiedostomuodossa","7Z File Extension - Open .7Z files","7Z files","7Z in WikiPedia","7z (7-zip)","7z (file format)","7z (file format) - Wikipedia, the free encyclopedia","7z (wikipedia)","7z - Uiquipedia","7z - Vikipedi","7z - Viquipèdia","7z - Wikipedia, The Free Encyclopedia","7z - Wikipedia, la enciclopedia libre","7z - Wikipedia, la enciclopedia libre - Wikipedia","7z - Wikipedia, la enciclopedia libre 7z es un","7z - Wikipedia, the free encyclopedia","7z - Wikipedia, the free encyclopedia - Wikipedia","7z - Wikipedia, the free encyclopedia 7z is a","7z - Wikipédia","7z - 维基百科，自由的百科全书","7z -- Wikipedia","7z -wikipedia","7z @ Wikipedia","7z Related Content:","7z Wikipedia","7z Wikipedia The Free Encyclopedia","7z Wikipedia article","7z Wikipedia la enciclopedia libre","7z Wikipedia sayfası","7z Wikipedia the free encyclopedia","7z Wikipedia, the free encyclopedia","7z archive file format","7z archive format","7z archive manager","7z at Wikipedia","7z bei Wikipedia","7z bei Wikipedia (en)","7z compression format","7z en Wikipedia","7z es un formato de compresión","7z est un format ouvert sous licence GLGPL","7z file format at Wikipedia.org Encyclopedia","7z for Macs","7z format","7z format - Wikipedia","7z format uses strong encryption","7z la Wikipedia (en)","7z na Wikipedia","7z na Wikipedii","7z na Wikipédii","7z on Wikipedia","7z sur Wikipedia","7z sıkıştırma","7z und 7-zip","7z wikipedia the encyclopedia","7z wikipedia the free encyclopedia","7z |","7z – Wikipedia","7z – Wikipédia, a enciclopédia livre","7z – wikipedia","7z –Wikipedia","7z,","7z-Format","7z-compression","7z-er","7z-komprimering","7z-архивы","7z-сжатия","7z; it is used under the","7zとは？ (Wikipediaへのリンク)","7zの","7zのは、","7z壓縮","7z格式","7z은","7з је","En savoir plus sur le format 7z","Extract 7Z Files with WinZip®","Format 7z","Kaj pravi Wikipedia o 7-zip","Mais informações sobre o Formato 7z","Mais informações sobre o formato aqui!","P7z (7z)","Read More 7z wikipedia the free encyclopedia","Read More About 7z wikipedia the free encyclopedia","Suomenkielisen Wikipedian 7z-artikkeli","The first thing you should do when confronted","Vikipedi'deki 7z","Wikipedia (7z)","Wikipedia 7z","Wikipedia : 7z","Wikipedia article .7z","Wikipedia article 7 زد","Wikipedia article 7Z","Wikipedia article 7z","Wikipedia article 7z (file format)","Wikipedia article about 7z","Wikipedia article about the 7z file format","Wikipedia article on .7z","Wikipedia article on 7z","Wikipedia artikel .7z","Wikipedia artikel 7z","Wikipedia entry for 7z","Wikipedia l'articolo 7Z","Wikipedia l'articolo 7z","Wikipedia über 7z","Wikipedia によれば 16000000000GB(!) までのファイルサイズ対応","Wikipedia 的7z 页面","Wikipedia's article on the 7z compression format","Wikipedia-Artikel 7Z","Wikipedia-Artikel 7z","Wikipedia-Seite zu '7z'","Wikipedia: 7z","Wikipedia:7z","Wikipediaで「.7z」を調べる","Wikipediaで「7z」を調べる","Wikipediaにある7zの解説","Wikipediaドイツ版 - 7z","Wikipediaフランス語版 - 7z","Wikipedia中国語版 - 7z","Wikipedia日本語版 - 7z","Wikipedia英語版 - 7z","Wikipédia artigo .7Z","Wikipédia artigo .7z","Wikipédia artigo 7Z","Wikipédia artigo 7z","alternativas libres","ander bestandsformaat","ar:7 زد","ar:7z","article 7z","article de Wikipedia sur 7z","artigo da Wikipédia 7z","artículo de Wikipedia 7z","ast:7z","ca:7z","compatible program","de:7z","en.wikipedia.org/7z","en.wikipedia.org/wiki/7Z","en.wikipedia.org/wiki/7z","en.wikipedia.org/wiki/7z#Pr...","es.wikipedia.org/wiki/7z","es:7z","fi:7Z","fi:7z","format .7z","formato de compressão 7z","fr:7z","http://ar.wikipedia.org/wiki/7_%D8%","http://ast.wikipedia.org/wiki/7z","http://ca.wikipedia.org/wiki/7z","http://de.wikipedia.org/wiki/7Z","http://de.wikipedia.org/wiki/7z","http://de.wikipedia.org/wiki/7z#Wichtigste_Eigenschaften","http://en.wikiped...at_present","http://en.wikipedia.org/wiki/.7z","http://en.wikipedia.org/wiki/7Z","http://en.wikipedia.org/wiki/7z","http://en.wikipedia.org/wiki/7z#7z_support_at_present","http://en.wikipedia.org/wiki/7z#Compression_method_filters","http://en.wikipedia.org/wiki/7z#Compression_methods","http://en.wikipedia.org/wiki/7z#External_links","http://en.wikipedia.org/wiki/7z#Implementations","http://en.wikipedia.org/wiki/7z#Limitations","http://en.wikipedia.org/wiki/7z#Mac","http://en.wikipedia.org/wiki/7z#Pre-proc","http://en.wikipedia.org/wiki/7z#Pre-processing_filters","http://en.wikipedia.org/wiki/7z#Windows","http://en.wikipedia.org/wiki/7z_(file_format)","http://es.wikipedia.org/wiki/7z","http://fi.wikipedia.org/wiki/7Z","http://fi.wikipedia.org/wiki/7z","http://fr.wikipedia.org/wiki/7z","http://hu.wikipedia.org/wiki/7z","http://it.wikipedia.org/wiki/7z","http://ko.wikipedia.org/wiki/7z","http://nl.wikipedia.org/wiki/.7z","http://pl.wikipedia.org/wiki/7z","http://pt.wikipedia.org/wiki/.7z","http://pt.wikipedia.org/wiki/7z","http://sl.wikipedia.org/wiki/7z","http://sv.wikipedia.org/wiki/7z","http://tr.wikipedia.org/wiki/7z","http://zh.wikipedia.org/wiki/7z","http://é.wikipedia.org/wiki/7z","hu:7z","it:7z","ja.wikipedia.org/wiki/7z","ja:7z","kikizas.net › 7Z versus RAR: 2 compression formats","ko:7z","l'article de Wikipédia .7z","l'article de Wikipédia 7z","la ayuda secciona actualmente del artículo de 7z","la compresión 7z","la compresión 7z-","la compression 7z-","le Ŧ appui actuellement ŧ sectionnent de l","na sustentação presentemente seciona do artigo de 7z","nel supporto attualmente seziona dell'articolo di 7z","nl:.7z","other archiver","pl:7z","pt:7z","s'informer","sl:7z","supported utility","sv:7z","tr:7z","ttp://ja.wikipedia.org/wiki/7z","van de Steun momenteel van het artikel van","zh:7z","« » 7z Wikipedia","статейкой","صيغة 7z","۷z","संकुचित कर रहे हैं.","การบีบอัด 7z -","“Support at Present” section of Wikipedia's 7z article","「.7z」についてWikipediaで調査","「.7z」をWikiで調べる","「7z」についてWikipediaで調査","「7z」をWikipediaで調べる","「7z」をWikiで調べる","「サポートで現在」区分する見つけることができる","ウィキペディアの記事 .7z","ウィキペディアの記事 7z","圧縮を。","支持找到”当前区分Wikipedia的7z文章","維基百科的7z 網頁","維基百科的文章“ 7z ”","維基百科～7z","维基百科的文章“ 7z ”","위키 피 디아 문서 .7z","위키 피 디아 문서 7z","７Z","７ｚ"],"name":"7z","categories":["1999 introductions","All articles with unsourced statements","Archive formats","Articles with unsourced statements from June 2014","Lossless compression algorithms","Russian inventions","Wikipedia articles needing clarification from October 2015"],"tag_line":"7z is a compressed archive file format that supports several different data compression, encryption and pre-processing algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pigeonhole-sort","_score":0,"_source":{"description":"Pigeonhole sorting is a sorting algorithm that is suitable for sorting lists of elements where the number of elements (n) and the number of possible key values (N) are approximately the same. It requires O(n + N) time. It is similar to counting sort, but differs in that it \"moves items twice: once to the bucket array and again to the final destination [whereas] counting sort builds an auxiliary array then uses the array to compute each item's final destination and move the item there.\"\nThe pigeonhole algorithm works as follows:\nGiven an array of values to be sorted, set up an auxiliary array of initially empty \"pigeonholes,\" one pigeonhole for each key through the range of the original array.\nGoing over the original array, put each value into the pigeonhole corresponding to its key, such that each pigeonhole eventually contains a list of all values with that key.\nIterate over the pigeonhole array in order, and put elements from non-empty pigeonholes back into the original array.\n\n^ NIST's Dictionary of Algorithms and Data Structures: pigeonhole sort\n^ Black, Paul E. \"Dictionary of Algorithms and Data Structures\". NIST. Retrieved 6 November 2015.","alt_names":["- Pigeonhole sort :","-> Read the article about 'Pigeonhole sort'","...more on Wikipedia about Pigeonhole sort","Güvercin yuvası sıralaması","Güvercin yuvası sıralaması - Vikipedi","Learn about Pigeonhole sort>>>","Pigeon Loch Sortierung","Pigeon agujero de clasificación","Pigeon buco ordinamento","Pigeon lubang pengurutan","Pigeon lỗ phân loại","Pigeon trou de tri","Pigeonhole Sort","Pigeonhole soort","Pigeonhole sort","Pigeonhole sort - Wikipedia, the free encyclopedia","Pigeonhole sortu","Pigeonhole рода","PigeonholeSort","Quecedane triagem","Schublade sortieren","Taube Loch sortieren","Taube holing","Taubenschlagprinzip Art","Today I Learned How To Sort Pigeons","Wikipedia article Pigeonhole sort","Wikipedia article about Pigeonhole sort","Wikipedia article on Pigeonhole sort","Wikipedia article Թվային տեսակավորում","Wikipedia entry for Pigeonhole sort","Wikipediaで「鳩の巣ソート」を調べる","due hul slags","dueslag sortere","en.wikipedia.org/wiki/Pigeonhole_sort","especie de encasillar","gołąb rodzaju dziury","http://en.wikipedia.org/wiki/Pigeonhole_ sort","http://en.wikipedia.org/wiki/Pigeonhole_sort","http://ja.wikipedia.org/wiki/鳩の巣ソート","http://zh.wikipedia.org/zh-tw/% BD% E9","kalapati holing","le pigeon holing","merpati Holing","paloma Holing","piccione speleologia","pigeon hole sort","pigeon holing","pigeonhole sort","pombo holing","rozškatulkovat řazení","sorta incasellare","tipo casillero","wikipedia's pigeonhole_sort","zaszufladkować sortowania","Приемное сортировка","голубей разбуривание","голубем рода дыра","Թվային տեսակավորում","طبقه ای","डब्बों तरह","นก พิราบ holing","นก พิราบ หลุม เรียง","「鳩の巣ソート」をWikiで調べる","ピジョンホールソート","分类似乎","分類似乎","維基百科的文章“ 鸽巢排序”","鳩の巣ソート","鳩の巣ソート - Wikipedia","鳩の巣ソートとは？ (Wikipediaへのリンク)","鳩の巣ｿｰﾄ-wikipedia","鳩穴のソート","鴿巢排序","鸽巢排序","鸽巢排序- 维基百科，自由的百科全书","비둘기 구멍에 정렬이","비둘기가"],"name":"Pigeonhole sort","categories":["Sorting algorithms","Stable sorts"],"tag_line":"Pigeonhole sorting is a sorting algorithm that is suitable for sorting lists of elements where the number of elements (n) and the number of possible key values (N) are approximately the same."}}
,{"_index":"throwtable","_type":"algorithm","_id":"elevator-algorithm","_score":0,"_source":{"description":"The elevator algorithm (also SCAN) is a disk scheduling algorithm to determine the motion of the disk's arm and head in servicing read and write requests.\nThis algorithm is named after the behavior of a building elevator, where the elevator continues to travel in its current direction (up or down) until empty, stopping only to let individuals off or to pick up new individuals heading in the same direction.\nFrom an implementation perspective, the drive maintains a buffer of pending read/write requests, along with the associated cylinder number of the request. Lower cylinder numbers indicate that the cylinder is closer to the spindle, and higher numbers indicate the cylinder is farther away.","alt_names":["elevator algorithm","- C-SCAN :","- Elevator algorithm :","-> Read more about Elevator algorithm","-> Read the article about 'Elevator algorithm'","...more on Wikipedia about Elevator algorithm","C-SCAN","Elevator Algorithm","Elevator Algorithm for Hard Disk scheduling","Elevator Seeking","Elevator algorithm","Elevator algorithm - Wikipedia","Elevator algorithm - Wikipedia :: The free encyclopedia","Elevator algorithm - Wikipedia, the free encyclopedia","Elevator algorithm - Wikipedia, the free encyclop…","Elevator algorithm - Wikipedia, th…","Elevator algorithm Wikipedia the free encyclopedia","Elevator algorithm on wikipedia.org","Elevator algorithm – Wikipedia","Elevator algorithm: Analysis","Elevator seeking","Elevator sort chip/algorithm.","Elevator_algorithm","Elevátor algoritmus","Read More elevator algorithm wikipedia the free encyclopedia","SCAN algoritmen","Scan Disk Scheduling","What are variations of Elevator algorithm","Wiki: elevator algorithm","Wikipedia article C-SCAN","Wikipedia article Elevator algorithm","Wikipedia article Elevator seeking","Wikipedia article on C-SCAN","Wikipedia article on Elevator algorithm","Wikipedia article on Elevator seeking","Wikipedia entry for Elevator algorithm","Wikipedia: Elevator algorithm","[10] SCAN","de SCAN","den SCAN","die SCAN","do SCAN","el SCAN","elevator algorithms","elevator algortihm's","elevator seek","elevator seeking","elevator seeks","en.wikipedia.org/wiki/Elevator_algorithm","en:Elevator algorithm","http://en.wikipedia.org/wiki/C-SCAN","http://en.wikipedia.org/wiki/Elevator_al","http://en.wikipedia.org/wiki/Elevator_algorithm","http://en.wikipedia.org/wiki/Elevator_al…","il movimento di testine di","la SCAN","le SCAN","lo SCAN","o CCAA","plain-dumb elevator logic","take a lot longer","the elevator algorithm","výtahovým algoritmem","了SCAN","在扫描"],"name":"Elevator algorithm","categories":["All articles needing additional references","Articles needing additional references from November 2007","Disk scheduling algorithms","Sorting algorithms"],"tag_line":"The elevator algorithm (also SCAN) is a disk scheduling algorithm to determine the motion of the disk's arm and head in servicing read and write requests."}}
,{"_index":"throwtable","_type":"algorithm","_id":"reduced-offset-lempel-ziv","_score":0,"_source":{"description":"Reduced offset Lempel Ziv (also known as ROLZ) is a data compression algorithm, which was developed by Ross Williams. It is a dictionary method, the on LZ77 builds, however, uses the contrast to this contextual methods.\nSoftware technical concept was first described by Malcolm Taylor in its data compression program RK (or WinRK implemented). By QUAD -Compressor of Ilia Muraviev there is a free implementation (under LGPL)\n\n","alt_names":["Lempel-Ziv Ross Williams","ROLZ"],"name":"Reduced Offset Lempel Ziv","categories":["Algorithms and data structures stubs","All articles lacking in-text citations","All articles to be merged","All orphaned articles","All stub articles","Articles lacking in-text citations from December 2015","Articles to be merged from December 2015","Compression algorithms","Computer science stubs","Orphaned articles from December 2015"],"tag_line":"Reduced offset Lempel Ziv (also known as ROLZ) is a data compression algorithm, which was developed by Ross Williams."}}
,{"_index":"throwtable","_type":"algorithm","_id":"tournament-sort","_score":0,"_source":{"description":"Tournament sort is a sorting algorithm. It improves upon the naive selection sort by using a priority queue to find the next element in the sort. In the naive selection sort, it takes O(n) operations to select the next element of n elements; in a tournament sort, it takes O(log n) operations (after building the initial tournament in O(n)). Tournament sort is a variation of heapsort.","alt_names":["Reference: Tournament sorting","Tournament Sort","Tournament sort","Tournament sort - Wikipedia, the free encyclopedia","Tournament sort - Wikipedia,...","Tournament_sort","Wikipedia article Tournament sort","Wikipedia article on Tournament sort","http://en.wikipedia.org/wiki/Tournament_sort","orders of magnitude better","wikipedia page on tournament sort"],"name":"Tournament sort","categories":["All articles needing additional references","Articles needing additional references from July 2012","Sorting algorithms"],"tag_line":"Tournament sort is a sorting algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"smoothsort","_score":0,"_source":{"description":"Smoothsort is a comparison-based sorting algorithm. It is a variation of heapsort developed by Edsger Dijkstra in 1981. Like heapsort, smoothsort is an in-place algorithm with an upper bound of O(n log n), but it is not a stable sort. The advantage of smoothsort is that it comes closer to O(n) time if the input is already sorted to some degree, whereas heapsort averages O(n log n) regardless of the initial sorted state.","alt_names":[],"name":"Smoothsort","categories":["Articles with example Java code","Comparison sorts","Dutch inventions","Heaps (data structures)","Sorting algorithms"],"tag_line":"Smoothsort is a comparison-based sorting algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lz77-and-lz78","_score":0,"_source":{"description":"LZ77 and LZ78 are the two lossless data compression algorithms published in papers by Abraham Lempel and Jacob Ziv in 1977 and 1978. They are also known as LZ1 and LZ2 respectively. These two algorithms form the basis for many variations including LZW, LZSS, LZMA and others. Besides their academic influence, these algorithms formed the basis of several ubiquitous compression schemes, including GIF and the DEFLATE algorithm used in PNG.\nThey are both theoretically dictionary coders. LZ77 maintains a sliding window during compression. This was later shown to be equivalent to the explicit dictionary constructed by LZ78—however, they are only equivalent when the entire data is intended to be decompressed. LZ78 decompression allows random access to the input as long as the entire dictionary is available, while LZ77 decompression must always start at the beginning of the input.\nThe algorithms were named an IEEE Milestone in 2004.\n\n","alt_names":["http://ru.wikipedia.org/wiki/LZ77","LZ77","( The distance is sometimes called the offset instead","- Lempel–Ziv :","-> Read the article about 'LZ77 and LZ78'","...Wikipedia LZ77","1 LZ77","2 LZ78","<span style=font-size:small;>LZ algorithm</span","A lossless data compression algorithm","Compression de fenêtre coulissante","Corredizas de compresión ventana","Correr compressão janela","Finestra scorrevole di compressione","Jendela geser kompresi","L728 compression algorithm","LZ algorithm","LZ compression algorithm","LZ family","LZ, zip, gz","LZ-family","LZ-packare","LZ77 & LZ78","LZ77 & LZ78 (Wikipedia)","LZ77 (algorithm) - Wikipedia, the free encyclopedia","LZ77 - Wikipedia","LZ77 [Wikipedia]","LZ77 algorithm","LZ77 and LZ78","LZ77 and LZ78 (algorithms) - Wikipedia, the free encyclopedia","LZ77 and LZ78 - Wikipedia, the free ...","LZ77 and LZ78 - Wikipedia, the free encyclopedia","LZ77 and LZ78 - Wikipedia, the free encyclopedia ...","LZ77 and LZ78 Wikipedia the free encyclopedia","LZ77 and LZ78 algorithms summary","LZ77 and LZ78 are the names for the","LZ77 and LZ78; it is used under the","LZ77 compression","LZ77 e LZ78","LZ77 e LZ78 - Wikipedia","LZ77 et LZ78","LZ77 et LZ78 - Wikipédia","LZ77 in","LZ77 is the sliding window compression algorithm, which","LZ77 och LZ78","LZ77 or LZ88","LZ77 tai LZ78","LZ77 и LZ78","LZ77 с реализацией","LZ77 – Wikipedia","LZ77 – Wikipedia, wolna encyklopedia","LZ77 – Wikipédia, a enciclopédia livre","LZ77 — Википедия","LZ77(external link)","LZ77-Algorithmus","LZ77-jäsennyksessä","LZ77-pohjaisessa tiivistämisessä","LZ77-wikipedia","LZ77/78","LZ77/LZ78","LZ77/LZSS","LZ77_and_LZ78","LZ77Википедия","LZ77とは？ (Wikipediaへのリンク)","LZ77与LZ78","LZ77与LZ78 - 维基百科，自由的百科全书","LZ77與LZ78 - 維基百科，自由的百科全書","LZ78","LZ78 - Wikipedia","LZ78 – Wikipedia","LZ78-wikipedia","LZ78とは？ (Wikipediaへのリンク)","Learn about LZ77 and LZ78>>>","Lempel Ziv","Lempel and Ziv","Lempel-Ziv (LZ)","Lempel-Ziv 77","Lempel-Ziv Data Compression Algorithm","Lempel-Ziv algorithm","Lempel-Ziv code","Lempel-Ziv coding","Lempel-Ziv compression","Lempel-Ziv-Algorithmus","Lempel-Ziv-Algorithmus von 1977","Lempelâ€“Ziv","Lempel–Ziv","Lempel–Ziv coding","Lempel–Ziv; it is used under the","Liv Zempel family","Lz77","Lz77 And Lz78","Przesuwne okno kompresji","Schiebefenster Kompression","Sliding window compression","Trượt nén cửa sổ","View LZ77 on Wikipedia","Wikipedia : LZ77","Wikipedia article LZ77","Wikipedia article LZ77 and LZ78","Wikipedia article LZ77 e LZ78","Wikipedia article LZ77 et LZ78","Wikipedia article LZ78","Wikipedia article Lempel-Ziv","Wikipedia article Lempel–Ziv","Wikipedia article on LZ77","Wikipedia article on LZ77 and LZ78","Wikipedia article on Lempel–Ziv","Wikipedia entry for LZ77 and LZ78","Wikipedia l'articolo LZ77","Wikipedia l'articolo LZ78","Wikipedia-Artikel LZ77","Wikipedia-Artikel LZ78","Wikipedia-Seite zu 'LZ77'","Wikipedia-Seite zu 'LZ78'","Wikipedia: LZ77 & LZ78","Wikipedia:LZ77 and LZ78","Wikipedia:LZ78","Wikipediaで「LZ77」を調べる","Wikipediaで「LZ78」を調べる","Wikipédia artigo LZ77","Wikipédia artigo Lz77","Ziv-Lempel Encoding","cs:LZ77","de.wikipedia.org/wiki/LZ78","en.wikipedia.org/wiki/LZ77","family of compression algorithms","http://cs.wikipedia.org/wiki/LZ77","http://de.wikipedia.org/wiki/LZ77","http://de.wikipedia.org/wiki/LZ78","http://en.wikipedia....i/LZ77_and_LZ78","http://en.wikipedia.org/wi ki/Lempel-Ziv","http://en.wikipedia.org/wiki/LZ77","http://en.wikipedia.org/wiki/LZ77_and_LZ","http://en.wikipedia.org/wiki/LZ77_and_LZ78","http://en.wikipedia.org/wiki/LZ77_and_LZ78#","http://en.wikipedia.org/wiki/LZ77_and_LZ…","http://en.wikipedia.org/wiki/Lempel-Ziv","http://et.wikipedia.org/wiki/LZ77","http://fr.wikipedia.org/wiki/LZ77","http://fr.wikipedia.org/wiki/LZ77_et_LZ78","http://hu.wikipedia.org/wiki/LZ77","http://it.wikipedia.org/wiki/LZ77_e_LZ78","http://ja.wikipedia.org/wiki/LZ78","http://pl.wikipedia.org/wiki/LZ77","http://pt.wikipedia.org/wiki/LZ77","http://pt.wikipedia.org/wiki/LZ77#Algoritmo","http://zh.wikipedia.org/wiki/LZ77","http://zh.wikipedia.org/wiki/LZ77%E4%B8","http://zh.wikipedia.org/zh-cn/LZ77%E4","http://zh.wikipedia.org/zh-hant/LZ77","l'algorithme LZ77","l'article de Wikipédia LZ77","l'article de Wikipédia LZ78","lz78","ru.wikipedia.org/wiki/LZ77","sliding window compression","ttp://ja.wikipedia.org/wiki/LZ77","zh.wikipedia.org/zh-cn/LZ77","zh.wikipedia.org/zh/LZ77与LZ78","Алгоритм LZ77","Алгоритм Лемпеля-Зіва","Википедии статью LZ77","Википедии статью LZ77/78","Википедии статью LZ78","Л. З.","Раздвижные окна сжатия","Соответствующая статья в википедии(Алгоритм LZ77 описан по","алгоритм сжатия lz77","скользящего окна","เลื่อน อัด หน้าต่าง","• LZ77 & LZ78","「LZ77」をWikipediaで調べる","「LZ77」をWikiで調べる","「LZ78」をWikiで調べる","ここは危険","ウィキペディアの記事 LZ77","ウィキペディアの記事 LZ78","ウィンドウを圧縮スライディング","川芎嗪","滑动窗口压缩","滑動窗口壓縮","維基百科的文章“ LZ77 ”","維基百科的文章“ LZ77与LZ78 ”","维基百科的文章“ LZ77 ”","维基百科的文章“ LZ77与LZ78 ”","압축 슬라이딩 창","출발지가 ."],"name":"LZ77 and LZ78","categories":["All accuracy disputes","All articles containing potentially dated statements","Articles containing potentially dated statements from 2008","Articles with disputed statements from November 2010","Lossless compression algorithms","Use dmy dates from August 2012"],"tag_line":"LZ77 and LZ78 are the two lossless data compression algorithms published in papers by Abraham Lempel and Jacob Ziv in 1977 and 1978."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dynamic-markov-compression","_score":0,"_source":{"description":"Dynamic Markov compression (DMC) is a lossless data compression algorithm developed by Gordon Cormack and Nigel Horspool. It uses predictive arithmetic coding similar to prediction by partial matching (PPM), except that the input is predicted one bit at a time (rather than one byte at a time). DMC has a good compression ratio and moderate speed, similar to PPM, but requires somewhat more memory and is not widely implemented. Some recent implementations include the experimental compression programs hook by Nania Francesco Antonio, ocamyd by Frank Schwellinger, and as a submodel in paq8l by Matt Mahoney. These are based on the 1993 implementation in C by Gordon Cormack.","alt_names":["- Dynamic Markov Compression :","- Dynamic Markov compression :","Compresión dinámica Markov","Dynamic Compression Markov","Dynamic Markov Compression","Dynamic Markov Compression - Wikipedia, the free encyclopedia","Dynamic Markov Compression; it is used under the","Dynamic Markov Komprimierung","Dynamic Markov compression","Dynamic Markov compression - Wikipedia, the free encyclopedia","Dynamic Markov compression - Wikipedia, the free encyclopedia ...","Dynamic Markov compression Wikipedia the free encyclopedia","Dynamic Markov compression; it is used under the","Dynamic_Markov_compression","Năng động Markov nén","What is algorithm of Dynamic Markov compression","Wikipedia article Dynamic Markov Compression","Wikipedia article Dynamic Markov compression","Wikipedia article on Dynamic Markov Compression","Wikipedia article on Dynamic Markov compression","Wikipedia entry for Dynamic Markov compression","dynamic Markov compression","http://en.wikipedia.org/wiki/Dynamic_Mar","http://en.wikipedia.org/wiki/Dynamic_Markov_Compression","http://en.wikipedia.org/wiki/Dynamic_Markov_compression","http://en.wikipedia.org/wiki/Dynamic_Markov_compression#","http://en.wikipedia.org/wiki/Dynamic_Mar…","Динамическое сжатие Марков","ไดนามิก มาร์ค อ ฟ อัด","ダイナミックマルコフ圧縮","动态马尔科夫压缩","動態馬爾科夫壓縮","동적 마르코프 압축"],"name":"Dynamic Markov compression","categories":["Lossless compression algorithms","Markov models"],"tag_line":"Dynamic Markov compression (DMC) is a lossless data compression algorithm developed by Gordon Cormack and Nigel Horspool."}}
,{"_index":"throwtable","_type":"algorithm","_id":"incremental-encoding","_score":0,"_source":{"description":"Incremental encoding, also known as front compression, back compression, or front coding, is a type of delta encoding compression algorithm whereby common prefixes or suffixes and their lengths are recorded so that they need not be duplicated. This algorithm is particularly well-suited for compressing sorted data, e.g., a list of words from a dictionary.\nFor example:\nThe encoding used to store the common prefix length itself varies from application to application. Typical techniques are storing the value as a single byte; delta encoding, which stores only the change in the common prefix length; and various universal codes. It may be combined with other general lossless data compression techniques such as entropy encoding and dictionary coders to compress the remaining suffixes.\n\n","alt_names":["-> Read more about Incremental encoding","...more on Wikipedia about Incremental encoding","Codifica incrementale, una variazione del delta encoding molto","Incremental Encoding","Incremental encoding","Incremental encoding - Wikipedia, the free encyclopedia","Incremental_encoding","Wikipedia article Incremental encoding","Wikipedia entry for Incremental encoding","front compress","http://en.wikipedia.org/wiki/Incremental_encoding","incremental encoding","ru.wikipedia.org/.../%25D0%2598%25D0%25BD%25D0","Інкрементне кодування","Википедии статью Инкрементное кодирование","Инкрементное кодирование","“Incremental encoding - Wikipedia, the free encyclopedia”, en.wikipedia"],"name":"Incremental encoding","categories":["All stub articles","Database index techniques","Lossless compression algorithms","Storage software stubs"],"tag_line":"Incremental encoding, also known as front compression, back compression, or front coding, is a type of delta encoding compression algorithm whereby common prefixes or suffixes and their lengths are recorded so that they need not be duplicated."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lzx-(algorithm)","_score":0,"_source":{"description":"LZX is the name of an LZ77 family compression algorithm. It is also the name of a file archiver with the same name. Both were invented by Jonathan Forbes and Tomi Poutanen.\n\n","alt_names":["-> Read the article about 'LZX (algorithm)'","...more on Wikipedia about LZX (algorithm)",".LZX",".lzx - .chm - .lit","Comprehensive info from Wikipedia","Das Verfahren wurde zuerst 1995 im gleichnamigen Kompressionsprogramm","LZX (algorithm)","LZX (algorithm) (wikipedia)","LZX (algorithm) - Wikipedia :: The free encyclopedia","LZX (algorithm) - Wikipedia, the free encyclopedia","LZX (algorithm) - Wikipedia, the free encyclopedia ...","LZX (algorithm); it is used under the","LZX - Wikipedia","LZX algorithm","LZX algorithm - Wikipedia, the free encyclopedia","LZX compression","LZX,","LZX-Algorithmus","LZX-Algorithmus – Wikipedia","LZX-wikipedia","LZX_%28algorithm%29","LZX_(algorithm)","Lzx (Algorithm)","Wikipedia : LZX","Wikipedia article ''LZX (algorithm)''","Wikipedia article LZX","Wikipedia article LZX (algorithm)","Wikipedia article about LZX","Wikipedia article on LZX","Wikipedia article on LZX (algorithm)","Wikipedia entry for LZX (algorithm)","Wikipedia-Artikel LZX-Algorithmus","Wikipedia-Seite zu 'LZX-Algorithmus'","Wikipedia: LZX (algorithm)#Microsoft Cabinet files","Wikipediaで「LZX」を調べる","de:LZX-Algorithmus","http://de.wikipedia.org/wiki/LZX-Algorit","http://de.wikipedia.org/wiki/LZX-Algorithmus","http://en.wikipedia.org/wiki/LZX","http://en.wikipedia.org/wiki/LZX (algorithm)","http://en.wikipedia.org/wiki/LZX_","http://en.wikipedia.org/wiki/LZX_%28...m","http://en.wikipedia.org/wiki/LZX_%28algorithm%29","http://en.wikipedia.org/wiki/LZX_%28algo…","http://en.wikipedia.org/wiki/LZX_(a","http://en.wikipedia.org/wiki/LZX_(algorithm)","http://en.wikipedia.org/wiki/LZX_(algorithm)#","http://ja.wikipedia.org/wiki/LZX","http://pl.wikipedia.org/wiki/LZX","http://ru.wikipedia.org/wiki/LZX","http://zh.wikipedia.org/wiki/LZX","ja:LZX","lzx algorithm","pl:LZX","zh:LZX","لزx","ウィキペディアの記事 LZX","維基百科的文章“ LZX ”","维基百科的文章“ LZX ”"],"name":"LZX (algorithm)","categories":["Amiga","Lossless compression algorithms"],"tag_line":"LZX is the name of an LZ77 family compression algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"algorithm-bstw","_score":0,"_source":{"description":"The Algorithm BSTW is a data compression algorithm, named after its designers, Bentley, Sleator, Tarjan and Wei in 1986. BSTW is a dictionary-based algorithm that uses a move-to-front transform to keep recently seen dictionary entries at the front of the dictionary. Dictionary references are then encoded using any of a number of encoding methods, usually Elias delta coding or Elias gamma coding.","alt_names":["...more on Wikipedia about Algorithm BSTW","Algorithm BSTW","Algorithm BSTW - Wikipedia :: The free encyclopedia","Algorithm BSTW - Wikipedia, the free encyclopedia","BSTW algorithm","Wikipedia entry for Algorithm BSTW","algorithm BSTW","http://en.wikipedia.org/wiki/Algorithm_B","http://en.wikipedia.org/wiki/Algorithm_BSTW","yago-res:Algorithm BSTW"],"name":"Algorithm BSTW","categories":["Algorithms and data structures stubs","All articles needing additional references","All stub articles","Articles needing additional references from May 2008","Computer science stubs","Lossless compression algorithms"],"tag_line":"The Algorithm BSTW is a data compression algorithm, named after its designers, Bentley, Sleator, Tarjan and Wei in 1986."}}
,{"_index":"throwtable","_type":"algorithm","_id":"felics","_score":0,"_source":{"description":"FELICS, which stands for Fast Efficient & Lossless Image Compression System, is a lossless image compression algorithm that performs 5-times faster than the original lossless JPEG codec and achieves a similar compression ratio.","alt_names":["FELICS","FELICS - Wikipedia, the free encyclopedia","FELICS - 维基百科，自由的百科全书","FELICS from Wikipedia","Fast Efficient & Lossless Image Compression System","Felics","Lossless Image Codec FELICS","Wikipedia article FELICS","Wikipedia article on FELICS","Wikipedia entry for FELICS","en.wikipedia.org/wiki/FELICS","en:FELICS","felics entry","http://en.wikipedia.org/wiki/FELICS","http://zh.wikipedia.org/wiki/FELICS","yago-res:FELICS","維基百科的文章“ FELICS ”","维基百科的文章“ FELICS ”"],"name":"FELICS","categories":["All articles needing additional references","Articles needing additional references from August 2011","Lossless compression algorithms","Lossy compression algorithms","Use dmy dates from July 2013"],"tag_line":"FELICS, which stands for Fast Efficient & Lossless Image Compression System, is a lossless image compression algorithm that performs 5-times faster than the original lossless JPEG codec and achieves a similar compression ratio."}}
,{"_index":"throwtable","_type":"algorithm","_id":"burrows–wheeler-transform","_score":0,"_source":{"description":"The Burrows–Wheeler transform (BWT, also called block-sorting compression) rearranges a character string into runs of similar characters. This is useful for compression, since it tends to be easy to compress a string that has runs of repeated characters by techniques such as move-to-front transform and run-length encoding. More importantly, the transformation is reversible, without needing to store any additional data. The BWT is thus a \"free\" method of improving the efficiency of text compression algorithms, costing only some extra computation.","alt_names":[],"name":"Burrows–Wheeler transform","categories":["Articles with example Python code","Articles with example pseudocode","Lossless compression algorithms","Transforms"],"tag_line":"The Burrows–Wheeler transform (BWT, also called block-sorting compression) rearranges a character string into runs of similar characters."}}
,{"_index":"throwtable","_type":"algorithm","_id":"liblzg","_score":0,"_source":{"description":"liblzg is a compression library for performing lossless data compression. It implements an algorithm that is a variation of the LZ77 algorithm, called the LZG algorithm, with the primary focus of providing a very simple and fast decoding method. One of the key features of the algorithm is that it requires no memory during decompression. The software library is free software, distributed under the zlib license.","alt_names":["Liblzg","Wikipedia article about liblzg","Wikipedia article on Liblzg","http://en.wikipedia.org/wiki/Liblzg","liblzg","liblzg - Wikipedia, the free encyclopedia"],"name":"Liblzg","categories":["All articles lacking reliable references","All articles with topics of unclear notability","Articles lacking reliable references from March 2015","Articles with topics of unclear notability from March 2015","Free data compression software","Lossless compression algorithms","Software using the zlib license"],"tag_line":"liblzg is a compression library for performing lossless data compression."}}
,{"_index":"throwtable","_type":"algorithm","_id":"zopfli","_score":0,"_source":{"description":"Zopfli is a data compression algorithm that encodes data into DEFLATE, gzip and zlib formats. Zopfli is regarded as the most size-efficient DEFLATE encoder available. In February 2013, a reference implementation of the Zopfli algorithm was released by Google as a free software programming library under the Apache License, Version 2.0. The name Zöpfli is the Swiss German diminutive of “Zopf”, a special type of Hefezopf.","alt_names":[],"name":"Zopfli","categories":["All articles needing additional references","Articles needing additional references from September 2015","Free computer libraries","Lossless compression algorithms"],"tag_line":"Zopfli is a data compression algorithm that encodes data into DEFLATE, gzip and zlib formats."}}
,{"_index":"throwtable","_type":"algorithm","_id":"exponentiation-by-squaring","_score":0,"_source":{"description":"In mathematics and computer programming, exponentiating by squaring is a general method for fast computation of large positive integer powers of a number, or more generally of an element of a semigroup, like a polynomial or a square matrix. Some variants are commonly referred to as square-and-multiply algorithms or binary exponentiation. These can be of quite general use, for example in modular arithmetic or powering of matrices. For semigroups for which additive notation is commonly used, like elliptic curves used in cryptography, this method is also referred to as double-and-add.\n\n","alt_names":["machtsverheffen door kwadrateren","'exponentiation logarithmique.","'square and multiply' method","- Exponentiation by squaring :","-> Read the article about 'Exponentiation by squaring'","...Wikipedia Algorytm szybkiego potęgowania","...Wikipedia Binär exponentiering","...Wikipedia Exponenciación binaria","...mehr auf Wikipedia über Binäre Exponentiation","...mehr auf Wikipedia über Schnelles Potenzieren","...more on Wikipedia about Exponentiation by squaring","00aa8cb36815ee3bd4146cd4863fb ...","1 Underlying idea","10 Signed-digit recoding","11 Alternatives and generalizations","2 2 k -ary Method","2k-ary Method","2乗したべき乗を","3 Sliding Window Method","4 Montgomery's Ladder Technique","5 Fixed Base Exponent","6 Yao's Method","7 Euclidean Method","8 Further applications","9 Example implementations","9.1 Computation by powers of 2","9.1.1 Runtime example: Compute 3 10","9.1.2 Runtime example: Compute 3 10","9.2 Calculation of products of powers","9.2.1 Example","9.2.2 Using transformation","9.2.3 Examples","Algorytm szybkiego pot?gowania - Wikipedia, wolna encyklopedia","Algorytm szybkiego potęgowania","Algorytm szybkiego potęgowania – Wikipedia, wolna encyklopedia","Algorytmu szybkiego potęgowania. (pl.wikipedia.org)","Alzare ad una potenza","Astendamine poolt kvadratuur","Binary Exponentiation","Binary Exponentiation, Wikipedia, English","Binary Method of Exponentiation.","Binary exponentiation","Binäre Exponentiation","Binäre Exponentiation - Square and Multiply","Binäre Exponentiation ? Wikipedia","Binäre Exponentiation â€“ Wikipedia","Binäre Exponentiation – Wikipedia","Binäre Exponentiation, Wikipedia, Deutsch","Binäre Modulo-Exponentation (Wikipedia)","Binäre_Exponentiation","Binären Exponentiation","Door machtsverheffing door kwadrateren","Eksponen oleh mengkuadratkan","Eksponentiation af kvadrat","Eksponentiering ved Squaring","Elevamento a potenza di quadratura","Elevamento a potenza di squadratura","Elevamento elevando al quadrato","Elevar a uma potência","Elevar a una potencia","Elevazione a potenza","Exponenciaci?n binaria - Wikipedia, la enciclopedia libre","Exponenciació binària","Exponenciación binaria","Exponenciación binaria - Wikipedia, la enciclopedia libre","Exponenciación elevando al cuadrado","Exponenciación_binaria","Exponenciação 2","Exponenciação elevando","Exponentiating by squaring","Exponentiating by squaring; it is used under the","Exponentiating_by_squaring","Exponentiation By Squaring","Exponentiation By Squaring - Wikipedia, The Free Encyclopedia","Exponentiation by Squaring","Exponentiation by Squaring - Wikipedia, the free encyclopedia","Exponentiation by squaring","Exponentiation by squaring - Simple English Wikipedia, the free","Exponentiation by squaring - Wikipedia, the free encyclopedia","Exponentiation by squaring - Wikipedia, the free encyclopedia ...","Exponentiation by squaring Wikipedia the free encyclopedia","Exponentiation by squaring is a reasonably good way","Exponentiation by squaring method....This does the same","Exponentiation by squaring's Underlying idea","Exponentiation by squaring, Wikipedia, Englisch und ausführlicher","Exponentiation by squaring.","Exponentiation modulo n","Exponentiation oleh mengkuadratkan","Exponentiation par carré","Exponentiation rapide","Exponentiation rapide - Wikipédia","Exponentiation squaring하여","Exponentiation โดย squaring","Exponentiation_by_squaring","Fixed Base Exponent","For fast exponentiation","Hatványozás által négyszögesítése","Heben Sie zu einer Leistung","Het verhogen tot een macht","Kvadriraj i množi","Kāpināšanas ar PS","Kėlimas laipsniu pagal suvedimas","Learn about Exponentiation by squaring>>>","Machtsverheffen door Haaks zetten","Matrix exponentiation","Methode Quadrieren und Multiplizieren","ModPower","ModPower bei der wikipedia","Montgomery's Ladder Technique","Potenciranje z Kvadriranje","Potenssiinkorotus mennessä neliöimistä","Potenzierung durch Quadratur","Potenzierung durch Quadrieren","Potęgowanie przez Kwadratura","Potęgowanie przez kwadratury","Power ( x , n ) = 1 , if n = 0 x","Quadrieren und Multiplizieren","Raise to a power","Repeated squaring","Schnellen Potenzieren","Schnelles Potenzieren","Schnelles Potenzieren - Wikipedia","Schnelles_Potenzieren","Sliding Window Method","Slightly less obvious","Square & Multiply","Square und Multiply","Square-A-Multiply","Square-And-Multiply","Square-And-Multiply-Algorithmus","Square-And-Vermenigvuldig","Square-E-Moltiplicare","Square-and-Multiply","Square-and-Multiply-Algorithmus","Square-and-multiply algorithm","Squaring algorithm","Szybkie potęgowanie","Te verhogen tot een vermogen","This can be done","Thut t bnh phng v nhn ting Vit","Thuật toán bình phương và nhân","Thuật toán bình phương và nhân – Wikipedia tiếng","Umocňování tím, že srovná","Verfahren zu effizienten Potenzierung","Wikipedia - Exponentiation by squaring","Wikipedia : ยกกำลังโดย squaring","Wikipedia article Exponentiating by squaring","Wikipedia article Exponentiation by squaring","Wikipedia article Square-and-multiply algorithm","Wikipedia article on Exponenciación binaria","Wikipedia article on Exponentiating by squaring","Wikipedia article on Square-and-multiply algorithm","Wikipedia entry for Exponentiation by squaring","Wikipedia sur Exponentiation rapide","Wikipedia-Artikel Binäre Exponentiation","Wikipedia-Artikel ModPower","Wikipedia-Artikel Schnelles Potenzieren","Wikipedia-Seite zu 'Binäre Exponentiation'","Wikipedia-Seite zu 'Schnelles Potenzieren'","Wikipedia: Eksponen oleh menegakkan","Wikipedia: Elevamento da quadratura","Wikipedia: Exponenciación binaria","Wikipedia: Exponenciação por quadratura","Wikipedia: Exponentiation by squaring","Wikipedia: Exponentiation sa pamamagitan ng squaring","Wikipedia: Lũy thừa của squaring","Wikipedia: Potenzierung durch Quadrieren","Wikipedia: Schnelles Potenzieren","Wikipédia: Exponentiation","a more efficient algorithm","algorytm szybkiego potęgowania","an efficient algorithm for computing large powers","artículo de Wikipedia Exponenciacion binaria","artículo de Wikipedia Exponenciación binaria","b62e557695fb8e8cfb9a4bf5f69c94 ...","basic repeated squaring method","binaerer Exponentiation","binarnego algorytmu","binary exponentiation","binary exponentiation algorithm","binary powering","binäre Exponentiation","by squaring","ca:Exponenciació binària","cccc1886ebe44bb3b4cc0a4bc46f7c ...","cuadrado y multiplicar-","de.wikipedia.org/wik...odulo-Exponentiation","de.wikipedia.org/wiki/Bin%C3%A4re_Exponentiation","de:Binäre Exponentiation","den richtigen Algorithmus","di elevamento a potenza di quadratura","door machtsverheffing door kwadrateren","door machtsverheffing door kwadrateren legt","double-and-add","double-and-add method","durch Quadrieren erklärt Potenzierung","eksponentiation ved kvadratur forklarer","elevamento elevando al quadrato","elevamento elevando al quadrato spiega","en.wikipedia.org/wiki/Exponentiation_by_squaring","en:Exponentiation by squaring","es:Exponenciación binaria","exponenciació binària","exponenciación binaria","exponenciación elevando al cuadrado","exponenciación elevando al cuadrado explica","exponenciação por quadratura","exponentation by squaring","exponentiaion by squaring","exponentiation binaire","exponentiation by squaring","exponentiation by squaring - Wikipedia, the free encyclopedia","exponentiation by squaring explains","exponentiation by squaring simple english wikipedia the free","exponentiation by squaring wikipedia the free encyclopedia","exponentiation by squaring,","exponentiation by squaring.","exponentiation logarithmique","exponentiation par carré","exponentiation par la quadrature","exponentiation rapide","fr:Exponentiation rapide","http://de.wikipedia.org/wiki/Bin%C3%...Exponentiation","http://de.wikipedia.org/wiki/Bin%C3%A4re_Exponentiation","http://de.wikipedia.org/wiki/Binäre_Exponentiation","http://de.wikipedia.org/wiki/Schnelles_P","http://de.wikipedia.org/wiki/Schnelles_Potenzieren","http://de.wikipedia.org/wiki/Schnelles_Potenzieren#Algorithmus","http://de.wikipedia.org/wiki/Schnelles_Potenzieren...","http://en.wikipedia....ion_by_squaring","http://en.wikipedia.org/wiki/Exponen...by_powers_of_2","http://en.wikipedia.org/wiki/Exponen...ring_algorithm","http://en.wikipedia.org/wiki/Exponentiating by squaring","http://en.wikipedia.org/wiki/Exponentiating_b...","http://en.wikipedia.org/wiki/Exponentiating_by_squaring","http://en.wikipedia.org/wiki/Exponentiating_by_squaring#Squaring_algorithm","http://en.wikipedia.org/wiki/Exponentiation by squaring","http://en.wikipedia.org/wiki/Exponentiation_b...","http://en.wikipedia.org/wiki/Exponentiation_by_","http://en.wikipedia.org/wiki/Exponentiation_by_squaring","http://en.wikipedia.org/wiki/Exponentiation_by_squaring#Alternatives_and_generalizations","http://en.wikipedia.org/wiki/Exponentiation_by_squaring#Computation_by_powers_of_2","http://en.wikipedia.org/wiki/Exponentiation_by_squaring#Example_implementations","http://en.wikipedia.org/wiki/Exponentiation_by_squaring#Further_applications","http://en.wikipedia.org/wiki/Exponentiation_by_squaring#Squaring_algorithm","http://en.wikipedia.org/wiki/Repeated_squaring","http://en.wikipedia.org/wiki/Square-..._Base_Exponent","http://en.wikipedia.org/wiki/Square-...iply_algorithm","http://en.wikipedia.org/wiki/Square-and-multiply_algorithm","http://en.wikipedia.org/wiki/Square−and−multiply_algorithm","http://es.wikipedia.org/wiki/Exponenciaci%C3%B3n_binaria","http://es.wikipedia.org/wiki/Exponenciac…","http://fr.wikipedia.org/wiki/Exponentiation_rapide","http://pl.wikipedia.org/w...ot%C4%99gowania","http://pl.wikipedia.org/wiki/Algoryt...o_potęgowania","http://pl.wikipedia.org/wiki/Algorytm_s ... %99gowania","http://pl.wikipedia.org/wiki/Algorytm_szyb...ot%C4","http://pl.wikipedia.org/wiki/Algorytm_szybkiego_pot%C4%99gowania","http://ru.wikipedia.org/wiki/Алгорит...ения_в_степень","http://ru.wikipedia.org/wiki/Алгоритм_б … _в_степень","http://ru.wikipedia.org/wiki/Алгоритм_бы...","http://ru.wikipedia.org/wiki/Алгоритм_быстрого_возведения_в_степень","http://ru.wikipedia.org/wiki/Быстрое...ение_в_степень","http://sv.wikipedia.org/wiki/Bin%C3%A4r_exponentiering","j) Binäres Exponentieren","kwadrat-and-mnożyć","l'algoritmo square and multiply","l'algoritmo square and multiply,","le http://en.wikipedia.","logarytmicznie","method of exponentiation by squaring","mocnění čtvercením","multiply_algorithm","método binário de exponenciação","método de exponenciación binaria","n = ∑ i = 0 l - 1 n i b","náměstí-a-násobit","piazza-e-moltiplica","pl:Algorytm szybkiego potęgowania","plaza-y-Multiplicar","potęgowania przez kwadratury","potęgowania przez podnoszenie do kwadratu","potęgowanie przez kwadratury","potęgowanie przez kwadratury wyjaśnia","quadratisch-and-Multiply","quick exponentiation scheme","recursive squaring algorithm","repeated square and multiply","repeated squaring","repeated squaring algorithm","repeatedly squaring","ru:Алгоритм быстрого возведения в степень","schnellem Potenzieren","simple:Exponentiation by squaring","sliding window exponentiation","square and multiply","square and multiply modulo n","square-and-multiply","square-and-multiply algorithm","squaring method","squaring द्वारा घातांक","squarings","sv:Binär exponentiering","szybkiego potęgowania","the correct algorithm","thuật toán bình phương và nhân","umocňování tím, že srovná","umocňování tím, že srovná vysvětluje","used for fast matrix exponentation","using exp by squaring","va voir le lien que je t'ai","vi:Thuật toán bình phương và nhân","wiki: Exponentiation_by_squaring","wiki:Exponentiation_by_squaring","wiki:Алгоритм_быстрого_возведения_в_степень","właściwego","Élever à une puissance","Élévation à une puissance","Алгоритм быстрого возведения в степень","Быстрое возведение в степень","Википедия: Возведение в степень возведением в квадрат","Возведение в степень путем возведения в квадрат","Возведение путем возведения в квадрат","Возведения в степень","Возведено в степень","Піднесення до степеня шляхом зведення в квадрат","Степеновање по квадратури","алгоритм быстрого возведения числа в степень","алгоритма быстрого возведения в степень","алгоритмом «возводи в квадрат и перемножай»","более эффективный алгоритм","быстрого возведения в степень","возведение в степень путем возведения в квадрат","возведение в степень путем возведения в квадрат объясняет","возведение путем возведения в квадрат","квадратного и-кратно","площади-And-Multiply","площади-И-кратно","този алгоритъм","швидкого піднесення до степеня","بتوان رساندن توسط تربیع","देखना चाहता हूँ सकता","โดยการยกกำลัง squaring","ხარისხში აყვანის სწრაფი ალგორითმი","スクエアそしてマルチプライ","スクエアリングで累乗","レイズの電源を","乗によってべき乗","乗によってべき乗を","二乗の指数","二乗の指数について説明します","二乗の指数を","冪乗の","冪的平方","出典：べき乗2乗で","幂的平方","平方和乘法运算","平方幂的解释","提高到一个电源","提高到电源","现蕾幂的","由平方幂","維基百科：冪的平方","维基百科：幂的平方","角穴および-乗算","電源に引き上げ","위키백과 : Exponentiation squaring에 의해","제곱으로 지수값 구하기"],"name":"Exponentiation by squaring","categories":["Computer arithmetic","Computer arithmetic algorithms","Exponentials"],"tag_line":"In mathematics and computer programming, exponentiating by squaring is a general method for fast computation of large positive integer powers of a number, or more generally of an element of a semigroup, like a polynomial or a square matrix."}}
,{"_index":"throwtable","_type":"algorithm","_id":"s3-texture-compression","_score":0,"_source":{"description":"S3 Texture Compression (S3TC) (sometimes also called DXTn or DXTC) is a group of related lossy texture compression algorithms originally developed by Iourcha et al. of S3 Graphics, Ltd. for use in their Savage 3D computer graphics accelerator. The method of compression is strikingly similar to the previously published Color Cell Compression, which is in turn an adaptation of Block Truncation Coding published in the late 1970s. Unlike some image compression algorithms (e.g. JPEG), S3TC's fixed-rate data compression coupled with the single memory access (cf. Color Cell Compression and some VQ-based schemes) made it well-suited for use in compressing textures in hardware-accelerated 3D computer graphics. Its subsequent inclusion in Microsoft's DirectX 6.0 and OpenGL 1.3 (via the GL_EXT_texture_compression_s3tc extension) led to widespread adoption of the technology among hardware and software makers. While S3 Graphics is no longer a competitor in the graphics accelerator market, license fees are still levied and collected for the use of S3TC technology, for example in game consoles and graphics cards. The wide use of S3TC has led to a de facto requirement for OpenGL drivers to support it, but the patent-encumbered status of S3TC presents a major obstacle to open source implementations.","alt_names":["- S3 Texture Compression :","- S3TC :","- Texture compression :","-> Read more about DXTC","...more on Wikipedia about S3 Texture Compression","1 Codecs","2 DXT1","3 DXT2 and DXT3","4 DXT4 and DXT5","5 S3TC Format Comparison","Compresión de texturas","Compressed texture","Continue to http://en.wikipedia.org/wiki/S3_","DTX1, DTX3 o DTX5","DXT 1-5","DXT Compression","DXT Wikipedia","DXT*","DXT-compressed","DXT-compressor","DXT/S3TC","DXT1","DXT1 or DXT5","DXT2 and DXT3","DXT3","DXT3とDXT5の違い","DXT4 and DXT5","DXT5","DXT5 Format","DXT5 compressed","DXT??","DXTC","DXTC - Wikipedia","DXTC - Wikipedia, the free encyclopedia","DXTC format","DXTC(Wikipedia)","DXTC-wikipedia","DXTn","DXTn (S3)","DXTn Info @Wikipedia","DXTn, S3TC compression - Wikipedia","DXT圧縮","DirectX Texture Compression","Dxtc","GL_COMPRESSED_RGB_S3TC_DXT1_EXT","Learn about S3 Texture Compression>>>","More information on DXT formats","S3 Compression","S3 Graphics Texture Compression","S3 Texture Compression","S3 Texture Compression - Wik...","S3 Texture Compression - Wikipedia, the free encyclopedia","S3 Texture Compression - Wikipedia, the free encyclopedia ...","S3 Texture Compression S3TC manchmal auch DXTn oder","S3 Texture Compression Wikipedia The Free Encyclopedia","S3 Texture Compression from Wikipedia","S3 Texture Compression â€“ Wikipedia","S3 Texture Compression – Wikipedia","S3 Texture Compression(encompasses DXT1-5)","S3 Texture Compression(英語)","S3 Texture Com…","S3 Texture compression","S3 compression","S3 texture compression","S3-style","S3CT","S3TC","S3TC (DXT)","S3TC (DXT1)","S3TC (aka DXTn or DXTC)","S3TC Format","S3TC Format Comparison","S3TC bei der wikipedia","S3TC o S3 Texture Compression","S3TC texture","S3TC/ DXTC","S3TC/DXTC Compression","S3_Texture_Compression","S3_Texture_Compression aka DXT","S3tc","S3tc – Wikipédia, a enciclopédia livre","ST3C","See this link for information about DXT file","Since I'm not very good at explaining","Texture Compresion","Texture compression","Texture compression - Wikipedia, the free encyclopedia","Texture compression Wikipedia the free encyclopedia","Texture compression from Wikipedia","Texture compression; it is used under the","Texture_compression","The wikipedia article about DXT5","This algorithm has several variations from DXT1 to","Wikipedia - DXTn","Wikipedia : DXTC","Wikipedia article DXT1","Wikipedia article DXT5","Wikipedia article DXTC","Wikipedia article S3 Texture Compression","Wikipedia article S3TC","Wikipedia article on DXT1","Wikipedia article on DXT5","Wikipedia article on S3 Texture Compression","Wikipedia article on S3TC","Wikipedia article on Texture compression","Wikipedia entry for DXTC","Wikipedia entry for S3 Texture Compression","Wikipedia on s3tc","Wikipedia's entry on DXT compression","Wikipedia, DXT","Wikipedia-Artikel DXT","Wikipedia-Artikel S3 Texture Compression","Wikipedia-Artikel S3TC","Wikipedia-Seite zu 'S3 Texture Compression'","Wikipediaで「DXTC」を調べる","Wikipédia artigo S3tc","algorithme de compression particulier","artigo da Wikipédia S3tc","compresiÃ³n de texturas","compresión de la textura","compresión de texturas","compress textures on the video card","compression de texture","de.wikipedia.org/wiki/S3_Texture_Compression","de:S3 Texture Compression","en.wikipedia.org/wiki/DXTC","en.wikipedia.org/wiki/S3_Texture_Compression","en.wikipedia.org/wiki/S3_Texture_Compression Are you engaged","en.wikipedia.org/wiki/Texture_compression","en:Texture compression","f DXTC","hardware compression","http://ceb.wikipedia.org/wiki/DXTC","http://de.wikipedia.org/wiki/DXT","http://de.wikipedia.org/wiki/S3TC","http://de.wikipedia.org/wiki/S3_Texture_","http://de.wikipedia.org/wiki/S3_Texture_Compression","http://en.wikipedia....ure_Compression","http://en.wikipedia.org/wiki/DXT1","http://en.wikipedia.org/wiki/DXT1#DXT1","http://en.wikipedia.org/wiki/DXT1)","http://en.wikipedia.org/wiki/DXT5","http://en.wikipedia.org/wiki/DXT5#Codecs","http://en.wikipedia.org/wiki/DXTC","http://en.wikipedia.org/wiki/S3TC","http://en.wikipedia.org/wiki/S3TC#DXT1","http://en.wikipedia.org/wiki/S3TC#S3TC_Format_Comparison","http://en.wikipedia.org/wiki/S3_Text...#DXT4_and_DXT5","http://en.wikipedia.org/wiki/S3_Text...mat_Comparison","http://en.wikipedia.org/wiki/S3_Text...mpression#DXT1","http://en.wikipedia.org/wiki/S3_Texture ... Comparison","http://en.wikipedia.org/wiki/S3_Texture_...4_and_DXT5","http://en.wikipedia.org/wiki/S3_Texture_Compr...","http://en.wikipedia.org/wiki/S3_Texture_Compression","http://en.wikipedia.org/wiki/S3_Texture_Compression#DXT1","http://en.wikipedia.org/wiki/S3_Texture_Compression#DXT4_and_DXT5","http://en.wikipedia.org/wiki/Texture_compression","http://en.wikipedia.org/wi​ki/S3_Texture_Compression","http://es.wikipedia.org/wiki/Compresi%C3%B3n_de_texturas","http://ja.wikipedia.org/wiki/DXTC","http://ja.wikipedia.org/wiki/DXTCのthumbnail","in the proper format","ja:DXTC","komprese textur","on, http://en.wikipedia.org/wiki/Texture_compression","pt:S3tc","texture compressie","texture compression","texture compression algorithm","texture decompression","texture di compressione","texture puristus","texture_compression","ttp://ja.wikipedia.org/wiki/DXTC","wikipedia: S3 Texture Compression","yago-res:DXTC","|S3 Texture Compression","он знает.","فشرده سازی بافت","ポリゴンテクスチャ圧縮のド根っこの特許を持っていて、この特許だけで食っている"],"name":"S3 Texture Compression","categories":["3D computer graphics","Lossy compression algorithms","Texture compression"],"tag_line":"S3 Texture Compression (S3TC) (sometimes also called DXTn or DXTC) is a group of related lossy texture compression algorithms originally developed by Iourcha et al."}}
,{"_index":"throwtable","_type":"algorithm","_id":"schönhage–strassen-algorithm","_score":0,"_source":{"description":"The Schönhage–Strassen algorithm is an asymptotically fast multiplication algorithm for large integers. It was developed by Arnold Schönhage and Volker Strassen in 1971. The run-time bit complexity is, in Big O notation, O(n log n log log n) for two n-digit numbers. The algorithm uses recursive Fast Fourier transforms in rings with 22n + 1 elements, a specific type of number theoretic transform.\nThe Schönhage–Strassen algorithm was the asymptotically fastest multiplication method known from 1971 until 2007, when a new method, Fürer's algorithm, was announced with lower asymptotic complexity; however, Fürer's algorithm currently only achieves an advantage for astronomically large values and is not used in practice.\nIn practice the Schönhage–Strassen algorithm starts to outperform older methods such as Karatsuba and Toom–Cook multiplication for numbers beyond 2215 to 2217 (10,000 to 40,000 decimal digits). The GNU Multi-Precision Library uses it for values of at least 1728 to 7808 64-bit words (33,000 to 150,000 decimal digits), depending on architecture. There is a Java implementation of Schönhage–Strassen which uses it above 74,000 decimal digits.\nApplications of the Schönhage–Strassen algorithm include mathematical empiricism, such as the Great Internet Mersenne Prime Search and computing approximations of π, as well as practical applications such as Kronecker substitution, in which multiplication of polynomials with integer coefficients can be efficiently reduced to large integer multiplication; this is used in practice by GMP-ECM for Lenstra elliptic curve factorization.\n^ A. Schönhage and V. Strassen, \"Schnelle Multiplikation großer Zahlen\", Computing 7 (1971), pp. 281–292.\n^ Martin Fürer, \"Faster integer multiplication\", STOC 2007 Proceedings, pp. 57–66.\n^ Rodney Van Meter and Kohei M. Itoh, \"Fast quantum modular exponentiation\", Physical Review A, Vol. 71 (2005).\n^ Overview of Magma V2.9 Features, arithmetic section: Discusses practical crossover points between various algorithms.\n^ Luis Carlos Coronado García, \"Can Schönhage multiplication speed up the RSA encryption or decryption?\", University of Technology, Darmstadt (2005)\n^ \"MUL_FFT_THRESHOLD\". GMP developers' corner. Retrieved 3 November 2011. \n^ \"An improved BigInteger class which uses efficient algorithms, including Schönhage–Strassen\". Oracle. Retrieved 2014-01-10. \n^","alt_names":[],"name":"Schönhage–Strassen algorithm","categories":["Computer arithmetic algorithms","Multiplication"],"tag_line":"The Schönhage–Strassen algorithm is an asymptotically fast multiplication algorithm for large integers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"block-truncation-coding","_score":0,"_source":{"description":"Block Truncation Coding, or BTC, is a type of lossy image compression technique for greyscale images. It divides the original images into blocks and then uses a quantiser to reduce the number of grey levels in each block whilst maintaining the same mean and standard deviation. It is an early predecessor of the popular hardware DXTC technique, although BTC compression method was first adapted to colour long before DXTC using a very similar approach called Color Cell Compression. BTC has also been adapted to video compression \nBTC was first proposed by e.j. and O.R. Mitchell  at Purdue University. Another variation of BTC is Absolute Moment Block Truncation Coding or AMBTC, in which instead of using the standard deviation the first absolute moment is preserved along with the mean. AMBTC is computationally simpler than BTC and also typically results in a lower Mean Squared Error (MSE). AMBTC was proposed by Maximo Lema and Robert Mitchell.\nUsing sub-blocks of 4x4 pixels gives a compression ratio of 4:1 assuming 8-bit integer values are used during transmission or storage. Larger blocks allow greater compression (\"a\" and \"b\" values spread over more pixels) however quality also reduces with the increase in block size due to the nature of the algorithm.\nThe BTC algorithm was used for compressing Mars Pathfinder's rover images.","alt_names":["Block Truncation Coding","Block Truncation Coding - Wikipedia, the free encyclopedia","Block Truncation Coding - Wikipedia, the free encyclopedia ...","Compression procedure","What is the example of Block truncation coding","Wikipedia article Block Truncation Coding","Wikipedia entry for Block Truncation Coding","block truncation coding","en.wikipedia.org/wiki/Block_Truncation_Coding","http://en.wikipedia.org/wiki/Block_Trunc","http://en.wikipedia.org/wiki/Block_Truncation_Coding","yago-res:Block Truncation Coding"],"name":"Block Truncation Coding","categories":["Image compression","Lossy compression algorithms"],"tag_line":"Block Truncation Coding, or BTC, is a type of lossy image compression technique for greyscale images."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bailey–borwein–plouffe-formula","_score":0,"_source":{"description":"The Bailey–Borwein–Plouffe formula (BBP formula) is a spigot algorithm for computing the nth binary digit of pi (symbol: π) using base 16 math. The formula can directly calculate the value of any given digit of π without calculating the preceding digits. The BBP is a summation-style formula that was discovered in 1995 by Simon Plouffe and was named after the authors of the paper in which the formula was published, David H. Bailey, Peter Borwein, and Simon Plouffe. Before that paper, it had been published by Plouffe on his own site. The formula is\n.\nThe discovery of this formula came as a surprise. For centuries it had been assumed that there was no way to compute the nth digit of π without calculating all of the preceding n − 1 digits.\nSince this discovery, many formulas for other irrational constants have been discovered of the general form\n\nwhere α is the constant and p and q are polynomials in integer coefficients and b ≥ 2 is an integer base.\nFormulas in this form are known as BBP-type formulas. Certain combinations of specific p, q and b result in well-known constants, but there is no systematic algorithm for finding the appropriate combinations; known formulas are discovered through experimental mathematics.","alt_names":[],"name":"Bailey–Borwein–Plouffe formula","categories":["All articles needing additional references","Articles needing additional references from March 2014","Pi algorithms"],"tag_line":"The Bailey–Borwein–Plouffe formula (BBP formula) is a spigot algorithm for computing the nth binary digit of pi (symbol: π) using base 16 math."}}
,{"_index":"throwtable","_type":"algorithm","_id":"wavelet-scalar-quantization","_score":0,"_source":{"description":"The Wavelet Scalar Quantization algorithm (WSQ) is a compression algorithm used for gray-scale fingerprint images. It is based on wavelet theory and has become a standard for the exchange and storage of fingerprint images. WSQ was developed by the FBI, the Los Alamos National Laboratory, and the National Institute of Standards and Technology (NIST).\nThis compression method is preferred over standard compression algorithms like JPEG because at the same compression ratios WSQ doesn't present the \"blocking artifacts\" and loss of fine-scale features that are not acceptable for identification in financial environments and criminal justice. \nMost American law enforcement agencies use Wavelet Scalar Quantization (WSQ) - for efficient storage of compressed fingerprint images at 500 pixels per inch (ppi). For fingerprints recorded at 1000 ppi spatial resolution, law enforcement (including the FBI) uses JPEG 2000 instead of WSQ.","alt_names":[],"name":"Wavelet scalar quantization","categories":["Fingerprints","Graphics file formats","Lossy compression algorithms"],"tag_line":"The Wavelet Scalar Quantization algorithm (WSQ) is a compression algorithm used for gray-scale fingerprint images."}}
,{"_index":"throwtable","_type":"algorithm","_id":"3dc","_score":0,"_source":{"description":"3Dc (FourCC : ATI2), also known as DXN, BC5, or Block Compression 5 is a lossy data compression algorithm for normal maps invented and first implemented by ATI. It builds upon the earlier DXT5 algorithm and is an open standard. 3Dc is now implemented by both ATI and Nvidia.","alt_names":["...mehr auf Wikipedia über 3Dc","...more on Wikipedia about 3Dc","3 Dc","3DC","3Dc","3Dc - Wikipedia","3Dc - Wikipedia, the free en...","3Dc - Wikipedia, the free encyclopedia","3Dc – Wikipedia","3Dc-wikipedia","3Dc; it is used under the","3dc - Wikipedia, the free encyclopedia","ATIの3Dc","Look for De:3Dc","Wikipedia 3Dc page","Wikipedia : 3Dc","Wikipedia article ''3Dc''","Wikipedia article 3Dc","Wikipedia article on 3Dc","Wikipedia entry for 3Dc","Wikipedia-Artikel 3Dc","Wikipediaで「3Dc」を調べる","de:3Dc","http://de.wikipedia.org/wiki/3Dc","http://en.Liarpedia.org/wiki/Ninjemys","http://en.wikipedia.org/wiki/3Dc","http://es.wikipedia.org/wiki/3Dc","http://ja.wikipedia.org/wiki/3Dc","http://ja.wikipedia.org/wiki/3Dcのthumbnail","ja:3Dc","yago-res:3Dc","ウィキペディアの記事 3Dc"],"name":"3Dc","categories":["3D graphics software","Lossy compression algorithms","Open formats","Texture compression"],"tag_line":"3Dc (FourCC : ATI2), also known as DXN, BC5, or Block Compression 5 is a lossy data compression algorithm for normal maps invented and first implemented by ATI."}}
,{"_index":"throwtable","_type":"algorithm","_id":"agm-method","_score":0,"_source":{"description":"In mathematics, the AGM method (for arithmetic–geometric mean) makes it possible to construct fast algorithms for calculation of exponential and trigonometric functions, and some mathematical constants and in particular, to quickly compute .","alt_names":["- AGM method :","88642e05b8923d1b06dd4c4fcfbc8 ...","91b5a2fe952ffb93905f4f0f3165fb ...","AGM method","AGM method - Wikipedia, the free encyclopedia","AGM method of Gauss","AGM method; it is used under the","AGM_method","The AGM method of Gauss","Wikipedia article AGM method","Wikipedia article AGM_method","Wikipedia article The AGM method of Gauss","Wikipedia article on AGM method","Wikipedia entry for AGM method","http://en.wikipedia.org/wiki/AGM_method","yago-res:AGM method","АГС метод Гаусса"],"name":"AGM method","categories":["All articles to be merged","Articles to be merged from September 2012","Computer arithmetic algorithms"],"tag_line":"In mathematics, the AGM method (for arithmetic–geometric mean) makes it possible to construct fast algorithms for calculation of exponential and trigonometric functions, and some mathematical constants and in particular, to quickly compute ."}}
,{"_index":"throwtable","_type":"algorithm","_id":"apple-video","_score":0,"_source":{"description":"Apple Video is a lossy video compression and decompression algorithm (codec) developed by Apple Inc. and first released as part of QuickTime 1.0 in 1991. The codec is also known as QuickTime Video, by its FourCC RPZA and the name Road Pizza. When used in the AVI container, the FourCC AZPR is also used. The bit-stream format of Apple Video has been reverse-engineered and a decoder has been implemented in the projects XAnim and libavcodec.","alt_names":[],"name":"Apple Video","categories":["Apple Inc. software","Lossy compression algorithms","Video codecs"],"tag_line":"Apple Video is a lossy video compression and decompression algorithm (codec) developed by Apple Inc. and first released as part of QuickTime 1.0 in 1991."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lamport's-bakery-algorithm","_score":0,"_source":{"description":"Lamport's bakery algorithm is a computer algorithm devised by computer scientist Leslie Lamport, which is intended to improve the safety in the usage of shared resources among multiple threads by means of mutual exclusion.\nIn computer science, it is common for multiple threads to simultaneously access the same resources. Data corruption can occur if two or more threads try to write into the same memory location, or if one thread reads a memory location before another has finished writing into it. Lamport's bakery algorithm is one of many mutual exclusion algorithms designed to prevent concurrent threads entering critical sections of code concurrently to eliminate the risk of data corruption.\n\n","alt_names":["http://en.wikipedia.org/wiki/Lamport's_bakery_algorithm","Lamport's bakery algorithm","Lamport's bakery algorithm - Wikipedia, the free encyclopedia","- Lamport's bakery algorithm :","...Wikipedia Algoritmo de la panadería de Lamport","...Wikipedia Algoritmo del fornaio","...Wikipedia Algorytm piekarniany","...more on Wikipedia about Lamport's bakery algorithm","1 Nature of the problem","2. Bakery's Alg.","2.1 Analogy","2.2 Critical section","2.3 Non-critical section","3 Implementation of the algorithm","3.2 Discussion","Algorithme de la boulangerie","Algorithme de la boulangerie - Wikipédia","Algoritmo de la panadería de Lamport","Algoritmo de la panadería de Lamport - Wikipedia, la","Algoritmo del fornaio","Algoritmo del fornaio - Wikipedia","Algorytm piekarniany","Bakery Algorithm","Bakery Lock","Bakery algorithm","Bakery's Algorithm","Bäcker-Algorithmus","Lamport Bakery Algorithm","Lamport a pékség algoritmus - Wikipédia, a szabad enciklopédia","Lamport bageri algoritme","Lamport bakkerij-algoritme","Lamport pekařství algoritmus","Lamport s bakery algorithm Wikipedia the free encyclopedia","Lamport's Bakery Algorithm","Lamport's Bakery Algorithmus","Lamport's Bakery algorithm","Lamport's Bakery ալգորիթմ","Lamport's bakery algorithm - Wikipedia :: The free encyclopedia","Lamport's bakery algorithm - Wikipedia, the ...","Lamport's bakery algorithm - Wikipedia, the free …","Lamport's bakery algorithm - mutual exclusions without atomic hardware","Lamport's_Bakery_Algorithm","Learn about Lamport's bakery algorithm>>>","The bakery algorithm","What is algorithm of Lamport Bakery algorithm","Wikipedia - Lamport's Bakery Algorithm","Wikipedia : ランポートのパン屋のアルゴリズム","Wikipedia article ''Lamport's bakery algorithm''","Wikipedia article Algorytm piekarniany","Wikipedia article Bakery algorithm","Wikipedia article Lamport's Bakery algorithm","Wikipedia article Lamport's Bakery ալգորիթմ","Wikipedia article Lamport's bakery algorithm","Wikipedia article on Algorytm piekarniany","Wikipedia article on Bakery algorithm","Wikipedia sur Algorithme de la boulangerie","agoritmo del fornaio","algoritmo de la panadería de Lamport","algoritmo di Lamport del fornaio","an algorithm devised by Leslie Lamport for implementing","artículo de Wikipedia Algoritmo de la panaderia de","artículo de Wikipedia Algoritmo de la panadería de","bakery algorithm","bakery 演算法","dell'algoritmo di panetteria Lamport","denne algoritme","en.wikipedia.org/...Lamport's_bakery_algorithm","en.wikipedia.org/wiki/Lamport%27s_bakery_algorithm","en:Lamport's bakery algorithm","es.wikipedia.org/wiki/Algoritmo_de_la_panader%C3%ADa_de_Lamport...","http://en.wikipedia.org/wiki/Lamport%27 ... _algorithm","http://en.wikipedia.org/wiki/Lamport%27s...","http://en.wikipedia.org/wiki/Lamport%27s_bakery_algorithm","http://en.wikipedia.org/wiki/Lamport%27s…","http://en.wikipedia.org/wiki/Lamport...kery_algorithm","http://es.wikipedia.org/wiki/Algoritmo_de_la_panader%C3%ADa_de_Lamport","http://fr.wikipedia.org/wiki/Algorithme_de_la_boulangerie","http://it.wikipedia.org/wiki/Algoritmo_del_fornaio","http://pl.wikipedia.org/wiki/Algorytm_piekarniany","hy:Lamport's Bakery ալգորիթմ","la panadería algoritmo de Lamport","napisano w en-wiki","panificio algoritmo","see the page on wikipedia","wiki:Bakery algorithm","Алгоритм Лампорта (Алгоритм Булочника)","Лампорта","نانوایان لمپورت","है Lamport बेकरी एल्गोरिथ्म","ランポートのパン屋のアルゴリズム","ランポートのパン屋のアルゴリズム - Wikipedia","ランポートのパン屋のアルゴリズム – Wikipedia","面包店算法","빵집 알고리즘(Lamport's Bakery Algorithm)","ﾗﾝﾎﾟｰﾄのﾊﾟﾝ屋のｱﾙｺﾞﾘｽﾞﾑ"],"name":"Lamport's bakery algorithm","categories":["All articles lacking in-text citations","All articles to be merged","Articles lacking in-text citations from December 2010","Articles to be merged from October 2013","Articles with example pseudocode","Concurrency control algorithms","Use dmy dates from December 2012"],"tag_line":"Lamport's bakery algorithm is a computer algorithm devised by computer scientist Leslie Lamport, which is intended to improve the safety in the usage of shared resources among multiple threads by means of mutual exclusion."}}
,{"_index":"throwtable","_type":"algorithm","_id":"peterson's-algorithm","_score":0,"_source":{"description":"Peterson's algorithm (AKA Peterson's solution) is a concurrent programming algorithm for mutual exclusion that allows two processes to share a single-use resource without conflict, using only shared memory for communication. It was formulated by Gary L. Peterson in 1981. While Peterson's original formulation worked with only two processes, the algorithm can be generalized for more than two, as shown below.","alt_names":["http://en.wikipedia.org/wiki/Peterson's_algorithm","Peterson's algorithm - Wikipedia, the free encyclopedia","Peterson's algorithm","- Peterson's algorithm :","-> Read more about Peterson's algorithm",". Peterson's algorith","...Wikipedia Algoritmo de Peterson","...Wikipedia Algoritmo di Peterson","...Wikipedia Algoritmo tie-breaker","...Wikipedia Algorytm Petersona","...mehr auf Wikipedia über Algorithmus von Peterson","1. Peterson's Solution","1.1 Mutual exclusion","1.2 Progress requirement","1.3 Bounded waiting","2 C implementation example using two POSIX threads","Algorihme de Peterson","Algorithme de Peterson","Algorithme de Peterson - Wikipédia","Algorithmus von Peterson","Algorithmus von Peterson – Wikipedia","Algorithmus_von_Peterson","Algoritmo Peterson","Algoritmo de Peterson","Algoritmo de Peterson - Wikipedia, la enciclopedia libre","Algoritmo de Peterson - Wikipédia, a enciclopédia livre","Algoritmo de Peterson – Wikipédia, a enciclopédia livre","Algoritmo di Peterson","Algoritmo di Peterson - Wikipedia","Algoritmo para dos procesos","Algorytm Petersona","Algorytm Petersona – Wikipedia, wolna encyklopedia","I just learned Peterson's algorithm for mutual exclusion","Learn about Peterson's algorithm>>>","Peterson Algorithm","Peterson Algorithmuses","Peterson lock","Peterson 算法","Peterson's 2-Processor Algorithm","Peterson's Algorithm","Peterson's Algorithmus","Peterson's Lock","Peterson's Solution","Peterson's algorithm (english)","Peterson's algorithm - Wikipedia :: The free encyclopedia","Peterson's algorithm - Wikipedia, the free ...","Peterson's algorithm for mutual exclusion","Peterson's algoritme","Peterson's algortihm","Peterson's lock","Peterson's locking algorithm","Peterson's mutual exclusion algorithm","Peterson's protocol","Peterson's solution","Peterson-Algo","Peterson-Algorithmus","Petersonov algoritmus","Petersons Algorithm","Petersonův algoritmus","Petersonのアルゴリズムでは、","Wederzijds uitsluitingsalgoritme van Peterson","Wederzijds uitsluitingsalgoritme van Peterson - Wikipedia","Wikipedia (Peterson's algorithm)","Wikipedia : ピーターソンのアルゴリズム","Wikipedia Algoritmo de Peterson","Wikipedia article Algorithmus von Peterson","Wikipedia article Algoritmo de Peterson","Wikipedia article Algorytm Petersona","Wikipedia article Peterson's algorithm","Wikipedia article on Algoritmo de Peterson","Wikipedia – Peterson's algorithm","Wikipedia-Artikel Algorithmus von Peterson","Wikipedia-Artikel Peterson-Algorithmus","Wikipedia-Seite zu 'Algorithmus von Peterson'","Wikipedia-Seite zu 'Peterson-Algorithmus'","Wikipedia: Peterson's Algorithm","Wikipedia:Algoritmo_di_Peterson","Wikipediaで「ピーターソンのアルゴリズム」を調べる","algorithme de Peterson","algoritmo de Peterson","algoritmo de peterson","algorytm Peterson","artículo de Wikipedia Algoritmo de Peterson","de.wikipedia.org/wiki/Algorithmus_von_Peterson","el algoritmo de Peterson","en.wikipedia.org/wiki/Peterson%27s_algorithm","es.wikipedia.org/wiki/Algoritmo_de_Peterson","es:Algoritmo de Peterson","hm. http://en.wikipedia.org/wiki/Peterson's_algorithm","http://de.wikipedia.org/wiki/Algorithmus_von_Peterson","http://de.wikipedia.org/wiki/Peterson-Algorithmus","http://en.wikipedia.org/wiki/Peterson%27s_alg...","http://en.wikipedia.org/wiki/Peterson%27s_algorithm","http://en.wikipedia.org/wiki/Peterson's algorithm","http://en.wikipedia.org/wiki/Peterson's_…","http://es.wikipedia.org/wiki/Algoritmo_de_Peterson","http://fr.wikipedia.org/wiki/Algorithme_de_Peterson","http://goo.gl/eOi3R","http://it.wikipedia.org/wiki/Algoritmo_di_Peterson","http://pl.wikipedia.org/wiki/Algorytm_Petersona","ja:ピーターソンのアルゴリズム","ko:피터슨의 알고리즘","l'algorithme de Peterson","l'algoritmo di Peterson","pl:Algorytm Petersona","pt:Algoritmo de Peterson","uk:Алгоритм Петерсона","uk:Алгоритм Пітерсона","wederzijds uitsluitingsalgoritme van Peterson","wikipedia:ピーターソンのアルゴリズム","Алгоритм Петерсона","Алгоритм Пітерсона","алгоритма Петерсона","ピーターソンの<b>アルゴリズム</b> - Wikipedia","ピーターソンのアルゴリズム","ピーターソンのアルゴリズム - Wikipedia","ピーターソンのアルゴリズム from Wikipedia","ピーターソンのアルゴリズム – Wikipedia","피터슨의 알고리즘","ﾋﾟｰﾀｰｿﾝのｱﾙｺﾞﾘｽﾞﾑ","ﾋﾟｰﾀｰｿﾝのｱﾙｺﾞﾘｽﾞﾑ-wikipedia"],"name":"Peterson's algorithm","categories":["All articles with unsourced statements","Articles with example C code","Articles with unsourced statements from May 2015","Concurrency control algorithms"],"tag_line":"Peterson's algorithm (AKA Peterson's solution) is a concurrent programming algorithm for mutual exclusion that allows two processes to share a single-use resource without conflict, using only shared memory for communication."}}
,{"_index":"throwtable","_type":"algorithm","_id":"logical-clock","_score":0,"_source":{"description":"A logical clock is a mechanism for capturing chronological and causal relationships in a distributed system. Distributed system may have no physically synchronous global clock, so a logical clock allows global ordering on events from different processes in such systems. The first implementation, the Lamport timestamps, was proposed by Leslie Lamport in 1978 (Turing Award in 2013).\nIn logical clock systems each process has two data structures: logical local time and logical global time. Logical local time is used by the process to mark its own events, and logical global time is the local information about global time. A special protocol is used to update logical local time after each local event, and logical global time when processes exchange data.\nLogical clocks are useful in computation analysis, distributed algorithm design, individual event tracking, and exploring computational progress.\nSome noteworthy logical clock algorithms are:\nLamport timestamps, which are monotonically increasing software counters.\nVector clocks, that allow for partial ordering of events in a distributed system.\nVersion vectors, order replicas, according to updates, in an optimistic replicated system.\nMatrix clocks, an extension of vector clocks that also contains information about other processes' views of the system.","alt_names":["logical clock","Uhrenbedingung","...mehr auf Wikipedia über Logische Uhr","...more on Wikipedia about Logical clock","Logical Clock","Logical Clocks","Logical Time and Logical Clocks","Logical clock","Logical clock - Wikipedia, the free encyclopedia","Logical clocks","Logical_clock","Logische Uhr","Logische Uhr - Wikipedia","Logische Uhren","Logische_Uhr","Relógios lógicos","Uhrenbedingung bei der wikipedia","Wikipedia article ''Logical clock''","Wikipedia article Logical clock","Wikipedia article on Logical clocks","Wikipedia entry for Logical clock","Wikipedia-Artikel Logische Uhr","Wikipedia-Artikel Uhrenbedingung","Wikipedia-Seite zu 'Logische Uhr'","Wikipedia-Seite zu 'Uhrenbedingung'","Wikipedia:Logical clock","Wikipédia artigo Relógios lógicos","a http://en.wikipedia.org/wiki/Logical_clocks","de:Logische Uhr","http://de.wikipedia.org/wiki/Logische_Uh","http://de.wikipedia.org/wiki/Logische_Uhr","http://en.wikipedia.org/wiki/Logical_clo","http://en.wikipedia.org/wiki/Logical_clock","http://en.wikipedia.org/wiki/Logical_clocks","logical clock.","logical clocks","logische Uhr","logische Zeit","logischen Uhren","pt:Relógios lógicos","schwache Konsistenz-Kriterium","sr:Логички часовник","yago-res:Logical clock","Логические часы","逻辑锁"],"name":"Logical clock","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Distributed algorithms","Wikipedia articles with GND identifiers"],"tag_line":"A logical clock is a mechanism for capturing chronological and causal relationships in a distributed system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"chudnovsky-algorithm","_score":0,"_source":{"description":"The Chudnovsky algorithm is a fast method for calculating the digits of π. It was published by the Chudnovsky brothers in 1989, and was used in the world record calculations of 2.7 trillion digits of π in December 2009, 5 trillion digits of π in August 2010, 10 trillion digits of π in October 2011, and 12.1 trillion digits in December 2013.\nThe algorithm is based on the negated Heegner number , the j-function , and on the following rapidly convergent generalized hypergeometric series:\n\nNote that 545140134 = 163 x 3344418 and,\n\nThis identity is similar to some of Ramanujan's formulas involving π, and is an example of a Ramanujan–Sato series.","alt_names":["Chudnovsky algorithm","- Chudnovsky algorithm :","1 π = 12 ∑ k = 0 ∞ ( - 1 ) k ( 6","Algorithm of Chudnovsky","Algoritmo Chudnovsky","Algoritmo de Chudnovsky","Chudnovsky Algorithm - Wikipedia, The Free Encyclopedia","Chudnovsky algorithm - Wikipedia :: The free encyclopedia","Chudnovsky algorithm - Wikipedia, the free encyclopedia","Chudnovsky algorithm on wikipedia.org","Chudnovsky algoritmus","Chudnovsky method","Chudnovsky's","Chudnovsky's algorithm","Chudnovsky-Algorithmus","Wikipedia article Chudnovsky algorithm","Wikipedia article Chudnovsky method","Wikipedia entry for Chudnovsky algorithm","[color=#00ff00]算法","algorithme de Chudnovsky","bit more involved way to calculate pi","don't actually understand it","formule de Chudnowski","http://en.wikipedia....ovsky_algorithm","http://en.wikipedia.org/wiki/Chudnovsky_algorithm","http://en.wikipedia.org/wiki/Chudnovsky_algorithm...","http://en.wikipedia.org/wiki/C​hudnovsky_algorithm","http://ru.wikipedia.org/wiki/Алгоритм_Чудновского","l'algorithme de Chudnovsky","own 1989 algorithm","Алгоритм Чудновского","Алгоритма Chudnovsky","алгоритм Чудновского","алгоритму Чудновского","алгоритъма Чудновски","формуле Чудновского","формуле Чудовского","формулу Чудновског","формулу Чудновского","効率的な計算式","楚德诺夫斯基算法","楚德诺夫斯基算法- 维","楚德诺夫斯基算法- 维基百科","楚德诺夫斯基算法- 维基百科，自由的百科全书"],"name":"Chudnovsky algorithm","categories":["All stub articles","Number stubs","Pi algorithms"],"tag_line":"The Chudnovsky algorithm is a fast method for calculating the digits of π."}}
,{"_index":"throwtable","_type":"algorithm","_id":"distributed-minimum-spanning-tree","_score":0,"_source":{"description":"The distributed minimum spanning tree (MST) problem involves the construction of a minimum spanning tree by a distributed algorithm, in a network where nodes communicate by message passing. It is radically different from the classical sequential problem, although the most basic approach resembles Borůvka's algorithm. One important application of this problem is to find a tree that can be used for broadcasting. In particular, if the cost for a message to pass through an edge in a graph is significant, a MST can minimize the total cost for a source process to communicate with all the other processes in the network.\nThe problem was first suggested and solved in  time in 1983 by Gallager et al., where  is the number of vertices in the graph. Later, the solution was improved to  and finally  where D is the network, or graph diameter. A lower bound on the time complexity of the solution has been eventually shown to be","alt_names":["DSMT at Wikipedia","Distributed minimum spanning tree","Distributed minimum spanning tree - Wikipedia, the free encyclopedia","O ( V log * V + D )","Wikipedia article Distributed minimum spanning tree","Wikipedia entry for Distributed minimum spanning tree","distributed minimum spanning tree","http://en.wikipedia.org/wiki/Distributed_minimum_spanning_tree","yago-res:Distributed minimum spanning tree","Разстроено минимално покриващо дърво"],"name":"Distributed minimum spanning tree","categories":["Distributed algorithms","Spanning tree"],"tag_line":"The distributed minimum spanning tree (MST) problem involves the construction of a minimum spanning tree by a distributed algorithm, in a network where nodes communicate by message passing."}}
,{"_index":"throwtable","_type":"algorithm","_id":"distributed-algorithm","_score":0,"_source":{"description":"A distributed algorithm is an algorithm designed to run on computer hardware constructed from interconnected processors. Distributed algorithms are used in many varied application areas of distributed computing, such as telecommunications, scientific computing, distributed information processing, and real-time process control. Standard problems solved by distributed algorithms include leader election, consensus, distributed search, spanning tree generation, mutual exclusion, and resource allocation.\nDistributed algorithms are a sub-type of parallel algorithm, typically executed concurrently, with separate parts of the algorithm being run simultaneously on independent processors, and having limited information about what the other parts of the algorithm are doing. One of the major challenges in developing and implementing distributed algorithms is successfully coordinating the behavior of the independent parts of the algorithm in the face of processor failures and unreliable communications links. The choice of an appropriate distributed algorithm to solve a given problem depends on both the characteristics of the problem, and characteristics of the system the algorithm will run on such as the type and probability of processor or link failures, the kind of inter-process communication that can be performed, and the level of timing synchronization between separate processes.","alt_names":[],"name":"Distributed algorithm","categories":["Distributed algorithms"],"tag_line":"A distributed algorithm is an algorithm designed to run on computer hardware constructed from interconnected processors."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cristian's-algorithm","_score":0,"_source":{"description":"Cristian's Algorithm (introduced by Flaviu Cristian in 1989) is a method for clock synchronization which can be used in many fields of distributive computer science but is primarily used in low-latency intranets. Cristian observed that this simple algorithm is probabilistic, in that it only achieves synchronization if the round-trip time (RTT) of the request is short compared to required accuracy. It also suffers in implementations using a single server, making it unsuitable for many distributive applications where redundancy may be crucial.","alt_names":["Cristian's algorithm","Algorisme de Cristian","Algorithmus von Cristian","Algorithmus von Cristian – Wikipedia","Algorithmus_von_Cristian","Algoritmo de Cristian","Algoritmo de Cristian - Wikipedia, la enciclopedia libre","Christian's algorithm","Cristian's Algorithm","Cristian's algorithm - Wikipedia, the free ...","Cristian's algorithm - Wikipedia, the free encyclopedia","Cristians algorithm","Wikipedia article Algoritmo de Cristian","Wikipedia article Cristian's algorithm","Wikipedia-Artikel Algorithmus von Christian","Wikipedia-Artikel Algorithmus von Cristian","Wikipedia: Cristian's algorithm","[10] Christian's algorithm","artículo de Wikipedia Algoritmo de Cristian","en:Cristian's algorithm","http://de.wikipedia.org/wiki/Algo... n_Cristian","http://de.wikipedia.org/wiki/Algorithmus_von_Cristian","http://en.wikipedia.org/wiki/Cristian%27s_algorithm","http://en.wikipedia.org/wiki/Cristian's_algorithm","http://es.wikipedia.org/wiki/Algoritmo_de_Cristian","http://pt.wikipedia.org/wiki/Algoritmo_de_Cristian"],"name":"Cristian's algorithm","categories":["Distributed algorithms","Synchronization"],"tag_line":"Cristian's Algorithm (introduced by Flaviu Cristian in 1989) is a method for clock synchronization which can be used in many fields of distributive computer science but is primarily used in low-latency intranets."}}
,{"_index":"throwtable","_type":"algorithm","_id":"raymond's-algorithm","_score":0,"_source":{"description":"Raymond's Algorithm is a lock based algorithm for mutual exclusion on a distributed system. It imposes a logical structure (a K-ary tree) on distributed resources. As defined, each node has only a single parent, to which all requests to attain the token are made.","alt_names":["Raymond's algorithm","1.1 Nodal Properties","Raymd's algorithm","Raymond's Algorithm","Raymond's algorithm - Wikipedia, the free encyclopedia","Wikipedia article Raymond's Algorithm","Wikipedia article Raymond's algorithm","http://en.wikipedia.org/wiki/Raymond%27s_algorithm","http://en.wikipedia.org/wiki/Raymond's_a"],"name":"Raymond's algorithm","categories":["Concurrency control algorithms"],"tag_line":"Raymond's Algorithm is a lock based algorithm for mutual exclusion on a distributed system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"local-algorithm","_score":0,"_source":{"description":"A local algorithm is a distributed algorithm that runs in constant time, independently of the size of the network.","alt_names":[],"name":"Local algorithm","categories":["All orphaned articles","All stub articles","Computing stubs","Distributed algorithms","Orphaned articles from September 2013"],"tag_line":"A local algorithm is a distributed algorithm that runs in constant time, independently of the size of the network."}}
,{"_index":"throwtable","_type":"algorithm","_id":"symmetric-key-algorithm","_score":0,"_source":{"description":"Symmetric-key algorithms are algorithms for cryptography that use the same cryptographic keys for both encryption of plaintext and decryption of ciphertext. The keys may be identical or there may be a simple transformation to go between the two keys. The keys, in practice, represent a shared secret between two or more parties that can be used to maintain a private information link. This requirement that both parties have access to the secret key is one of the main drawbacks of symmetric key encryption, in comparison to public-key encryption.\n\n","alt_names":["симметричные","private key encryption","symmetric key encryption","симметричный криптоалгоритм","symmetric key cryptography","symetrická","Crittografia Simmetrica","symmetric key","http://en.wikipedia.org/wiki/Symmetric-key_algorithm","(Private-Key-Kryptographie).","(criptografia de chave privada).","(criptografía de clave privada).","(crittografia a chiave privata).","(cryptographie à clé privée).","(kriptografi kunci pribadi).","(private-phím mật mã).","(qué son claves simétricas)","(частного ключа шифрования).","(ส่วนตัว อ่าน รหัส กุญแจ).","(개인 키 암호화).",") simmetrica","- Shared key :","- Symmetric cipher :","- Symmetric key :","- Symmetric-key algorithm :","-> Read the article about 'Symmetric-key algorithm'","-key algorithm","...Wikipedia Criptografia simétrica","...Wikipedia Criptografía simétrica","...Wikipedia Crittografia simmetrica","...Wikipedia Cryptographie symétrique","...Wikipedia Kryptografia symetryczna","...Wikipedia Symmetrisk kryptering","...mehr auf Wikipedia über Symmetrisches Kryptosystem","...more on Wikipedia about Symmetric-key algorithm","1 Types of symmetric-key algorithms","1. Symmetric-key algorithm - Wikipedia, the free encyclopedia","2 Cryptographic primitives based on symmetric ciphers","2 Symmetric vs. asymmetric algorithms","2.1 Speed of algorithms","2.2 Key management","2.3 Hybrid cryptosystem","3 Construction of symmetric ciphers","3 Cryptographic primitives based on symmetric ciphers","4 Construction of symmetric ciphers","4 Security of symmetric ciphers","5 Key generation","5 November 2009","5 Security of symmetric ciphers","6 Key generation","A criptografía simétrica","ALGORITMO DE CIFRADO SIMÉTRICO","Algorismes de criptografia simètrica","Algoritmo de chave sim?trica - Wikip?dia, a","Algoritmo de chave simétrica","Algoritmo de chave simétrica – Wikipédia, a enciclopédia livre","Algoritmo simétrico clave","Algoritmos de chave simétrica","Algoritmos de cifrado de diseño más reciente como","Algorytm symetryczny – Wikipedia, wolna encyklopedia","Algorytm_symetryczny","Algorytmy symetryczne","Chiffrement Symetrique","Chiffrement Symétrique","Chiffrement_symétrique","Cifratura Simmetrica","Cifratura simmetrica","Clé secrète","Construction of symmetric ciphers","Cours Crypto Symétrique","Criptazione simmetrica","Criptograf?a sim?trica - Wikipedia, la enciclopedia libre","Criptografia Simetrica","Criptografia convencional","Criptografia simètrica","Criptografia simétrica","Criptografia_Simétrica","Criptografía Simétrica","Criptografía simétrica","Criptografía simétrica - Wikipedia","Criptografía simétrica - Wikipedia, la enciclopedia libre","Criptografía simétrica?","Crittografia simmetrica","Crittografia simmetrica (it.wiki)","Crittografia simmetrica - Wikipedia","Crittografia simmetrica Wikipedia","Crittografia_simmetrica","Cryptographic ...","Cryptographic primitives based on symmetric ciphers","Cryptographie sym?trique - Wikip?dia","Cryptographie symétrique","Cryptographie symétrique - Wikipédia","Cимметричные криптосистемы","Diese Verfahren","Dieser Artikel beschränkt sich auf die Darstellung von","HTTP://DE.WIKIPEDIA.ORG/WIKI/SYMMETRISCHES_KRYPTOSYSTEM","Kriptografia simetriko","Kriptografia simetrikoa","Kryptografia symetryczna","Kryptografia_symetryczna","Kryptografie/Symmetrisches Kryptosystem","La crittografia","Private key encryption","Private key scheme","Private-key","Private-key cryptography","Public-Key Crypto","Read More symmetrickey algorithm simple english wikipedia the","Read More symmetrickey algorithm wikipedia the free encyclopedia","Security of symmetric ciphers","Shared_key","Simetrinio rakto kriptografija","Single-key encryption","Symetric-key algorithms - Wikipedia","Symetrická kryptografie","Symetrická kryptografie - Wikipedie","Symetrická šifra","Symmetische Verfahren","Symmetric (secret key) encryption","Symmetric Encryption","Symmetric Key","Symmetric Key Algorithm","Symmetric Key Algorithms","Symmetric Key Cryptography (SKC)","Symmetric Key Encryption","Symmetric algorithm","Symmetric algorithms","Symmetric alogrithms","Symmetric cipher","Symmetric cipher in Wikipedia","Symmetric cipher systems","Symmetric encryption","Symmetric key","Symmetric key algorithm","Symmetric key algorithm - Wikipedia, the free encyclopedia","Symmetric key algorithm Wikipedia the free encyclopedia","Symmetric key algorithm Wikipedia the free encyclopedia - result","Symmetric key algorithm.","Symmetric key algorithms","Symmetric key cryptography","Symmetric key cryptography:","Symmetric key encryption","Symmetric keys","Symmetric vs. asymmetric algorithms","Symmetric-Key Algorithm","Symmetric-Key Encryption","Symmetric-Keys.","Symmetric-key","Symmetric-key algorith","Symmetric-key algorithm","Symmetric-key algorithm - Simple English Wikipedia, the free","Symmetric-key algorithm - Wikipedia :: The free encyclopedia","Symmetric-key algorithm - Wikipedia, the fr","Symmetric-key algorithm - Wikipedia, the free ency...","Symmetric-key algorithm - Wikipedia, the free encyclopedia","Symmetric-key algorithm - Wikipedia, the free encyclopedia ...","Symmetric-key algorithm - Wikipedia, the free encyclopedia Symmetric","Symmetric-key algorithm aka private key algorithm","Symmetric-key algorithm in Wikipedia","Symmetric-key algorithm – Wikipedia, the free encyclopedia","Symmetric-key algorithm.","Symmetric-key algorithms","Symmetric-key encryption","Symmetric-key_algorithm","Symmetric-nøgle","Symmetric/Private Keys","Symmetric_cipher","Symmetric_key","Symmetric_key_algorithm","Symmetric_key_cryptography","Symmetrickey algorithm","Symmetrische Ver- und Entschlüsselung","Symmetrische Verschlüsselung","Symmetrische Verschlüsselungsalgorithmen","Symmetrische cryptografie","Symmetrische_Verschl%C3%BCsselung bei der wikipedia","Symmetrische_Verschlüsselung","Symmetrische_cryptografie","Symmetrischen Verschlüsselungsalgorithmen","Symmetrischer Kryptographie","Symmetrischer Verschlüsselungsalgorithmus","Symmetrischer_Verschl%C3%BCsselungsalgorithmus bei der wikipedia","Symmetrischer_Verschlüsselungsalgorithmus","Symmetrisches Kryptosystem","Symmetrisches Kryptosystem â€“ Wikipedia","Symmetrisches Kryptosystem – Wikipedia","Symmetrisches Kryptosystemen","Symmetrisches Verschlüsselungsverfahren","Symmetrisches Verschlüsselungsverfahren - Wikipedia","Symmetrisches_Kryptosystem","Symmetrisches_Kryptosystem bei der wikipedia","Symmetrisches_Verschl%C3%BCsselungsverfahren bei der wikipedia","Symmetrisk krypto","Symmetriske krypteringsalgoritmer","Szyfr_symetryczny","Thu?t to?n kh?a ??i x?ng","Thuật toán khóa đối","Thuật toán khóa đối xứng","Thuật toán khóa đối xứng – Wikipedia tiếng Việt","Types of symmetric ...","Types of symmetric-key algorithms","View Symmetric-key algorithm on Wikipedia","Wikipedia - Symmetric Key Algorithms","Wikipedia - Symmetrisches Kryptosystem","Wikipedia : 共通鍵暗号","Wikipedia Criptografía simétrica","Wikipedia article Algoritmo de chave simétrica","Wikipedia article Algorytm symetryczny","Wikipedia article Kriptografia simetriko","Wikipedia article Simetria ĉifro","Wikipedia article Symetrická šifra","Wikipedia article Symmetric key algorithm","Wikipedia article Symmetrisches Kryptosystem","Wikipedia article on Cifrado simétrico","Wikipedia article on Criptografía simétrica","Wikipedia article on Symmetric key algorithm","Wikipedia article on Symmetric key cryptography","Wikipedia article on Symmetric-key algorithm","Wikipedia article Симметричные криптосистемы","Wikipedia article Սիմետրիկ բանալիով ալգորիթմներ","Wikipedia article צופן סימטרי","Wikipedia article სიმეტრიული კრიპტოსისტემა","Wikipedia entry for Symmetric-key algorithm","Wikipedia sur Cryptographie à clef secrète","Wikipedia survey of Symmetric key encryption","Wikipedia-Artikel Symmetrische Verschlüsselung","Wikipedia-Artikel Symmetrischer Verschlüsselungsalgorithmus","Wikipedia-Artikel Symmetrisches Kryptosystem","Wikipedia-Artikel Symmetrisches Verschlüsselungsverfahren","Wikipedia-Seite zu 'Symmetrische Verschlüsselung'","Wikipedia-Seite zu 'Symmetrischer Verschlüsselungsalgorithmus'","Wikipedia-Seite zu 'Symmetrisches Kryptosystem'","Wikipedia-Seite zu 'Symmetrisches Verschlüsselungsverfahren'","Wikipedia: Symetrische Verschlüsselung (AES, 3DES, Blowfish)","Wikipedia:Crittografia_simmetrica","Wikipedia:Symmetric key algorithm","Wikipediaで「共通鍵暗号」を調べる","Wikipediaで「対象鍵暗号」を調べる","Wikipediaで「秘密鍵暗号」を調べる","Wikipédia artigo Criptografia Simétrica","Wikipédia artigo Criptografia simétrica","Xifratge simètric","Zifratu simetrikoan","[ Symetrické šifry ]","[/url]Thuật toán khóa đối xứng là những","[5] Secret-key algorithm","[5] Symmetric key cryptography","[Симметричные криптосистемы]","a Symmetric-key algorithm","a chiave simmetrica","a decryptable form","algoritm simetric","algoritmi a chiave simmetrica","algoritmi simmetrici","algoritmo a chiave simmetrica","algoritmo a chiave simmetrica di cifratura","algoritmo de chave simétrica","algoritmo de clave simétrica","algoritmo de criptografía simétrica","algoritmo simmetrico","algoritmo simmetrico-chiave","algoritmo simétrico","algoritmo simétrico de clave","algoritmos de chaves simétricas","algoritmos de cifrado simétrico","algoritmos de clave simétrica","algorytmu klucza symetrycznego","ar:تشفير بالمفتاح المتناظر","artículo de Wikipedia Cifrado simétrico","artículo de Wikipedia Criptografía simétrica","ca:Criptografia simètrica","chave simétrica","chaves simétricas","chiave privata","chiave simmetrica","chiffrement symétrique","chiffrements à clé secrète","cifrado simetrico","cifrado simétric","cifrado simétrico","cifrado simétricos","cifrari simmetrici","cifrari simmetrici;","cifrario simmetrico","cifratura a chiave simmetrica","cifratura simmetrica","clau privada","clau simètrica","clave simétrica","clave simétrica.","claves simétricas","clefs symétriques","clés secrètes","clés symétriques","criptografia de chave simétrica","criptografia de llave simetrica","criptografia simatrica","criptografia simètrica","criptografia simétrica","criptografía clásica","criptografía de clave simétrica","criptografía simétrica","crittografia a chiave privata, chiamata anche crittografia simmetrica","crittografia a chiave simmetrica","crittografia simmetrica","crittografia simmetrica,","cryptage symétrique","crypter*","cryptographie symétriqu","cryptographie symétrique","cryptographie symétrique,","cryptographie symétrique.","cryptographie à clef secrète","cryptographie...","cryptologie symétrique","cryptosystème symétrique","de claves simétricas","de:Symmetrisches_Kryptosystem","el:Κρυπτογράφηση Συμμετρικού Κλειδιού","en.wikipedia.org/...Symmetric_key","en.wikipedia.org/...Symmetric_key_algorithm","en.wikipedia.org/wiki/Symmetric-key_a...","en.wikipedia.org/wiki/Symmetric-key_algorithm","en:Symmetric key algorithm","encriptación simétrica","encriptação simétrica","eo:Simetria ĉifro","fa:الگوریتم کلید متقارن","http ://fr.wikipedia.org/wiki/Cryptographie","http://ca.wikipedia.org/wiki/Xifrat_sim%C3%A8tric","http://ca.wikipedia.org/wiki/Xifratge_de_clau_sim%C3%A8trica","http://cs.wikipedia.org/wiki/Symetrick%C3%A1_kryptografie","http://de.wikipedia.org/wiki/Sy mmetrische_Verschl%C3","http://de.wikipedia.org/wiki/Symmetr...l%C3","http://de.wikipedia.org/wiki/Symmetrische_Ver...","http://de.wikipedia.org/wiki/Symmetrische_Verschl%C3%BCsselun","http://de.wikipedia.org/wiki/Symmetrische_Verschl%C3%BCsselung","http://de.wikipedia.org/wiki/Symmetrische_Verschlüsselung","http://de.wikipedia.org/wiki/Symmetrischer_Verschlüsselungsalgorithmus","http://de.wikipedia.org/wiki/Symmetrisches_Kryptosystem","http://de.wikipedia.org/wiki/Symmetrisches_Kryptosystem#Verfahren","http://de.wikipedia.org/wiki/Symmetrisches_Verschl%C3%BCsselungsverfahren","http://el.wikipedia.org/wiki/Κρυπτογράφηση_Συμμετρικού_Κλειδιού","http://en.wikipedia....c-key_algorithm","http://en.wikipedia.org/wiki/Symmetr...ric_algorithms","http://en.wikipedia.org/wiki/Symmetric-","http://en.wikipedia.org/wiki/Symmetric-k","http://en.wikipedia.org/wiki/Symmetric-key_algorithm#Symmetric_vs","http://en.wikipedia.org/wiki/Symmetric-key_algorithm#Types_of_symmetric","http://en.wikipedia.org/wiki/Symmetric-k…","http://en.wikipedia.org/wiki/Symmetric_cipher","http://en.wikipedia.org/wiki/Symmetric_key","http://en.wikipedia.org/wiki/Symmetric_key_","http://en.wikipedia.org/wiki/Symmetric_key_algorithm","http://en.wikipedia.org/wiki/Symmetric_key_algorithm.","http://en.wikipedia.org/wiki/Symmetric_key_cryptography","http://eo.wikipedia.org/wiki/Simetria_%C4%89ifro","http://es.wikipedia.org/wiki/Cifrad","http://es.wikipedia.org/wiki/Cifrado_simétrico","http://es.wikipedia.org/wiki/Criptograf%C3","http://es.wikipedia.org/wiki/Criptograf%C3%ADa_sim","http://es.wikipedia.org/wiki/Criptograf%C3..._sim","http://fr.wikipedia.org/wiki/Chiff [...] 3%A9trique","http://fr.wikipedia.org/wiki/Chiffremen ... 3%A9trique","http://fr.wikipedia.org/wiki/Cryptograph...3%A9trique","http://fr.wikipedia.org/wiki/Cryptographie_sym%C3%A9trique","http://fr.wikipedia.org/wiki/Cryptographie_symétrique","http://it.wikipedia.org/wiki/Crittografia_simmetrica","http://ja.wikipedia.org/wiki/共通鍵暗号","http://nl.wikipedia.org/wiki/Symmetrische_cryptogr","http://nl.wikipedia.org/wiki/Symmetrische_cryptografie","http://pl.wikipedia.org/wiki/Algory","http://pl.wikipedia.org/wiki/Algorytm_symetryczny","http://pl.wikipedia.org/wiki/Kryptografia_symetryczna","http://pt.wikipedia.org/wiki/Algorit...have_simétrica","http://pt.wikipedia.org/wiki/Algoritmo_de_Chave-sim%C3","http://pt.wikipedia.org/wiki/Algoritmo_de_chave_sim%C3%A9trica","http://pt.wikipedia.org/wiki/Criptografia_sim%C3%A9trica","http://ru.wikipedia.org/wiki/Алгори...етричным_ключом","http://ru.wikipedia.org/wiki/Симметричны...","http://ru.wikipedia.org/wiki/Симметричные_криптосистемы","http://ru.wikipedia.org/wiki/Симметричный_шифр","http://simple.wikipedia.org/wiki/Symmetr…","hy:Symmetric key algorithm","hy:Սիմետրիկ բանալիով ալգորիթմներ","identieke route","ifrado simétrico","imétricas","khóa đối xứng","klucz symetryczny","klucza symetrycznego algorytmu","klucza symetrycznego algorytmu szyfrowania","kluczy symetrycznych","kriptografia simetrikoa","kriptografia simetrikoan","l'article de Wikipédia Chiffrement symétrique","l'article de Wikipédia Cryptographie symétrique","mmetric-key (","mã hóa khóa đối xứng","mètode simètric","mật mã hóa khóa đối xứng","normal encryption","pl:Algorytm symetryczny","private-key cryptographic","private-key cryptography","pt.wikipedia.org/wiki/Criptografia_sim%C3%A9trica","pt:Algoritmo de Chave-simétrica","pt:Algoritmo de chave simétrica","r Verschlüsselungsalgorithmu","riptografía de clave simétrica","rittografia simmetrica,","secret key algorithm","secret key algorithms","shared key","shared keys","si on ne possède pas la clef","simetria ĉifro","simetrinio rakto kriptografijoje","simetrinės kriptografijos","simetriskās kriptosistēmās","simple:Symmetric-key algorithm","sistemas de cifrado","sistemas de cifrado simétricos","sistemas de cifrado simétricos.","sk:Symetrická šifra","symetric encryption","symetric key algorithm","symetrical algorithms","symetrická kryptografie","symetrická šifra","symetrické kryptografii","symetrické šifry","symetrický klíč algoritmu","symetrický klíč-algoritmus","symetrische","symetrische Verschlüsselung","symetryczne (szybsze)","symetrycznego szyfrowania","symetrycznej","symetryczny algorytm szyfrowania","symmetric (shared secret)","symmetric (single key)","symmetric algorithm","symmetric algorithms","symmetric cipher","symmetric ciphers","symmetric cryptographic cipher","symmetric cryptography","symmetric cryptosystem","symmetric cryptosystems","symmetric cypher","symmetric encryption","symmetric encryption algorithm","symmetric encryption key","symmetric encryption scheme","symmetric key algorithm","symmetric key algorithms","symmetric key algorithms (","symmetric key cryptosystems","symmetric key pair","symmetric keys","symmetric session key","symmetric system","symmetric(对称的) key algorithms","symmetric(对称的)-key algorithm","symmetric-","symmetric-key","symmetric-key algorithm","symmetric-key algorithm - Wikipedia, the free encyclopedia","symmetric-key algorithms","symmetric-key cipher","symmetric-key ciphers","symmetric-key cryptography","symmetric-key cryptosystems","symmetric-key encryption","symmetric-key encryption algorithm","symmetric-key encryption system","symmetric-key system","symmetric-key systems","symmetrical algorithm","symmetrically decrypts","symmetrisch algoritme","symmetrisch versleutelingsalgoritme","symmetrische VerschlÃ¼sselung","symmetrische Verschlüsseln","symmetrische Verschlüsselung","symmetrische Verschlüsselungsalgorithmen","symmetrische cryptografie","symmetrische cryptografieën","symmetrische encryptie","symmetrische encryptie-algoritme","symmetrische encryptie-algoritmen","symmetrische encryptiealgoritmes","symmetrische sleutel","symmetrische sleutel algoritme","symmetrischem Schlüssel","symmetrischen Algorithmus","symmetrischen Kryptographie","symmetrischen Kryptosystem","symmetrischen Kryptosysteme","symmetrischen Kryptosystemen","symmetrischen Kryptosystems","symmetrischen Schlüssel","symmetrischen Schlüssel-Algorithmus","symmetrischen Schlüsseln","symmetrischen Verschlüsselung","symmetrischen Verschlüsselungen","symmetrischen Verschlüsselungsalgorithmus","symmetrischen Verschlüsselungsverfahren","symmetrischer Algorithmen","symmetrischer Kryptografie","symmetrischer Kryptosysteme","symmetrischer Schlüssel-Algorithmus","symmetrischer Sitzungsschlüssel","symmetrischer Verschlüsselung","symmetrischer Verschlüsselungsalgorithmus","symmetrischer Verschlüsselungsverfahren","symmetrisches Kryptosystem","symmetrisches Kryptosystem,","symmetrisches Verschlüsselungsverfahren","symmetrisk kryptering","symmetrisk kryptering algoritme","symmetrisk krypteringsalgoritm","symmetrisk nøgle algoritme","symmetrisk nøgle kryptering algoritme","symmetriskt","synchronous cryptography","szyfr symetryczny","szyfrów symetrycznych","technologie symetrickych klicu","that no one sees the contents of your","this article on symmetric-key cryptography","thuật toán khóa đối xứng","two-way encryption","type of symmetric algorithm","uk:Шифрування з симетричними ключами","usikker krypteringsalgoritme","very informative page","well-respected symmetric algorithm","wiki: Symetrická kryptografie (EN)","wikipedia - Symmetric key algorithm","wikipedia: Symmetric-key_algorithm","wikipedia:Symmetric-key algorithm","ymmetric-key (s","ð symmetric-key encryption","Συμμετρικό κρυπτοσύστημα","κρυπτοσύστημα","συμμετρικο","συμμετρικού","Алгоритм с симметричным ключом","Википедии статью Симметричное шифрование","Википедии статью Симметричные криптосистемы","Симетрични криптографски алгоритми. Преидимства, недостатъци, приложение.","Симетричні алгоритми шифрування","Симетричні алгоритми шифрування — Вікіпедія","Симметричное шифрование","Симметричные криптоалгоритмы","Симметричные криптосистемы","Симметричные криптосистемы — Википедия","Симметричные шифры","Симметричные_криптосистемы","Там только подтверждение моих слов","Шифрование с симметричным (скрытым) ключом","Шифрування з симетричними ключами","индивидуальным ключом","криптографии с симметричным ключом","симетрични криптиращи алгоритми","симметрично зашифрованными","симметричного","симметричного шифра","симметричного шифрования","симметричное","симметричное шифрование","симметричной криптосистеме","симметричный алгоритм","симметричный ключ","симметричный ключ алгоритм","симметричный ключ алгоритма","симметричный шифр","симметричным ключом алгоритмом шифрования","симметричным шифрованием","симметричным шифром","симметричными шифрами","симметричных алгоритмов","симметричных алгоритмов шифрования","симметричных криптосистем","הצפנה סימטרי","ויקיפדיה - 'צופן סימטרי'","מפתח סימטרי","צופן סימטרי","צופן סימטרי – ויקיפדיה","الگوریتم کلید متقارن - ویکیپدیا","تشفير بالمفتاح المتناظر","सममित कुंजी एन्क्रिप्शन एल्गोरिथ्म","სიმეტრიული გაშიფრვის","სიმეტრიული კრიპტოსისტემა","სიმეტრიული კრიპტოსისტემა - ვიკიპედია","「共通鍵暗号」をWikipediaで調べる","「秘密鍵暗号」についてWikipediaで調査","「秘密鍵暗号」をWikiで調べる","『共通鍵暗号』の解説","ウィキペディアの記事 共通鍵暗号","一个对称密钥","共有鍵","共通<b>鍵暗号</b> - Wikipedia","共通鍵暗号","共通鍵暗号 - Wikipedia","共通鍵暗号 -- Wikipedia","共通鍵暗号 – Wikipedia","共通鍵暗号-wikipedia","共通鍵暗号方式","共通鍵暗号方式 - Wikipedia","对称加密法","对称加密算法","对称密钥","对称密钥加密算法","对称密钥算法","对称算法","対称キー","対称鍵暗号化アルゴリズムを","対象鍵暗号","対象鍵暗号 - Wikipedia","效率高上数百到数千倍","私鑰加密","私钥加密","秘密鍵暗号","秘密鍵暗号 - Wikipedia","대칭키 암호 시스템(Symmetric Cryptosystem)"],"name":"Symmetric-key algorithm","categories":["All articles needing additional references","All articles with unsourced statements","Articles needing additional references from April 2012","Articles needing additional references from December 2015","Articles with unsourced statements from April 2012","Cryptographic algorithms","Wikipedia articles with GND identifiers"],"tag_line":"Symmetric-key algorithms are algorithms for cryptography that use the same cryptographic keys for both encryption of plaintext and decryption of ciphertext."}}
,{"_index":"throwtable","_type":"algorithm","_id":"randomness-extractor","_score":0,"_source":{"description":"A randomness extractor, often simply called an \"extractor\", is a function, which being applied to output from a weakly random entropy source, together with a short, uniformly random seed, generates a highly random output that appears independent from the source and uniformly distributed. Examples of weakly random sources include radioactive decay or thermal noise; the only restriction on possible sources is that there is no way they can be fully controlled, calculated or predicted, and that a lower bound on their entropy rate can be established. For a given source, a randomness extractor can even be considered to be a true random number generator (TRNG); but there is no single extractor that has been proven to produce truly random output from any type of weakly random source.\nSometimes the term \"bias\" is used to denote a weakly random source's departure from uniformity, and in older literature, some extractors are called unbiasing algorithms, as they take the randomness from a so-called \"biased\" source and output a distribution that appears unbiased. The weakly random source will always be longer than the extractor's output, but an efficient extractor is one that lowers this ratio of lengths as much as possible, while simultaneously keeping the seed length low. Intuitively, this means that as much randomness as possible has been \"extracted\" from the source.\nNote that an extractor has some conceptual similarities with a pseudorandom generator (PRG), but the two concepts are not identical. Both are functions that take as input a small, uniformly random seed and produce a longer output that \"looks\" uniformly random. Some pseudorandom generators are, in fact, also extractors. (When a PRG is based on the existence of hard-core predicates, one can think of the weakly random source as a set of truth tables of such predicates and prove that the output is statistically close to uniform.) However, the general PRG definition does not specify that a weakly random source must be used, and while in the case of an extractor, the output should be statistically close to uniform, in a PRG it is only required to be computationally indistinguishable from uniform, a somewhat weaker concept.\nNIST Special Publication 800-90B (draft) recommends several extractors, including the SHA hash family and states that if the amount of entropy input is twice the number of bits output from them, that output can be considered essentially fully random.","alt_names":["- Randomness extractor :","- Von Neumann extractor :","84e1e62c87892ca1acd7c8f36314c ...","A randomness extractor is an algorithm that converts","How to apply for Randomness extractor","Randomness Extractor","Randomness extractor","Randomness extractor - Wikipedia, the free encyclopedia","Randomness extractor Wikipedia the free encyclopedia","Randomness extractor Wikipedia the free encyclopedia - result","Randomness extractor; it is used under the","Randomness extractors","Read More randomness extractor wikipedia the free encyclopedia","Von Neumann extractor","What are applications of Randomness extractor","Wikipedia article Randomness extractor","Wikipedia article Von Neumann extractor","Wikipedia article on Randomness extractor","Wikipedia entry for Randomness extractor","Wikipedia link: Randomness extractor","en.wikipedia.org/wiki/Randomness_extractor","http://en.Liarpedia.org/wiki/Randomness_extractor","http://en.wikipedia.org/wiki/Randomness_extractor","http://en.wikipedia.org/wiki/Randomness_extractor#Von_Neuman...","http://en.wikipedia.org/wiki/Randomness_extractor#Von_Neumann_extractor","http://en.wikipedia.org/wiki/Von_Neumann_extractor","min Wikipediaside om emnet kommer først op om","randomness extractor","relevant topic","such algorithms are non-trivial","von Neuman's extractor","von Neumann Extractor","von Neumann extractor","“Randomness extractor - Wikipedia, the free encyclopedia”, en.wikipedia"],"name":"Randomness extractor","categories":["Computational complexity theory","Cryptographic algorithms","Random number generation","Randomness"],"tag_line":"A randomness extractor, often simply called an \"extractor\", is a function, which being applied to output from a weakly random entropy source, together with a short, uniformly random seed, generates a highly random output that appears independent from the source and uniformly distributed."}}
,{"_index":"throwtable","_type":"algorithm","_id":"vector-clock","_score":0,"_source":{"description":"Vector clocks is an algorithm for generating a partial ordering of events in a distributed system and detecting causality violations. Just as in Lamport timestamps, interprocess messages contain the state of the sending process's logical clock. A vector clock of a system of N processes is an array/vector of N logical clocks, one clock per process; a local \"smallest possible values\" copy of the global clock-array is kept in each process, with the following rules for clock updates:\n\nInitially all clocks are zero.\nEach time a process experiences an internal event, it increments its own logical clock in the vector by one.\nEach time a process prepares to send a message, it sends its entire vector along with the message being sent.\nEach time a process receives a message, it increments its own logical clock in the vector by one and updates each element in its vector by taking the maximum of the value in its own vector clock and the value in the vector in the received message (for every element).\nThe vector clocks algorithm was independently developed by Colin Fidge and Friedemann Mattern in 1988.","alt_names":["Vektoruhr","- Vector clocks :","...mehr auf Wikipedia über Vektoruhr","Description of a Vector Clock","Horloge vectorielle - Wikip?dia","Horloge vectorielle - Wikipédia","Read more on Vector Clocks","Relógios vetoriais","State Vectors","State vectors","Vector Clock","Vector Clocks","Vector Clocks on Wikipedia","Vector clock","Vector clock - Wikipedia, the free encycloped","Vector clock - Wikipedia, the free encycloped...","Vector clock - Wikipedia, the free encyclopedia","Vector clock Wikipedia the free encyclopedia","Vector clock from Wikipedia","Vector clocks","Vector clocks - Wikipedia, the free encyclopedia","Vector_clock","Vektoruhr – Wikipedia","Vektoruhren","Vektoruhren wurden von","Wikipedia article Vector clock","Wikipedia article on Vector clock","Wikipedia article on Vector clocks","Wikipedia entry for Vector clock","Wikipedia-Artikel Vektoruhr","Wikipedia-Seite zu 'Vektoruhr'","Wikipédia artigo Relógios vetoriais","[3] Vector timestamps","de.wikipedia.org/wiki/Vektoruhr","en.wikipedia.org/wiki/vector_clock","en:Vector clocks","en:Vector_clock","http://de.wikipedia.org/wiki/Vektoruhr","http://en.wikipedia....ki/Vector_clock","http://en.wikipedia.org/wiki/Vector_cloc","http://en.wikipedia.org/wiki/Vector_clock","http://en.wikipedia.org/wiki/Vector_clocks","http://en.wikipedia.org/wiki/vector_clock","http://fr.wikipedia.org/wiki/Horloge_vectorielle","logical vector clock","ordering/causality","partial message ordering","pt:Relógios vetoriais","ru:Векторные часы","time in a distributed system","vector clock","vector clocks","vector clock算法","vector timestamp","vector trails","vector-clock","wikipedia: Vector clock","Векторные часы","вектор часы","☞ vector clocks","벡터 클럭"],"name":"Vector clock","categories":["Distributed algorithms"],"tag_line":"Vector clocks is an algorithm for generating a partial ordering of events in a distributed system and detecting causality violations."}}
,{"_index":"throwtable","_type":"algorithm","_id":"suzuki-kasami-algorithm","_score":0,"_source":{"description":"The Suzuki-Kasami algorithm is a token-based algorithm for achieving mutual exclusion in distributed systems. The process holding the token is the only process able to enter its critical section.\nThis is a modification to Ricart–Agrawala algorithm in which a REQUEST and REPLY message are used for attaining the critical section. but in this algorithm they introduced a method in which a seniority vise and also by handing over the critical section to other node by sending a single PRIVILEGE message to other node. So, the node which has the privilege it can use the critical section and if it does not have one it cannot. If a process wants to enter its critical section and it does not have the token, it broadcasts a request message to all other processes in the system. The process that has the token, if it is not currently in a critical section, will then send the token to the requesting process. The algorithm makes use of increasing Request Numbers to allow messages to arrive out-of-order.","alt_names":["Suzuki-Kasami algorithm","Suzuki-Kasami algorithm - Wikipedia, the free encyclopedia","Wikipedia entry for Suzuki-Kasami algorithm","http://en.Liarpedia.org/wiki/Suzuki-Kasami_algorithm","http://en.wikipedia.org/wiki/Suzuki-Kasami_algorithm"],"name":"Suzuki-Kasami algorithm","categories":["All articles needing additional references","All articles needing cleanup","All articles needing expert attention","All articles with topics of unclear notability","Articles needing additional references from September 2014","Articles needing cleanup from May 2009","Articles needing expert attention from May 2009","Articles needing expert attention with no reason or talk parameter","Articles with topics of unclear notability from May 2009","Cleanup tagged articles without a reason field from May 2009","Computer science articles needing expert attention","Distributed algorithms","Wikipedia pages needing cleanup from May 2009"],"tag_line":"The Suzuki-Kasami algorithm is a token-based algorithm for achieving mutual exclusion in distributed systems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"discrete-logarithm-records","_score":0,"_source":{"description":"Discrete logarithm records are the best results achieved to date in solving the discrete logarithm problem, which is the problem of finding solutions x to the equation gx = h given elements g and h of a finite cyclic group G. The difficulty of this problem is the basis for the security of several cryptographic systems, including Diffie–Hellman key agreement, ElGamal encryption, the ElGamal signature scheme, the Digital Signature Algorithm, and the elliptic curve cryptography analogs of these. Common choices for G used in these algorithms include the multiplicative group of integers modulo p, the multiplicative group of a finite field, and the group of points on an elliptic curve over a finite field.","alt_names":["Discrete logarithm records","Discrete logarithm records - Wikipedia, the free encyclopedia","Discrete logarithm records Wikipedia the free encyclopedia","Discrete logarithm records#Elliptic curves","discrete logarithm records","http://en.wikipedia.org/wiki/Discrete_logarithm_records"],"name":"Discrete logarithm records","categories":["All articles containing potentially dated statements","Articles containing potentially dated statements from 2010","Articles containing potentially dated statements from 2014","Articles containing potentially dated statements from January 2014","Asymmetric-key algorithms","Computational hardness assumptions","Logarithms","Modular arithmetic","World records"],"tag_line":"Discrete logarithm records are the best results achieved to date in solving the discrete logarithm problem, which is the problem of finding solutions x to the equation gx = h given elements g and h of a finite cyclic group G. The difficulty of this problem is the basis for the security of several cryptographic systems, including Diffie–Hellman key agreement, ElGamal encryption, the ElGamal signature scheme, the Digital Signature Algorithm, and the elliptic curve cryptography analogs of these."}}
,{"_index":"throwtable","_type":"algorithm","_id":"mosquito","_score":0,"_source":{"description":"In cryptography, MOSQUITO was a stream cypher algorithm designed by Joan Daemen and Paris Kitsos. It was submitted to the eSTREAM Project of the eCRYPT network. After the initial design was broken by Joux and Muller, a tweaked version named MOUSTIQUE was proposed which made it to Phase 3 of the eSTREAM evaluation process as the only self-synchronizing cipher remaining. However, MOUSTIQUE was subsequently broken by Käsper et al., leaving the design of a secure and efficient self-synchronising stream cipher as an open research problem.","alt_names":["Learn about MOSQUITO>>>","MOSQUITO","MOSQUITO - Wikipedia, the free encyclopedia","Wikipedia article MOSQUITO","Wikipedia article on MOSQUITO","Wikipedia英語版 - MOSQUITO","http://en.wikipedia.org/wiki/MOSQUITO"],"name":"MOSQUITO","categories":["All articles to be expanded","All stub articles","Articles needing translation from Russian Wikipedia","Articles to be expanded from August 2013","Cryptographic algorithms","Cryptography stubs"],"tag_line":"In cryptography, MOSQUITO was a stream cypher algorithm designed by Joan Daemen and Paris Kitsos."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cycles-per-byte","_score":0,"_source":{"description":"Cycles per byte (sometimes abbreviated cpb) is a unit of measurement which indicates the number of clock cycles a microprocessor will perform per byte (usually of octet size) of data processed in an algorithm. It is commonly used as a partial indicator of real-world performance in cryptographic functions.","alt_names":["cpb","- Cycles per byte :","Cycles per byte","Cycles per byte - Wikipedia, the free encyclopedia","Cycles per byte - Wikipedia, the free encyclopedia ...","Wikipedia article Cycles per byte","Wikipedia article on Cycles per byte","Wikipedia entry for Cycles per byte","cycles per byte","cycles/byte","http://en.wikipedia.org/wiki/Cycles_per_byte","yago-res:Cycles per byte"],"name":"Cycles per byte","categories":["All stub articles","Computer benchmarks","Cryptographic algorithms","Cryptography stubs"],"tag_line":"Cycles per byte (sometimes abbreviated cpb) is a unit of measurement which indicates the number of clock cycles a microprocessor will perform per byte (usually of octet size) of data processed in an algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"schoof–elkies–atkin-algorithm","_score":0,"_source":{"description":"The Schoof–Elkies–Atkin algorithm (SEA) is an algorithm used for finding the order of or calculating the number of points on an elliptic curve over a finite field. Its primary application is in elliptic curve cryptography. The algorithm is an extension of Schoof's algorithm by Noam Elkies and A. O. L. Atkin to significantly improve its efficiency (under heuristic assumptions).\n\n","alt_names":[],"name":"Schoof–Elkies–Atkin algorithm","categories":["Asymmetric-key algorithms","Elliptic curve cryptography","Finite fields","Group theory","Number theory"],"tag_line":"The Schoof–Elkies–Atkin algorithm (SEA) is an algorithm used for finding the order of or calculating the number of points on an elliptic curve over a finite field."}}
,{"_index":"throwtable","_type":"algorithm","_id":"wired-equivalent-privacy","_score":0,"_source":{"description":"Wired Equivalent Privacy (WEP) is a security algorithm for IEEE 802.11 wireless networks. Introduced as part of the original 802.11 standard ratified in 1997, its intention was to provide data confidentiality comparable to that of a traditional wired network. WEP, recognizable by the key of 10 or 26 hexadecimal digits, was at one time widely in use and was often the first security choice presented to users by router configuration tools.\nIn 2003 the Wi-Fi Alliance announced that WEP had been superseded by Wi-Fi Protected Access (WPA). In 2004, with the ratification of the full 802.11i standard (i.e. WPA2), the IEEE declared that both WEP-40 and WEP-104 have been deprecated.","alt_names":["(Wired Equivalent Privacy)","http://ja.wikipedia.org/wiki/Wired_Equivalent_Privacy","Wired Equivalent Privacy","WEP","Wep","encriptación WEP","Wikipedia on WEP","Wikipedia article on WEP","wep","WEP encryption","WEP-Verschlüsselung","http://ja.wikipedia.org/wiki/WEP","Wired Equivalent Privacy - Wikipedia, the free encyclopedia","WEP (Wired Equivalent Privacy)","WEP key","http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy","(WEP)","(Wired Equivalent Privacy) 7)",", Wired Equivalent Privacy - WEP","- WEP-on-wikipedia","-> Read more about Wired Equivalent Privacy","...Wikipedia Wired Equivalent Privacy","...Wikipedia Wired equivalent privacy","...mehr auf Wikipedia über Wired Equivalent Privacy","...more on Wikipedia about Wired Equivalent Privacy","//WEP//","//en.wikipedia.org/wiki/Wired Equivalent Privacy","//en.wikipedia.org/wiki/Wired_Equivalent_Privacy","128 Bit WEP Verschlüsselung","128 bit WEP","128 bit WEP encryption","128-bit WEP","128-bit Wep","128bit WEP Encryption","2001年以降、暗号解読者らによって深刻な弱点がいくつか明らかとなり、最終的には普通に手に入るソフトウェアを使って数分でWEPコネクションを解読可能となっている","40-bit WEP passphrase","40k-80k packets en welgeteld 3 seconden rekenwerk","64 (40 bit )","64/128/256 бит","802.11 WEP",": - WEP-on-wikipedia - :",": Wired Equivalent Privacy","A 128-bit WEP key is almost always","A flaw in WEP","AXLinux","Articolo originale su WEP","Begriff WEP","Chiave WEP di rete wireless","Cifrado WEP","Clave WEP","Clef WEP","Click Here for the definition of WEP in","Click for wikipedia article","Common alternatives","Concernant le wep","Cryptage WEP","Da chave WEP da rede sem fio","De clave WEP da rede sen fíos","Defectos","Definición de WEP","Definición de Wired Equivalent Privacy más completo","Depuis juillet 2006, il est possible de pénétrer","Download Wi-Fi WEP Key Generator 2.2 Free","Dynamic WEP","Dynamic WEP (802.1x)","El protocolo de encriptación WEP","El protocolo de encriptación Wep","Encryption details","Engelstalige wikipedia over WEP (Wired Equivalent Privacy)","Eochair WEP líonra gan sreang","Erläuterungen WEP","External Site: Wired Equivalent Privacy","Fuck you for not supporting WPA.","How To Configure a Wireless LAN with WEP","How to find your lost WEP or WPA","In 2003 the Wi-Fi Alliance announced that","It is cryptographically very weak","Jaringan nirkabel kunci WEP","Kabelansluten Equivalent Privacy","Kabloya Eşdeğer Mahremiyet","Ključ WEP brezžično omrežje","Klucz WEP sieci bezprzewodowej","Klucza WEP sieci bezprzewodowych","Kunci WEP jaringan nirkabel","L'article de Wikipedia sur les clés WEP","La clé WEP du réseau sans fil","Le WEP","Le WEP a donc été supplanté par le","Le Wired Equivalent Privacy (abrégé WEP) est un","Le cryptage WEP sur Wikipedia","Learn More - Wikipedia – WEP Key","Learn about Wired Equivalent Privacy>>>","Meer info WEP","MÅ","NOT to be secure","Nerdy link here...","Netze mit WEP Verschlüsselung","Nintendo - Customer Service | Nintendo Wi-Fi Connection - WEP","Open-System-Authentifizierung","PRNG Stream Wipe","Presentado en 1999, el sistema WEP fue pensado","Protocole WEP","Protocolo WEP (PT)","See More WEP on Wikipedia","Significado WEP","Since 2001, several serious weaknesses in the protocol","Sistem keamanan WEP (Wired Equivalent Privacy)","Speciaal voor de TS","Teil WEP 64 Bit","The Codex of Collective Wisdom","The flaws section is interesting","Today a WEP connection can be cracked with","Un poco más sobre el cifrado wireless","Verschlüsselung WEP","Vikipedi'deki WEP","W.E.P.","WEB Standard","WEP (64 or 128 bit)","WEP (Wikipedia)","WEP (Wired Equivalency Protocol)","WEP (Wired Equivalent Privacy","WEP (Wired Equivalent Privacy) 128Bit","WEP (Wired Equivalent Privacy) key","WEP (Wired Equivalent Privacy),","WEP (Wired Equivalent Privacy).","WEP (Wireless Equivalency Protocol)","WEP (not good anyways)","WEP - Vikipedi","WEP - Wikip","WEP - Wikipédia","WEP - Wired Equivalent Privacy","WEP - Wired Equivalent Privacy:","WEP - Википедија","WEP - 維基百科，自由的百科全書","WEP - 维基百科，自由的百科全书","WEP -- Wikipedia EN","WEP 128","WEP 128 bit, WEP 64 bit","WEP 64","WEP 64 bits, WEP 128 bit","WEP 64/128/152-bit","WEP :","WEP : Wired Equivalent Privacy","WEP <","WEP = Wired Equivalent Privacy","WEP = Wired Equivalent Privacy.","WEP ?","WEP ? Wikip?dia, a enciclop?dia livre","WEP Defined","WEP English","WEP Key","WEP Security","WEP Verschlüsselung","WEP Verschlüsselungsalgorithmus","WEP Wikipedia","WEP Wikipedia Entry","WEP a 40 o 108 bit, ma debolezze","WEP anahtarı kablosuz ağ","WEP baziranih bežičnih mreža.","WEP bezvadu tīkls","WEP bits","WEP can be easily cracked","WEP cheie de reţea fără fir","WEP chiave di rete wireless","WEP code","WEP defined","WEP des réseaux sans fil clés","WEP encrypted networks","WEP encryption algorithm","WEP encryption key recovery","WEP encryption protocol","WEP encryption standard","WEP encryption system","WEP enkripcija","WEP ewlenin ta 'netwerk wireless","WEP for wireless security","WEP here","WEP info","WEP is a dead security protocol","WEP is better than nothing. Change the default","WEP is fairly weak","WEP key bits","WEP key mạng không dây","WEP key traadita võrgu","WEP key wireless network","WEP key wireless networking","WEP keys","WEP klabea","WEP ključ bežične mreže","WEP ključ bežično umrežavanje","WEP ključ brezžičnega omrežja","WEP klíč bezdrátové sítě","WEP klíče","WEP klíče bezdrátové sítě","WEP kyçe e rrjetit pa tel","WEP kľúč bezdrôtovej siete","WEP kľúče bezdrôtovej siete","WEP l","WEP lykill þráðlaust net","WEP líonraithe eochair gan sreang","WEP mode","WEP muhimu wireless mitandao","WEP muhimu wireless mtandao","WEP na wikipedii","WEP nøkkel trådløst nettverk","WEP nøkkelen trådløst nettverk","WEP on wiki","WEP password","WEP passwords","WEP plus","WEP protocol","WEP raktą bevielio tinklo","WEP rede sem fio-chave","WEP rhwydwaith di-wifr allweddol","WEP rhwydweithio allweddol di-wifr","WEP s","WEP security","WEP segun la wikipedia","WEP significa Wired Equivalent Privacy","WEP significa Wired Equivalent Privacy, e foi introduzido","WEP silahkan langsung ke paman wiki","WEP silahkan langsung ke paman wiki,..","WEP sleutel draadlose netwerk","WEP spec","WEP sur Wikipedia","WEP utama rangkaian wayarles","WEP wi-fi","WEP wifi key","WEP wiki","WEP wireless networking ewlenin","WEP y","WEP взломать легко за пару минут","WEP защита","WEP клуч безжична мрежа","WEP клуч безжично вмрежување","WEP ключ бездротової мережі","WEP ключ безжична мрежа","WEP ключ бесправадной сеткі","WEP ключ беспроводной сети","WEP לרשתות אלחוטיות מפתח","WEP مفتاح الشبكة اللاسلكية","WEP کلید شبکه بی سیم","WEP कुंजी वायरलेस नेटवर्क","WEP कुंजी वायरलेस नेटवर्किंग","WEP เครือข่ายไร้สายที่สำคัญ","WEP – Wikipédia, a enciclopédia livre","WEP — Википедия","WEP 키 무선 네트워크","WEP'a","WEP)","WEP,","WEP, WPA or WPA2,","WEP, or Wirless Equivalent Privacy","WEP, t","WEP-","WEP-Algorithmus","WEP-Schlüssel","WEP-Schlüssel Wireless-Netzwerk","WEP-Schlüssel für drahtlose Netzwerke","WEP-Standard","WEP-Standards","WEP-Verfahren","WEP-Verschlüsselungen","WEP-avain langattoman verkon","WEP-beveiliging","WEP-encryptie","WEP-key","WEP-kryptering","WEP-kulcs vezeték nélküli hálózat","WEP-kulcs vezeték nélküli hálózati","WEP-nyckel trådlöst nätverk","WEP-nøgle trådløst netværk","WEP-protokollen","WEP-protokollen (Wired Equivalent Privacy)","WEP-salauksen","WEP-sleutel draadloos netwerk","WEP-sleutel voor draadloos netwerken","WEP-verschlüsselten","WEP-võti traadita võrgu","WEP-wikipedia","WEP...","WEP64 encryption","WEP:","WEP?","WEPs","WEPã‚ãƒ¼","WEP—Wired Equivalent Privacy","WEPの","WEPは","WEPは、","WEPを","WEPキーのワイヤレスネットワーキング","WEPキーワイヤレスネットワーク","WEP加密","WEP协议","WEP協議","WEP密鑰的無線網絡","WEP密钥的无线网络","WEP形式","WEP暗号化","WEP的","WEP는","WEP는 키 무선 네트워킹","WEP를","WEP를의","WEP，","WP: WEP","WPA is obsolete and has been. Use WPA2","WPE (Wired Equivalent Privacy)","Wep encryption","Wep to encrypt my wireless network","Wep(Wired Equivalent Privacy)","Wep, Wired Equivalent Privacy","What is WEP?","WiKi - WEP - Wired Equivalent Privacy","Wifi με κρυπτογράφηση WEP","Wiki om WEP","Wikipedia - WEP","Wikipedia France (WEP)","Wikipedia Wired Equivalent Privacy","Wikipedia about WEP","Wikipedia article WEP2","Wikipedia article Wired Equivalent Privacy","Wikipedia article on Wired Equivalent Privacy","Wikipedia artikel WEP","Wikipedia artikel Wep","Wikipedia entry for Wired Equivalent Privacy","Wikipedia es una buena fuente.","Wikipedia l'articolo Wired Equivalent Privacy","Wikipedia on Wired Equivalent Privacy","Wikipedia's WEP page","Wikipedia-Artikel Wired Equivalent Privacy","Wikipedia-Seite zu 'Wired Equivalent Privacy'","Wikipedia: WEP","Wikipedia: Wired Equivalent Privacy","Wikipedia: Wired Equivalent Privacy (eng)","Wikipedia: Wired Equivalent Privacy - Wikipedia, the free encyclopedia","Wikipedia:Wired Equivalent Privacy","Wikipedia:Wired_Equivalent_Privacy","Wikipediaで「WEP」を調べる","Wikipediaで「Wired Equivalent Privacy」を調べる","Wikipediaフランス語版 - wep","Wikipedia中国語版 - wep","Wikipedia日本語版 - WEP","Wikipedia日本語版 - wep","Wikipedia（WEP）","Wikipédia artigo WEP","Wikipédia artigo Wep","Wired Equivalency Privacy","Wired Equivalency Privacy (WEP)","Wired Equivalency Protocol","Wired Equivalency Protocol (WEP)","Wired Equivalent","Wired Equivalent Privacy ( WEP )","Wired Equivalent Privacy (WEP) is a security algorithm","Wired Equivalent Privacy (Wep)","Wired Equivalent Privacy (wikipedia)","Wired Equivalent Privacy - Simple English Wikipedia, The Free","Wired Equivalent Privacy - Simple English Wikipedia, the free","Wired Equivalent Privacy - Viquipèdia","Wired Equivalent Privacy - W...","Wired Equivalent Privacy - WEP","Wired Equivalent Privacy - WEP @ Wikipedia","Wired Equivalent Privacy - Wikip?dia","Wired Equivalent Privacy - Wikipedia","Wired Equivalent Privacy - Wikipedia :: The free encyclopedia","Wired Equivalent Privacy - Wikipedia, The Free Encyclopedia","Wired Equivalent Privacy - Wikipedia, la enciclopedia libre","Wired Equivalent Privacy - Wikipedia, the free ...","Wired Equivalent Privacy - Wikipedia, the free encyclopedia ...","Wired Equivalent Privacy - Wikipedie","Wired Equivalent Privacy - Wikipédia","Wired Equivalent Privacy ? Wikipedia","Wired Equivalent Privacy @ Wikipedia","Wired Equivalent Privacy WEP","Wired Equivalent Privacy Wikipedia","Wired Equivalent Privacy Wikipedia The Free Encyclopedia","Wired Equivalent Privacy Wikipedia la enciclopedia libre","Wired Equivalent Privacy Wikipedia the free encyclopedia","Wired Equivalent Privacy Wikipedia the free encyclopedia - result","Wired Equivalent Privacy from Wikipedia","Wired Equivalent Privacy or WEP.","Wired Equivalent Privacy or Wireless Encryption Protocol","Wired Equivalent Privacy | Ask.com Encyclopedia","Wired Equivalent Privacy â�“ Wikipedia, wolna encyklopedia","Wired Equivalent Privacy – Wikipedia","Wired Equivalent Privacy – Wikipedia, wolna encyklopedia","Wired Equivalent Privacy)","Wired Equivalent Privacy, WEP","Wired Equivalent Privacy; it is used under the","Wired Equivalent Protocol","Wired Equivlent Privacy","Wired equivalent Privacy (WEP)","Wired equivalent privacy","Wired-Encyption-Protokoll","Wired-Equivalent-Privacy-Wikipedia--the-free-encyclopedia","Wired. Equivalent Privacy (WEP)","Wired_Equivalent_Privacy","Wired_Equivalent_Privacy#Schwachstellen","Wired_Equivalent_Privacy-wikipedia","Wireless Encryption Protocol","Wireless Encryption Protocol (WEP)","Wireless Equifalent Privacy","Wireless Equivalency Protocol)","Wireless Equivalent Privacy","Wireless Equivalent Protection","Wireless encryption protocol","Wires Equivalent Privacy, WEP","Wèp","Zaščita WEP","Zu brechen ist","[3] Wired Equivalent Privacy","a lot stronger than WEP","algoritmo WEP","algoritmo de cifrado débil","almost no security at all","apribile","ar:الخصوصية المكافئة للشبكات السلكية","artículo de Wikipedia WEP","auch gleich unverschlüsselt","bessere Methoden wie WPA","beveiligingsniveau","bg:Wired Equivalent Privacy","bra genomgång","broken a few years after","by anybody on the street","ca:Wired Equivalent Privacy","can be cracked within 2 minutes","can hack WEP in less than 10 minutes","chave WEP","chiave WEP","cifrado WEP, que desde 2001 es vulnerable","cifrado wep","cifrado wep de 256bits","clau WEP","clave WEP","clave Wep","clave wep","claves WEP","cle wep","clef WEP","clé WEP","cléf WEP","cok kisa surede","cracked WEP wireless configuration","cs:Wired Equivalent Privacy","das (eigentlich relativ nutzlose) WEP","das unsichere WEP","de WEP","de.wikipedia.org/ wiki/Wired_Equivalent_Privacy","de.wikipedia.org/wik...d_Equivalent_Privacy","de.wikipedia.org/wiki/Wired_Equival...","de.wikipedia.org/wiki/Wired_Equivalent_Privacy","de:Wired Equivalent Privacy","deutsche Wikipedia zu WEP","discredited, completely useless encryption system","disini untuk WEP","does WPA / WEP security affect wireless speeds? (WXP","door middel van WEP","e WE","e WEP","egyrészről","el protocolo WEP","en WEP","en.wikipedia.org/ wiki/Wired_Equivalent_Privacy","en.wikipedia.org/...Wired_Equivalent_Privacy","en.wikipedia.org/wiki/WEP2","en.wikipedia.org/wiki/Wi...uivalent_Privacy","en.wikipedia.org/wiki/Wi...y#Authentication","en.wikipedia.org/wiki/Wired...","en.wikipedia.org/wiki/Wired_Equivalen...","en.wikipedia.org/wiki/Wired_Equivalent_Privac y","en.wikipedia.org/wiki/Wired_Equivalent_Privacy","en.wikipedia.org/wiki/Wired_Equivalent_Privacy#Flaws","en.wikipedia.org/wiki/Wired_Equi···_Privacy","en:Wired Equivalent Privacy","encriptacion RC4","encriptacion WEP","encryption over wireless networks","er knekt","es.wikipedia.org/wiki/WEP","es.wikipedia.org/wiki/Wired_Equivalent_P … icaci.C3.B3n","es.wikipedia.org/wiki/Wired_Equivalent_Privacy","es:Wired Equivalent Privacy","extremely vulnerable wireless networking standard.","fa:معادل امنیت سیمی","fi:WEP","five-second Wikipedia search","fr.wikipedia.org/wiki/Wir...","fr:Wired Equivalent Privacy","geknackt werden","genug Quellen","gewesen","he:Wired Equivalent Privacy","hilariously insecure","hopelessly broken","hopelessly insecure","hr:WEP","http://bg.wikipedia.org/wiki/Wired_Equivalent_Privacy","http://ca.wikipedia.org/wiki/WEP","http://cs.wikipedia.org/wiki/WEP","http://cs.wikipedia.org/wiki/Wired_Equivalent_Privacy","http://de.wikipedia.org/wiki/Wi red_Equivalent_Privacy","http://de.wikipedia.org/wiki/Wired Equivalent Privacy","http://de.wikipedia.org/wiki/WiredEquivalentPrivacy","http://de.wikipedia.org/wiki/WiredEquivalentPrivacy#BrechendesSchl","http://de.wikipedia.org/wiki/Wired_","http://de.wikipedia.org/wiki/Wired_...uthenticatio n","http://de.wikipedia.org/wiki/Wired_E...Authentication","http://de.wikipedia.org/wiki/Wired_E...Schwachstellen","http://de.wikipedia.org/wiki/Wired_E...WEP-Datenpaket","http://de.wikipedia.org/wiki/Wired_E...ma.C3","http://de.wikipedia.org/wiki/Wired_E...schwachstellen","http://de.wikipedia.org/wiki/Wired_Equi ... achstellen","http://de.wikipedia.org/wiki/Wired_Equi ... entication","http://de.wikipedia.org/wiki/Wired_Equiv","http://de.wikipedia.org/wiki/Wired_Equiv...#Schwachstellen","http://de.wikipedia.org/wiki/Wired_Equiv..._Authentication","http://de.wikipedia.org/wiki/Wired_Equiv...nt_Privacy","http://de.wikipedia.org/wiki/Wired_Equiva ...","http://de.wikipedia.org/wiki/Wired_Equival...#Schwachstellen","http://de.wikipedia.org/wiki/Wired_Equivalent...","http://de.wikipedia.org/wiki/Wired_Equivalent_Priv acy","http://de.wikipedia.org/wiki/Wired_Equivalent_Privac...","http://de.wikipedia.org/wiki/Wired_Equivalent_Privacy","http://de.wikipedia.org/wiki/Wired_Equivalent_Privacy#Angriff_auf_die_ Authentifikation","http://de.wikipedia.org/wiki/Wired_Equivalent_Privacy#Einsatz","http://de.wikipedia.org/wiki/Wired_Equivalent_Privacy#Erfolgreicher_Angriff_auf_die_Authentifikation","http://de.wikipedia.org/wiki/Wired_Equivalent_Privacy#Schwachstellen","http://de.wikipedia.org/wiki/Wired_Equivalent_Privacy#Shared_Key_Authentication","http://de.wikipedia.org/wiki/Wired_Equivalent_Privacy#Sicherheitsma.C3","http://de.wikipedia.org/wiki/Wired_Equiv…","http://en.Liarpedia.org/wiki/Wired_Equivalent_Privacy","http://en.wikipedia ... serious weaknesses in the protocol","http://en.wikipedia....ivalent_Privacy","http://en.wikipedia....t_Privacy#Flaws","http://en.wikipedia.org/wik...d_Equivalent_Privacy","http://en.wikipedia.org/wiki/W [...] nt_Privacy","http://en.wikipedia.org/wiki/W.....nt_Privacy","http://en.wikipedia.org/wiki/W....vacy#Flaws","http://en.wikipedia.org/wiki/W...d_Equivalent_Privacy","http://en.wikipedia.org/wiki/WEP2","http://en.wikipedia.org/wiki/Wired_...","http://en.wikipedia.org/wiki/Wired_E...Authentication","http://en.wikipedia.org/wiki/Wired_E...PA_and_WPA2.29","http://en.wikipedia.org/wiki/Wired_E..._Privacy#Flaws","http://en.wikipedia.org/wiki/Wired_E...acy#References","http://en.wikipedia.org/wiki/Wired_E...ivacy#Remedies","http://en.wikipedia.org/wiki/Wired_E...y#WPA_and_WPA2","http://en.wikipedia.org/wiki/Wired_E...yption_details","http://en.wikipedia.org/wiki/Wired_Eq...","http://en.wikipedia.org/wiki/Wired_Equi ... entication","http://en.wikipedia.org/wiki/Wired_Equi ... vacy#Flaws","http://en.wikipedia.org/wiki/Wired_Equi valent_Privacy","http://en.wikipedia.org/wiki/Wired_Equiv...","http://en.wikipedia.org/wiki/Wired_Equiv...nt_Privacy","http://en.wikipedia.org/wiki/Wired_Equiv...vacy#Flaws","http://en.wikipedia.org/wiki/Wired_Equiva...rivacy","http://en.wikipedia.org/wiki/Wired_Equivalent _Priv...","http://en.wikipedia.org/wiki/Wired_Equivalent(...)","http://en.wikipedia.org/wiki/Wired_Equivalent...","http://en.wikipedia.org/wiki/Wired_Equivalent_...","http://en.wikipedia.org/wiki/Wired_Equivalent_Pri","http://en.wikipedia.org/wiki/Wired_Equivalent_Priv acy","http://en.wikipedia.org/wiki/Wired_Equivalent_Priv...","http://en.wikipedia.org/wiki/Wired_Equivalent_Privac","http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy – How WEP","http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy#","http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy#802.11i_","http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy#Authentication","http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy#Details","http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy#Encryption_details","http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy#Flaws","http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy#cite_note-7","http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy...","http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy>","http://en.wikipedia.org/wiki/Wired_Equivalent_P…","http://en.wikipedia.org/wiki/Wired_Equiv…","http://en.wikipedia.org/wiki/Wired_Eq…","http://en.wikipedia.org/wiki/W​ired_Equivalent_Privacy","http://en.wikipedia.org/wiki/wired_equiv...","http://en.wikipedia.org/wi​ki/Wired_Equivalent_Privac​y","http://es.wikipedia....ivalent_Privacy","http://es.wikipedia.org/wiki/WEP","http://es.wikipedia.org/wiki/WEP#Defectos","http://es.wikipedia.org/wiki/WEP2","http://es.wikipedia.org/wiki/Wired_Equivalent_Privacy","http://es.wikipedia.org/wiki/Wired_Equivalent_Privacy#Defectos","http://es.wikipedia.org/wiki/Wired_Equivalent_Privacy#Detalles_del_Cifrado","http://es.wikipedia.org/wiki/Wired_Equiv…","http://fi.wikipedia.org/wiki/WEP","http://fr.wikipedia....ivalent_Privacy","http://fr.wikipedia.org/wiki/W [...] nt_Privacy","http://fr.wikipedia.org/wiki/WEP","http://fr.wikipedia.org/wiki/WEP#Les_failles","http://fr.wikipedia.org/wiki/WEP#Les_solutions","http://fr.wikipedia.org/wiki/WEP#Les_sol…","http://fr.wikipedia.org/wiki/Wep","http://fr.wikipedia.org/wiki/Wep(...)","http://fr.wikipedia.org/wiki/Wired_Equivalent_Privacy","http://fr.wikipedia.org/wiki/Wired_Equivalent_Privacy#Les_failles","http://fr.wikipedia.org/wiki/Wired_Equiv…","http://fr.wikipedia.org/wiki/Wired_equivalent_privacy","http://hu.wikipedia.org/wiki/WEP","http://hu.wikipedia.org/wiki/WEP#WEP2","http://id.wikipedia.org/wiki/Wired_Equivalent_Privacy","http://id.wikipedia.org/wiki/Wired_Equiv…","http://it.wikipedia.org/wiki/Wired_","http://it.wikipedia.org/wiki/Wired_E...rivacy#Difetti","http://it.wikipedia.org/wiki/Wired_Equiv...cy#Difetti","http://it.wikipedia.org/wiki/Wired_Equiv...http://it","http://it.wikipedia.org/wiki/Wired_Equivalent...","http://it.wikipedia.org/wiki/Wired_Equivalent_Priv...","http://it.wikipedia.org/wiki/Wired_Equivalent_Privacy","http://it.wikipedia.org/wiki/Wired_Equivalent_Privacy#Difetti","http://it.wikipedia.org/wiki/Wired_Equiv…","http://ko.wikipedia.org/wiki/Wired_Equivalent_Privacy","http://nl.wikipedia.org/wiki/WEP","http://nl.wikipedia.org/wiki/Wep","http://nl.wikipedia.org/wiki/Wired_Equivalent_Priv","http://nl.wikipedia.org/wiki/Wired_Equivalent_Privacy","http://nl.wikipedia.org/wiki/Wired_Equivalent_Privacy#WEP_Onveilig","http://no.wikipedia.org/wiki/WEP","http://pl.wikipedia....ivalent_Privacy","http://pl.wikipedia.org/w...ivalent_Privacy","http://pl.wikipedia.org/wiki/Wired_Equivalent_Privacy","http://pt.wikipedia.org/wiki/WEP","http://pt.wikipedia.org/wiki/Wep","http://ru.wikipedia.org/wiki/WEP","http://sr.wikipedia.org/wiki/WEP","http://sv.wikipedia....ivalent_Privacy","http://sv.wikipedia.org/wiki/W ired_Equivalent_Privacy","http://sv.wikipedia.org/wiki/WEP","http://sv.wikipedia.org/wiki/Wired_Equivalent_Privacy","http://tr.wikipedia.org/wiki/WEP","http://zh.wikipedia.org/wiki/WEP","http://zh.wikipedia.org/zh-cn/WEP","http://zh.wikipedia.org/zh-hk/WEP","http://zh.wikipedia.org/zh-tw/WEP","http://zh.wikipedia.org/zh/有線等效加密","hu:WEP","iJuanaSearch: WEP - Vikipedi","iJuanaSearch: WEP - Wikipédia","iJuanaSearch: WEP – Wikipédia, a enciclopédia livre","iJuanaSearch: Wired Equivalent Privacy - Wikipedia","iJuanaSearch: Wired Equivalent Privacy - Wikipedia, la enciclopedia libre","iJuanaSearch: Wired Equivalent Privacy - Wikipedia, the free encyclopedia","id:Wired Equivalent Privacy","implemented WEP","in some protocols","infos sur le cryptable WEP","insecure protocol","ired Equivalent Privacy é","is very flawed","isn't very secure","it's not much better than leaving your data","it:Wired Equivalent Privacy","ja:Wired Equivalent Privacy","kao da zaštite ni nema","ko:Wired Equivalent Privacy","ko:유선 동등 프라이버시","kohtuuttoman helposti","l'article de Wikipédia WEP","l'article de Wikipédia Wep","la clau WEP d'una xarxa wireless","la clave WEP de una red wireless","laptop Asus Eee PC 2G Surf","le WEP dans Wikipédia","le wep","lien : fr.wikipedia.org/wiki/Wired_Equival ...","more digestible summary of WEP flaws","nesta pagina da wikepedia em PT","nicht ordentlich gesichert","nl:Wired Equivalent Privacy","no:WEP","not really that secure","nur mit WEP geschützten","o WE","o WEP","obsolete and insecure","offensichtlich keine ist","open authentication","open authentication, and those that have","p. WE","page de wikipedia expliquant le WEP","per WEP","pitoyable","pl.wikipedia.org/wiki/Wired_Equivalent_Privacy","pl:Wired Equivalent Privacy","protocollo WEP","protocolo WEP","protocolo Web","pt.wikipedia.org/wiki/WEP","pt:WEP","quasiment aucune sécurité","r WEP","razbijena","rrjeteve pa tel WEP key","ru.wikipedia.org/wiki/WEP","ru:WEP","schnell und einfach zu knacken","se pirater en 5 minutes","seguridad WEP.","several serious weaknesses","shared-key authentication can often pose a problem","simple:Wired Equivalent Privacy","sistema de cifrado WEP","sr:WEP","sv:Wired Equivalent Privacy","this WEP","tired old WEP","tr:WEP","ttp://en.wikipedia.org/wiki/Wired_Equivalent_Privacy,","uk:WEP","un algorithme de chiffrement comportant de grandes failles","unsecure since 2001","very flawed","w: WEP","wEp","weak encryption algorithm","wep — Википедия","why WEP is no longer secure for wireless","wiki Wired_Equivalent_Privacy","wiki-wep","wikipedia page for WEP","wikipedia wep mais rien a voir avec web","wikipedia://WEP","wired equivalent privacy","wireless entry point","wèp","zh:有線等效加密","zu brechen ist","{WEP, acrónimo de Wired Equivalent Privacy o “Privacidad","|WEP","¿Que significan WEP y WPA?","ältere Standard WEP","écrite ici","šifrirni protokol WEP","Κλειδί WEP ασύρματο δίκτυο","Πώς λειτουργεί το WEP","ВЕП","ВЕП кључ бежично умрежавање","ВЕП кључ бежичну мрежу","Википедии статью WEP","Википедии статью Wired Equivalent Privacy","Шифрование WEP","Шифрование WEP, WPA","на WEP","уязвимости WEP","шифрование WEP","וועפּ","וועפּ שליסל וויירליס נעטוואָרקינג","וועפּ שליסל וויירליס נעץ","מודל הפעולה","מפתח WEP לרשת אלחוטית","שגיאות מזעזעות","الارشاد","الارشاد الشبكات اللاسلكية الرئيسية","الخصوصية ا***افئة للشبكات السلكية","الخصوصية المكافئة للشبكات السلكية","معادل امنیت سیمی","کلید WEP شبکه های بی سیم","คีย์ WEP เครือข่ายไร้สาย","– WEP","「WEP」についてWikipediaで調査","「WEP」をWikipediaで調べる","ていた驚きを与えられていないが","なWired Equivalent Privacy","のWired Equivalent Privacy","ウィキペディアの記事 WEP","ワイヤレスのセキュリティにWEP","・WEP（Wired Equivalent Privacy）","有線と同等のプライバシー","有線等価プライバシー","有線等效加密","有線等效加密- 維基百科，自由的百科全書","有線等效加密- 维基百科，自由的百科全书","有线等效加密","的WEP","維基百科的文章“ WEP ”","維基百科的文章“ 有線等效加密”","维基百科的文章“ WEP ”","维基百科的文章“ 有線等效加密”","認証方式","유선 동등 프라이버시"],"name":"Wired Equivalent Privacy","categories":["All articles with unsourced statements","Articles with unsourced statements from December 2011","Broken cryptography algorithms","Computer network security","Cryptographic protocols","IEEE 802.11","Wireless networking"],"tag_line":"Wired Equivalent Privacy (WEP) is a security algorithm for IEEE 802.11 wireless networks."}}
,{"_index":"throwtable","_type":"algorithm","_id":"integer-factorization","_score":0,"_source":{"description":"In number theory, integer factorization is the decomposition of a composite number into a product of smaller integers. If these integers are further restricted to prime numbers, the process is called prime factorization.\nWhen the numbers are very large, no efficient, non-quantum integer factorization algorithm is known; an effort by several researchers concluded in 2009, factoring a 232-digit number (RSA-768), utilizing hundreds of machines took two years and the researchers estimated that a 1024-bit RSA modulus would take about a thousand times as long. However, it has not been proven that no efficient algorithm exists. The presumed difficulty of this problem is at the heart of widely used algorithms in cryptography such as RSA. Many areas of mathematics and computer science have been brought to bear on the problem, including elliptic curves, algebraic number theory, and quantum computing.\nNot all numbers of a given length are equally hard to factor. The hardest instances of these problems (for currently known techniques) are semiprimes, the product of two prime numbers. When they are both large, for instance more than two thousand bits long, randomly chosen, and about the same size (but not too close, e.g., to avoid efficient factorization by Fermat's factorization method), even the fastest prime factorization algorithms on the fastest computers can take enough time to make the search impractical; that is, as the number of digits of the primes being factored increases, the number of operations required to perform the factorization on any computer increases drastically.\nMany cryptographic protocols are based on the difficulty of factoring large composite integers or a related problem—for example, the RSA problem. An algorithm that efficiently factors an arbitrary integer would render RSA-based public-key cryptography insecure.","alt_names":["Faktorisieren","factorise","prime factorization","factorisable","Prime factorization","Fundamentalsatz_der_Arithmetik","Primfaktor","factorización de enteros","素因数分解","integer factorization","*the *integer *factorization","- Integer factorization :","- Prime factorization :","-> Read the article about 'Integer factorization'","... resuelva eficientemente este problema; un reciente intento de","...Wikipedia Décomposition en produit de facteurs premiers","...mehr auf Wikipedia über Faktorisierungsproblem","...mehr auf Wikipedia über Faktorisierungsverfahren","...mehr auf Wikipedia über Fundamentalsatz der Arithmetik","...mehr auf Wikipedia über Primfaktorzerlegung","...more on Wikipedia about Integer factorization","1 Prime decomposition","150px-PrimeDecomposition ...","2 Current state of the art","2.1 Difficulty and complexity","2.6 (Primfaktorzerlegung)","3 Current state of the art","3 Factoring algorithms","3.1 Special-purpose","3.2 General-purpose","3.3 Other notable algorithms","344b6b22e7b4bfe04aeb505020a ...","<U>소인수분해</U>","Algorithmes de...","Can we factor quickly?","Casos de factorizaciòn","Current state of the art","D?composition en produit de facteurs premiers - Wikip","Definición de Factorización de enteros más completo","Die Primfaktorzerlegung ist die Darstellung einer natürlichen Zahl","Diese Darstellung ist bis auf die Reihenfolge der","Décomposition en facteurs premiers","Décomposition en produit de facteurs premiers","Décomposition en produit de facteurs premiers - Wikipédia","Décomposition en produit de...","Décomposition en...","FACTORIZE","Facteurs premiers","Factor table","Factoring algorithms","Factoring.","Factorisation d'entiers","Factorisation des entiers","FactoritzaciÃ³","Factorització dels enters - Viquipèdia","Factorizaci?n de enteros - Wikipedia, la enciclopedia libre","Factorización de enteros","Factorización de enteros - Wikipedia, la enciclopedia libre","Factorización de números enteros","Factorización de números enteros.","Factorización_de_enteros","Factorizar enteros","Factors numbers","Faktoren zerlegt","Faktorigo de entjero","Faktorigo de entjero - Vikipedio","Faktorisiere","Faktorisieren - Wikipedia","Faktorisierung ganzer Zahlen","Faktorisierung integer","Faktorisierungsalgorithmen","Faktorisierungsproblem","Faktorisierungsproblem für ganze Zahlen","Faktorisierungsproblem großer Zahlen","Faktorisierungsproblem_für_ganze_Zahlen","Faktorisierungsverfahren","Faktorisierungsverfahren ? Wikipedia","Faktorisierungsverfahren – Wikipedia","Faktorizace celého čísla","Faktorsierungsproblem","Faktorzerlegung","Fakturierungsverfahren","Fatoração de inteiros","Fatoração de inteiros – Wikipédia, a enciclopédia livre","Fattorizzazione di interi","Frumþáttun","Frumþáttun - Wikipedia, frjálsa alfræðiritið","Fundamentalsatz der Arithmetik - Wikipedia","Fundamentalsatz_der_Arithmetik bei der wikipedia","Fundamentalsatzes der Arithmetik","Gibt es einen schnellen Algorithmus zur Primfaktorenzerlegung?","Gibt es einen schnellen Algorithmus zur Primfaktorzerlegung?","Heuristic running time","Integer Factorial","Integer Factorization","Integer Factorization (and Prime Factorization, and other goodness","Integer Factorization (wikipedia)","Integer Factorization - Wikipedia, The Free Encyclopedia","Integer Factorization - Wikipedia, the free encyclopedia","Integer Factorization Problem","Integer Factorization a la wikipedia","Integer Factorization algorithm","Integer factoring problem","Integer factorisatie","Integer factorisation","Integer factorization","Integer factorization (wikipedia)","Integer factorization - Wikipedia, the free ...","Integer factorization - Wikipedia, the free encycl...","Integer factorization - Wikipedia, the free encyclopedia","Integer factorization - Wikipedia, the free encyclopedia In number","Integer factorization - Wikipedia, the free encyclopediaIn number","Integer factorization Wikipedia the free encyclopedia","Integer factorization Wikipedia the free encyclopedia - result","Integer factorization from wiki","Integer factorization problem","Integer factorization: Current state of the art","Integer factorization; it is used under the","Integer faktorisering","Integer fattorizzazione","Integer na czynniki","Integer факторизации","Integer-Faktorisierung","Integer_factorization","Integer_factorization (Wikipedia)","Integer_factorization#Difficulty_and_complexity","Komplexität von Faktorisierung","Large integer factorization","Learn about Integer factorization>>>","Mais fatoração de inteiros na Wikipedia.","O exp 64 9 b 1 / 3 ( log","Ontbinden in priemfactoren","Prime Factorisation","Prime factorisation","Prime factorization algorithm","Prime factorization algorithms","Prime_factorization","Primfaktoren zerlegt","Primfaktorzerlegung","Primfaktorzerlegung - Wikipedia","Primfaktorzerlegung ? Wikipedia","Primfaktorzerlegung – Wikipedia","Primfaktorzerlegungen","Primteiler","Prvočíselný rozklad","Prvočíselný rozklad - Wikipedie - Wikipedia","Prímfelbontás","Prímfelbontás - Wikipédia","Razcep","Read More integer factorization wikipedia the free encyclopedia","Tante Vicky hilft ...","Unique Prime Factorization","Verfahren zur Faktorisierung","View Prime factorization on Wikipedia","What is the definition of prime factorization ? - Yahoo","Wikipedia article Décomposition en produit de facteurs premiers","Wikipedia article Factorització dels enters","Wikipedia article Factorización de enteros","Wikipedia article Faktorigo de entjero","Wikipedia article Faktorisierungsverfahren","Wikipedia article Fatoração de inteiros","Wikipedia article Frumþáttun","Wikipedia article Integer factorization","Wikipedia article Integer factorization problem","Wikipedia article Integer_factorization","Wikipedia article Praštevilski razcep","Wikipedia article Prime factorization","Wikipedia article Primfaktorzerlegung","Wikipedia article Prvočíselný rozklad","Wikipedia article Prímfelbontás","Wikipedia article on Descomposición en producto de factores","Wikipedia article on Factorización de enteros","Wikipedia article on Integer factorization","Wikipedia article on Prime factorization","Wikipedia article on integer factorization","Wikipedia article تحليل عدد صحيح","Wikipedia article 소인수 분해","Wikipedia entry for Integer factorization","Wikipedia entry on integer factorisation","Wikipedia on Prime factorization","Wikipedia sur Décomposition en facteurs premiers","Wikipedia sur Factorisation des entiers","Wikipedia's (incomplete) list","Wikipedia's Integer Factorization entry","Wikipedia's treatment of the subject.","Wikipedia, Stichwort Fundamentalsatz der Arithmetik","Wikipedia-Artikel Faktorisierungsproblem","Wikipedia-Artikel Faktorisierungsproblem für ganze Zahlen","Wikipedia-Artikel Faktorisierungsverfahren","Wikipedia-Artikel Fundamentalsatz der Arithmetik","Wikipedia-Artikel Primfaktor","Wikipedia-Artikel Primfaktorzerlegung","Wikipedia-Seite zu 'Faktorisierungsproblem für ganze Zahlen'","Wikipedia-Seite zu 'Faktorisierungsproblem'","Wikipedia-Seite zu 'Faktorisierungsverfahren'","Wikipedia-Seite zu 'Fundamentalsatz der Arithmetik'","Wikipedia-Seite zu 'Primfaktor'","Wikipedia-Seite zu 'Primfaktorzerlegung'","Wikipedia-décomposition en facteurs premiers","Wikipedia.ru как бэ намекает нам:","Wikipedia: Factorización de enteros","Wikipedia: Faktorisierungsverfahren","Wikipedia: Integer Factorization","Wikipedia:Faktorisierungsproblem","Wikipedia:Faktorisierungsverfahren","Wikipedia:Fundamentalsatz der Arithmetik","Wikipedia:Primfaktorzerlegung","Wikipediaで「整数の因数分解」を調べる","Wikipediaで「素因数分解」を調べる","Wikipedia｢素因数分解｣","a list of algorithms","actoring integers","actorisable e","actorizes","an algorithm for common cases","an algorithm for general cases","ar:تحليل عدد صحيح","ar:مسألة التفكيك إلى جداء عوامل أولية","ar:مشكلة التفكيك إلى جداء عوامل أولية","artículo de Wikipedia Factorización de enteros","better factorization algorithm","bf579b28988b401a55a426b79c08e6 ...","ca:Factorització dels enters","celé číslo faktorizace","cs:Prvočíselný rozklad","de.wikipedia.org/wiki/Faktorisierungsverfahren","de.wikipedia.org/wiki/Primfaktorzerlegung","de:Primfaktor","de:Primfaktorzerlegung","de:Primfaktorzerlegung#Der Fundamentalsatz: Existenz und Eindeutigkeit","de:Primfaktorzerlegung#Fundamentalsatz der Arithmetik","deciding if a 1024-digit prime number may","descompondre en factors primers","descomposició en factors primers","descomposición en factores primos","descomposición en números primos","décomposable","décomposer le nombre en facteurs premiers","décomposition en produit de facteurs premiers","décompositions en produit de facteurs premiers","en.wikipedia.org/...Integer_factorization","en.wikipedia.org/wiki/Integer_factori...","en.wikipedia.org/wiki/Integer_factorization","en.wikipedia.org/​wiki/​Integer_factorization","en:integer factorization","eo:Faktorigo de entjero","es:Factorización de enteros","facteurs premiers","factor table","factor the product of two large prime numbers","factor the product of two prime numbers","factoreo de números grandes","factoring a number","factoring algorithms","factoring an integer","factoring information","factoring integers into prime factors","factoring is a hard problem","factoring large integer number","factoring large integers","factoring large numbers","factoring of large integers","factoring problem","factoring tree","factoring very large numbers","factorisation Integer","factorisation d'entiers","factorisation des entiers","factorisation des nombres entiers","factorisation จำนวนเต็ม","factorise large numbers","factoriseren","factorización de enteros en números primos","factorización de enteros primos","factorización de los enteros","factorización de números","factorización de números primos","factorización entera","factorización entero","factorizar en números primos","factorizar en primos","factorizar números muy grandes","factorization of large integers","factorization of large numbers","factorization problem","factorization สำคัญ","factorização de primos","factorizes","factorizing numbers","factors a number,","factors of two","faktorisieren","faktorizálás","faktoryzacji liczb całkowitych","faktoryzacji liczby całkowitej","fatoração do inteiro","fattorizzazione Integer","fattorizzazione di interi","finding the factors","finding the original factors","fr.wikipedia.org/wiki/Décomposition_en_produit_de_facteurs_premiers","fr:Décomposition en produit de facteurs premiers","frumþáttun","frumþætti","gefactoriseerd","geheel getal factorisatie","generic prime factorization algorithms","http//de.wikipedia.org/wiki/Primfaktorzerlegung","http://ca.wikipedia.org/wiki/Factoritzaci%C3%B3_en_nombres_primers","http://de.wikipedia.org/wiki/Fa ktorisierungsverfahren","http://de.wikipedia.org/wiki/Faktorisier...itere_Verfahren","http://de.wikipedia.org/wiki/Faktorisierun...Cr_ganze_Zahlen","http://de.wikipedia.org/wiki/Faktorisierungsproblem","http://de.wikipedia.org/wiki/Faktorisierungsproblem_f%C3%BCr_ganze_Zahlen","http://de.wikipedia.org/wiki/Faktorisierungsverfahren","http://de.wikipedia.org/wiki/Faktorisierungsverfahren#Geschichte","http://de.wikipedia.org/wiki/Fundamentalsatz_der_Arithmetik","http://de.wikipedia.org/wiki/Pr imfaktorzerlegung","http://de.wikipedia.org/wiki/Primfaktor","http://de.wikipedia.org/wiki/Primfaktorz","http://de.wikipedia.org/wiki/Primfaktorzerlegung","http://de.wikipedia.org/wiki/Primfaktorzerlegung#Beispiele_f.C3","http://de.wikipedia.org/wiki/Primfaktorzerlegung#Fundamentalsatz_der_Arithmetik","http://de.wikipedia.org/wiki/Primfaktorzerlegung#Praktische_Anwendung","http://de.wikipedia.org/wiki/Primfaktorzerlegung#Weblinks","http://de.wikipedia.org/wiki/Primfaktorz…","http://de.wikipedia.org/wiki/primfaktorz.","http://en.wikipedia....r_factorization","http://en.wikipedia....ring_algorithms","http://en.wikipedia.org/w...Difficulty_and_complexity","http://en.wikipedia.org/wiki....orithms","http://en.wikipedia.org/wiki/Integer...and_complexity","http://en.wikipedia.org/wiki/Integer...eneral-purpose","http://en.wikipedia.org/wiki/Integer_fac","http://en.wikipedia.org/wiki/Integer_facto...ring_algorithms","http://en.wikipedia.org/wiki/Integer_factorizatio","http://en.wikipedia.org/wiki/Integer_factorization","http://en.wikipedia.org/wiki/Integer_factorization →","http://en.wikipedia.org/wiki/Integer_factorization#Current_state_of_the_art","http://en.wikipedia.org/wiki/Integer_factorization#Difficulty_and_comple...","http://en.wikipedia.org/wiki/Integer_factorization#Difficulty_and_complexity","http://en.wikipedia.org/wiki/Integer_factorization#Difficulty_and_complexity:","http://en.wikipedia.org/wiki/Integer_factorization#Factoring_algorithms","http://en.wikipedia.org/wiki/Integer_factorization#Factoring_algorithms.","http://en.wikipedia.org/wiki/Integer_factorization#General-purpose","http://en.wikipedia.org/wiki/Integer_factorization#Special-purpose","http://en.wikipedia.org/wiki/Integer_factorization?","http://en.wikipedia.org/wiki/Integer_factorization_problem","http://en.wikipedia.org/wiki/Integer_factorization_problem#Difficulty_and_complexity","http://en.wikipedia.org/wiki/Integer_fac…","http://en.wikipedia.org/wiki/Prime_factorizatio...","http://en.wikipedia.org/wiki/Prime_factorization","http://en.wikipedia.org/wiki/Prime_factorization#Difficulty_and_complexity","http://es.wikipedia.org/wiki/Factorizaci%C3%B3n_de_enteros","http://es.wikipedia.org/wiki/Factorización_de_enteros","http://fr.wikipedia.org/wiki/D%C3%A9composition_en_produit_d","http://fr.wikipedia.org/wiki/D%C3%A9composition_en_produit_de_facteurs_premiers","http://hu.wikipedia.org/wiki/Faktoriz%C3%A1ci","http://ja.wikipedia.org/wiki/素因数分解","http://nl.wikipedia.org/wiki/Ontbinden_in_priemfactoren","http://ru.wikipedia.org/wiki/Факторизаци...","http://ru.wikipedia.org/wiki/Факторизация_целых_чисел","http://sv.wikipedia.org/wiki/Primtalsfaktorisering","http://zh.wikipedia.org/zh-cn/整数分解","integer factiorization","integer factoring algorithms","integer factoring problem","integer factorisatie","integer factorisation","integer factorizat","integer factorization - wikipedia, the free encyclopedia","integer factorization / prime decomposition","integer factorization methods","integer factorization problem","integer factorizations","is:Frumþáttun","ja:素因数分解","ko:소인수 분해","l'article de Wikipédia Décomposition en produit de","many known methods","n (http://de.wikipedia.org/wiki/Faktorisierungsverfahren","nguyên tố tích nhân","no algorithm has been published that can factor","on factoring integers","ongelman","praštevilskega razcepa","predicting the number of operations needed to factor","pretty heady math","priemfactorisatie","prime factorization algorithm","prime factorization of integers","prime factorization problem","prime factorizations","prime factorizations),","prime factors of large numbers","prime number decomposition","prime numbers factorization","prime-factorisation","primtalsfaktorisera","problema de factorización de enteros","problema de la factorización de enteros","product of their prime factors","producto de divisores primos","prvočíselný rozklad","pt.wikipedia.org/wiki/Fatora%C3%A7%C3","r Primfaktorzerlegun","razcep na prafaktorje","really smart algorithms","rimfaktor","says O\\left(\\exp\\left(\\left(\\begin{matrix","schnellere","several months of computer time using the combined","sl:Praštevilski razcep","suspected to be in","sv:Primtalsfaktorisering","technically there are many solutions","the decision version of factoring is not known","the encryption used depends on it being very","un produit de nombres premiers","unknown whether integer factorization (into primes) is an","w:素因数分解","well-known special-purpose algorithms","y prime","yeah, really","zh:整数分解","État actuel de...","παραγοντοποίησης ακεραίων","Факторизация целых чисел","Факторизация целых чисел — Википедия","Целое факторизации","другие алгоритмы","премьер факторизации","разложенный на множители","факторизации целых","факторизации целых чисел","факторизацию целых чисел","целое факторизации","التحليل للعوامل الأولية","التفكيك إلى جداء عوامل أولية","العوامل الأولية","تحليل عدد صحيح","عوامله الأولية","لﯾﻟﺣﺗﻟاو","مسألة التفكيك إلى جداء عوامل أولية","مشكلة التفكيك إلى جداء عوامل أولية","पूर्णांक गुणन","「素因数分解」についてWikipediaで調査","「素因数分解」をWikipediaで調べる","の整数の因数分解の","の整数因数分解","ウィキペディアの記事 素因数分解","一意分解の定理","因子分解","因數分解","整数factorisation","整数の因数分解","整数の素因数分解","整数分解","整数分解- 维基百科，自由的百科全书","整数因子分解","整數分解","整數分解- 維基百科，自由的百科全書","整數因子分解","整數因數分解","算法比指數數量級時間要快，","素因数分解 (Wikipedia) へのリンク","素因数分解 - Wikipedia","素因数分解 [Wikipedia]","素因数分解(factorization,factoring)","素因数分解-wikipedia","素因数分解の","素因数分解の問題","素因数分解の記録","素因数分解アルゴリズム","素因数分解アルゴリズム in 素因数分解 - Wikipedia","素因数分解問題","素数分解","素數分解","維基百科的文章“ 因数分解”","維基百科的文章“ 整数分解”","維基百科的文章“ 质因数分解”","维基百科的文章“ 整数分解”","维基百科的文章“ 质因数分解”","能被因數分解","質因數分解","质因数分解","소수 분해","소인수 분해","소인수 분해 (Prime Factorization)","소인수 분해 위키백과, 우리 모두의백과사전","소인수분해","위키 피 디아 문서 소인수 분해","위키 피 디아 문서 소인수분해","위키 피 디아의 페이지에서보십시오.","정수 factorisation","ﺔﯾﻟوأ لﻣاوﻋ ءادﺟ ﯽﻟإ كﯾﮐﻔﺗﻟا ﺔﻟﮐﺷﻣ","ﺔﯾﻟوأ لﻣاوﻋ ءادﺟ ﯽﻟإ كﯾﮐﻔﺗﻟا ﺔﻟﮐﺷﻣو"],"name":"Integer factorization","categories":["Computational hardness assumptions","Integer factorization algorithms","Unsolved problems in computer science"],"tag_line":"In number theory, integer factorization is the decomposition of a composite number into a product of smaller integers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"shamir's-secret-sharing","_score":0,"_source":{"description":"Shamir's Secret Sharing is an algorithm in cryptography created by Adi Shamir. It is a form of secret sharing, where a secret is divided into parts, giving each participant its own unique part, where some of the parts or all of them are needed in order to reconstruct the secret.\nCounting on all participants to combine the secret might be impractical, and therefore sometimes the threshold scheme is used where any  of the parts are sufficient to reconstruct the original secret.","alt_names":["Shamir's Secret Sharing Scheme","Shamir's secret sharing","Shamir's","Shamir's Secret Sharing - Wikipedia, the free encyclopedia","Shamir's Secret Sharing","- Shamir's Secret Sharing :","...mehr auf Wikipedia über Shamirs Secret Sharing","2 Shamir's secret-sharing scheme","3.1.1 Preparation","3.1.2 Reconstruction","Adi Shamir's key splitting techniques","Esquema de Shamir","Esquema de Shamir - Wikipedia, la enciclopedia libre","How is Shamir's Secret Sharing used","Le partage de clé secrète de Shamir","Partage de clé secrète de Shamir","Partage de secret","Secret Sharing (wikipedia, básico)","Secret Sharing.","Secreto Compartido Shamir","Shamir Secret Sharing","Shamir Secret Sharing Scheme","Shamir er","Shamir ist","Shamir je","Shamir secret sharing","Shamir's Scheme","Shamir's Secret","Shamir's Secret Sharing (Wikipedia)","Shamir's Secret Sharing - Wikipedia","Shamir's Secret Sharing - Wikipedia, the ...","Shamir's Secret Sharing @Wikipedia","Shamir's Secret Sharing Algorithm","Shamir's Secret Sharing algorithm","Shamir's Secret Sharing protocol","Shamir's Secret Sharing – Wikipedia","Shamir's Secret Sharing.","Shamir's Teilen von Geheimnissen","Shamir's method","Shamir's secret ...","Shamir's secret sharing algorithm","Shamir's secret-sharing","Shamir's threshold secret sharing scheme","Shamir-féle titokmegosztás","Shamir-ovu schému","Shamirs Secret Sharing","Shamirs Secret Sharing Scheme","Shamir的(k,n)門檻值方式","Shamir的秘密共享","Wikipedia article Shamir's Secret Sharing","Wikipedia on Shamir's Secret Sharing","Wikipedia “Shamir's Secret Sharing” page","Wikipedia-Artikel Shamir's Secret Sharing","Wikipedia-Artikel Shamirs Secret Sharing","Wikipedia-Seite zu 'Shamir's Secret Sharing'","Wikipedia-Seite zu 'Shamirs Secret Sharing'","[wikipedia による解説]","algorytm Secret Sharing Shamira","artículo de Wikipedia Esquema de Shamir","artículo de Wikipedia Esquema de shamir","de:Shamir's Secret Sharing","en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing","en:Shamir's Secret Sharing","esquema de Shamir","http://de.wikipedia.org/wiki/Shamir%27s_Secret_Sharing","http://de.wikipedia.org/wiki/Shamir%E2%80","http://de.wikipedia.org/wiki/Shamirs Secret Sharing","http://de.wikipedia.org/wiki/Shamirs_Sec","http://de.wikipedia.org/wiki/Shamirs_Secret_Sharing","http://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing","http://en.wikipedia.org/wiki/Shamir's_Secret_Sh...","http://en.wikipedia.org/wiki/Shamir's_Secret_Sharing","http://en.wikipedia.org/wiki/Shamir's_Secret_Sharing#Mathematical_definition","http://es.wikipedia.org/wiki/Esquema_de_Shamir","http://fr.wikipedia.org/wiki/Partage_de_cl%C3%A9_secr","http://ru.wikipedia.org/wiki/Схема_..._секрета_Шамира","hu:Shamir féle titokmegosztás","hu:Shamir-féle titokmegosztás","in viele Teile zerlegt","ithm","list of properties","partage de clé secrète de Shamir","partage de clés secrètes de Shamir","ru.wikipedia.org/wiki/Схема_разделения_секрета_Шамира","ru:Схема Шамира","secret partagé de Shamir","secret sharing algorithm","segreta condivisione di Shamir","tajemnicy Szamira wymiany","the Shamir secret-sharing scheme","type Shamir","« Shamir's Secret Sharing »","Схема Шамира","Схема разделения секрета Шамира","Схемата на Шамир(най-популярната схема)","Шамира","разбивает ключ на части","хорошей подготовке","शमीर है रहस्य साझा","シャミールの"],"name":"Shamir's Secret Sharing","categories":["All articles needing expert attention","All articles that are too technical","Articles needing expert attention from March 2014","Information-theoretically secure algorithms","Secret sharing","Wikipedia articles that are too technical from March 2014"],"tag_line":"Shamir's Secret Sharing is an algorithm in cryptography created by Adi Shamir."}}
,{"_index":"throwtable","_type":"algorithm","_id":"algebraic-group-factorisation-algorithm","_score":0,"_source":{"description":"Algebraic-group factorisation algorithms are algorithms for factoring an integer N by working in an algebraic group defined modulo N whose group structure is the direct sum of the 'reduced groups' obtained by performing the equations defining the group arithmetic modulo the unknown prime factors p1, p2, ... By the Chinese remainder theorem, arithmetic modulo N corresponds to arithmetic in all the reduced groups simultaneously.\nThe aim is to find an element which is not the identity of the group modulo N, but is the identity modulo one of the factors, so a method for recognising such one-sided identities is required. In general, one finds them by performing operations that move elements around and leave the identities in the reduced groups unchanged. Once the algorithm finds a one-sided identity all future terms will also be one-sided identities, so checking periodically suffices.\nComputation proceeds by picking an arbitrary element x of the group modulo N and computing a large and smooth multiple Ax of it; if the order of at least one but not all of the reduced groups is a divisor of A, this yields a factorisation. It need not be a prime factorisation, as the element might be an identity in more than one of the reduced groups.\nGenerally, A is taken as a product of the primes below some limit K, and Ax is computed by successive multiplication of x by these primes; after each multiplication, or every few multiplications, the check is made for a one-sided identity.","alt_names":["&Zopf; / n &Zopf; [ t ]","Algebraic group factorisation algorithm","Algebraic-group Factorisation Algorithm - Wikipedia, The Free Encyclopedia","Algebraic-group factorisation algorithm","Algebraic-group factorisation algorithm - Wikipedia, the free ...","Algebraic-group factorisation algorithm - Wikipedia, the free ... ...","Algebraic-group factorisation algorithm - Wikipedia, the free encyclopedia","Algebraic-group factorisation algorithms","Algebraic-group factorization algorithm","Wikipedia article Algebraic-group factorisation algorithm","Wikipedia article Algebraic-group factorisation algorithms","Wikipedia article Algebraic-group factorization algorithm","Wikipedia article on Algebraic-group factorization algorithm","Wikipedia entry for Algebraic-group factorisation algorithm","algebraic-group factorisation algorithm","algebraic-group factorisation algorithms","algebraic-group factorization algorithm","algebraic-group factorization algorithms","http://en.wikipedia.org/wiki/Algebraic-g","http://en.wikipedia.org/wiki/Algebraic-group factorisation","http://en.wikipedia.org/wiki/Algebraic-group_factorisation_algorithm"],"name":"Algebraic-group factorisation algorithm","categories":["All articles lacking sources","Articles lacking sources from January 2015","Integer factorization algorithms"],"tag_line":"Algebraic-group factorisation algorithms are algorithms for factoring an integer N by working in an algebraic group defined modulo N whose group structure is the direct sum of the 'reduced groups' obtained by performing the equations defining the group arithmetic modulo the unknown prime factors p1, p2, ... By the Chinese remainder theorem, arithmetic modulo N corresponds to arithmetic in all the reduced groups simultaneously."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dixon's-factorization-method","_score":0,"_source":{"description":"In number theory, Dixon's factorization method (also Dixon's random squares method or Dixon's algorithm) is a general-purpose integer factorization algorithm; it is the prototypical factor base method. Unlike for other factor base methods, its run-time bound comes with a rigorous proof that does not rely on conjectures about the smoothness properties of the values taken by polynomial.\nThe algorithm was designed by John D. Dixon, a mathematician at Carleton University, and was published in 1981.","alt_names":["Dixon's factorization method - Wikipedia, the free encyclopedia","Dixon's factorization method","Dixon's algorithm","- Dixon's factorization method :","-> Read the article about 'Dixon's factorization method'","...Wikipedia Factorisation de Dixon","...more on Wikipedia about Dixon's factorization method","Dix's factorizati method","Dixon factorisatie","Dixon s factorization method Wikipedia the free encyclopedia","Dixon's","Dixon's Algorithm","Dixon's Factorization Method - Wikipedia, The Free Encyclopedia","Dixon's factorization","Dixon's factorization algorithm","Dixon's factorization method - Wikipedia :: The free encyclopedia","Dixon's_factorization_method","Dixons Faktorisierungsmethode","Dixons factorisatiemethode","Dixons_Faktorisierungsmethode","WIKI Dixon's factorization method","What is Dixon factorization method's example","Wikipedia article ''Dixon's factorization method''","Wikipedia article Dixon's algorithm","Wikipedia article Dixon's factorization method","Wikipedia article about Dixon's factorization method","Wikipedia sur Factorisation de Dixon","algoritme van Dixon","de:Dixons Faktorisierungsmethode","en.wikipedia.org/...Dixon%27s_algorithm","en.wikipedia.org/wiki/Dixon%27s_factorization_method","en:Dixon's factorization method","http://de.wikipedia.org/wiki/Dixons_Faktorisierungsmethode","http://en.wikipedia.org/wiki/Dixon %27s_factorization_method","http://en.wikipedia.org/wiki/Dixon%2...ization_method","http://en.wikipedia.org/wiki/Dixon%27s_factorization_method","http://en.wikipedia.org/wiki/Dixon&#39;s","http://en.wikipedia.org/wiki/Dixon's factorization method","http://en.wikipedia.org/wiki/Dixon's...ization_method","http://en.wikipedia.org/wiki/Dixon's_factorization_method","http://fr.wikipedia.org/wiki/Factorisation_de_Dixon","http://nl.wikipedia.org/wiki/Dixons_factorisatieme","http://nl.wikipedia.org/wiki/Dixons_factorisatiemethode","http://ru.wikipedia.org/wiki/Алгоритм_Диксона","l'article de Wikipédia Factorisation De Dixon","l'article de Wikipédia Factorisation de Dixon","nl:Dixon factorisatie","nl:Dixon's factorisatie methode","nl:Dixons factorisatiemethode","ru:Алгоритм Диксона","uk:Метод факторизації Діксона","x 2 mod N","Алгоритм Диксона","Метод факторизації Діксона"],"name":"Dixon's factorization method","categories":["Integer factorization algorithms"],"tag_line":"In number theory, Dixon's factorization method (also Dixon's random squares method or Dixon's algorithm) is a general-purpose integer factorization algorithm; it is the prototypical factor base method."}}
,{"_index":"throwtable","_type":"algorithm","_id":"universal-hashing","_score":0,"_source":{"description":"In mathematics and computing universal hashing (in a randomized algorithm or data structure) refers to selecting a hash function at random from a family of hash functions with a certain mathematical property (see definition below). This guarantees a low number of collisions in expectation, even if the data is chosen by an adversary. Many universal families are known (for hashing integers, vectors, strings), and their evaluation is often very efficient. Universal hashing has numerous uses in computer science, for example in implementations of hash tables, randomized algorithms, and cryptography.","alt_names":["- Universal hashing :","2 Mathematical guarantees","2-universal hash","3.1 Hashing integers","3.2 Hashing vectors","3.3 Hashing strings","Pr h &Element; H [ h ( x ) = h ( y","Universal Hash functions","Universal Hashing","Universal hash","Universal hash function","Universal hashing","Universal hashing - Wikipedia, the free encyclopedia","Universal hashing - Wikipedia, the free encyclopedia wikipedia.org","Universal hashing; it is used under the","Universal_hashing","Universelle Hash-Funktion","Universelle_Hash-Funktion","What are the uses of Universal hashing","Wikipedia article Universal hashing","Wikipedia article on Universal hash function","Wikipedia article on Universal hashing","Wikipedia entry for Universal hashing","Wikipedia-Artikel Universelle Hash-Funktion","Wikipedia-Artikel Universelle Hashfunktion","Wikipedia-Seite zu 'Universelle Hash-Funktion'","Wikipedia-Seite zu 'Universelle Hashfunktion'","a universal hash scheme","http://de.wikipedia.org/wiki/Universelle_Hash-Funktion","http://en.wikipedia.org/wiki/Universal_hash","http://en.wikipedia.org/wiki/Universal_hashin...","http://en.wikipedia.org/wiki/Universal_hashing","k-wise independent hash functions","sufficient randomness","universal family","universal hash","universal hash function","universal hash functions","universal hashing","universal hashing.","universal-2 hashing","universal_hashing","universelles Hashing","wen:Universal hashing","| Universal Hashing","универсальное семейство хэш-функций","위키 피 디아 문서 유니버설 해싱","유니버설 해싱"],"name":"Universal hashing","categories":["Computational complexity theory","Cryptographic hash functions","Hashing","Search algorithms"],"tag_line":"In mathematics and computing universal hashing (in a randomized algorithm or data structure) refers to selecting a hash function at random from a family of hash functions with a certain mathematical property (see definition below)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"continued-fraction-factorization","_score":0,"_source":{"description":"In number theory, the continued fraction factorization method (CFRAC) is an integer factorization algorithm. It is a general-purpose algorithm, meaning that it is suitable for factoring any integer n, not depending on special form or properties. It was described by D. H. Lehmer and R. E. Powers in 1931, and developed as a computer algorithm by Michael A. Morrison and John Brillhart in 1975.\nThe continued fraction method is based on Dixon's factorization method. It uses convergents in the regular continued fraction expansion of\n.\nSince this is a quadratic irrational, the continued fraction must be periodic (unless n is square, in which case the factorization is obvious).\nIt has a time complexity of , in the O and L notations.","alt_names":["- Continued fraction factorization :","-> Read the article about 'Continued fraction factorization'","...more on Wikipedia about Continued fraction factorization","CFRAC","CFRAC ·","Continued Fraction Factorization","Continued Fraction Factorization - Wikipedia, The Free Encyclopedia","Continued fraction factorization","Continued fraction factorization - Wikipedia, the free ...","Continued fraction factorization - Wikipedia, the free encyclopedia","Continued fraction factorization - Wikipedia, the free encyclopedia ...","Continued fraction factorization Wikipedia the free encyclopedia","Continued_fraction_factorization","Kettenbruchmethode","Kettenbruchmethode – Wikipedia","Learn about Continued fraction factorization>>>","Lexikon: Kettenbruchmethode - ComputerBase","Morrison-Brillhart algorithm","Screenshot http://www.computerbase.de/lexikon/Kettenbruchmethode","Wikipedia article ''Continued fraction factorization''","Wikipedia article CFRAC","Wikipedia article Continued fraction factorization","Wikipedia entry for Continued fraction factorization","Wikipedia-Artikel CFRAC","Wikipedia-Artikel Kettenbruchmethode","Wikipedia-Seite zu 'Kettenbruchmethode'","continued fraction factorization","continued fraction method","de:Kettenbruchmethode","http://de.wikipedia.org/wiki/CFRAC","http://de.wikipedia.org/wiki/Kettenbruchmethode","http://en.wikipedia.org/wiki/Continued_fraction_factorization","k n , k &Element; &Zopf; +","yago-res:Continued fraction factorization"],"name":"Continued fraction factorization","categories":["All stub articles","Integer factorization algorithms","Number theory stubs"],"tag_line":"In number theory, the continued fraction factorization method (CFRAC) is an integer factorization algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"euler's-factorization-method","_score":0,"_source":{"description":"Euler's factorization method is a technique for factoring a number by writing it as a sum of two squares in two different ways. For example the number  can be written as  or as  and Euler's method gives the factorization .\nThe idea that two distinct representations of an odd positive integer may lead to a factorization was apparently first proposed by Marin Mersenne. However, it was not put to use extensively until Euler one hundred years later. His most celebrated use of the method that now bears his name was to factor the number , which apparently was previously thought to be prime even though it is not a pseudoprime by any major primality test.\nEuler's factorization method is more effective than Fermat's for integers whose factors are not close together and potentially much more efficient than trial division if one can find representations of numbers as sums of two squares reasonably easily. Euler's development ultimately permitted much more efficient factoring of numbers and, by the 1910s, the development of large factor tables going up to about ten million. The methods used to find representations of numbers as sums of two squares are essentially the same as with finding differences of squares in Fermat's factorization method.\nThe great disadvantage of Euler's factorization method is that it cannot be applied to factoring an integer with any prime factor of the form 4k + 3 occurring to an odd power in its prime factorization, as such a number can never be the sum of two squares. Even odd composite numbers of the form 4k + 1 are often the product of two primes of the form 4k + 3 (e.g. 3053 = 43 × 71) and again cannot be factored by Euler's method.\nThis restricted applicability has made Euler's factorization method disfavoured for computer factoring algorithms, since any user attempting to factor a random integer is unlikely to know whether Euler's method can actually be applied to the integer in question. It is only relatively recently that there have been attempts to develop Euler's method into computer algorithms for use on specialised numbers where it is known Euler's method can be applied.","alt_names":["http://es.wikipedia.org/wiki/M%C3%A9todo_de_factorizaci","Euler's factorization method","( a - c ) · ( a + c ) = ( d - b ) · ( d + b","- Euler's factorization method :","00202266a082535f384cbc6c9ce1e0 ...","039035cf7047ac7b05162ea604e51b ...","37a57b860273997e1a81834b5fecb ...","Euler s factorization method","Euler s factorization method Wikipedia the free encyclopedia","Euler's factoring method","Euler's factorizati method","Euler's factorization method - Wikipedia, the ...","Euler's factorization method - Wikipedia, the free encyclopedia","Euler`s factorization method","Eulerova faktorizační metoda","Metodo di fattorizzazione di Eulero","Método de factorización de Euler - Wikipedia, la enciclopedia","Wikipedia article Euler's Factorization method","Wikipedia article Euler's factorization method","cs:Eulerova faktorizační metoda","es:Método de factorización de Euler","http://cs.wikipedia.org/wiki/Eulerova_faktoriza%C4%8Dn","http://en.wikipedia.org/wiki/Euler %27s_factorization_method","http://en.wikipedia.org/wiki/Euler%27s_factorization_method","http://en.wikipedia.org/wiki/Euler's_factorization_method","http://it.wikipedia.org/wiki/Metodo_di_fattorizzazione_di_Eulero"],"name":"Euler's factorization method","categories":["All articles with unsourced statements","Articles with unsourced statements from July 2013","Integer factorization algorithms"],"tag_line":"Euler's factorization method is a technique for factoring a number by writing it as a sum of two squares in two different ways."}}
,{"_index":"throwtable","_type":"algorithm","_id":"shanks'-square-forms-factorization","_score":0,"_source":{"description":"Shanks's square forms factorization is a method for integer factorization devised by Daniel Shanks as an improvement on Fermat's factorization method.\nThe success of Fermat's method depends on finding integers  and  such that , where  is the integer to be factored. An improvement (noticed by Kraitchik) is to look for integers  and  such that . Finding a suitable pair  does not guarantee a factorization of , but it implies that  is a factor of , and there is a good chance that the prime divisors of  are distributed between these two factors, so that calculation of the greatest common divisor of  and  will give a non-trivial factor of .\nA practical algorithm for finding pairs  which satisfy  was developed by Shanks, who named it Square Forms Factorization or SQUFOF. The algorithm can be expressed in terms of continued fractions, or in terms of quadratic forms. Although there are now much more efficient factorization methods available, SQUFOF has the advantage that it is small enough to be implemented on a programmable calculator.","alt_names":["Shanks' square forms factorization","...more on Wikipedia about Shanks' square forms factorization","50202288c672fe863d31afb4f5d67 ...","Factorization quadrado do formulário dos Shanks","Facturización cuadrada de la forma de las cañas","SQUFOF","Scomposizione in fattori quadrata della forma delle tibie","Shanks kvadrerar bildar factorization","Shanks square forms factorization","Shanks%27_square_forms_factorization","Shanks'","Shanks' Square Forms Factorization - Wikipedia, The Free Encyclopedia","Shanks' square form factorization","Shanks' square forms","Shanks' square forms factorization - Wikipedia :: The free encyclopedia","Shanks' square forms factorization - Wikipedia, the free encyclopedia","Shanks'formes square factorization","Square forms factorization","Vierkante de vormontbinding in factoren van stelen","What is Shanks' square forms factorisation's example","Wikipedia article SQUFOF","Wikipedia article Shanks' square forms factorization","en.wikipedia.org/wiki/SQUFOF","http://en.Liarpedia.org/wiki/Shanks%27_square_forms_factorization","http://en.wikipedia....s_factorization","http://en.wikipedia.org/wiki/SQUFOF","http://en.wikipedia.org/wiki/Shanks %27_square_forms_factorization","http://en.wikipedia.org/wiki/Shanks%27_square_forms_factorization","http://en.wikipedia.org/wiki/Shanks%27_square_forms_factorization#Algorithm","http://en.wikipedia.org/wiki/Shanks'_squ","http://en.wikipedia.org/wiki/Shanks'_square_forms_factorization","Τετραγωνική παραγοντοποίηση μορφής κνημών","Факторизация формы хвостовиков квадратная","سيقان مربّعة شكل تحليل إلى عوامل","すねの正方形の形態の因数分解","小腿的方形的形式工厂化","小腿的方形的形式工廠化","정강이의 정연한 모양 인수 분해"],"name":"Shanks' square forms factorization","categories":["All articles lacking in-text citations","All articles needing expert attention","Articles lacking in-text citations from March 2015","Articles needing expert attention from November 2008","Articles needing expert attention with no reason or talk parameter","Integer factorization algorithms","Mathematics articles needing expert attention"],"tag_line":"Shanks's square forms factorization is a method for integer factorization devised by Daniel Shanks as an improvement on Fermat's factorization method."}}
,{"_index":"throwtable","_type":"algorithm","_id":"basic-sequential-algorithmic-scheme","_score":0,"_source":{"description":"The basic sequential algorithmic scheme (BSAS) is a very basic clustering algorithm that is easy to understand. In the basic form vectors are presented only once and the number of clusters is not known at priori. What is needed is the dissimilarity measured as the distance d (x, C) between a vector point x and a cluster C, threshold of dissimilarity Θ and the number of maximum clusters allowed q. The idea is to assign every newly presented vector to an existing cluster or create a new cluster for this sample, depending on the distance to the already defined clusters. As pseudocode, the algorithm looks like the following:\n\n 1. m = 1; Cm = {x1}; // Init first cluster = first sample     \n 2. for every sample x from 2 to N      \n   a. find cluster Ck such that min d(x, Ck)     \n   b. if d(x, Ck) > Θ AND (m < q)      \n     i. m = m + 1; Cm = {x} // Create a new cluster      \n   c. else           i. Ck = Ck + {x} // Add sample to the nearest cluster      \n     ii. Update representative if needed      \n 3. end algorithm\n\nAs can be seen the algorithm is simple but still quite efficient. Different choices for the distance function lead to different results and unfortunately the order in which the samples are presented can also have a great effect to the final result. What’s also very important is a correct value for Θ. This value has a direct effect on the number of formed clusters. If Θ is too small unnecessary clusters are created and if too large a value is chosen less than required number of clusters are formed.\nOne detail is that if q is not defined the algorithm ‘decides’ the number of clusters on its own. This might be wanted under some circumstances but when dealing with limited resources a limited q is usually chosen. Also, BSAS can be used with a similarity function simply by replacing the min function with max.\nThere exists a modification to BSAS called modified BSAS (MBSAS), which runs twice through the samples. It overcomes the drawback that a final cluster for a single sample is decided before all the clusters have been created. The first phase of the algorithm creates the clusters (just like 2b in BSAS) and assigns only a single sample to each cluster. Then the second phase runs through the remaining samples and classifies them to the created clusters (step 2c in BSAS).","alt_names":[],"name":"Basic sequential algorithmic scheme","categories":["Algorithms and data structures stubs","All articles covered by WikiProject Wikify","All articles needing additional references","All articles needing cleanup","All articles with too few wikilinks","All stub articles","Articles covered by WikiProject Wikify from March 2014","Articles needing additional references from May 2014","Articles needing cleanup from February 2014","Articles with too few wikilinks from March 2014","Cleanup tagged articles with a reason field from February 2014","Computer science stubs","Data clustering algorithms","Wikipedia pages needing cleanup from February 2014"],"tag_line":"The basic sequential algorithmic scheme (BSAS) is a very basic clustering algorithm that is easy to understand."}}
,{"_index":"throwtable","_type":"algorithm","_id":"skipjack-(cipher)","_score":0,"_source":{"description":"In cryptography, Skipjack is a block cipher—an algorithm for encryption—developed by the U.S. National Security Agency (NSA). Initially classified, it was originally intended for use in the controversial Clipper chip. Subsequently, the algorithm was declassified and now provides a unique insight into the cipher designs of a government intelligence agency.\n\n","alt_names":["- Skipjack (cipher) :","-> Leggi tutto l'articolo su 'Skipjack'","...Wikipedia Skipjack (cryptographie)","...mehr auf Wikipedia über Skipjack","...more on Wikipedia about Skipjack (cipher)","Background Info @ Wikipedia","History of Skipjack","SKIPJACK cipher","SkipJack","Skipjack (cipher)","Skipjack (cipher) - Wikipedia, the free enc","Skipjack (cipher) - Wikipedia, the free encyclopedia","Skipjack (cipher) - Wikipedia, the free encyclopedia ...","Skipjack (cryptographie) - W...","Skipjack (cryptographie) - Wikipédia","Skipjack - Wikipedia","Skipjack bei der wikipedia","Skipjack cipher","Skipjack cipher Wikipedia the free encyclopedia","Skipjack encryption algorithm","Skipjack – Wikipedia","Skipjack(w)","Skipjack-Algorithmus","Skipjack_(cipher)","Skipjack加密","What is Skipjack algorithm in pop culture","Wikipedia :: SkipJack (NSA)","Wikipedia article Skipjack (cipher)","Wikipedia article on Skipjack","Wikipedia entry for Skipjack (cipher)","Wikipedia, Skipjack (cipher)","Wikipedia-Artikel Skipjack","Wikipedia-Seite zu 'Skipjack'","Wikipedia: Skipjack (cipher)","Wikipediaで「スキップジャック (暗号)」を調べる","article Skipjack (cipher)","artículo de Wikipedia Skipjack","en.wikipedia.org/wiki/Skipjack_%28cipher%29","en:Skipjack (cipher)","es:Skipjack","http://de.wikipedia.org/wiki/Skipjack","http://en.wikipedia.org/wiki/Skipjack_%28cipher%29","http://en.wikipedia.org/wiki/Skipjack_(cipher)","http://en.wikipedia.org/wiki/Skipjack_(c…","http://en.wikipedia.org/wiki/Skipjack_encryption_algorithm","http://es.wikipedia.org/wiki/Skipjack","http://fr.wikipedia.org/wiki/Skipjack_%28cryptographie%29","http://it.wikipedia.org/wiki/Skipjack","http://pl.wikipedia.org/wiki/Skipjack_(algorytm)","http://ru.wikipedia.org/wiki/Skipjack","it:Skipjack","ja:スキップジャック (暗号)","l'article de Wikipédia Skipjack (cryptographie)","pl:Skipjack (algorytm)","ru:Skipjack","skipjack (cipher) - Wikipedia, the free encyclopedia","skipjack加密","Википедии статью Skipjack","スキップジャック (暗号)","スキップジャック (暗号) - Wikipedia","ｽｷｯﾌﾟｼﾞｬｯｸ_(暗号)-wikipedia"],"name":"Skipjack (cipher)","categories":["All articles lacking in-text citations","All articles with specifically marked weasel-worded phrases","Articles lacking in-text citations from March 2009","Articles with specifically marked weasel-worded phrases from January 2014","Block ciphers","National Security Agency cryptography","Pages using duplicate arguments in template calls","Type 2 encryption algorithms"],"tag_line":"In cryptography, Skipjack is a block cipher—an algorithm for encryption—developed by the U.S. National Security Agency (NSA)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"special-number-field-sieve","_score":0,"_source":{"description":"In number theory, a branch of mathematics, the special number field sieve (SNFS) is a special-purpose integer factorization algorithm. The general number field sieve (GNFS) was derived from it.\nThe special number field sieve is efficient for integers of the form re ± s, where r and s are small (for instance Mersenne numbers).\nHeuristically, its complexity for factoring an integer  is of the form:\n\nin O and L-notations.\nThe SNFS has been used extensively by NFSNet (a volunteer distributed computing effort), NFS@Home and others to factorise numbers of the Cunningham project; for some time the records for integer factorisation have been numbers factored by SNFS.\n^ Pomerance, Carl (December 1996), \"A Tale of Two Sieves\" (PDF), Notices of the AMS 43 (12), pp. 1473–1485","alt_names":["-> Read more about Special number field sieve","...more on Wikipedia about Special number field sieve","1b9f95abdb03f217dcf2a4dfc3e59 ...","Algoritmo especial de criba del cuerpo de números","Choice of parameters","Criba del campo de los números especiales","Criba especial del cuerpo de números - Wikipedia, la","Crible spécial de corps de nombres (SNFS)","Definición de Criba especial del cuerpo de números","Details of method","Limitations of algorithm","SNFS","Special Number Field Sieve","Special Number Field Sieve (SNFS)","Special Number Field Sieve - Wikipedia, The Free Encyclopedia","Special number field sieve","Special number field sieve - Wikipedia, the free encyclopedia","Wikipedia (Special number field sieve)","Wikipedia article ''Special number field sieve''","Wikipedia article Erityinen lukukuntaseula","Wikipedia article Special number field sieve","Wikipedia article on Special number field sieve","Wikipedia entry for Special number field sieve","a0742d824087ced755b3637040dee1 ...","artículo de Wikipedia Criba del campo de los","e 1 + o ( 1 ) 32 9 log n","en.wikipedia.org/wiki/Special_number_field_sieve","fr:Algorithme de factorisation par crible sur les","http://en.wikiped...number field sieve","http://en.wikipedia.org/wiki/Special number field","http://en.wikipedia.org/wiki/Special..._of_parameters","http://en.wikipedia.org/wiki/Special_num","http://en.wikipedia.org/wiki/Special_number_field_sieve","http://es.wikipedia.org/wiki/Criba_especial_del_cuerpo_de_n%C3%BAmeros","special number field sieve","special_number_field_sieve","spèsjal numbeâh field sieve","καταχώρηση στην wikipedeia"],"name":"Special number field sieve","categories":["Integer factorization algorithms"],"tag_line":"In number theory, a branch of mathematics, the special number field sieve (SNFS) is a special-purpose integer factorization algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"saville","_score":0,"_source":{"description":"SAVILLE is a classified NSA Type 1 encryption algorithm. It is used broadly, often for voice encryption, and implemented in a large number of encryption devices.\nLittle is known publicly about the algorithm itself due to its classified nature and inclusion in the NSA's Suite A. Some documentation related to the KYK-13 fill device and statements made by military officials suggest that SAVILLE has a 128-bit key. On the AIM microchip, it runs at 4% of the clock rate (compare DES at 76% and BATON at 129%). The Cypris chip mentions 2 modes; specifications for Windster and Indictor specify that they provide Saville I.\nSome devices and protocols that implement SAVILLE:\nThe VINSON family (voice encryption)\nAPCO Project 25 (single-channel land mobile radios) (Saville has algorithm ID 04)\nVersatile encryption chips: AIM, Cypris, Sierra I/II, Windster, Indictor, Presidio, Railman","alt_names":["SAVILLE","- SAVILLE :","...mehr auf Wikipedia über SAVILLE","...more on Wikipedia about SAVILLE","SAVILLE - <b>Wikipedia</b>","SAVILLE - Wikipedia","SAVILLE - Wikipedia, the free encyclopedia","SAVILLE Wikipedia the free encyclopedia","SAVILLE in Wikipedia","SAVILLE on wikipedia.org","SAVILLE; it is used under the","Saville (cipher)","Wikipedia article SAVILLE","Wikipedia article Saville (cipher)","Wikipedia article on SAVILLE","Wikipedia-Artikel SAVILLE","de:SAVILLE","en.wikipedia.org/wiki/SAVILLE","http://de.wikipedia.org/wiki/SAVILLE","http://en.wikipedia.org/wiki/SAVILLE","saville - Wikipedia, the free encyclopedia","yago-res:SAVILLE"],"name":"SAVILLE","categories":["All articles lacking sources","All stub articles","Articles lacking sources from February 2008","Block ciphers","Cryptography stubs","Type 1 encryption algorithms"],"tag_line":"SAVILLE is a classified NSA Type 1 encryption algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"adleman–pomerance–rumely-primality-test","_score":0,"_source":{"description":"In computational number theory, the Adleman–Pomerance–Rumely primality test is an algorithm for determining whether a number is prime. Unlike other, more efficient algorithms for this purpose, it avoids the use of random numbers, so it is a deterministic primality test. It is named after its discoverers, Leonard Adleman, Carl Pomerance, and Robert Rumely. The test involves arithmetic in cyclotomic fields.\nIt was later improved by Henri Cohen and Hendrik Willem Lenstra, commonly referred to as APR-CL. It can test primality of an integer n in time:","alt_names":[],"name":"Adleman–Pomerance–Rumely primality test","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Number theory stubs","Primality tests"],"tag_line":"In computational number theory, the Adleman–Pomerance–Rumely primality test is an algorithm for determining whether a number is prime."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sieve-of-eratosthenes","_score":0,"_source":{"description":"In mathematics, the sieve of Eratosthenes (Ancient Greek: κόσκινον Ἐρατοσθένους, kóskinon Eratosthénous), one of a number of prime number sieves, is a simple, ancient algorithm for finding all prime numbers up to any given limit. It does so by iteratively marking as composite (i.e., not prime) the multiples of each prime, starting with the multiples of 2.\nThe multiples of a given prime are generated as a sequence of numbers starting from that prime, with constant difference between them that is equal to that prime. This is the sieve's key distinction from using trial division to sequentially test each candidate number for divisibility by each prime.\nThe sieve of Eratosthenes is one of the most efficient ways to find all of the smaller primes. It is named after Eratosthenes of Cyrene, a Greek mathematician; although none of his works have survived, the sieve was described and attributed to Eratosthenes in the Introduction to Arithmetic by Nicomachus.\nThe sieve may be used to find primes in arithmetic progressions.","alt_names":["Eratosthenova síta","Sieving","Crivo de Eratóstenes","La criba de Eratóstenes","prime number sieve","sieve of eratosthenes","Sieb_des_Eratosthenes","'Sieve of Eratosthenes'","'de Zeef van Eratosthenes '","'la criba de Eratosthenes","'κόσκινό'","( решето Эратосфена )","(External) sieve of Eratosthenes","(Sieve of Eratosthenes)","(animation)","(http://de.wikipedia","+ ¿Cómo se hace la criba de Eratóstenes?","- Sieve of Eratosthenes :","-> Leggi l'articolo completo su Crivello di Eratostene","-> Read the article about 'Sieve of Eratosthenes'","...Wikipedia Criba de Eratóstenes","...Wikipedia Crivello di Eratostene","...Wikipedia Eratosthenes såll","...Wikipedia Sito Eratostenesa","...mehr auf Wikipedia über Sieb des Eratosthenes","...more on Wikipedia about Sieve of Eratosthenes","1 Αλγόριθμος","1 算式","1.1 Παράδειγμα","1.1 步骤","15429","2 Algorithm complexity and implementation","2 Algorithm details and complexity","2 Πολυπλοκότητα αλγορίθμου και υλοποίηση","2 总结","2.1 范例","2.2 孪生质数的公式","2.3 黎曼猜想的素数公式与埃拉托斯特尼筛法关系","2.4 哥德巴赫猜想的合理框架","2.5 范例","3 Mnemonic","3 Το Κόσκινο του Όιλερ","4 Euler's Sieve","4 Euler's sieve","<http://de.wikipedia.org/wiki/Sieb_des_Eratosthenes>","Algorithm details and complexity","Ang salaan ng Eratosthenes","Animation von Wikipedia.de","B. http://de","Background information on sieving","Ciurul lui Eratostene","Ciurul lui Eratosthenes","Ciurul lui eratostene","Ciurului lui Erathostenes","Ciurului lui Eratostene","Cool Applet for the Sieve of Eratosthenes!","Criba de Erastóstenes","Criba de Eratostenes","Criba de Eratosthenes","Criba de Eratstenes la enciclopedia libre","Criba de EratÃ³stenes - Wikipedia, la enciclopedia libre","Criba de Eratóstenes","Criba de Eratóstenes - Wikipedia, la enciclopedia libre","Criba de Eratóstenes wikipedia []","Criba de Eratóstenes.","Crible d'?ratosth?ne - Wikip?dia","Crible d'Erathosthène","Crible d'Eratosthène","Crible d'Ératosthène","Crible d'Ératosthène - Wikipédia","Crible_d%27%C3%89ratosth%C3%A8ne","Criveddu d'EratÃ²stini - Wikipedia","Criveddu d'Eratòstini","Criveddu d'Erat├▓stini - Wikipedia","Crivello","Crivello di Eratostene","Crivello di Eratostene - Wikipedia","Crivello di Eratostene Wikipedia []","Crivello di Eratostene.","Crivo De Eratóstenes","Crivo de Erastótenes","Crivo de Erastótenes - Wikipedia","Crivo de Erathosthenes","Crivo de Eratóstenes - PT","Crivo de Eratóstenes - Wikipédia, a enciclopédia livre","Crivo de Eratóstenes do Wikipedia","Crivo de Eratóstenes na Wikipedia","Crivo de Eratóstenes – Wikipédia, a enciclopédia livre","Crivo de Eratóstenes.","Crivo de Eratósthenes","Crivo na Wikipédia","Các Sàng của Eratosthenes","Das Sieb des Eratosthenes","Definición de Criba de Eratóstenes más completo","Demo zum Sieb des Eratosthenes","Descrizione in Wikipedia","Deze methode","Drobná inšpirácia","Erastostheneen seula","Erastosthenes Sieve","Erastosthenes' Sieve","Erastotheneen seula","Erastothenovo síto","Erat-Osthenes","Eratastena sietu","Erathostenes såll","Erathostenes' sieve","Erathosthenes' zeef","Erathosthenes筛","Eratostano rėtį","Eratosten kalburu","Eratosten kalburu - Vikipedi","Eratostena siets","Eratostene-02/Wikipedia","Eratosteno rėtis","Eratosteno rėtis – Vikipedija","Eratostenovega rešeta","Eratostenovho sita","Eratostenovo sito","Eratostenovo sito (wiki eng)","Eratostenovo sito - Wikipedija, prosta enciklopedija","Eratostenovo síto","Eratosthanes's sieve","Eratosthene's Sieve","Eratostheneen seula","Eratostheneen seulalla","Eratostheneen seulalle","Eratostheneen_seulalla","Eratosthenes 'Sieve","Eratosthenes Information","Eratosthenes Sieve","Eratosthenes Sieve algorithm","Eratosthenes Yöntemi","Eratosthenes sieve","Eratosthenes sieve.","Eratosthenes sil","Eratosthenes såll","Eratosthenes की चलनी","Eratosthenes' Sieve","Eratosthenes' method","Eratosthenes' si","Eratosthenes' si - Wikipedia, den frie e...","Eratosthenes' si - Wikipedia, den frie encyklopædi","Eratosthenes' sieve","Eratosthenes' sieves","Eratosthenes' sil","Eratosthenes' såll","Eratosthenes's Sieve","Eratosthenes's sieve","Eratosthenes?Sieve","Eratosthenes´ Sieve","Eratosthenes筛选法","Eratosthenova síta.","Eratosthenovo síto","Eratosthenovo síto - Wikipedie","Eratosthenovo síto - Wikipedie, otevřená encyklopedie","Eratostēna siets","Eratoszthenesz szitaja","Eratoszthenész módszerének","Eratoszthenész szitája","Eratoszthenész szitáját","Eratoszthenészi szitával","Eratothenes' Sieve","Eratothenese sõel","Eratsothene's sieve","Eratóstenes tamiz","Erostathenes såld","Euler's Sieve","Euler's sieve","Exemple...","Find Prime & Composite Numbers","Finding Prime Numbers - demo","Formula forFinding all Prime Numbers","How to get prime numbers","If you want it to go faster, there","Il crivello di Eratostene","Il crivello di Eratostene è un antico procedimento","Informacion del Algoritmo, pincha aqui","Inventato da Eratostene di Cirene","Kribrilo de Eratosteno","Kribrilo de Eratosteno - Vikipedio","La Criba de Eratóstenes","La criba de Erastótenes","La criba de eratóstenes","Le crible d'Erathostène","Le crible d'Eratosthène","Licht aus! Spot an!","Mmm.. selects only the primest of all numbers","O Crivo de Eratóstenes","Peneira de [wikipedia Eratóstenes]","Peneira ou Eratóstenes","Pie of Pie","Prime generating","Primzahlen-Sieb","Primzahlen-Sucher","Read More About sieve of eratosthenes - wikipedia the","Read More sieve of eratosthenes wikipedia the free","Saringan Erathosthenes","Saringan Eratosthenes","Saringan Eratosthenes - Wikipedia bahasa Indonesia ...","Saringan Eratosthenes - Wikipedia bahasa Indonesia, ensiklopedia bebas","Saringan Eratosthenes yang","Saringan Eratosthenes.","Saringan [wikipedia Eratosthenes]","Saringan atau Eratosthenes","Screening method","Sedàs d'Eratòstenes","See the animation at wikipedia","Seive of Erastosthenes","Seive of Eratosthenes","Setaccio o Eratostene","Si eve of Eratosthenes , an algorithm for locating","Siass d'Eratòstene - Wikipedia an piemontèis, l'enciclopedìa","Sicie Eratostenesa","Sieb der Eratosthenes","Sieb des Erastothenes","Sieb des Erathosthenes","Sieb des Erathosthenes (Wikipedia)","Sieb des Eratostenes","Sieb des Eratosthenes","Sieb des Eratosthenes - Wikipedia","Sieb des Eratosthenes ? Wikipedia","Sieb des Eratosthenes – Wikipedia","Sieb des Eratosthenes-Algorithmus","Sieb des Eratosthenes.","Sieb oder Eratosthenes","Sieb von Eratosthenes","Sieb-Algorithmus","Sieb-des-Eratosthenes","Siebes des Eratosthenes","Siebes von Eratosthenes","Siebs des Eratosthenes","Siebs von","Siebs von Eratosthenes","Sieve Erathosthenes의에","Sieve Of Eratosthenes","Sieve Of Eratosthenes - Wikipedia, The Free Encyclopedia","Sieve Of Eratosthenes.","Sieve af Erathosthenes","Sieve af Eratosthenes","Sieve algorithm","Sieve de Wikipédia [Eratosthène]","Sieve di Eratostene","Sieve oder Eratosthenes","Sieve of","Sieve of Erasthenes","Sieve of Erasthenes-Primes","Sieve of Erasthones","Sieve of Erasthosthenes","Sieve of Erasthosthenes - Wikipedia","Sieve of Erastosthenes","Sieve of Erastothenes","Sieve of Erathostenes","Sieve of Erathosthanes","Sieve of Erathosthenes","Sieve of Eratosthanes","Sieve of Eratosthene","Sieve of Eratosthenes","Sieve of Eratosthenes (Greek)","Sieve of Eratosthenes (primes less than 100)","Sieve of Eratosthenes - Simple English Wikipedia, the free","Sieve of Eratosthenes - Wikipedia, the free ...","Sieve of Eratosthenes - Wikipedia, the free ... The numbers","Sieve of Eratosthenes - Wikipedia, the free encyclop...","Sieve of Eratosthenes - Wikipedia, the free encyclopedia","Sieve of Eratosthenes - Wikipedia, the free encyclopedia (1","Sieve of Eratosthenes - Wikipedia, the free encyclopedia ...","Sieve of Eratosthenes Algorithm","Sieve of Eratosthenes Simple English Wikipedia the free","Sieve of Eratosthenes Wikipedia article","Sieve of Eratosthenes Wikipedia the free encyclopedia","Sieve of Eratosthenes Wikipedia the free encyclopedia - result","Sieve of Eratosthenes [wikipedia]","Sieve of Eratosthenes algorithm","Sieve of Eratosthenes algorithm steps for primes below","Sieve of Eratosthenes i","Sieve of Eratosthenes wikipedia []","Sieve of Eratosthenes – Wikipedia, the free encyclopedia","Sieve of Eratosthenes! Oldest Prime Number Generation Algorithm","Sieve of Eratosthenes's","Sieve of Eratosthenes,","Sieve of Eratosthenes.","Sieve of Eratosthenes1","Sieve of Eratosthenes; it is used under the","Sieve of Eratostheneses","Sieve of Eratostheness","Sieve of Eratostosthenes","Sieve of Eratothenes","Sieve of Erotoshtenes","Sieve of eratosthenes","Sieve or Eratosthenes","Sieve 에라 토 스테 네스의","Sieve 에라 토 스테 네스의보다","Sieve 에라 토 스테 네스의에서","Sieve_of_Eratosthenes","Sieve_of_Eratosthenes Animation","Sieve_of_Eratosthenes.","Sieveは、ウィキペディアのエラトステネス[]を","Sigten af Eratosthenes","Sita Euklidesa","Sita e Eratostenit","Sita_e_Eratostenit","Sito Erastotenesa","Sito Eratostenesa","Sito Eratostenesa czy","Sàng Eratosthenes","Sàng Of Eratosthenes","Sàng của Erathosthenes","Sàng của Eratosthenes","Sàng của Eratosthenes.","Sàng hoặc Eratosthenes","Síto Eratosthenes","THE sieve","Tabla de Criba","Tamis ou Eratosthène","Tamiz o Eratóstenes","Tentu Saringan Eratosthenes","The Sieve","The Sieve Of Eratosthenes","The Sieve of Eratosthene","The Sieve of Eratosthenes","The Sieve of Eratosthenes →","The sieve of Erastosthenes","The sieve of Eratosthenes","This finds all the primes to k","Useful web page","Verfahren von Eratosthenes","Vikipedi'deki Eratosten kalburu","What is algorithm of Eratosthenes' Sieve?","What is algorithm of Sieve of Eratosthenes?","Wikipedia (I know, but the description is valid","Wikipedia (Zeef van Eratosthemes)","Wikipedia - Sieb des Eratosthenes","Wikipedia - Sieve of Eratosthenes","Wikipedia - エラトステネスの篩","Wikipedia No Comments Yet There are no comments","Wikipedia article Criba de Eratóstenes","Wikipedia article Cribratum Eratosthenis","Wikipedia article Criveddu d'Eratòstini","Wikipedia article Crivello di Eratostene","Wikipedia article Crivo de Eratóstenes","Wikipedia article Eratostenovo sito","Wikipedia article Eratosthenes såll","Wikipedia article Eratosthenes' si","Wikipedia article Eratoszthenész szitája","Wikipedia article Kribrilo de Eratosteno","Wikipedia article Sedàs d'Eratòstenes","Wikipedia article Siass d'Eratòstene","Wikipedia article Sieve of Eratosthenes","Wikipedia article Sita e Eratostenit","Wikipedia article Sito Eratostenesa","Wikipedia article on Criba de Eratóstenes","Wikipedia article on Sieve method","Wikipedia article on Sieve of Eratosthenes","Wikipedia article on the Sieve of Eratosthenes","Wikipedia article Κόσκινο του Ερατοσθένη","Wikipedia article Ератостеново сито","Wikipedia article Решето Ератосфена","Wikipedia article Решето на Ератостен","Wikipedia article ერატოსთენეს საცერი","Wikipedia article 에라토스테네스의 체","Wikipedia entry for Sieve of Eratosthenes","Wikipedia l'articolo Crivello di Eratostene","Wikipedia on Sieve of Eratosthenes","Wikipedia on the Sieve of Eratosthenes","Wikipedia page about the Sieve of Eratosthenes","Wikipedia エラトステネスの篩","Wikipedia's Sieve Article","Wikipedia-Artikel Sieb des Eratosthenes","Wikipedia-Seite zu 'Sieb des Eratosthenes'","Wikipedia-Sieve of Eratosthenes","Wikipedia: Criba de Eratóstenes","Wikipedia: Sieve of Erathosthenes","Wikipedia: Sieve of Eratosthenes","Wikipedia: Sito_Eratostenesa","Wikipedia:en:Sieve of Eratosthenes","Wikipedia:エラトステネスの篩","Wikipedia（エラトステネスの篩）","Wikipédia artigo Crivo de Eratóstenes","Wikpedia animation of the sieve process","Zeef of Eratosthenes","Zeef van Erathosthenes","Zeef van Eratosthenes","Zeef van Eratosthenes - Wikipedia","a demonstration of the Sieve of Eratosthenes","a general explanation of the algorithm I used","a sieve borrowed from Erastosthenes","a sieve of Eratosthenes in Haskell","algorithm for generating prime numbers","algoritma Sieve of Eratosthenes","algoritmus na hľadanie prvočísel","algorytmu Eratostenesa","aller Primzahlen kleiner","animation of this algorithm in the Wikipedia article","ar:غربال إراتوستينس","article Wikipédia du Crible d'Ératosthène","article Wikipédia du Crible d'Ératosthène en anglais","article on the Sieve","artículo de Wikipedia Criba de Eratostenes","artículo de Wikipedia Criba de Eratóstenes","at this wiki site","caminhada de Eratosthenes","can be found on Wikipedia.","ciuru e aici","ciurul lui Eratosthenes","ciurul lui eratostene","complexity O(n * (log n) * (log log n","criba","criba de Erastóstenes","criba de Eratóstenes","criba de Eratóstenes.","criba de eratostenes","criba de eratóstenes","crible d'Erastophène","crible d'Erathosphène","crible d'Erathosthenes","crible d'Erathostène","crible d'Eratosthene","crible d'Eratosthène","crible d'Eratosthène.","crible d'algorithme d'Eratosthène","crible d'Érastothène","crible d'Ératosthène","crivello","crivello dei numeri primi","crivello di","crivello di Erastotene","crivello di Eratostene","crivo de Erastótenes","crivo de Eratosthenes","crivo de Eratóstenes","crivo de erastótenes","crossing-off of multiples","das Sieb des Eratosthenes","das Siebes von Eratosthenes","de zeef van Eratosthenes","de.wikipedia.org/wik...ieb_des_Eratosthenes","de.wikipedia.org/wiki/Sieb_des_Eratosthenes","del Crivello di Eratostene","die Anleitung auf Wikipedia","e http://de.wikipedia.org/wiki/Sieb des","el sedàs d'Eratòstenes","el:Κόσκινο του Ερατοσθένη","eliminating the multiples of every number","en.wikipedia.org/...Sieve_of_Eratosthenes","en.wikipedia.org/wiki/Sieve...","en.wikipedia.org/wiki/Sieve_of_Eratosthenes","eranthenos Sieb.","eranthenos salaan.","eranthenos saringan.","eranthenos sieve","eranthenos сита.","eranthenos 쪽에서","eranthenosふるい","eranthenos筛","eranthenos篩","erathostenes såll","es http://en.wikipedia.org/","es. http://en.wikipedia.org/wiki/Sieve_","es.wikipedia.org/...Criba_de_Erat%C3%B3stenes","gesiebt","good 'ole sieve","his sieve algorithm","http//de.wikipedia.org/wiki/Sieb_des_Eratosthenes","http://bg.wikipedia....то_на_Ератостен","http://bg.wikipedia.org/wiki/Решето_на_Ератостен","http://bit.ly/c0Dlls","http://bs.wikipedia.org/wiki/Eratostenovo_sito","http://ca.wikipedia.org/wiki/Sed%C3%A0s_d","http://cs.wikipedia....tosthenovo_s%C3%ADto","http://cs.wikipedia.org/wiki/Eratosthenovo_s%C3%ADto","http://cs.wikipedia.org/wiki/Eratosthenovo_síto","http://de.wikipedia.org/wiki/Si eb_des_Eratosthenes","http://de.wikipedia.org/wiki/Sieb_des_Er","http://de.wikipedia.org/wiki/Sieb_des_Eratosthenes","http://de.wikipedia.org/wiki/Sieb_des_Er…","http://de.wikipedia.org/wiki/SiebdesEratosthenes","http://el.wikipedia.org/wiki/Κόσκινο_του_Ερατοσθένη","http://en.wikipedia....of_Eratosthenes","http://en.wikipedia....of_eratosthenes","http://en.wikipedia.o...Sieve_of_Eratosthenes","http://en.wikipedia.org/wiki/ Sieve_of_Eratosthenes","http://en.wikipedia.org/wiki/Eratosthenes_Sieve","http://en.wikipedia.org/wiki/Sieve of Eratosthenes","http://en.wikipedia.org/wiki/Sieve%5Fof%5FEratosthenes","http://en.wikipedia.org/wiki/Sieve\\.of\\.Eratosthenes","http://en.wikipedia.org/wiki/Sieve_o...enes#Algorithm","http://en.wikipedia.org/wiki/Sieve_of_E ... complexity","http://en.wikipedia.org/wiki/Sieve_of_E ... ementation","http://en.wikipedia.org/wiki/Sieve_of_Er","http://en.wikipedia.org/wiki/Sieve_of_Erastothenes","http://en.wikipedia.org/wiki/Sieve_of_Eratost...","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes -","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes By trebliH","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes Search for","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity_a","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity_a=","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity_an","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity_and","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity_and=","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity_and_implementation","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity_and_implementation.","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_details_and_complexity","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Euler.27s","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Euler.27s_","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Euler.27s_Sieve","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Euler.27s_sieve","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Example","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Pseudocode","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#cite_note-7","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).","http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes.","http://en.wikipedia.org/wiki/Sieve_of_Er…","http://en.wikipedia.org/wiki/Sieve_of_eratosthenes","http://en.wikipedia.org/wiki/Sieve_of_er…","http://en.wikipedia.org/wiki/S​ieve_of_Eratosthenes","http://es.wikipedia.org/wiki/Criba_de_Erat%C3%B","http://es.wikipedia.org/wiki/Criba_de_Erat%C3%B3stenes","http://es.wikipedia.org/wiki/Criba_de_Eratostenes","http://es.wikipedia.org/wiki/Criba_de_Eratóstenes","http://es.wikipedia.org/wiki/Criba_de_Eratóstenes#Pseudoc.C3","http://es.wikipedia.org/wiki/Criba_de_Er…","http://fi.wikipedia.org/wiki/Eratostheneen_seula","http://fr.wikipedia.org/wiki/Cribl [...] th%C3","http://fr.wikipedia.org/wiki/Crible_...A8ne_en_Python","http://fr.wikipedia.org/wiki/Crible_...atosth%C3","http://fr.wikipedia.org/wiki/Crible_d%27%C","http://fr.wikipedia.org/wiki/Crible_d%27%C3","http://fr.wikipedia.org/wiki/Crible_d%27…","http://fr.wikipedia.org/wiki/Crible_d'% ... th%C3","http://fr.wikipedia.org/wiki/Crible_d'%C3%89ratosth","http://fr.wikipedia.org/wiki/Crible_d'%C…","http://fr.wikipedia.org/wiki/Crible_d'Er…","http://fr.wikipedia.org/wiki/Crible_d'Ératosthène","http://goo.gl/0Lk0g","http://he.wikipedia.org/wiki/הנפה_של_ארטוסתנס","http://hr.wikipedia.org/wiki/Eratostenovo_sito","http://hu.wikipedia.org/wiki/Eratoszthe … it%C3","http://hu.wikipedia.org/wiki/Eratoszthen%C3%A9sz_szit","http://id.wikipedia.org/wiki/Saringan_Eratosthenes","http://id.wikipedia.org/wiki/S​aringan_Eratosthenes","http://it.wikipedia....o_di_Eratostene","http://it.wikipedia.org/wiki/Crivel...isual_basic_6.0","http://it.wikipedia.org/wiki/Crivell...tene#Algoritmo","http://it.wikipedia.org/wiki/Crivello di Eratostene","http://it.wikipedia.org/wiki/Crivello_d ... zione_in_C","http://it.wikipedia.org/wiki/Crivello_di_Eratostene","http://it.wikipedia.org/wiki/Crivello_di_Eratostene#Algoritmo","http://it.wikipedia.org/wiki/Crivello_di…","http://ja.wikipedia.org/wiki/エラトステネスのふるい","http://ja.wikipedia.org/wiki/エラトステネスの篩","http://nl.wikipedia.org/wiki/Zeef_van_Eratosthenes","http://nl.wikipedia.org/wiki/Z​eef_van_Eratosthenes","http://no.wikipedia.org/wiki/Eratosthenes'_sil","http://ping.fm/ma7Bh","http://pl.wikipedia....to_Eratostenesa","http://pl.wikipedia.org/wiki/Sito_E...","http://pl.wikipedia.org/wiki/Sito_Eratostenesa","http://pms.wikipedia.org/wiki/Siass_d'Erat%C3","http://pt.wikipedia...._de_Eratóstenes","http://pt.wikipedia....rat%C3%B3stenes","http://pt.wikipedia.org/wiki/Crivo_de_Erat%C3%B3stenes","http://pt.wikipedia.org/wiki/Crivo_de_Eratóstenes","http://pt.wikipedia.org/wiki/Crivo_de_Er…","http://ro.wikipedia.org/wiki/Ciurul_lui_Eratostene","http://ru.wikipedia.org/wiki/Решето_Эрат...","http://ru.wikipedia.org/wiki/Решето_Эратосфена","http://ru.wikipedia.org/wiki/Эратосфена_решето#Pascal","http://scn.wikipedia.org/wiki/Criveddu_d'Erat%C3","http://sk.wikipedia.org/wiki/Eratostenovo_sito","http://sv.wikipedia.org/wiki/Eratosthenes_s%C3%A5ll","http://sv.wikipedia.org/wiki/Eratosthenes_s%E5ll","http://tr.wikipedia.org/wiki/Eratosten_kalburu","http://tr.wikipedia.org/wiki/eratosten_kalburu","http://vi.wikipedia.org/wiki/S%C3%A0ng_Eratosthenes","id.wikipedia.org/wiki/Saringan_Eratosthenes","ieve of Eratosthenes","il crivello di Eratostene","implementación en python en la wikipedia.","interesting to me","it.wikipedia.org/wiki/Crivello_di_Eratostene)","its sieve","j) Sieb des Euler","kaynak wiki","la Criba de Eratóstenes","la criba de Eratóstenes","la:Cribratum Eratosthenis","lagunex.com","lv:Eratostena siets","nl.wikipedia.org/wiki/Zeef_van...","nl.wikipedia.org/wiki/Zeef_van_Eratosthenes","o Crivo de Eratóstenes","ordinary sieve","org/wiki/Sieve_of_Eratosthenes","outlines the algorithm","panala ng Eratosthenes","par le Crible d'Ératosthène","peneira eranthenos.","pl.wikipedia.org/wiki/Sito_Eratostenesa","pms:Siass d'Eratòstene","popis algoritmu na Wikipedii","prime sieve algorithm","principio di Eratostene","real upper bound","salaan ng Erathosthenes","saringan Eratosthenes","saringan Eratosthenes.","sedàs d'Eratòstenes","seive of eratosthenes","setaccio eranthenos.","sh:Eratostenovo sito","sicie Eratostenesa","sieb des eratosthenes","sien af Eratosthenes","sieve algorithm","sieve method.","sieve of Erastothenes","sieve of Erathostenes","sieve of Erathosthenes","sieve of Eratosthenes","sieve of erastothenes","sieve of erathones","sieve of eratosthenes.","sieve or Eratosthenes","sieving method","sigte med Eratosthenes","simple sieve method","simple sieve of Evatosthenes","sita Eratostanesa","sita Eratostenesa","sitem Eratostenesa","sito Erastotenes","sito Erastotenesa","sito Eratostenesa","sito erastotenesa","specific algorithm for solving this problem","sq:Sita e Eratostenit","su Wikipedia in inglese","su algoritmo","sàng","sàng Eratosthenes","sàng của Eratosthenes","sàng eranthenos.","sáldur Eratosthenesar.","síto Eratosthenes","tamis eranthenos.","tamiz de","tamiz eranthenos.","teoreminha da raiz quadrada de N","the Eratosthenes Sieve","the Sieve of","the Sieve of Erastothenes","the Sieve of Eratosthenes","the Sieve of Eratosthenes.","the algorithm on the Wikipedia page","the necessary logic","the sieve of Erastosthenes","the sieve of Eratosthenes","the sieve of erathostenes","to cię zainteresuje","traditional algorithm","ttp://en.wikipedia.org/wiki/Sieve_of_Eratosthenes","unbounded sieve of Eratosthenes","vi:Sàng Eratosthenes","w:Criba de Eratóstenes","w:Sieb_des_Eratosthenes","w:Sieve of Eratosthenes","w:Решето Эратосфена","what its doing","wiki - Sieve of Eratosthenes","wikipedia.org/wiki/Sieve_of_Eratosthenes","wikipedia:エラトステネスの篩","wiki條目在此","yang Saringan Eratosthenes","zeef van Eratosthenes","zeef van Eratosthenes op Wikipedia","~ de.wikipedia.org > Wiki > Sieb des Eratosthenes","«Решето Эратосфена»","ð åøåò î Ý ð à ò îñô","Κόσκινο του Ερατοσθένη","Το Κόσκινο του Ερατοσθένη","Το κόσκινο του Ερατοσθένη","άρθρο Sieve of Eratosthenes","κóσκινο","κόσκινο","σείστρο","Википедии статью Решето Эратосфена","Википедии статью Эратосфена решето","Ератостеново сито","Решета Эратосфена","Решето","Решето Erathosthenes","Решето Ератосфена","Решето Эратосфена","Решето Эратосфена (Википедия)","Решето Эратосфена википедии []","Решето Эратосфена — Википедия","Решето Эратосфена,","Решето Эратосфена.","Решето Эратосфена—Википедия","Решето Эратосфера","Решето на Ератостен","Решето_Эратосфена","Решетото на Ератостен","Сито или Эратосфена","Сквозь решето Эратосфена","Справка из WIKI","алгоритъм за намиране на простите числа съществува","на вид несложный метод","основной статье по алгоритму","очень большой вычислительной мощностью","про простые числа","решета Ератосфена","решета Эратосфена","решета Эратосфена,","решете Эратосфена","решето","решето Эратосфена","решето на Ератостен","решето эратосфена","решетом Эратосфена","сито на Ератостен","ссылочку из Википедии","בנפה של ארטוסתנס","בתיאור שב-וויקיפדיה.","ההנפה ארטוסתנס","הנפה של","הנפה של אטוסתנס","הנפה של ארטוסתנס","הנפה של ארטוסתנס – ויקיפדיה","הנפה של ארסטותנס","הנפה_של_ארטוסתנס","הנפה_של_ארטוסתנס/http://he.wikipedia.org/wiki","ויקיפדיה - 'הנפה של ארטוסתנס'","כברה של ארטוסתנס","מציאת מספרים ראשוניים","נפה של ארטוסטנס","נפה של ארטוסתנס","ط؛ط±ط¨ط§ظ„ ط§ط±ط","غربال إراتوستينس","غربال اراتوستن","غربال اراتوستن - ویکیپدیا","غربال اراتوستنس","पढ़ रखा","परिचित 'चलनी","ইউলারের সিভ","അല്ഗോരിതത്തിലെത്തിച്ചേര്ന്നത്","ഇറാറ്റോസ്തനീസിന്റെ അരിപ്പയും","യുളേഴ്സ് അല്ഗോരിതം","กรอง eranthenos.","กรอง ของ","กรอง ของ Eratosthenes","กรอง ของ Eratosthenes.","กระชอน หรือ Eratosthenes","ซีฟของเอราทอสเทนีส","ตะกร้า ของ Erathosthenes","ตะกร้า ของ Eratosthenes","ตะแกรงของ [วิกิพีเดีย Eratosthenes]","ตะแกรงของเอราทอสธีเนส","ერატოსთენეს საცერი","ერატოსთენეს საცერი - ვიკიპედია","“Sieb”","“Sieve of Eratosthenes”","”решет","「エラトステネスのふるい」","「エラトステネスのふるい」についてWikipediaで調査","「エラトステネスの篩」についてWikipediaで調査","「エラトステネスの篩（ふるい）」","『エラトステネスの篩』Wikipedia","ふるいErathosthenesの","ふるいやエラトステネス","ふるいエラトステネスの","エラストテネスのふるい","エラストテネスの篩法","エラトステネスのふるい","エラトステネスのふるいの","エラトステネスのふるいは","エラトステネスのふるいは、","エラトステネスのふるいを","エラトステネスのふるいプログラム","エラトステネスの篩","エラトステネスの篩 (wikipediaへのリンク)","エラトステネスの篩 - Wikipedia","エラトステネスの篩 – Wikipedia","エラトステネスの篩(sieve of Eratosthenes)","エラトステネスの篩-wikipedia","エラトステネスの篩い","エラトステネスの篩のwiki","エラトステネスの篩（ふるい）","エラトステネスの篩（ふるい） - Wikipedia","エラトステネスの篩（エラトステネスのふるい）","エラトステネスの篩（フリー百科事典『ウィキペディア Wikipedia』）","エラトステネスは、","了埃拉托色尼","分子筛的埃拉托塞尼","在埃拉托斯特尼篩","埃拉托塞尼","埃拉托塞尼分子筛的","埃拉托斯特尼'筛","埃拉托斯特尼筛","埃拉托斯特尼筛子","埃拉托斯特尼筛法","埃拉托斯特尼筛法 - 维基百科","埃拉托斯特尼筛法 - 维基百科，自由的百科全书","埃拉托斯特尼筛法- 维基百科，自由的百科全书","埃拉托斯特尼筛的","埃拉托斯特尼篩法","埃拉托斯特尼篩法- 維基百科，自由的百科全書","埃拉托斯特尼篩法[百科]","埃拉托斯特尼，筛","埃拉托斯芬篩法","埃拉托色尼筛","对Erathosthenes筛","滤网或埃拉托斯特尼","的埃拉托斯特尼筛","的埃拉托斯特尼篩","的埃拉托色尼筛","的埃拉托色尼篩","筛或埃拉托色尼","筛法","筛法的相关信息","筛选法","篩或埃拉托色尼","篩的Erathosthenes","篩的埃拉托色尼","簡単な素数の見つけ方","維基百科的文章“ 埃拉托斯特尼筛法”","维基百科的文章“ 埃拉托斯特尼筛法”","维基筛的埃拉托塞尼[]","藤原の課題 参考","该埃拉托斯特尼筛","에라 토 스테 네스의 Sieve","에라 토 스테 네스의 체를","에라토스테네스 형님의 체","에라토스테네스의 채","에라토스테네스의 체","에라토스테네스의 체 - 위키백과, 우리 모두의 백과사전","체 또는 에라 토 스테 네스","（エラトステネスの篩）","，埃拉托色尼","ｴﾗﾄｽﾃﾈｽのふるい","ｴﾗﾄｽﾃﾈｽの篩-wikipedia"],"name":"Sieve of Eratosthenes","categories":["Algorithms","All articles needing additional references","Articles containing Ancient Greek-language text","Articles containing Greek-language text","Articles needing additional references from June 2015","Articles with example pseudocode","Pages using citations with accessdate and no URL","Primality tests","Sieve theory"],"tag_line":"In mathematics, the sieve of Eratosthenes (Ancient Greek: κόσκινον Ἐρατοσθένους, kóskinon Eratosthénous), one of a number of prime number sieves, is a simple, ancient algorithm for finding all prime numbers up to any given limit."}}
,{"_index":"throwtable","_type":"algorithm","_id":"flowchart","_score":0,"_source":{"description":"A flowchart is a type of diagram that represents an algorithm, workflow or process, showing the steps as boxes of various kinds, and their order by connecting them with arrows. This diagrammatic representation illustrates a solution model to a given problem. Flowcharts are used in analyzing, designing, documenting or managing a process or program in various fields.\n\n","alt_names":["Flussdiagramme","diagrammi di flusso","1 вариант","fluxograma","ISO_5807","DIN_66001","4 Recomendaciones","Ablaufdiagramm","Flowcharts","DIN 66001","блок-схемы","Flow Charts","Flowchart","Diagrama de flujo","flowchart","flow chart","Programmablaufplan","'flow chart'","(Programmablaufplans)","- Flow chart :","- Flowchart :","- Flowcharts :","-> Read more about Flowchart","-> Read the article about 'Flowchart'",". Flowchart","...Wikipedia Diagrama de flujo","...Wikipedia Diagramma a blocchi","...Wikipedia Fluxograma","...Wikipedia Schemat blokowy","...mehr auf Wikipedia über Ablaufdiagramm","...mehr auf Wikipedia über Programmablaufplan","...more on Wikipedia about Flowchart","1 Símbolos utilizados","2 Creating flowcharts on a computer","2 Flowchart building blocks","2 Símbolos utilizados","2 Ventajas de los diagramas de flujo","2.1 Manual","2.2 Auto","3 Características que debe cumplir un diagrama de","3 Flowchart building blocks","3 Tipos de diagramas de flujo","3 Tipos de diagramas de flujos","3 Types of flowchart","3 Types of flowcharts","3.3 Data-flow extensions","4 Simbología y significado","4 Types of flowchart","4 Ventajas de los diagrama de flujo","4.1 Manual","4.2 Automatic","4.3 Web-based","5 Tipos de diagramas de flujo","5 Tipos de diagramas de flujos","5 Ventajas de los Diagrama De Flujo","5 Ventajas de los Diagramas de Flujo","5 Ventajas de los diagrama de flujo","6 Tipos de diagramas de flujo","6 Tipos de diagramas de flujos","<<-- Diagramas de flujo -->>",">>> http://it.wikipedia.org/wiki/Diagramma_a_blocchi","?????aµµa ???? - ????pa?de?a","A database IS commonly represented as an upright","A flowchart (also spelled flow-chart and flow","Ablaufdiagramm - Wikipedia","Ablaufdiagramm â","Ablaufdiagramm – Wikipedia","Ablaufdiagramme","Ablaufdiagrammen","Ablaufdiagramms","Ablaufplan","About Flowcharts","Ak?? ?emas? - Vikipedi","Akış semaları","Akış şema","Akış şeması","Akış şeması - Vikipedi","Algorhythmen: Flussdiagramm","Algorigramme","Application Flow Diagrams","Aufbau oder Ablauf","Basic Flowchart","Blokinė schema","Click here for more information in creating a","Create a Flowchart","DIAGRAMA DE FLUJO","DIÀGRAMA DE FLUJO","Data flowcharts, showing controls over a data flows","DdF","Decision Flow Diagrams","Diagram alir","Diagram alir - Wikipedia bahasa Indonesia, ensiklopedia bebas","Diagram alur","Diagram alur - Wikipedia bahasa Indonesia, ensiklopedia bebas","Diagram poteka","Diagram poteka - Wikipedija, prosta enciklopedija","Diagrama de FLujo (Información)","Diagrama de Flujo","Diagrama de Flujos","Diagrama de Flux","Diagrama de flujo - Wikipedia","Diagrama de flujo - Wikipedia, la enciclopedia libre","Diagrama de flujo - Wikipedia, la…","Diagrama de flujo Wikipedia la enciclopedia libre","Diagrama de flux","Diagrama de flux - Viquipèdia","Diagrama_de_flujo","Diagrama_ëd_fluss","Diagramas de Flujo","Diagramas de Flujo II- Diagrams/Flowchart","Diagramas de Flujos","Diagramas de flujo","Diagramas de flujo - Wikipedia","Diagramas de flujo en Wikipedia","Diagramas de flujo.","Diagramma a blocchi","Diagramma a blocchi - Wikipedia","Diagramma di flusso","Diagrammi di Flusso","Diagrammi di flusso","Diagramy blokowe","Dijagram tijeka","Dijagram toka","Dijagram toka - Wikipedia","Dijagram toka Wikipedia","Dijagram toka Wikipedia slobodna enciklopedija","Esempio da wikipedia","Esistono molti tipi di rappresentazioni grafiche per descrivere","FLOW CHART","FLOWCHART 작성요령","FLUXOGRAMA PARA RESOLUÇÃO RÁPIDA DE PROBLEMAS","Flow Algorithm","Flow Chart","Flow Chart Basics 2","Flow Chart Diagram","Flow Chart at Wikipedia","Flow Chart- Wikipedia","Flow Charting","Flow chart","Flow chart - Wikipedia","Flow chart [W]","Flow chart building blocks","Flow chart; it is used under the","Flow charted","Flow charting","Flow charts","Flow-Chart","Flow-chart","Flow-charts","FlowChart","Flow_chart","Flowchart (wikipedia)","Flowchart - Lưu đồ","Flowchart - Wikipedia, The Free Encyclopedia","Flowchart - Wikipedia, the free encycl","Flowchart - Wikipedia, the free encyclopedia","Flowchart - Wikipedia, the free encyclopedia For the poetical","Flowchart - Wikipedia, the free encyclopedia The original programming","Flowchart - Wikipedia, the free encyclopedia... process flow chart","Flowchart - Wikipedia, the free encyclopediaA flowchart is","Flowchart - Wikipedia, the free encyclopediaCommon alternate names","Flowchart - Wikipedia, the free encyclopediaIntroduction to Programming","Flowchart - Wikipedia, the free encyclopediaThe original programming","Flowchart - wikipedia","Flowchart : Wikipedia","Flowchart Symbols","Flowchart Wiki","Flowchart Wikipedia The Free Encyclopedia","Flowchart Wikipedia the free encyclopedia","Flowchart Wikipedia the free encyclopedia - result","Flowchart Wikipedia, the free ...","Flowchart article","Flowchart building blocks","Flowchart building blocks.","Flowchart defined","Flowchart from Wikipedia","Flowchart on Wikipedia","Flowchart on wikipedia.org","Flowchart symbols","Flowchart |","Flowchart – Wikipedia, the free encyclopedia","Flowchart.","Flowchart; it is used under the","Flowcharting","Flowcharting explained","Flowcharts in Wiki","Flowcharts in generell","Flowcharts on Wikipedia","Flowcharts, Baby!^^","Flowcharts; it is used under the","Fludiagramo","Fludiagramo - Vikipedio","Flussdiagramm (genauer: Programmablaufplan)","Flussdiagramme oder Programmablaufplan (PAP)","Fluxograma - Wikipédia, a enciclopédia livre","Fluxograma ? Wikip?dia, a enciclop?dia livre","Fluxograma ? Wikipdia, a enciclopdia livre","Fluxograma Wikip dia a enciclop dia livre","Fluxograma existente na Wikipedia","Fluxograma – Wikipédia, a enciclopédia livre","Fluxogramas","Fluxu-diagrama","Flußdiagramm","Flußdiagramm (","Flæðirit","Flödesschema","Flödesscheman","Graph::Easy","Haz Clic Aquí Para Ver Diagramas De Flujo","I flow chart o diagrammi di flusso","IBM製のフローチャート用テンプレート","ISO 5807","ISO 5807 Wikipedia","ISO 5807 in","ISO 5807 – Wikipedia","In tal senso i diagrammi di flusso detti","Jausma #1","Learn about Flowchart>>>","Legendas-flxuogramas","MANUAL WIKIPEDIA","Make a flowchart","Mengenal flowchart","Mer om flytdiagrammer.","Mer om flödesdiagram på Wikipedia","More on Flow Chart","Noção de Fluxograma","O que é Fluxograma?","Obtido em http://pt.wikipedia.org/wiki/Fluxograma","Ordinogramme","Organigramme de programmation","Organigramme de programmation - Wikip?dia","Organigramme de programmation - Wikipédia","Organigramme_de_programmation","PAP - ProgrammAblaufPlan","Pesquisar flowchart na Wikipedia Portugal","Pesquisar fluxograma na Wikipedia Portugal","Pesquise por fluxograma na Wikipedia!","Plokkskeem (ik)","Pomoč","Process Flow Chart","Process Flow Software for Attorneys: Hammurabi","Process Flow Software for Attorneys: Hammurabi .","Programmablauf","Programmablauf als Flussdiagramm","Programmablaufpl&#228;nen","Programmablaufplan (PAP)","Programmablaufplan (Wikipedia)","Programmablaufplan - Wikipedia","Programmablaufplan ? Wikipedia","Programmablaufplan Wikipedia","Programmablaufplan aus Wikipedia","Programmablaufplan nach DIN 66001","Programmablaufplan â","Programmablaufplan â€“ Wikipedia","Programmablaufplan – Wikipedia","Programmablaufplan – Wikipedia-Eintrag >>","Programmablaufplan.","Programmablaufplan/Flowchart","Programmablaufplandiagrammen","Programmablaufplans","Programmablaufpläne","Programmablaufpläne (PAP)","Programmablaufplänen","Programmabläufe in der Informatik grafisch darzustellen","Programmanlaufpläne","Página sobre fluxogramas na wikipedia em Inglês","Página sobre fluxogramas na wikipedia em Português","Que es un diagrama de flujo","Rappresentazione dei processi","Read More About flowchart - wikipedia the free encyclopedia","Read More flowchart wikipedia the free encyclopedia","Read more about Flowchart at Wikipedia","Reglas para diagrama de flujo","Schema a blocchi","Schema a blocchi - Wikipedia","Schemat blokowy","Schemat blokowy - Wikipedia, wolna encyklopedia","Schemat blokowy ? Wikipedia, wolna encyklopedia","Schemat blokowy â�“ Wikipedia, wolna encyklopedia","Schemat blokowy – Wikipedia, wolna encyklopedia","Schemat blokowy – Wikipedia, wolna…","Schemat blokowy 鈥�Wikipedia, wolna encyklopedia","Schematy blokowe.","Search for Flowchart on Wikipedia!","Search for Flowcharts on Wikipedia!","Search info on Flowchart at Wikipedia","Siga este link para saber más","Source Wikipedia.org Arcticle - Flowchart","Stroomdiagram","Stroomdiagram - Wikipedia","Stroomschema","Suggested: flowchart","System Flow Chart","Símbolos utilizados","The flow chart or flow charts","Types of flow charts","Types of flowchart","UML flowchart diagram","Ver Diagramas de Flujo en Wikipedia","View Flowchart on Wikipedia","Vývojové diagramy","Vývojový diagram","Vývojový diagram - Wikipedie","Vývojový diagram - Wikipedie - Wikipedia","What Is a Flowchart?","What is a Flowchart -wiki","What is software of Process mapping symbols?","Wies gemacht wird.","Wiki Reference - Flow Charts","Wiki describes Flowcharting very well: http://en.wikipedia","Wiki flowchart","Wiki: FlowChart","Wikipedia (Flowchart)","Wikipedia - Flowchart","Wikipedia - フローチャート","Wikipedia : フローチャート","Wikipedia English - flowchart","Wikipedia Flowchart page","Wikipedia Programmablaufplan","Wikipedia Seite für Flowchart","Wikipedia article Diagram alir","Wikipedia article Diagram poteka","Wikipedia article Diagrama de flujo","Wikipedia article Diagrama ëd fluss","Wikipedia article Flow chart","Wikipedia article Flowchart","Wikipedia article Flowcharts","Wikipedia article Fludiagramo","Wikipedia article Fluxograma","Wikipedia article Flæðirit","Wikipedia article Stroomdiagram","Wikipedia article about Flowchart","Wikipedia article about flowchart","Wikipedia article on Diagrama de flujo","Wikipedia article on Flow chart","Wikipedia article on Flowchart","Wikipedia article on Flowcharts","Wikipedia article Διάγραμμα ροής","Wikipedia article Блок схема","Wikipedia article Блок-схема","Wikipedia article Блок-схеме","Wikipedia article Программа схемасы","Wikipedia article Программаның блок-схемасы","Wikipedia article خارطة الانسياب","Wikipedia article روندنما","Wikipedia article फ्लो चार्ट","Wikipedia article แผนภูมิสายงาน","Wikipedia article ბლოკ-სქემა","Wikipedia articles on Flow Charts","Wikipedia entry for Flowchart","Wikipedia entry on Flowcharting an Algorithm","Wikipedia entry on flowcharts","Wikipedia for some direction","Wikipedia l'articolo Diagramma a blocchi","Wikipedia link for flowcharts","Wikipedia on Flowcharts","Wikipedia page on Flowcharts","Wikipedia po angielsku - więcej o schematach blokowych","Wikipedia schematy blokowe","Wikipedia sur Algorigramme","Wikipedia zu Programmablaufplänen","Wikipedia – Diagrama de flujo","Wikipedia – Flowchart","Wikipedia – Programmablaufplan","Wikipedia's Flowchart Entry","Wikipedia(DE): Programmablaufplan","Wikipedia-Artikel Ablaufdiagramm","Wikipedia-Artikel DIN 66001","Wikipedia-Artikel Programmablaufplan","Wikipedia-Seite zu 'Ablaufdiagramm'","Wikipedia-Seite zu 'ISO 5807'","Wikipedia-Seite zu 'Programmablaufplan'","Wikipedia. Flow Charts","Wikipedia: Erläuterungen zu Flussdiagrammen","Wikipedia: Flowchart","Wikipedia: Programmablaufplan","Wikipedia: flowchart","Wikipedia: history and use of flowcharts","Wikipedia: routeschema","Wikipediaartikel zu Ablaufplänen","Wikipediabeschreibung PAP","Wikipediaeintrag über Flowcharts","Wikipediaで「フローチャート」を調べる","Wikipediaで「流れ図」を調べる","Wikipediaフランス語版 - flowchart","Wikipedia英語版 - flowchart","Wikipédia L'organigramme de programmation","Wikipédia artigo Flowchart","Wikipédia artigo Fluxograma","Wskazówka.","[7] Flow chart","[Leer Más","[encyclopedia article on flowcharts!]","account administration flowchart job diagram sample","akis diyagramlari","akış diyagramları","akış şemaları","algorigramme","anda aquí","ar:خارطة الانسياب","ar:خارطة انسياب","ar:خرائط سير المعلومات","article Flowchart","artigo da Wikipédia Fluxograma","artículo de Wikipedia Diagrama de Flujo","artículo de Wikipedia Diagrama de flujo","artículo de Wikipedia Diagramas de flujo","bg:Блок схема","biographie Flowchart discographie","biểu đồ lưu lượng","blokschema's","bs:Dijagram toka","ca:Diagrama de flux","charts that represents an algorithm or process, showing","cs:Vývojový diagram","d'un ordinogramme","data-flowchart","de-wp:Programmablaufplan","de.wikipedia.org/DIN_66001","de.wikipedia.org/wiki/Ablaufdiagramm","de.wikipedia.org/wiki/DIN_66001","de.wikipedia.org/wiki/Programmablaufplan","de:Programmablaufplan","des diagrammes","diagram alir","diagram poteka","diagrama de Flujo","diagrama de actividad ó flujo","diagrama de flujo","diagrama de flujo:","diagrama de flujos","diagramas de fl","diagramas de flujo","diagramas de flujo.","diagramas de flujos","diagrame poteka","diagramma a blocchi","diagrammes de flux","diagrammi a blocchi","dijagram toka","diseño de procesos","e http://de.wikipedia.org/wiki/Programmablaufplan","ee http://en.wikipedia.org/wiki/Flowchart#Symbols","egy kis info a folyamatábráról.","el:Διάγραμμα ροής","en z Wikipedii.","en.wiki >> Flowchart","en.wikipedia.org/Flowchart","en.wikipedia.org/wiki/Flow_chart","en.wikipedia.org/wiki/Flowc...","en.wikipedia.org/wiki/Flowchart","en.wikipedia.org/wiki/Flowcharts","en:Flowchart","entri Wikipedia buat flowchart","eo:Fludiagramo","es.wikipedia.org/...Diagrama_de_flujo","es.wikipedia.org/wiki/diagrama_de_flujo.pdf.","es:Diagrama de flujo","fa:روندنما","fa:فلوچارت","flow char","flow chart?","flow charting","flow charting symbols","flow chartok","flow charts","flow charts.","flow-chart","flow-chart diagrams","flow-charts","flowcahrt","flowchar","flowchart - Wikipedia, the free encyclopedia","flowchart - wikipedia, the free encyclopedia","flowchart artikel","flowchart based programming","flowchart diagrams","flowchart or process flow","flowchart wikipedia the free encyclopedia","flowchart,","flowcharted","flowcharting","flowcharting- wikipedia","flowchartprogramma","flowcharts","flowcharts here","flowcharts on Wikipedia","flujograma","fluxogram","fluxogramas","fluxogrames","flödesdiagram","flödesschema","fr:Organigramme de programmation","general overview + symbols","h http://pl.wikipedia.org/wiki/Schem","he:תרשים זרימה","hi:फ्लो चार्ट","hr:Dijagram tijeka","http://ar.wikipedia.org/wiki/خارطة_الانسياب","http://bit.ly/7npWSE","http://bs.wikipedia.org/wiki/Dijagram_toka","http://ca.wikipedia.org/wiki/Diagrama_de_flux","http://cs.wikipedia.org/wiki/Vývojový_diagram","http://de.wikipedia.org/wiki/Ablaufdiagr","http://de.wikipedia.org/wiki/Ablaufdiagramm","http://de.wikipedia.org/wiki/Ablaufdiagr…","http://de.wikipedia.org/wiki/DIN_66001","http://de.wikipedia.org/wiki/ISO_5807","http://de.wikipedia.org/wiki/Pr ogrammablaufplan","http://de.wikipedia.org/wiki/Program...ablaufplans.29","http://de.wikipedia.org/wiki/Programmablaufplan","http://de.wikipedia.org/wiki/Programmablaufplan#Elemente","http://de.wikipedia.org/wiki/Programmabl…","http://de.wikipedia.org/wiki/programmabl.","http://el.wikipedia.org/wiki/Διάγραμμα_ροής","http://en.wikipedia....wchart#Overview","http://en.wikipedia.org/wiki/Flow%5Fchart","http://en.wikipedia.org/wiki/Flow_chart","http://en.wikipedia.org/wiki/Flow_chart#...","http://en.wikipedia.org/wiki/Flow_chart#…","http://en.wikipedia.org/wiki/Flow_chart?","http://en.wikipedia.org/wiki/Flowchar","http://en.wikipedia.org/wiki/Flowchart","http://en.wikipedia.org/wiki/Flowchart#E…","http://en.wikipedia.org/wiki/Flowchart#Symbols","http://en.wikipedia.org/wiki/Flowchart#S…","http://en.wikipedia.org/wiki/Flowchart#cite_note-SSEV","http://en.wikipedia.org/wiki/Flowcharts","http://en.wikipedia.org/wiki/Flowchartは、","http://en.wikipedia.org/wiki/F​lowchart","http://en.wikipedia.org/wiki/flowchart","http://en.wikipedia.org/wiki/flowchart...","http://en.wikipedia.org/wi​ki/Flowchart","http://es.wikipedia.org/wiki/Diagrama_de","http://es.wikipedia.org/wiki/Diagrama_de...","http://es.wikipedia.org/wiki/Diagrama_de_Flujo","http://es.wikipedia.org/wiki/Diagrama_de_Fwujo","http://es.wikipedia.org/wiki/Diagrama_de_flu","http://es.wikipedia.org/wiki/Diagrama_de_fluj...","http://es.wikipedia.org/wiki/Diagrama_de_flujo","http://es.wikipedia.org/wiki/Diagrama_de_flujo#Caracter.C3","http://es.wikipedia.org/wiki/Diagrama_de_flujo#Definici.C3","http://es.wikipedia.org/wiki/Diagrama_de_flujo#Tipos_de_diagramas_de_flujos","http://es.wikipedia.org/wiki/Diagrama_de_flujo#Ventajas_de_los_diagrama_de_flujo","http://es.wikipedia.org/wiki/Diagrama_de_flujo#Ventajas_de_los_diagramas_de_flujo","http://es.wikipedia.org/wiki/Diagramas_de_flujo","http://es.wikipedia.org/wiki/Diagramas_d…","http://es.wikipedia.org/wiki/D​iagrama_de_flujo","http://fa.wikipedia.org/wiki/روندنما","http://fr.wikipedia.org/wiki/Ordinogramme","http://fr.wikipedia.org/wiki/Organig..._programmation","http://fr.wikipedia.org/wiki/Organigram ... grammation","http://fr.wikipedia.org/wiki/Organigramme_de_programmation","http://hi.wikipedia.org/wiki/फ्लो_चार्ट","http://id.wikipedia.org/wiki/Diagram_alir","http://id.wikipedia.org/wiki/Diagram_alur","http://id.wikipedia.org/wiki/Flowchart","http://is.wikipedia.org/wiki/Fl%C3%A6","http://it.wikipedia....ramma_a_blocchi","http://it.wikipedia.org/wiki/Diagramma_a_blocchi","http://it.wikipedia.org/wiki/Diagramma_a_blocchi#Condizioni_di_validit.C3","http://it.wikipedia.org/wiki/Diagramma_a…","http://it.wikipedia.org/wiki/Schema_a_blocchi","http://ja.wikipedia.org/wiki/フローチャート","http://nl.wikipedia.org/wiki/Stroomdiagram","http://pl.wikipedia.(...)kowy","http://pl.wikipedia....Schemat_blokowy","http://pl.wikipedia.org/wiki/Schema","http://pl.wikipedia.org/wiki/Schema...","http://pl.wikipedia.org/wiki/Schemat_blokowy","http://pl.wikipedia.org/wiki/Shemat_blokowy","http://pt.wikipedia.org/wiki/Fluxograma","http://ru.wikipedia.org/wiki/Flowchart","http://ru.wikipedia.org/wiki/Блок-схема","http://ru.wikipedia.org/wiki/Блок-схема#.D0","http://ru.wikipedia.org/wiki/Блок-схема_...","http://sl.wikipedia.org/wiki/Diagram_poteka","http://sv.wikipedia.org/wiki/Fl%C3%B6desschema","id:Diagram alir","id:Diagram alur","is:Flæðirit","it.wikipedia.org/wiki/Diagramma_a_blocchi","it:Diagramma a blocchi","it:Schema a blocchi","ja:フローチャート","ka.wikipedia.org/wiki/ბლოკ-სქემა","ka:ბლოკ-სქემა","kk:Программаның блок-схемасы","les conventions usuelles","logic flowchart where one question","lt:Blokinė schema","mhr:Блок-схеме","ms:Carta alir","nguaje natural.","nl:Stroomdiagram","norme ISO 5807","o que é fluxograma?","ordinogrames / organigrames / diagrames de flux","ordinogramme","organigramme de programmation","organigrammes de programmation","organigrammes divers","pl.wikipedia.org/wiki/Schemat_blokowy","pl:Schemat blokowy","pms:Diagrama ëd fluss","podstawowymi schematami blokowymi","process-flow chart","program flowcharts","pt.wikipedia.org/Fluxograma","pt:Fluxograma","ru.wikipedia.org/wiki/Flowchart","ru.wikipedia.org/wiki/Блок-схема","ru:Блок-схема","s Flußdiagramm","saiba o que é um fluxograma","schemacie","schemat blokowy","schematu blokowego","schematy blokowe","sh:Dijagram toka","shapes and components of a Process Map or","sl:Diagram poteka","stroomdiagram","stroomdiagrammen","stroomschema","sv:Flödesschema","sơ đồ khối","t flödesschema","ta:செயல்வழிப் படம்","tabel Arus","tableau de flux","ten z Wikipedii.","th:แผนภูมิสายงาน","tr:Akış şeması","ttp://en.wikipedia.org/wiki/Flowchart","ttp://es.wikipedia.org/wiki/Diagrama_de_fluj","uk:Блок-схема","user flow diagrams","visual narrative language","vývojové diagramy","vývojový diagram","vývojových diagramech","vývojových diagramů","w:Programmablaufplan","www,es.wikipedia.org/wiki/Diagrama_de_flujo","www.es.wikipedia.org/wiki/Diagrama_de_flujo","zh:流程图","značky vývojových diagramů","| http://de.wikipedia.org/wiki/Programmablaufplan","|diagramas de flujo","ývojový diagram","Διάγραμμα ροής","Διάγραμμα ροής - Βικιπαίδεια","διάγραμμα ροής","διαγράμματα ροής","λογικό διάγραμμα(Flowchart)","Блок схема","Блок схема - Wiki","Блок-Схема","Блок-схема","Блок-схема — Википедия","Блок-схема — Вікіпедія","Блок-схемы","Блок-схемы в Википерии","Блок-схемы на Википедии","Блок-схемы: ГОСТ","Википедии статью Блок-схема","Википедии статью Блок-схема алгоритма","Википедия_Блок-схемы","Вот, обозначения графических элементов","Госты знают","Программа схемасы","Программаның блок-схемасы","Ссылка 6 Блок-схемы","Что такое блок схемы (на Википедии)","блок - схем","блок-схем","блок-схем.","блок-схема","блок-схемам","блок-схемах","блок-схеми","блок-схеми.","блок-схемой","блок-схему","блок-схему алгоритма","блок-схемы алгоритмов","и блок-схем","предопределенный процесс","расписывайте","старых-добрых блок-схем","схемы алгоритмов","ויקיפדיה - 'תרשים זרימה'","תרשים הזרימה","תרשים זרימה","תרשים זרימה של דילמת אומגה - ויקיפדיה.","תרשים זרימה – ויקיפדיה","תרשימי זרימה","תרשימים קובץ","بالمخطط التدفقي","خارطة الانسياب","خرائط الانسياب","خوارط الانسياب","راهنمای فلوچارت","روندنما","روندنما - ویکیپدیا","روندنما - ویکیپدیا - Wikipedia","فلوچارت","فلوچارتی","مخطّط الانسياب","फ्लो चार्ट","செயல்வழிப் ...","செயல்வழிப் படம்","ఫ్లోచార్టులు","กราฟการไหล","แผนภูมิสายงาน","ბლოკ-სქემა","ბლოკ-სქემა - ვიკიპედია","“Flowchart - Wikipedia, the free encyclopedia”, en.wikipedia.org","「フローチャート」","「フローチャート」についてWikipediaで調査","「フローチャート」をWikipediaで調べる","「フローチャート」をWikiで調べる","「流れ図」についてWikipediaで調査","『フローチャート』の解説","ウィキペディアの記事 フローチャート","チャートを製品","フローチャー","フローチャート","フローチャート - Wikipedia","フローチャート - wikipedia (書きかけ項目)","フローチャートの説明は『ウィキペディア（Wikipedia）』で","フローチャート作成ソフト","フローチャート図","フローチャート式","フローチャート自体の説明は、Wikipedeia等をご参照ください","フローチャート表","フローチャート２","关于流程的那些链接：http://en.wikipedia.org/wiki/Flowchart","外部リンク:Flowchart","日本ではJIS で標準化されて","流れ図","流れ図についてのwiki","流程图","流程图- 维基百科，自由的百科全书","流程圖","流程圖- 維基百科，自由的百科全書","流程圖Flow Chart or Activity Diagram","的流程图","維基百科的文章“ 流程图”","維基百科～Flowchart","维基百科的文章“ 流程图”","흐름 차트를","ﻓﻠﻮﭼﺎﺭﺕ","ﾌﾛｰﾁｬｰﾄ"],"name":"Flowchart","categories":["Algorithm description languages","American inventions","Articles with example code","CS1 errors: external links","Computer programming","Diagrams","Quality control tools","Technical communication","Wikipedia articles with GND identifiers"],"tag_line":"A flowchart is a type of diagram that represents an algorithm, workflow or process, showing the steps as boxes of various kinds, and their order by connecting them with arrows."}}
,{"_index":"throwtable","_type":"algorithm","_id":"adaptive-algorithm","_score":0,"_source":{"description":"An adaptive algorithm is an algorithm that changes its behavior based on information available at the time it is run. This might be information about computational resources available, or the history of data recently received.\nFor example, stable partition, using no additional memory is O(n lg n) but given O(n) memory, it can be O(n) in time. As implemented by the C++ Standard Library, stable_partition is adaptive and so it acquires as much memory as it can get (up to what it would need at most) and applies the algorithm using that available memory. Another example is adaptive sort, whose behaviour changes upon the presortedness of its input.\nAn example of an adaptive algorithm in radar systems is the constant false alarm rate (CFAR) detector.\nIn machine learning and optimization, many algorithms are adaptive or have adaptive variants, which usually means that the algorithm parameters are automatically adjusted according to statistics about the optimisation thus far (e.g. the rate of convergence). Examples include adaptive simulated annealing, adaptive coordinate descent, AdaBoost, and adaptive quadrature.\nIn data compression, adaptive coding algorithms such as Adaptive Huffman coding or Prediction by partial matching can take a stream of data as input, and adapt their compression technique based on the symbols that they have already encountered.\nIn signal processing, the Adaptive Transform Acoustic Coding (ATRAC) codec used in MiniDisc recorders is called \"adaptive\" because the window length (the size of an audio \"chunk\") can change according to the nature of the sound being compressed, to try and achieve the best-sounding compression strategy.","alt_names":["Adaptive Algorithm","Adaptive algorithm","Adaptive algorithm - Wikipedia, the free encyclopedia","Adaptive algorithm on wikipedia.org","Algorithme adaptatif","Algorithme adaptatif - Wikip?dia","Algorithme adaptatif - Wikipédia","Wikipedia article Adaptive algorithm","Wikipedia article Algorithme adaptatif","Wikipedia article on Adaptive algorithm","Wikipedia entry for Adaptive algorithm","adaptive algorithm","fr:Algorithme adaptatif","http://en.wikipedia.org/wiki/Adaptive_al","http://en.wikipedia.org/wiki/Adaptive_algorithm","http://fr.wikipedia.org/wiki/Algorithme_adaptatif","ru:Адаптивный алгоритм","uk:Адаптивний алгоритм","yago-res:Adaptive algorithm","Адаптивний алгоритм — Вікіпедія","Адаптивные алгоритмы","Адаптивный алгоритм","Адаптивный алгоритм — Википедия","Википедии статью Адаптивный алгоритм"],"name":"Adaptive algorithm","categories":["Algorithms","All stub articles","Software engineering stubs"],"tag_line":"An adaptive algorithm is an algorithm that changes its behavior based on information available at the time it is run."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hyphenation-algorithm","_score":0,"_source":{"description":"A hyphenation algorithm is a set of rules (especially one codified for implementation in a computer program) that decides at which points a word can be broken over two lines with a hyphen. For example, a hyphenation algorithm might decide that impeachment can be broken as impeach-ment or im-peachment, but not, say, as impe-achment.\nOne of the reasons for the complexity of the rules of word-breaking is that different \"dialects\" of English tend to differ on the rule: American English tends to work on sound, while British English tends to look to the origins of the word and then to sound. There are also a large number of exceptions, which further complicates matters.\nSome rules of thumb can be found in the reference \"On Hyphenation – Anarchy of Pedantry\". Among algorithmic approaches to hyphenation, the one implemented in the TeX typesetting system is widely used. It is thoroughly documented in the first two volumes of Computers and Typesetting and in Frank Liang's dissertation. Contrary to the belief that TeX relies on a large dictionary of exceptions, the point of Liang's work was to get the algorithm as accurate as he practically could and keep any exception dictionary small. In TeX's original hyphenation patterns for US English, the exception list contains fourteen words.","alt_names":["- Hyphenation algorithm :","...more on Wikipedia about Hyphenation algorithm","Hyphenation algorithm","Hyphenation algorithm (article on Wikipedia)","Hyphenation algorithm - Wikipedia :: The free encyclopedia","Hyphenation algorithm - Wikipedia, the free","Hyphenation algorithm - Wikipedia, the free encyclopedia","Hyphenation algorithm - Wikipedia, the free encyclopedia wikipedia.org","Hyphenation algorithms","Hyphenation_algorithm","TeX algorithm","TeX's hyphenation algorithm","Tex-Algorithmus","Wikipedia article ''Hyphenation algorithm''","Wikipedia article Hyphenation algorithm","Wikipedia article on Hyphenation algorithm","Wikipedia entry for Hyphenation algorithm","algoritmi di compressione dati e dizionari di sillabazione","comprehensible to a computer","data compression algorithms and hyphenation dictionaries","en.wikipedia.org/wik...yphenation_algorithm","http://en.wikipedia.org/wiki/Hyphenation%5Falgorithm","http://en.wikipedia.org/wiki/Hyphenation_algorithm","http://en.wikipedia.org/wiki/Hyphenation…","hyphenation algorithm","hyphenation algorithms","hyphenation system","partir correctamente las palabras","w:Hyphenation algorithm","yago-res:Hyphenation algorithm","в алгоритме переноса, реализованном в системе TeX","“Hyphenation algorithm - Wikipedia, the free encyclopedia”, en.wikipedia"],"name":"Hyphenation algorithm","categories":["Algorithms","Articles needing more viewpoints from December 2013","Digital typography"],"tag_line":"A hyphenation algorithm is a set of rules (especially one codified for implementation in a computer program) that decides at which points a word can be broken over two lines with a hyphen."}}
,{"_index":"throwtable","_type":"algorithm","_id":"algorithm-design","_score":0,"_source":{"description":"Algorithm design is a specific method to create a mathematical process in solving problems. Applied algorithm design is algorithm engineering.\nAlgorithm design is identified and incorporated into many solution theories of operation research, such as dynamic programming and divide-and-conquer. Techniques for designing and implementing algorithm designs are algorithm design patterns, such as template method pattern and decorator pattern, and uses of data structures, and name and sort lists. Some current day uses of algorithm design can be found in internet retrieval processes of web crawling, packet routing and caching.\nMainframe programming languages such as ALGOL (for Algorithmic language), FORTRAN, COBOL, PL/I, SAIL, and SNOBOL are computing tools to implement an \"algorithm design\"... but, an \"algorithm design\" (a/d) is not a language. An a/d can be a hand written process, e.g. set of equations, a series of mechanical processes done by hand, an analog piece of equipment, or a digital process and/or processor.\nOne of the most important aspects of algorithm design is creating an algorithm that has an efficient runtime, also known as its big Oh.\nSteps in development of Algorithms\nProblem definition\nDevelopment of a model\nSpecification of Algorithm\nDesigning an Algorithm\nChecking the correctness of Algorithm\nAnalysis of Algorithm\nImplementation of Algorithm\nProgram testing\nDocumentation Preparation\n\n^ Goodrich, Michael T.; Tamassia, Roberto (2002), Algorithm Design: Foundations, Analysis, and Internet Examples, John Wiley & Sons, Inc., ISBN 0-471-38365-1","alt_names":["algorithm design","- Algorithm design :","1)Design and Analysis of Algorithms","Algorithm Design","Algorithm design","Algorithm design - Wikipedia :: The free encyclopedia","Algorithm design - Wikipedia, the free encyclopedia","Algorithm design Wikipedia the free encyclopedia","Algorithm_design","Wikipedia Algorithm Design definition","Wikipedia Algorithm design definition","Wikipedia article Algorithm design","Wikipedia article Algorithm_design","Wikipedia article on Algorithm design","Wikipedia entry for Algorithm design","algorithm design and optimization","algorithmic design","fa:طراحی الگوریتم","http://en.wikipedia.org/wiki/Algorithm_d","http://en.wikipedia.org/wiki/Algorithm_design","lgorithm design","t algorithm design","Разработка алгоритмов","طراحی الگوریتم","طراحی الگوریتم - ویکیپدیا","طراحیالگوريتم"],"name":"Algorithm design","categories":["Algorithms","All stub articles","Mathematical analysis stubs","Operations research"],"tag_line":"Algorithm design is a specific method to create a mathematical process in solving problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"jump-and-walk-algorithm","_score":0,"_source":{"description":"Jump-and-Walk is an algorithm for point location in triangulations (though most of the theoretical analysis were performed in 2D and 3D random Delaunay triangulations). Surprisingly, the algorithm does not need any preprocessing or complex data structures except some simple representation of the triangulation itself. The predecessor of Jump-and-Walk was due to Lawson (1977) and Green and Sibson (1978), which picks a random starting point S and then walks from S toward the query point Q one triangle at a time. But no theoretical analysis was known for these predecessors until after mid-1990s.\nJump-and-Walk picks a small group of sample points and starts the walk from the sample point which is the closest to Q until the simplex containing Q is found. The algorithm was a folklore in practice for some time, and the formal presentation of the algorithm and the analysis of its performance on 2D random Delaunay triangulation was done by Devroye, Mucke and Zhu in mid-1990s (the paper appeared in Algorithmica, 1998). The analysis on 3D random Delaunay triangulation was done by Mucke, Saias and Zhu (ACM Symposium of Computational Geometry, 1996). In both cases, a boundary condition was assumed, namely, Q must be slightly away from the boundary of the convex domain where the vertices of the random Delaunay triangulation are drawn. In 2004, Devroye, Lemaire and Moreau showed that in 2D the boundary condition can be withdrawn (the paper appeared in Computational Geometry: Theory and Applications, 2004).\nJump-and-Walk has been used in many famous software packages, e.g., QHULL, Triangle and CGAL.","alt_names":["Jump and Walk algorithm","Jump-and-Walk algorithm","Jump-and-Walk algorithm - Wikipedia, the free encyclopedia","Wikipedia article Jump-and-Walk algorithm","Wikipedia entry for Jump-and-Walk algorithm","http://en.wikipedia.org/wiki/Jump-and-Wa","http://en.wikipedia.org/wiki/Jump-and-Walk_algorithm","jump-and-walk algorithm"],"name":"Jump-and-Walk algorithm","categories":["Algorithms","Triangulation (geometry)"],"tag_line":"Jump-and-Walk is an algorithm for point location in triangulations (though most of the theoretical analysis were performed in 2D and 3D random Delaunay triangulations)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"driver-scheduling-problem","_score":0,"_source":{"description":"The driver scheduling problem (DSP) is type of problem in operations research and theoretical computer science.\nThe DSP consists of selecting a set of duties (assignments) for the drivers or pilots of vehicles (e.g., buses, trains, boats, or planes) involved in the transportation of passengers or goods.\nThis very complex problem involves several constraints related to labour and company rules and also different evaluation criteria and objectives. Being able to solve this problem efficiently can have a great impact on costs and quality of service for public transportation companies. There is a large number of different rules that a feasible duty might be required to satisfy, such as\nMinimum and maximum stretch duration\nMinimum and maximum break duration\nMinimum and maximum work duration\nMinimum and maximum total duration\nMaximum extra work duration\nMaximum number of vehicle changes\nMinimum driving duration of a particular vehicle\nOperations research has provided optimization models and algorithms that lead to efficient solutions for this problem. Among the most common models proposed to solve the DSP are the Set Covering and Set Partitioning Models (SPP/SCP). In the SPP model, each work piece (task) is covered by only one duty. In the SCP model, it is possible to have more than one duty covering a given work piece. In both models, the set of work pieces that needs to be covered is laid out in rows, and the set of previously defined feasible duties available for covering specific work pieces is arranged in columns. The DSP resolution, based on either of these models, is the selection of the set of feasible duties that guarantees that there is one (SPP) or more (SCP) duties covering each work piece while minimizing the total cost of the final schedule.","alt_names":[],"name":"Driver scheduling problem","categories":["Algorithms"],"tag_line":"The driver scheduling problem (DSP) is type of problem in operations research and theoretical computer science."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hakmem","_score":0,"_source":{"description":"HAKMEM, alternatively known as AI Memo 239, is a February 1972 \"memo\" (technical report) of the MIT AI Lab containing a wide variety of hacks, including useful and clever algorithms for mathematical computation, some number theory and schematic diagrams for hardware — in Guy L. Steele's words, \"a bizarre and eclectic potpourri of technical trivia\". Contributors included about two dozen members and associates of the AI Lab. The title of the report is short for \"hacks memo\", abbreviated to six upper case characters that would fit in a single PDP-10 machine word (using a six-bit character set).","alt_names":["- HAKMEM :","HACKMEM","HAKMEM","HAKMEM - Wikipedia, the free encyclopedia","HAKMEM from Wikipedia","HAKMEM, classic logic, programming and hardware puzzles","HAKMEM; it is used under the","Hakmem","MIT HAKMEM","Memo 239 (HAKMEM)","Source Wikipedia.org Arcticle - HAKMEM","Wikipedia article HAKMEM","Wikipedia article on HAKMEM","Wikipedia entry for HAKMEM","Wikipedia: HAKMEM","bit-bummers","en:HAKMEM","http://en.wikipedia.org/wiki/HAKMEM","Статья в Википедии о HAKMEM"],"name":"HAKMEM","categories":["1972 in Massachusetts","Algorithms","All articles lacking reliable references","All articles with unsourced statements","Articles lacking reliable references from July 2015","Articles with unsourced statements from August 2014","Computer science papers","Memoranda"],"tag_line":"HAKMEM, alternatively known as AI Memo 239, is a February 1972 \"memo\" (technical report) of the MIT AI Lab containing a wide variety of hacks, including useful and clever algorithms for mathematical computation, some number theory and schematic diagrams for hardware — in Guy L. Steele's words, \"a bizarre and eclectic potpourri of technical trivia\"."}}
,{"_index":"throwtable","_type":"algorithm","_id":"collaborative-diffusion","_score":0,"_source":{"description":"Collaborative Diffusion is a type of pathfinding algorithm which uses the concept of antiobjects, objects within a computer program that function opposite to what would be conventionally expected. Collaborative Diffusion is typically used in video games, when multiple agents must path towards a single target agent. For example, the ghosts in Pac-Man. In this case, the background tiles serve as antiobjects, carrying out the necessary calculations for creating a path and having the foreground objects react accordingly, whereas having foreground objects be responsible for their own pathing would be conventionally expected.\nCollaborative Diffusion is favored for its efficiency over other pathfinding algorithms, such as A*, when handling multiple agents. Also, this method allows elements of competition and teamwork to easily be incorporated between tracking agents. Notably, the time taken to calculate paths remains constant as the number of agents increases.","alt_names":[],"name":"Collaborative diffusion","categories":["Algorithms"],"tag_line":"Collaborative Diffusion is a type of pathfinding algorithm which uses the concept of antiobjects, objects within a computer program that function opposite to what would be conventionally expected."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lancichinetti-fortunato-radicchi-benchmark","_score":0,"_source":{"description":"Lancichinetti-Fortunato-Radicchi (LFR) benchmark is an algorithm that generates benchmark networks (artificial networks that resemble real-world networks). They have a priori known communities and are used to compare different community detection methods. The advantage of LFR over other methods is that it accounts for the heterogeneity in the distributions of node degrees and of community sizes.","alt_names":[],"name":"Lancichinetti-Fortunato-Radicchi Benchmark","categories":["Algorithms","All articles covered by WikiProject Wikify","All articles needing expert attention","All articles that are too technical","All articles with too few wikilinks","All orphaned articles","Articles covered by WikiProject Wikify from June 2015","Articles needing expert attention from June 2015","Articles with too few wikilinks from June 2015","Computer benchmarks","Orphaned articles from June 2015","Statistical models","Wikipedia articles that are too technical from June 2015"],"tag_line":"Lancichinetti-Fortunato-Radicchi (LFR) benchmark is an algorithm that generates benchmark networks (artificial networks that resemble real-world networks)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cascade-learning-based-on-adaboost","_score":0,"_source":{"description":"The Boosting Algorithms for Detector Cascade Learning is proposed by Mohammad Saberian and Nuno Vasconcelos in 2014, it is based on Viola–Jones object detection framework.\n\n","alt_names":[],"name":"Cascade Learning Based on Adaboost","categories":["Algorithms","Algorithms and data structures","All articles covered by WikiProject Wikify","All articles needing expert attention","All articles that are too technical","All articles with too few wikilinks","All orphaned articles","Articles covered by WikiProject Wikify from August 2015","Articles needing expert attention from August 2015","Articles with too few wikilinks from August 2015","Face recognition","Object recognition and categorization","Orphaned articles from September 2015","Wikipedia articles that are too technical from August 2015"],"tag_line":"The Boosting Algorithms for Detector Cascade Learning is proposed by Mohammad Saberian and Nuno Vasconcelos in 2014, it is based on Viola–Jones object detection framework.\n\n"}}
,{"_index":"throwtable","_type":"algorithm","_id":"boyer–moore-majority-vote-algorithm","_score":0,"_source":{"description":"The Boyer-Moore Vote Algorithm solves the majority vote problem in linear time  and logarithmic space . The majority vote problem is to determine in any given sequence of choices whether there is a choice with more occurrences than all the others, and if so, to determine this choice. Mathematically, given a finite sequence (length n) of numbers, the object is to find the majority number defined as the number that appears more than ⌊ n/2 ⌋ times.","alt_names":[],"name":"Boyer–Moore majority vote algorithm","categories":["Algorithms","All orphaned articles","Orphaned articles from December 2014"],"tag_line":"The Boyer-Moore Vote Algorithm solves the majority vote problem in linear time  and logarithmic space ."}}
,{"_index":"throwtable","_type":"algorithm","_id":"xor-swap-algorithm","_score":0,"_source":{"description":"In computer programming, the XOR swap is an algorithm that uses the XOR bitwise operation to swap values of distinct variables having the same data type without using a temporary variable. \"Distinct\" means that the variables are stored at different memory addresses; the actual values of the variables do not have to be different.","alt_names":["приём","XOR swap","# http://en.wikipedia.org/wiki/XOR_swap_algorithm Code_example","(http://en.wikipedia.org/wiki/Xor_swap_algorithm","-> Read the article about 'XOR swap algorithm'","...Wikipedia Algoritmo Xor Swap","2 Proof that the XOR swap works","3 Code example","4 Reasons for use in practice","440px-XOR_Swap.svg.png","5 Reasons for avoidance in practice","5.1 The XCHG instruction","5.2 Aliasing","Algorithm of an exchange by means of eliminating","Algoritma XOR swap","Algoritmo XOR swap","Algoritmo Xor Swap","Algoritmo Xor Swap – Wikipédia, a enciclopédia livre","Algoritmo de intercambio XOR","C example","Intercambio XOR","Learn about XOR swap algorithm>>>","Link【wikipesia】","More detail on XOR swap algorithm.","Proof that the XOR swap works","Reasons for avoidance in practice","Reasons for use in practice","See the explanation under the C example","Staat ook op wikipedia","Stichwort XOR","Swap XOR","Swap algorithm","Swap algorithme XOR","Swap by addition and subtraction","Swap without a temp variable using the power","Swap-By-XOR algorithm","Swap-By-XOR algoritme","Swap-By-XOR algoritmo","Swap-By-XOR algoritmu","Swap-By-XOR algorytmu","Swap-By-XOR-Algorithmus","Swap-By-XOR-algoritme","Swap-К-XOR алгоритм","Swaps values of a & b","Tingnan ang Wikipedia","Using the XOR swap algorithm to exchange nibbles","What variations does Xor swap algorithm/Assembler Code","Wikipedia : XOR交換アルゴリズム","Wikipedia article Algoritmo Xor Swap","Wikipedia article Swap by addition and subtraction","Wikipedia article XOR swap","Wikipedia article XOR swap algorithm","Wikipedia article on XOR swap","Wikipedia article on XOR swap algorithm","Wikipedia entry for XOR swap algorithm","Wikipedia has info on this","Wikipedia o zamienianiu przez XOR","Wikipedia: XOR swap algorithm","Wikipediaで「XOR交換アルゴリズム」を調べる","With three XOR operations the binary values 1010","XCHG","XOR BITWISE OPERATION","XOR SWAP","XOR SWAP İşlemine ait Wikipedia Sayfası","XOR Swap","XOR Swap Algorithm","XOR Swap Algorithm?","XOR Swap Trick","XOR Swap.","XOR Swapping Trick","XOR algoritme","XOR bytte trick","XOR sort","XOR swap Algorithm","XOR swap algorithm","XOR swap algorithm (englisch)","XOR swap algorithm - Wikipedia :: The free encyclopedia","XOR swap algorithm - Wikipedia, the free encycl...","XOR swap algorithm - Wikipedia, the free encyclopedia","XOR swap algorithm - swap two numbers without a","XOR swap algorithm na Wikipedii","XOR swap trick","XOR swappen","XOR swapping","XOR swapping trick","XOR swaps","XOR swaps de","XOR swapy","XOR swapów","XOR sztuczka wymiany","XOR trao đổi thuật toán","XOR vyměňovat trik","XOR алгоритма подкачки:","XOR замены","XOR замены хитрость","XOR свопы","XOR एल्गोरिथ्म","XOR गमागमन चाल","XOR स्वैप","XOR 交換アルゴリズム","XOR 교체 알고리즘","XOR 교체 알고리즘이","XOR 스왑 알고리즘","XOR 알고리즘","XOR-Algorithmus","XOR-Swap","XOR-Swap-Algorithmus","XOR-Swap-Algorithmus:","XOR-Swaps","XOR-swap trick","XOR-swapping truc","XOR-交换技巧","XOR_swap_algorithm","XORアルゴリズム","XORスワップ","XORスワップのトリックを","XOR交换伎俩","XOR交換アルゴリズム","XOR交換アルゴリズム - Wikipedia","XOR交換アルゴリズムとは？ (Wikipediaへのリンク)","XOR算法","Xor Swap","Xor Swap Algorithm","Xor swap","Xor swap algorith","Xor swap algorithm","Xor swap algorithm; it is used under the","Xor-SWAP tRIcQ","Xor_swap_algorithm","a trick to swap","algoritma XOR","algoritma XOR swap:","algoritmo XOR Swap:","algoritmo de intercambio XOR:","algoritmo de intercambio-By-XOR","article dedicated to the Xor Swap algorithm","artigo da Wikipédia Algoritmo Xor Swap","en.wikipedia.org/...Xor_swap_algorithm","en.wikipedia.org/XOR_swap","en.wikipedia.org/wiki/XOR_s...","en.wikipedia.org/wiki/XOR_swap_algorithm","en.wikipedia.org/…_swap_algorithm","en:Swap by addition and subtraction","en:XOR_swap_algorithm","evita l'algoritmo di swap tramite XOR","exclusive-or swap","giao dịch hoán đổi XOR","he:החלפה בעזרת XOR","http://bit.ly/jrCM0j","http://en.wikipedia...._swap_algorithm","http://en.wikipedia.org/wiki/Swap_by...nd_subtraction","http://en.wikipedia.org/wiki/Swap_by_addition_and_subtraction","http://en.wikipedia.org/wiki/XOR_swa...ce_in_practice","http://en.wikipedia.org/wiki/XOR_swap","http://en.wikipedia.org/wiki/XOR_swap_al","http://en.wikipedia.org/wiki/XOR_swap_algorit...","http://en.wikipedia.org/wiki/XOR_swap_algorithm","http://en.wikipedia.org/wiki/XOR_swap_algorithm # Code_example","http://en.wikipedia.org/wiki/XOR_swap_algorithm#Code_example","http://en.wikipedia.org/wiki/XOR_swap_algorithm#Reasons_for_avoidance_in_practice","http://en.wikipedia.org/wiki/XOR_swap_algorithm#The_XCHG_instruction","http://en.wikipedia.org/wiki/XOR_swap_algorithm.","http://en.wikipedia.org/wiki/XOR_swap_algorithm＃Code_example","http://en.wikipedia.org/wiki/XOR_swap_algorithm＃Reasons_for_avoidance_in_practice","http://en.wikipedia.org/wiki/XOR_swap_al…","http://en.wikipedia.org/wiki/Xor_swap_algorithm","http://en.wikipedia.org/wiki/Xor_swap_algorithm#Code_example","http://en.wikipedia.org/wiki/Xor_swap_algorithm#Usage_in_practice","http://en.wikipedia.org/wiki/Xor_swap_al…","http://et.wikipedia.org/wiki/V%C3%A4listavat_v","http://et.wikipedia.org/wiki/XOR_vahetus_algoritm","http://j.mp/jaWMRn","http://ja.wikipedia.org/wiki/XOR%E4%BA","http://ja.wikipedia.org/wiki/XOR交換アルゴリズム","http://ko.wikipedia.org/wiki/XOR_스왑","http://pt.wikipedia....oritmo_Xor_Swap","http://pt.wikipedia.org/wiki/Algoritmo_Xor_Swap","http://pt.wikipedia.org/wiki/Algoritmo_xor_swap","http://ru.wikipedia.org/wiki/Алгоритм_об...","http://ru.wikipedia.org/wiki/Алгоритм_обмена_при_помощи_исключающего_ИЛИ","http://tinyurl.com/5xm2qp","if such tricks are avoided","l'algorithme XOR","l'algoritmo XOR","l'algoritmo XOR swap:","los swaps de XOR","niet te vroeg juichen","operacijo XOR","shouldn't be used","significantly slower","sin usar variable temporal","swap algorithme XOR:","swap by addition and subtraction","swap it in","swap the contents of 2 variables","the XOR Swap Algorithm","the XOR trick","thuật toán XOR","thuật toán trao đổi XOR:","trik z operatorem XOR","trucco XOR scambio","truco XOR intercambio","ttp://ja.wikipedia.org/wiki/XOR%E4%BA","ttp://ja.wikipedia.org/wiki/XOR交換アルゴリズム","two variable swap operation","veja: Wikipedia","we haven't needed something that ugly since","wymiany XOR","xOr 交換のトリック","xor swap algorithm","xor swap algorithm.","xor swapping","xor(排他的論理和)を利用した変数値交換の技","známý XOR trik","ενδιαφέρον άρθρο στο wikipedia","Алгоритм обмена при помощи исключающего ИЛИ","Своп алгоритма XOR","алгоритм XOR","алгоритм обмена при помощи исключающего ИЛИ","алгоритмом XOR","обмен при помощи оператора XOR","старый фокус с исключающим ИЛИ","החלפה בעזרת XOR","החלפה בעזרת XOR – ויקיפדיה","ויקיפדיה - 'החלפה בעזרת Xor'","देखें विकिपीडिया","स्वैप करके XOR एल्गोरिथ्म","กลไก สลับ XOR","กลไก สลับ XOR:","ขั้น ตอน วิธี XOR","ดู วิ กิ พี เดีย","、XOR交換アルゴリズム","ウィキペディアを参照して","スワップバイXORアルゴリズムを","交换XOR算法","异或互换","异或交换","异或交换算法","异或算法","異或互換","異或交換算法","異或算法","위키 피 디아 문서 XOR 교체 알고리즘","위키 피 디아 문서 XOR 교환 알고리즘","위키 피 디아 문서 XOR 스왑 알고리즘","위키 피 디아를 참조하십시오"],"name":"XOR swap algorithm","categories":["Algorithms","All articles needing additional references","Articles needing additional references from February 2012","Articles with example C code","Binary arithmetic"],"tag_line":"In computer programming, the XOR swap is an algorithm that uses the XOR bitwise operation to swap values of distinct variables having the same data type without using a temporary variable."}}
,{"_index":"throwtable","_type":"algorithm","_id":"apx","_score":0,"_source":{"description":"In complexity theory the class APX (an abbreviation of \"approximable\") is the set of NP optimization problems that allow polynomial-time approximation algorithms with approximation ratio bounded by a constant (or constant-factor approximation algorithms for short). In simple terms, problems in this class have efficient algorithms that can find an answer within some fixed multiplicative factor of the optimal answer. The class APX is also sometimes known as MaxSNP because the basis of its definition is formed by SNP.\nAn approximation algorithm is called a -approximation algorithm for input size  if it can be proven that the solution that the algorithm finds is at most a multiplicative factor of  times worse than the optimal solution. Here,  is called the approximation ratio. Problems in APX are those with algorithms for which the approximation ratio  is a constant . The approximation ratio is conventionally stated greater than 1. In the case of minimization problems,  is the found solution's score divided by the optimum solution's score, while for maximization problems the reverse is the case. For maximization problems, where an inferior solution has a smaller score,  is sometimes stated as less than 1; in such cases, the reciprocal of  is the ratio of the score of the found solution to the score of the optimum solution.\nIf there is a polynomial-time algorithm to solve a problem to within every multiplicative factor of the optimum other than 1, then the problem is said to have a polynomial-time approximation scheme (PTAS). Unless P=NP there exist problems that are in APX but without a PTAS, so the class of problems with a PTAS is strictly contained in APX. One such problem is the bin packing problem.","alt_names":["- APX :","- APX-hard :","- Constant-factor approximation algorithm :","...more on Wikipedia about APX","APX - Wikipedia :: The free encyclopedia","APX - Wikipedia, the free encyclopedia","APX - Wikipedia, the free encyclopedia - Wikipedia","APX Related Content:","APX complete","APX hard","APX on Wikipedia","APX on wikipedia.org","APX – ויקיפדיה","APX-complete","APX-hard","APX-hard; it is used under the","Apx","Constant factor approximation algorithm","Constant-factor approximation algorithm","In complexity theory the class APX (an abbreviation","Source Wikipedia.org Arcticle - APX","What are some examples of Constant-factor approximation","Wikipedia article APX","Wikipedia article APX-hard","Wikipedia article Constant-factor approximation algorithm","Wikipedia article on APX","Wikipedia entry for APX","approximation factor","article APX","constant factor approximation algorithm","constant ratio approximation","constant-factor approximation algorithm","he:APX","http://en.wikipedia.org/wiki/APX","s. http://en.wikipedia.org/wiki/APX"],"name":"APX","categories":["Approximation algorithms","Complexity classes"],"tag_line":"In complexity theory the class APX (an abbreviation of \"approximable\") is the set of NP optimization problems that allow polynomial-time approximation algorithms with approximation ratio bounded by a constant (or constant-factor approximation algorithms for short)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"alpha-max-plus-beta-min-algorithm","_score":0,"_source":{"description":"The alpha max plus beta min algorithm is a high-speed approximation of the square root of the sum of two squares. The square root of the sum of two squares, also known as Pythagorean addition, is a useful function, because it finds the hypotenuse of a right triangle given the two side lengths, the norm of a 2-D vector, or the magnitude of a complex number z=a+bi given the real and imaginary parts.\n\nThe algorithm avoids performing the square and square-root operations, instead using simple operations such as comparison, multiplication, and addition. Some choices of the α and β parameters of the algorithm allow the multiplication operation to be reduced to a simple shift of binary digits that is particularly well suited to implementation in high-speed digital circuitry.\nThe approximation is expressed as:\n\nWhere  is the maximum absolute value of a and b and  is the minimum absolute value of a and b.\nFor the closest approximation, the optimum values for  and  are  and , giving a maximum error of 3.96%.","alt_names":["Alpha max plus beta min algorithm","Alpha max plus beta min algorithm - Wikipedia :: The","Alpha max plus beta min algorithm - Wikipedia, the","Wikipedia (Alpha max plus beta min algorithm)","Wikipedia article Alpha max plus beta min algorithm","Wikipedia entry for Alpha max plus beta min","en.wikipedia.org/wiki/Alpha_max_plus_...","http://en.wikipedia.org/wiki/Alpha_m..._min_algorithm","http://en.wikipedia.org/wiki/Alpha_max_p","http://en.wikipedia.org/wiki/Alpha_max_plus_beta_min_algorithm","http://en.wikipedia.org/wiki/Alpha_max_plus_beta_min_algorithm...","yago-res:Alpha max plus beta min algorithm"],"name":"Alpha max plus beta min algorithm","categories":["All articles with links needing disambiguation","Approximation algorithms","Articles with links needing disambiguation from November 2014","Root-finding algorithms"],"tag_line":"The alpha max plus beta min algorithm is a high-speed approximation of the square root of the sum of two squares."}}
,{"_index":"throwtable","_type":"algorithm","_id":"one-pass-algorithm","_score":0,"_source":{"description":"In computing, a one-pass algorithm is one which reads its input exactly once, in order, without unbounded buffering. A one-pass algorithm generally requires O(n) (see 'big O' notation) time and less than O(n) storage (typically O(1)), where n is the size of the input.\nBasically one-pass algorithm operates as follows: (1) the object descriptions are processed serially; (2) the first object becomes the cluster representative of the first cluster; (3) each subsequent object is matched against all cluster representatives existing at its processing time; (4) a given object is assigned to one cluster (or more if overlap is allowed) according to some condition on the matching function; (5) when an object is assigned to a cluster the representative for that cluster is recomputed; (6) if an object fails a certain test it becomes the cluster representative of a new cluster","alt_names":["one-pass","One Pass Algorithm","One pass algorithm","One-pass algorithm - Wikipedia, the free encyclopedia","One-pass algorithm - Wikipedia, the free encyclopedia ...","One-pass_algorithm","Wikipedia article One-pass algorithm","Wikipedia entry for One-pass algorithm","http://en.wikipedia.org/wiki/One-pass_al","http://en.wikipedia.org/wiki/One-pass_algorithm","one-pass algorithm","yago-res:One-pass algorithm"],"name":"One-pass algorithm","categories":["Algorithms","All articles lacking sources","Articles lacking sources from January 2007"],"tag_line":"In computing, a one-pass algorithm is one which reads its input exactly once, in order, without unbounded buffering."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pluscal","_score":0,"_source":{"description":"PlusCal (formerly called +CAL) is a formal specification language created by Leslie Lamport, which transpiles to TLA+. In contrast to TLA+'s action-oriented focus on distributed systems, PlusCal most resembles an imperative programming language and is better-suited to specifying sequential algorithms. PlusCal was designed to replace pseudocode, retaining its simplicity while providing a formally-defined and verifiable language. A one-bit clock is written in PlusCal as follows:\n\nPlusCal tools and documentation are found on the PlusCal Algorithm Language page.","alt_names":["- PlusCal :","PlusCal","Wikipedia article PlusCal","Wikipedia article on PlusCal","http://en.wikipedia.org/wiki/PlusCal"],"name":"PlusCal","categories":["Algorithm description languages","All stub articles","Computer science stubs","Formal methods","Formal specification languages"],"tag_line":"PlusCal (formerly called +CAL) is a formal specification language created by Leslie Lamport, which transpiles to TLA+."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ping-pong-scheme","_score":0,"_source":{"description":"Algorithms said to employ a Ping-Pong scheme exist in different fields of Software Engineering. They are characterized by an alternation between two entities. In the examples described below, these entities are communication partners, network paths or file blocks.","alt_names":["- Ping-pong scheme :","Ping pong scheme","Ping-pong scheme","Ping-pong scheme - Wikipedia, the free encyclopedia","Ping-pong scheme - Wikipedia, the free encyclopedia ...","Wikipedia article Ping-Pong Scheme","Wikipedia article Ping-pong scheme","Wikipedia entry for Ping-pong scheme","http://en.wikipedia.org/wiki/Ping-Pong_Scheme","http://en.wikipedia.org/wiki/Ping-pong_s","http://en.wikipedia.org/wiki/Ping-pong_scheme","yago-res:Ping-pong scheme"],"name":"Ping-pong scheme","categories":["Algorithms","All articles needing additional references","Articles needing additional references from June 2010"],"tag_line":"Algorithms said to employ a Ping-Pong scheme exist in different fields of Software Engineering."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pollard's-kangaroo-algorithm","_score":0,"_source":{"description":"In computational number theory and computational algebra, Pollard's kangaroo algorithm (aka Pollard's lambda algorithm, see Naming below) is an algorithm for solving the discrete logarithm problem. The algorithm was introduced in 1978 by the number theorist J. M. Pollard, in the same paper  as his better-known ρ algorithm for solving the same problem. Although Pollard described the application of his algorithm to the discrete logarithm problem in the multiplicative group of units modulo a prime p, it is in fact a generic discrete logarithm algorithm—it will work in any finite cyclic group.\n\n","alt_names":[],"name":"Pollard's kangaroo algorithm","categories":["Computer algebra","Logarithms","Number theoretic algorithms"],"tag_line":"In computational number theory and computational algebra, Pollard's kangaroo algorithm (aka Pollard's lambda algorithm, see Naming below) is an algorithm for solving the discrete logarithm problem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"genetic-algorithm","_score":0,"_source":{"description":"In the field of artificial intelligence, a genetic algorithm (GA) is a search heuristic that mimics the process of natural selection. This heuristic (also sometimes called a metaheuristic) is routinely used to generate useful solutions to optimization and search problems. Genetic algorithms belong to the larger class of evolutionary algorithms (EA), which generate solutions to optimization problems using techniques inspired by natural evolution, such as inheritance, mutation, selection, and crossover.","alt_names":["GATTO","GA's","GAs","Problem domains","۹ مراجع","ГА","۸ مطالب مرتبط","http://en.wikipedia....netic_algorithm","Genetischer_Algorithmus","algoritmi evolutivi","- ویکی پدیا","генетическую","Algoritmos genéticos","Algoritmo Genético","genetic algorithms","algoritmo genético","Genetic Algorithms","genetic algorithm","遺伝的アルゴリズム","Genetic Algorithm","'algoritma genetika'","'algoritmo genetico'","'algoritmo genético","'genetic algorithm'","'유전자 알고리즘을'들여다","(Wikipedia先生)","(genetikus algoritmus)","(no) http://en.wikipedia.org/wiki/Genetic_algorithm","* Wikipedia: Genetic algorithm *","*http://en.wikipedia.org/wiki/Genetic_algorithm",", http://en.wikipedia.org/wiki/genetic algorithms.","- Algoritmo Genetico","- Genetic Algorithm","- Genetic Algorithm :","- Genetic Algorithms :","- Genetic algorithm :","- Genetic algorithms :","-> Read more about Genetic algorithm",". Genetic algorithm",". انتخاب Scaling","...Wikipedia Algorithme génétique","...Wikipedia Algoritmo genetico","...Wikipedia Algoritmo genético","...Wikipedia Algorytm ewolucyjny","...Wikipedia Algorytm genetyczny","...a_genetic_programming.png","...mehr auf Wikipedia über Genetischer Algorithmus","...more on Wikipedia about Genetic algorithm","1 GA procedure","1 遗传算法的机理","1 遺傳演算法的機理","1.1 Initialization","1.1 演算法","1.1 算法","1.2 GA参数","1.2 GA參數","1.2 Selection","1.3 在線互動式演示與學習","1.3 在线交互式演示与学习","1.4 Termination","1.4 特点","1.4 特點","1.5 Pseudo-code algorithm","1.6 Observations","12.2 Tutorials","2 Cuándo usar estos algoritmos","2 Programação Genética","2 The building block hypothesis","2 Zapis algorytmu","2 变量","2 變數","3 Bibliotecas e Frameworks para Algoritmos Genéticos","3 Funcionamiento de un algoritmo genético básico","3 Kodowanie","3 Problem domains","3 适用的问题","3 適用的問題","32. Genetic algorithm - Wikipedia, the free encyclopedia","4 Esquema general del algoritmo","4 Funkcja przystosowania","4 http://el.wikipedia.org/","4.1 Funkcja oceny","4.2 Metody selekcji","5 Operatory przeszukiwania","5 應用領域","5.1 Krzyżowanie","5.1 Linkage-learning","5.2 Mutacja","6 Building block hypothesis","6 Problem domains","6 Zastosowania algorytmów genetycznych","6 相关技术","6 相關技術","6.1 Rozwiązywanie problemów NP","6.2 Projektowanie genetyczne","6.3 Projektowanie obwodów elektrycznych","6.4 Przeszukiwanie","7.1 Polskie","7.2 Angielskie","8 Related techniques","8.2 Angielska","AG | Wikipedia","ALGORITMOS GENÉTICOS","ALGORYTM GENETYCZNY","Alg Gen (Wiki)","Algorisme genètic","Algorisme gen�¨tic","Algorithme Générique","Algorithme g?n?tique - Wikip?dia","Algorithme génétique","Algorithme génétique - Wikipédia","Algorithme génétique sur Wikipedia","Algorithmes Génétiques","Algorithmes génétiques","Algorithmus geneticus","Algoritimo Genético","Algoritm genetic","Algoritm genetic - Wikipedia","Algoritma Genetika","Algoritma Genetika.","Algoritma genetik","Algoritma genetik - Wikipedia","Algoritma genetik - Wikipedia bahasa Indonesia, ensiklopedia bebas","Algoritma genetik - Wikipedia bahasa Indonesia, ensiklopedia...","Algoritmi Genetici","Algoritmi genetici","Algoritmi_genetici","Algoritmo Genetico","Algoritmo Genetico:","Algoritmo Genéticos","Algoritmo gen tico Wikipedia la enciclopedia libre","Algoritmo gen?tico - Wikipedia, la enciclopedia libre","Algoritmo gen?tico ? Wikip?dia, a enciclop?dia","Algoritmo genetico","Algoritmo genetico - Wikipedia","Algoritmo genetikoak","Algoritmo gentico - Wikipdia, a enciclopdia livre","Algoritmo genético","Algoritmo genético (Tipos de Procesos de IA)","Algoritmo genético (wikipedia)","Algoritmo genético - Wikipedia","Algoritmo genético - Wikipedia, la enciclopedia libre","Algoritmo genético - Wikipédia, a enciclopédia livre","Algoritmo genético – Wikipédia, a enciclopédia livre","Algoritmo gen谷tico - Wikipedia, la enciclopedia libre","Algoritmo gen鴩co - Wikipedia, la enciclopedia libre","Algoritmo xenético","Algoritmo xenético - Wikipedia, a enciclopedia libre","Algoritmos (e Programação) Genéticos","Algoritmos Geneticos","Algoritmos Genéticos","Algoritmos geneticos","Algoritmos genéticos - Wikipedia","Algoritmosgenéticos","Algoritmul genetic","Algorytm ewolucyjny","Algorytm genetyczny","Algorytm genetyczny - Wikipedia, wolna encyklopedia","Algorytm genetyczny ? Wikipedia, wolna encyklopedia","Algorytm genetyczny – Wikipedia, wolna encyklopedia","Algorytmy ewolucyjne","Algorytmy genetyczne","Algorítimos Genéticos","Algorítmos Genéticos","Algorítmos Genéticos (AG)","Algos génétiques","AnswerQuestions article on Genetic algorithm","Article in Wikipedia about Genetic algorithms","Artículo de la Wikipedia sobre algoritmos genéticos.","Bibliography: Wikipedia's Genetic Algorithm entry","Building Block Hypothesis","Computational evolutionary optimization","Computação Genética","Conceptos básicos de los algoritmos genéticos","Darwinian algorithm","Das wird viele Male wiederholt. Um eine Instanz","Definition of Genetic Algorithm","Definition of genetic algorithms","Definition of “Genetic Algorithm” in Wikipedia","Die Seiten Evolutionsstrategie, Evolutionärer Algorithmus und","Die Seiten Evolutionsstrategie, Evolutionärer Algorithmus und Genetischer","Die Seiten Evolutionsstrategie, Evolutionärer Algorithmus und Genetischer Algorithmus","Diese Mutation komme mit einer Wahrscheinlichkeit von 1","E39.gif","Evo malo preciznije izraženo nego u mom postu","Evolution simulated on computers","Evolutionary Algorithms work","Evolved algorithms","Fonctionnement d&#039;un algorithme génétique","Fonctionnement d'un algorithme génétique","GA (Genetic Algorithms)","GA @ Wikipedia","GA at Wikipedia","GA breeder pool","GA entry at wikipedia","GA from Wikipedia","GA libraries","GA（遺伝的アルゴリズム）","GEGA","GENETIC ALGORITHMS","GENETIC ALGORITHMS!","Ge?et???? ???????µ?? - ????pa?de?a","Ge?et???? ???????ľ?? - ????pa?de?a","Ge?et???? ???????�? - ????pa?de?a","Geic algorithm Simple English Wikipedia the free encyclopedia","Geneettinen algoritmi","Geneettiset algoritmit","Genetic Algorithim","Genetic Algorithims","Genetic Algorithm (GA)","Genetic Algorithm (Wikipedia)","Genetic Algorithm - Wikipedia","Genetic Algorithm - Wikipedia The Free Encyclopedia","Genetic Algorithm - Wikipedia, The Free Encyclopedia","Genetic Algorithm -- Wikipedia","Genetic Algorithm From Wikipedia","Genetic Algorithm Menu","Genetic Algorithm Training","Genetic Algorithm Wikipedia The Free Encyclopedia","Genetic Algorithm article on Wikipedia","Genetic Algorithm at Wikipedia","Genetic Algorithm in Wikipedia","Genetic Algorithm on Wikipedia","Genetic Algorithm's","Genetic Algorithms (GA)","Genetic Algorithms (Wikipedia)","Genetic Algorithms - wikipedia","Genetic Algorithms : Wikipedia Encyclopedia","Genetic Algorithms Defined","Genetic Algorithms Definition","Genetic Algorithms Definition.","Genetic Algorithms at Wikipedia","Genetic Algorithms on Wikipedia","Genetic Algorithms(GA).","Genetic Algorithms,","Genetic Algorithms.","Genetic Algorithms: Wikipedia","Genetic Algorithsm","Genetic Algoritm (Algorytm Genetyczny)","Genetic Algoritms","Genetic Algortihms","Genetic Algrethim","Genetic Programming techniques(*)","Genetic algorithm","Genetic algorithm (GA) applications - automated design","Genetic algorithm (Wikipedia)","Genetic algorithm - Simple English Wikipedia, the free ...","Genetic algorithm - Simple English Wikipedia, the free encyclopedia","Genetic algorithm - Tutorials","Genetic algorithm - Wikipedia","Genetic algorithm - Wikipedia, the free encyclopedia","Genetic algorithm - Wikipedia, the free encyclopedia »","Genetic algorithm - Wikipedia, the free encyclopediaA genetic","Genetic algorithm - Wikipédia","Genetic algorithm Simple English Wikipedia the free encyclopedia","Genetic algorithm Wikipedia the free encyclopedia","Genetic algorithm Wikipedia the free encyclopedia - result","Genetic algorithm for wikipedia","Genetic algorithm the free","Genetic algorithm with mutation","Genetic algorithm – Wikipedia, the free encyclopedia","Genetic algorithm – in sources of Wikipedia, the free","Genetic algorithm.","Genetic algorithms (GA)","Genetic algorithms (Wiki)","Genetic algorithms (Wikipedia)","Genetic algorithms, Wikipedia","Genetic/Evolutionary Algorithms","Genetic_Algorithms","Genetic_algorithm","Genetic_algorithms","Genetici","Genetické algoritmy","Genetický algoritmus","Genetický algoritmus - Wikipedie","Genetický algoritmus - Wikipédia","Genetický algoritmus - Wikipédia - Wikipedia","Genetický algoritmus učení","Genetics algorithms","Genetik Algoritma","Genetik Algoritmalar","Genetik algoritma","Genetik algoritma - Vikipedi","Genetik algoritmalar","Genetikus algoritmus","Genetikus algoritmus (Wikipedia)","Genetikus algoritmus - Wikip...","Genetikus algoritmus - Wikip?dia","Genetikus algoritmus - Wikipédia","Genetiniai algoritmai","Genetiniai algoritmai – Vikipedija","Genetisch Algoritme","Genetisch algoritme","Genetisch algoritme - Wikipedia","Genetische Algorithmen","Genetische Algorithmen GA sind Algorithmen, die auch nicht","Genetische Algorithmen.","Genetische algorithmen","Genetische algoritmen","Genetische algoritmes","Genetische_Algorithmen","Genetischen Algorithmen","Genetischen Algorithmus","Genetischer Algorithmen","Genetischer Algorithmus","Genetischer Algorithmus ? Wikipedia","Genetischer Algorithmus â�“ Wikipedia","Genetischer Algorithmus – Wikipedia","Genetischer Algorithmus — Wikipedia","Genetisk algoritme","Genetiske algoritmer","Genetički algoritmi","Genetski algoritmi","Genetski i evolucijski algoritmi","Genettic Algorithm","Genetyczny","Gi i thu t di truy n Wikipedia","Giải thuật di truyền","Giải thuật di truyền - Wikipedia tiếng Việt","Giải thuật di truyền – Wikipedia tiếng Việt","Gli algoritmi genetici","How are Darwinian algorithm's observations?","If you want to know more about Genetic","Im Gegensatz zur Genetischen Programmierung ist das Verfahren","Ir a Algoritmo genético - Wikipedia, la enciclopedia libre","L http://nl.wikipedia.org/wiki/Genetisch_","LG_optima.png","LINK： 遺伝的アルゴリズム","La sélection naturelle appliquée à l'informatique: les","Lalgorit Geredik","Lalgorit Geredik - Vükiped","Learn about Genetic algorithm>>>","Les algorithmes génétiques","Lietuviškos Vikipedijos nuorodos apie genetinius algoritmus","Los algoritmos genéticos","Ma davvero?!","Modified from: http://en.wikipedia.org/wiki/Genetic_algorithm","Mutation binärer Zahlen","Mutation von binären Zahlen","One more incredible result of the discovery of","Operatori per gli algoritmi genetici","Os algoritmos genéticos","Page Wikipedia sur les algorithmes génétiques","Pseudo-code of a genetic algorithm","Qui alcune idee generali sui GA (algoritmi genetici","Read More about genetic algorithm wikipedia the free","Read More genetic algorithm simple english wikipedia the","Read More genetic algorithm wikipedia the free encyclopedia","Referecia en inglés de la Wikipedia","Resources on Genetic Algorithms","Retineurali/Wikipedia","Satellite Scheduling & Genetic Algorithms","Selektion Zufällige Auswahl von Lösungskandidaten aus der aktuellen","Simple Genetic Algorithm","Sorry, I should have posted a link","The Building Block Hypothesis","The Wikipedia page on Genetic Algorithms","The building block ...","The building block hypothesis","There are algorithms out there that already function","Thumbnail of screenshot of Genetic algorithm - Wikipedia, the","Thuật toán di truyền","Try Wikipedia?","Uh huh, sure it is...","View Genetic algorithm on Wikipedia","View Genetic algorithms on Wikipedia","Vikipedi'deki Genetik Algoritmalar","W Algo génétiques","Weitere Informationen zur genetischen Programmierung","Wiki - Algorithmes génétiques","Wiki - Genetic Algorithms","Wiki about Genetic Algorithm","Wiki on Genetic Algorithms","Wiki: Genetic Algorithm","WikiPedia > Genetic algorithm ( GA )","WikiPedia:Genetic_algorithm","Wikipedia (Algoritmo genético)","Wikipedia - Genetic Algorithm","Wikipedia - Genetic Algorithms","Wikipedia - genetický algoritmus","Wikipedia - 遺伝的アルゴリズム","Wikipedia : Genetic Algorithm","Wikipedia : 遺伝的アルゴリズム","Wikipedia Article on Genetic Algorithms","Wikipedia English - Gega","Wikipedia Genetic Algo-","Wikipedia Genetic Algorithm","Wikipedia Genetic Algorithm Applications","Wikipedia Genetic Algorithm Discussion","Wikipedia Genetic Algorithm page","Wikipedia about [Genetic Algorithm]","Wikipedia article Algorisme genètic","Wikipedia article Algorithme génétique","Wikipedia article Algorithmus geneticus","Wikipedia article Algoritma genetik","Wikipedia article Algoritmo genético","Wikipedia article Algoritmo xenético","Wikipedia article Algorytm genetyczny","Wikipedia article GEGA","Wikipedia article Genetic Algorithm","Wikipedia article Genetic Algorithms","Wikipedia article Genetic algorithm","Wikipedia article Genetic algorithms","Wikipedia article Genetic_algorithm","Wikipedia article Genetický algoritmus","Wikipedia article Genetikus algoritmus","Wikipedia article Genetisk algoritme","Wikipedia article on Algoritmo genético","Wikipedia article on Algoritmo xenético","Wikipedia article on Algoritmos Genéticos","Wikipedia article on Algoritmos genéticos","Wikipedia article on Algoritmos xenéticos","Wikipedia article on GA","Wikipedia article on GEGA","Wikipedia article on Genetic algorithms","Wikipedia article on GeneticAlgorithm","Wikipedia article on genetic algorithms","Wikipedia article Генетический алгоритм","Wikipedia article אלגוריתם גנטי","Wikipedia article الگوریتم ژنتیکی","Wikipedia article خوارزميات وراثية","Wikipedia article ขั้นตอนวิธีเชิงพันธุกรรม","Wikipedia artikel Genetisch algoritme","Wikipedia categorizes a genetic algorithm","Wikipedia entry for GEGA","Wikipedia entry for Genetic algorithm","Wikipedia entry for genetic algorihtms","Wikipedia entry on GA","Wikipedia entry on Genetic Algorithms","Wikipedia genetic algorithms","Wikipedia l'articolo Algoritmo genetico","Wikipedia om Genetiske algortimer","Wikipedia on Genetic Algorithms","Wikipedia page about genetic algorithms","Wikipedia – Genetic Algorithm","Wikipedia's article on GA","Wikipedia's article on genetic algorithms","Wikipedia's introduction to Genetic Algorithms","Wikipedia-Artikel Genetische Algorithmen","Wikipedia-Artikel Genetischer Algorithmus","Wikipedia-Artikel Mutation binärer Zahlen","Wikipedia-Artikel Mutation von binären Zahlen","Wikipedia-Artikel über genetische Algorithmen","Wikipedia-Genetic Algorithm","Wikipedia-Seite zu 'Genetische Algorithmen'","Wikipedia-Seite zu 'Genetischer Algorithmus'","Wikipedia-Seite zu 'Mutation von binären Zahlen'","Wikipedia: Genetic Algorithm","Wikipedia: Genetic Algorithms","Wikipedia: Genetic algorithm","Wikipedia: Genetic algorithm (angol)","Wikipedia: Genetic_algorithm","Wikipedia::Genetic_Algorithm","Wikipedia:Algoritmi_genetici","Wikipedia:Genetic algorithms","Wikipedia:Genetic_algorithm","Wikipedia・遺伝的アルゴリズム","Wikipedia日本語版 - 遺伝的アルゴリズム","Wikipedia英語版 - Gega","Wikipedia：遺伝的アルゴリズム","Wikipédia artigo Algoritmo genético","[COLOR=#0000ff]genetic algorithms[/COLOR]","[Genetic Algorithms]","[[th:ขั้นตอนวิธีเชิงพันธุกรรม]]","[http://pt.wikipedia.org/wiki/Algoritmo_gen%C3%A9tico","[plus de détaille]","a genetic algorit","a genetic algorithm","a pile of other tricky problems","a search heuristic","algo génétique","algorisme genètic","algorismes genètics","algorith methods","algorithm genetig","algorithme génétique","algorithmes gÃ©nÃ©tiques","algorithmes génétiques","algorithmes génétiques)","algorithmes génétiques.","algorithms, etc.). Variations on this problem include multiple","algoritm genetic","algoritma genetik","algoritma genetika","algoritma genetika.","algoritme genètic","algoritme genètic (GA)","algoritmes genètics","algoritmi genetici","algoritmi genetici (GA)","algoritmi genetici.","algoritmi gjenetik","algoritmi immunologici","algoritmii genetici","algoritmilor genetici","algoritmo genetico","algoritmo genetikoak","algoritmo genético que resuelve el problema Royal Road","algoritmo xenético","algoritmos biologicamente inspirados","algoritmos geneticos","algoritmos genÃ©ticos","algoritmos genéticos","algoritmos genéticos.","algortimi genetici","algorytm genetyczny","algorytm genetyczny, zwany też ewolucyjnym","algorytmach ewolucyjnych","algorytmach genetycznych","algorytmach genetycznyh.","algorytmami ewolucyjnymi","algorytmami genetycznymi","algorytmu genetycznego","algorytmy ewolucyjne","algorytmy genetyczne","algorytmów ewolucyjnych","algorytmów genetycznych","algoríitmes genètics","all'articolo","and genetic algorithms","arenema","article allemand à ce sujet","articolo di Wikipedia su algoritmi genetici","artigo da Wikipédia Algoritmo genético","artigo da Wikipédia em algoritmos genéticos","artikel Wikipedia pada algoritma genetik","artículo de Wikipedia Algoritmo genético","artículo de Wikipedia Algoritmos Genéticos","artículo de Wikipedia Algoritmos genéticos","artículo en Wikipedia sobre algoritmos genéticos","attīstīt","azar.","building block theory","bài viết Wikipedia trên thuật toán di truyền","cadenas genéticas","cet article de Wikipedia sur des algorithmes génétiques","complex problems using evolution","currently far from settled","các thuật toán di truyền","các thuật toán di truyền.","d'algorithmes génétiques.","de um algoritmo genético","de.wikipedia.org — Genetischer_Algorithmus","de.wikipedia.org/...Genetischer_Algorithmus","de.wikipedia.org/wik...etischer_Algorithmus","de.wikipedia.org/wiki/Genetischer_Algorithmus","definici z wikipedie","des algorithmes génétiques","desenvolver","diversity in learning","does not necessarily imply a programmer","el cerebro utiliza un algoritmo muy simple que","el:Γενετικός Αλγόριθμος","en.wikipedia.org/.../Genetic_algorithm","en.wikipedia.org/...Genetic_algorithm","en.wikipedia.org/...Genetic_algorithms","en.wikipedia.org/wiki/Genetic_ ...","en.wikipedia.org/wiki/Genetic_algorit...","en.wikipedia.org/wiki/Genetic_algorithm","en.wikipedia.org/wiki/Genetic_algorithm#Problem_domains","en.wikipedia.org/wiki/Genetic_algorithms","enetic algorithm","erfða algrím","es.wikipedia.org/...Algoritmos_gen%C3%A9ticos","es.wikipedia.org/wiki/Algoritmo_gen%C3%A9tico","es.wikipedia.org/wiki/Algoritmos_gen%C3%A9ticos#Cu","es.wikipedia.org/wiki/Algoritmos_gen%c3%a9ticos","evolua","evoluoj","evolution was first simulated with computers in the","evolúciós algoritmusa","exchange best practices faster","exciting ideas","extracto obtenido de la Wikipedia","fejlődik","field of Computer Science","find application","fr.wikipedia.org/...Algorithme_g%C3%A9n%C3%A9tique","fr:Algorithme génétique","gelişmek","geneetiline algoritm","geneetilise algoritmi","geneettinen algoritmi","geneettiset algoritmit","geneettisillä algoritmeilla","geneettisissä algoritmeissa","geneettisiä algoritmeja","geneettistä algoritmia","generic algorithms","generiske algoritmer","genetic AI","genetic Algorithms","genetic algorith","genetic algorithm (GA)","genetic algorithm article","genetic algorithm creation","genetic algorithm cycle","genetic algorithm method","genetic algorithm simple english wikipedia the free encyclopedia","genetic algorithm wikipedia the encyclopedia","genetic algorithm wikipedia the free encyclopedia","genetic algorithm,","genetic algorithm-based bot","genetic algorithm.","genetic algorithms in computer science.","genetic algorithms,","genetic algorithms.","genetic algorithms?","genetic algoritms","genetic algs","genetic alogrithm","genetic optimization algorithms","genetic search","genetic search algorithms","genetic-algorithms","genetically evolve","genetice (GAs)","genetichen algoritum","geneticki algoritam","genetickih algoritama","genetické algoritmy","genetického algoritmu","genetický algoritmus","genetiese algoritme","genetik algoritma","genetik algoritmalar","genetik algoritmalarla","genetikaj algoritmoj","genetiko algorithm","genetikus algoritmus","genetikus algoritmusok","genetikus algoritmusokat","genetikus algoritmusokkal","genetinis algoritmas","genetinius algoritmus","genetinius algoritmus (GA)","genetinį algoritmą","genetisch algorithme","genetisch algoritme","genetisch algoritmen","genetische Algorithmen","genetische algoritmen","genetische algoritmes","genetischen Algorhitmen","genetischen Algorithmen","genetischen Algorithmus","genetischer Algorithmen","genetischer Algorithmus","genetisk algoritme","genetiska algoritmer","genetiske algoritme","genetiske algoritmen","genetiske algoritmer","genetskega algoritma","genetski algoritam","genetski algoritem","genetski algoritmi","genetskih algoritama","genetskim algoritmima","gentic algorithms","gentischen Algorithmus","gii thuat di truyen","giải thuật di truyền","gli algoritmi genetici","have a read at these","hi:आनुवंशिक एल्गोरिथ्म","http:// .wikipedia.org/wiki/Geneettinen_algoritmi","http://ar.wikipedia.org/wiki/%D8%AE%...AB","http://cs.wikipedia.org/wiki/Genetick%C3%BD","http://cs.wikipedia.org/wiki/Genetick%C3%BD_algoritmus","http://cs.wikipedia.org/wiki/Genetický_algoritmus","http://da.wikipedia.org/wiki/Genetisk_algoritme","http://de.wikipedia.org/wiki/G...lgorithmus","http://de.wikipedia.org/wiki/Ge netische_Algorithmen","http://de.wikipedia.org/wiki/Ge netischer_Algorithmus","http://de.wikipedia.org/wiki/Genetische_Algorithmen","http://de.wikipedia.org/wiki/Genetischer_","http://de.wikipedia.org/wiki/Genetischer_Algorithmus","http://de.wikipedia.org/wiki/Mutation_von_bin%C3%A4ren_Zahlen","http://el.wikipedia.org/wiki/Γεμεςικξί_Αλγϊοιθμξι.","http://el.wikipedia.org/wiki/Γενετικοί_Αλγόριθμοι","http://el.wikipedia.org/wiki/Γενετικοί_αλγόριθμοι","http://el.wikipedia.org/wiki/Γενετικός_Αλγόριθμος","http://en.wikipedia....etic_algorithms","http://en.wikipedia.org/wi ki/Genetic_algorithm","http://en.wikipedia.org/wiki/GEGA","http://en.wikipedia.org/wiki/Genetic algorithm","http://en.wikipedia.org/wiki/Genetic algorithm,","http://en.wikipedia.org/wiki/Genetic algorithm.","http://en.wikipedia.org/wiki/Genetic...m#Applications","http://en.wikipedia.org/wiki/Genetic...roblem_domains","http://en.wikipedia.org/wiki/Genetic...s#Applications","http://en.wikipedia.org/wiki/Genetic_Alg...","http://en.wikipedia.org/wiki/Genetic_Algorith","http://en.wikipedia.org/wiki/Genetic_Algorithm","http://en.wikipedia.org/wiki/Genetic_Algorithms","http://en.wikipedia.org/wiki/Genetic_alg orithm","http://en.wikipedia.org/wiki/Genetic_alg...","http://en.wikipedia.org/wiki/Genetic_algorith","http://en.wikipedia.org/wiki/Genetic_algorith...","http://en.wikipedia.org/wiki/Genetic_algorithm","http://en.wikipedia.org/wiki/Genetic_algorithm#Applications","http://en.wikipedia.org/wiki/Genetic_algorithm#History","http://en.wikipedia.org/wiki/Genetic_algorithm#Initialization","http://en.wikipedia.org/wiki/Genetic_algorithm#Methodology","http://en.wikipedia.org/wiki/Genetic_algorithm#Problem_domains","http://en.wikipedia.org/wiki/Genetic_algorithm)","http://en.wikipedia.org/wiki/Genetic_algorithm,","http://en.wikipedia.org/wiki/Genetic_algorithm.","http://en.wikipedia.org/wiki/Genetic_algorithm. . .","http://en.wikipedia.org/wiki/Genetic_algorithms","http://en.wikipedia.org/wiki/Genetic_algorithms (External Link","http://en.wikipedia.org/wiki/Genetic_algorithms#Applications","http://en.wikipedia.org/wiki/Genetic_algo…","http://en.wikipedia.org/wiki/Genetic_alg…","http://en.wikipedia.​org/wiki/Genetic_alg​orithm","http://es.wikipedia.org/wiki/Algoritmo gen%C3","http://es.wikipedia.org/wiki/Algoritmo_gen%C3%A9ti","http://es.wikipedia.org/wiki/Algoritmo_gen%C3%A9tico","http://es.wikipedia.org/wiki/Algoritmo_genético","http://es.wikipedia.org/wiki/Algoritmo_g…","http://es.wikipedia.org/wiki/Algoritmos_gen%C3%A9ticos","http://fa.wikipedia.org/wiki/الگوریتم_ژنتیک","http://fi.wikipedia.org/wiki/Geneettinen_algoritmi","http://fr.wikipedia.org/wiki/Algor [...] C3%A9tique","http://fr.wikipedia.org/wiki/Algor [...] apitulatif","http://fr.wikipedia.org/wiki/Algori...%A9n%C3","http://fr.wikipedia.org/wiki/Algorit...A9n%C3","http://fr.wikipedia.org/wiki/Algorit..._industrielles","http://fr.wikipedia.org/wiki/Algorithme ... C3%A9tique","http://fr.wikipedia.org/wiki/Algorithme … C3%A9tique","http://fr.wikipedia.org/wiki/Algorithme_...C3%A9tique","http://fr.wikipedia.org/wiki/Algorithme_g%C3%","http://fr.wikipedia.org/wiki/Algorithme_g%C3%A9n","http://fr.wikipedia.org/wiki/Algorithme_génétique","http://fr.wikipedia.org/wiki/Algorithme_génétique#Applications...","http://fr.wikipedia.org/wiki/Algorithmes_g%C3%A9n","http://hu.wikipedia.org/wiki/Genetikus_algoritmus","http://id.wikipedia.org/wiki/Algoritma_Genetik","http://id.wikipedia.org/wiki/Algoritma_genetik","http://it.wikipedia.org/wiki/Algoritmi_genetici","http://it.wikipedia.org/wiki/Algoritmo_genetico","http://it.wikipedia.org/wiki/algoritmi_g...","http://ja.wikipedia.org/wiki/遺伝的アルゴリズム","http://ja.wikipedia.org/wiki/遺伝的アルゴリズム#.E3.82","http://ja.wikipedia.org/wiki/遺伝的アルゴリズム#.E3.83","http://lt.wikipedia.org/wiki/Genetiniai_algoritmai","http://nl.wikipedia.org/wiki/Genetisch_algoritme","http://pl.wikipedia....rytm_ewolucyjny","http://pl.wikipedia....rytm_genetyczny","http://pl.wikipedia.org/wiki/Algorytm_ewolucyjny","http://pl.wikipedia.org/wiki/Algorytm_genetyczny","http://pl.wikipedia.org/wiki/Algorytmy_ewolucyjne","http://pl.wikipedia.org/wiki/Metody_ewolucyjne","http://pt.wikipedia.org/wiki/Algoritmo_Gen%C3%A9tico","http://pt.wikipedia.org/wiki/Algoritmo_gen%C3%A9tico","http://pt.wikipedia.org/wiki/Algoritmo_genético","http://pt.wikipedia.org/wiki/Algoritmo_g…","http://pt.wikipedia.org/wiki/Algoritmos_Gen%C3%A9ticos","http://pt.wikipedia.org/wiki/Algoritmos_…","http://ro.wikipedia.org/wiki/Algoritm_genetic","http://ru.wikipedia.org/wiki/%…%B8%D1%82","http://ru.wikipedia.org/wiki/Генетические_алгоритмы","http://ru.wikipedia.org/wiki/Генетический_алгоритм","http://tr.wikipedia.org/wiki/Genetik_Algoritmalar","http://tr.wikipedia.org/wiki/Genetik_algoritma","http://www.vitruality.com/?tag=galapagos","http://zh.wikipedia.org/zh/遗传算法","i algoritmi genetic","ici en francais","in-computo natural selection","jevolvu","kehittää","klasyczny algorytm genetyczny","kn:ಅನುವಂಶಿಕ ಕ್ರಮಾವಳಿ","kufuka","l'algorithme génétique","l'article de Wikipédia Algorithme génétique","les algorithmes génétiques","los algorismos genéticos","los algoritmos genéticos","los algoritmos genéticos.","lv:Ģenētiskais algoritms","m Wikipedia::Genetic_Algorithm","maumbile algorithm","new forms of computation","no glyphs","no:Genetisk algoritme","o algorytmach genetycznych","o que eles mencionam como aplicações","pl.wikipedia.org/wiki/Algorytm_genetyczny","plėtotis","pour Wiki aussi","programy genetyczne (ewolucyjne)","pt.wikipedia.org/wiki/Algoritmo_gen%C3%A9tico","rarest cases","razvijajo","razviti","robust work","ru.wikipedia.org/wiki/Генетический_алгоритм","ru:Генетический алгоритм","selected for fitness and bred","similar processes","simple genetic algorithm","source: http://en.wikipedia.org/wiki/Genetic_algorithm","sr:Генетички алгоритам","sr:Генетски алгоритам","sur en.wikipédia","symulować ewolucję","ta:மரபுசார் அல்காரிதம்","ta:மரபுசார் படிமுறைத் தீர்வு","te:జన్యు అల్గోరిథం","tecnologie basate sugli algoritmi genetici","tecnologie basate...","these (pops)","these genetic algorithms","this is not *new* new","thuật toán di truyền","thuật toán di truyền.","thuật toán gien","tp://en.wikipedia.org/wiki/Genetic_algorithms","tr:Genetik algoritma","ttp://en.wikipedia.org/wiki/Genetic_algorithm","udvikle sig","un Extrait de Wikipedia fr","utvikle seg","various genetic algorithms","vyvíjať sa","vyvíjet se","w:Genetic Algorithm","w:Genetischer Algorithmus","what you appear to be thinking of","wiki - 遺伝的アルゴリズム","wiki/Genetic_algorithm","wiki:Генетический_алгоритм","wikipedia converge en probabilidad","wikipedia entry on GA","wikipedia page on Genetic Algorithms","wikipedia 遺伝的アルゴリズム","wikipedia.org/... /Genetic_algorithm","wikipedia:遺伝的アルゴリズム","wp:Genetic algorithms","wpja:遺伝的アルゴリズム","wykorzystaniem algorytmów genetycznych","y las mejores mutan, cambian y se “reproducen","zh.wikipedia.org/...%97%E4%BC%A0%E7","«генетические алгоритмы»","éabhlóid","étaheuristique (cf. Wikipedia définition) !!!!!","ġenetika algoritmu","Ģenētiskais algoritms","ģenētisko algoritmu","ΓεÎ½ετικοί Αλγόριθμοι - Βικιπαίδεια","Γενετικοί Αλγόριθμοι - Βικιπαίδεια","Ηλεκτρονική εγκυκλοπαίδεια","γενετικού αλγορίθμου","γενετικούς αλγόριθμους","γενετικό αλγόριθμο","γενετικών αλγορίθμων","Вики: Генетический алгоритм","Википедии статью Генетические алгоритмы","Википедии статью Генетический алгоритм","Википедия: Генетический алгоритм","ГеÐ½етический алгоритм — Википедия","Генети́ческий алгори́тм","Генетические алгоритмы","Генетические алгоритмы.","Генетический ...","Генетический алгоритм","Генетический алгоритм (вики)","Генетический алгоритм (википедия)","Генетический алгоритм - Википедия","Генетический алгоритм — Википедия","Генетический подход","Генетический_алгоритм","Генетическими алгоритмами","Генетического алгоритма","Генетичний алгоритм","Генетичний алгоритм — Вікіпедія","Геннетические алгоритмы","Узнать что такое генетический алгоритм (ГА)","википедию (люди не зря стараются)","вот вкратце описание","вот что пишут","генетичен алгоритъм","генетическyesие алгоритмы","генетические (эволюционные) алгоритмы","генетические алгоритмы","генетические алгоритмы находят широкое применение","генетические алгоритмы.","генетический алгоритм","генетическим алгоритмам","генетическим алгоритмом","генетическими алгоритмами","генетических алгоритмах","генетических алгоритмах.","генетических алгоритмов","генетического алгоритма","генетички алгоритми","генетични алгоритми","генетичний алгоритм","генетичних алгоритмів","генетичного алгоритму","генетски алгоритам","еволуираат","еволуирати","занятный метод","здеь","метод генетических алгоритмов","развиваться","развівацца","розвиватися","се развива","ссылка для тех кому нужно погружение","статье Википедии о генетических алгоритмах","широко применяются","эти яйца,","אלגוריתם גנטי","אלגוריתם גנטי – ויקיפדיה","אלגוריתמים גנטיים","גענעטיק אַלגערידאַם","האלגוריתם הגנטי","האלגוריתמים הגנטיים","ויקיפדיה - 'אלגוריתם גנטי'","יוואַלוו","להתפתח","الخوارزميات الوراثية","الخوارزمية الجينية","الخوارزيمات الجينيه : تعريف","الگوريتم هاي ژنتيکي","الگوريتم ژنتيك","الگوريتم ژنتيک","الگوريتمهاي ژنتيک","الگوریتم های ژنتیک","الگوریتم ژنتیک","الگوریتم ژنتیک - ویکیپدیا","الگوریتم ژنتیک در ویکی پدیا","الگوریتم ژنتیک – ویکیپدیا","الگوریتم ژنتیکی","الگوریتم ژنتیکی - ویکیپدیا","الگوریتم ژنتیکی – ویکیپدیا","الگوریتم_ژنتیک","الگوریتمهای ژنتیک","الگوریتمهای ژنتیکی","انتخاب Roulette","انتخاب Tournament","ایده اصلی","بهینه یابی با الگوریتم ژنتیک","تعریف الگوریتم ژنتیک در ویکیپدیا","خوارزميات جينية","خوارزميات وراثية","خوارزمية الجينات","روش های انتخاب","روش های نمایش","روشه های انتخاب","عملگرهای الگوریتم","منبع توضیح برنامه نویسی ژنتیک","هدا موقع مليح على الجينتك بجد %% ان شاء","ویرایش ] فلو چارت این الگوریتم","۱انتخاب Elitist","۲ الگوریتم ژنتیک چیست؟","۲ عرصه الگوریتم ژنتیک در علوم رایانه ای","۳ روش های نمایش","۳ عملگرهای یک الگوریتم ژنتیک","۴ اجزائ الگوریتم ژنتیک","۴ عملگرهای یک الگوریتم ژنتیک","۵ شبه کد","۵ کاربردهای الگوریتم ژنتیک","۵.۱ شمای کلی شبه کد","۶ ایده اصلی","۷ روش های انتخاب","۷.۱ انتخاب Elitist","۷.۲ انتخاب Roulette","۷.۳ انتخاب Scaling","۷.۴ انتخاب Tournament","आनुवंशिक","आनुवंशिक एल्गोरिथम","आनुवंशिक एल्गोरिथ्म","आनुवंशिक एल्गोरिदम","विकसित करना","हैं आनुवंशिक","জেনেটিক এলগোরিদম","জেনেটিক প্রোগ্রামিং","மரபுசார் ...","மரபுசார் படிமுறைத் தீர்வு","జన్యు అల్గోరిథం","ಅನುವಂಶಿಕ ಕ್ರಮಾವಳಿ","ജെനെറ്റിക് അല്ഗോരിതത്തിന്","กลไก ทาง พันธุกรรม","กลไก ทาง พันธุกรรม.","ขั้น ตอน วิธี ทาง พันธุกรรม","ขั้นตอนวิธีทางพันธุกรรม","ขั้นตอนวิธีพันธุกรรม","ขั้นตอนวิธีเชิงพันธุกร ...","ขั้นตอนวิธีเชิงพันธุกรรม","ขั้นตอนวิธีเชิงพันธุกรรม - วิกิพีเดีย","บทความ วิ กิ พี เดีย ใน กลไก ทาง","พันธุ Algorithms","วิวัฒน์","“Algoritmos Genéticos”","“Genetic Algorithms”","“遗传算法”（Genetic Algorithm）","↑genetic algorithm","⇒詳細はこちらをクリック！","■遺伝的アルゴリズム - Wikipedia","「遺伝的アルゴリズム」についてWikipediaで調査","「遺伝的アルゴリズム」をWikipediaで調べる","アルゴリズムを遺伝的","エリート選択","一様交差","初期収束","基因法","基因演算法","應用遺傳演算法於智慧型空間熱舒適度系統之研究","百科文章基於遺傳算法","的遗传算法","的遺傳算法","維基百科的文章“ 遗传算法”","维基相关条目","進化的アルゴリズム(Genetic Algorithm)","遗传算法","遗传算法- 维基百科,自由的百科全书","遗传算法- 维基百科，自由的百科全书","遗传算法维基百科","遺伝アル","遺伝アルゴリズム","遺伝アルゴリズム - Wikipedia","遺伝的アルゴリズム (GA)","遺伝的アルゴリズム (wikipediaへのリンク)","遺伝的アルゴリズム - Wikipedia","遺伝的アルゴリズム - Wikipedia [ja.wikipedia.org]","遺伝的アルゴリズム - ウィキ","遺伝的アルゴリズム Wikipedia","遺伝的アルゴリズム からWikipediaを検索","遺伝的アルゴリズム(GA)","遺伝的アルゴリズム(Genetic Algorithm;GA)","遺伝的アルゴリズム(Wikipedia)","遺伝的アルゴリズム-Wikipedia","遺伝的アルゴリズム-wikipedia","遺伝的アルゴリズムでは、","遺伝的アルゴリズムは、","遺伝的アルゴリズムを","遺伝的アルゴリズム（GA）","遺伝的プログラム","遺伝的ｱﾙｺﾞﾘｽﾞﾑ","遺伝的ｱﾙｺﾞﾘｽﾞﾑ-wikipedia","遺傳演算法","遺傳演算法(Wiki)","遺傳演算法(genetic algorithm)","遺傳演算法- 維基百科，自由的百科全書","遺傳算法","위키 피 디아 문서 유전 알고리즘","유전 알고리즘","유전 알고리즘 - 위키백과, 우리 모두의 백과사전","유전(Genetic) 알고리즘","유전자 알고리즘","유전자 알고리즘과에 위키 피 디아의 문서의","유전자 알고리즘은","유전자 알고리즘을","유전자관련 알고리즘"],"name":"Genetic algorithm","categories":["All articles needing additional references","All articles with dead external links","All articles with unsourced statements","Articles needing additional references from May 2011","Articles with dead external links from September 2011","Articles with unsourced statements from August 2007","Articles with unsourced statements from December 2011","CS1 errors: dates","CS1 errors: external links","Cybernetics","Digital organisms","Genetic algorithms","Mathematical optimization","Optimization algorithms and methods","Pages using citations with accessdate and no URL","Search algorithms","Use dmy dates from July 2013","Wikipedia articles with BNF identifiers","Wikipedia articles with GND identifiers","Wikipedia articles with LCCN identifiers"],"tag_line":"In the field of artificial intelligence, a genetic algorithm (GA) is a search heuristic that mimics the process of natural selection."}}
,{"_index":"throwtable","_type":"algorithm","_id":"crossover-(genetic-algorithm)","_score":0,"_source":{"description":"In genetic algorithms, crossover is a genetic operator used to vary the programming of a chromosome or chromosomes from one generation to the next. It is analogous to reproduction and biological crossover, upon which genetic algorithms are based. Cross over is a process of taking more than one parent solutions and producing a child solution from them. There are methods for selection of the chromosomes. Those are also given below.","alt_names":["- Crossover (genetic algorithm) :","-> Read more about Crossover (genetic algorithm)","...mehr auf Wikipedia über Rekombination (genetischer Algorithmus)","...more on Wikipedia about Crossover (genetic algorithm)","Creuament (algorisme genÃ¨tic)","Creuament (algorisme genètic)","Crossover (genetic algorithm)","Crossover (genetic algorithm) - Wikipedia, the free encyclopedia","Crossover (genetic algorithm) - Wikipedia, the free encyclopedia ...","Crossover (genetic algorithm) from Wikipedia","Crossover (genetic algorithm); it is used under the","Crossover (križanje)","Crossover genetic algorithm","Crossover genetic algorithm Wikipedia the free encyclopedia","Crossover_(genetic_algorithm)","Cruzamiento","Genetic Crossover","RecombinaciÃ³n (computaciÃ³n evolutiva)","Recombinación (computación evolutiva)","Recombinación (computación evolutiva) - Wikipedia, la ...","Recombination (genetic algorithm)","Rekombination (genetischer Algorithmus)","Rekombination_(genetischer_Algorithmus)","Sobre-cruzamiento","Sobrecruzamiento","Wikipedia : Crossover","Wikipedia article ''Crossover (genetic algorithm)''","Wikipedia article Crossover (genetic algorithm)","Wikipedia article Crossover_(genetic_algorithm)","Wikipedia article Recombinación (computación evolutiva)","Wikipedia entry for Crossover (genetic algorithm)","Wikipedia-Artikel Rekombination (genetischer Algorithmus)","Wikipedia-Seite zu 'Rekombination (genetischer Algorithmus)'","ca:Creuament (algorisme genètic)","combine it with other pieces","cross-over.","crossover (genetic algorithm)","crossover function","cruzamiento de un punto","en.wikipedia.org/...Crossover_(genetic_algorithm)","en:Crossover (genetic algorithm)","en:Crossover_(genetic_algorithm)","es:Recombinación (computación evolutiva)","es:Sobrecruzamiento (computación evolutiva)","four different crossover operators","genetic cross-over","http://de.wikipedia.org/wiki/Rekombination_(genetischer_Algorithmus)","http://en.wikipedia.org/wiki/Crossov...tic_algorithm)","http://en.wikipedia.org/wiki/Crossover_%28genetic_algorithm%29","http://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)","http://es.wikipedia.org/wiki/Recombinaci%C3%B3n_","http://www.nd.com/genetic/crossover.html","método de cruzamiento","one-point crossover","one-point-crossover","operatori de crossover","penyeberangan","r crossover","sobre cruzamiento","sobrecruzamiento","uniform crossover","ایده های الگوریتم ژنتیک طوری","“Crossover (genetic algorithm) - Wikipedia, the free encyclopedia”, en"],"name":"Crossover (genetic algorithm)","categories":["All accuracy disputes","All articles to be expanded","Articles to be expanded from June 2013","Articles with disputed statements from June 2014","Genetic algorithms"],"tag_line":"In genetic algorithms, crossover is a genetic operator used to vary the programming of a chromosome or chromosomes from one generation to the next."}}
,{"_index":"throwtable","_type":"algorithm","_id":"unique-games-conjecture","_score":0,"_source":{"description":"In computational complexity theory, the Unique Games Conjecture is a conjecture made by Subhash Khot in 2002. The conjecture postulates that the problem of determining the approximate value of a certain type of game, known as a unique game, has NP-hard algorithmic complexity. It has broad applications in the theory of hardness of approximation. If it is true, then for many important problems it is not only impossible to get an exact solution in polynomial time (as postulated by the P versus NP problem), but also impossible to get a good polynomial-time approximation. The problems for which such an inapproximability result would hold include constraint satisfaction problems which crop up in a wide variety of disciplines.\nThe conjecture is unusual in that the academic world seems about evenly divided on whether it is true or not.\n\n\"Some very natural, intrinsically interesting statements about things like voting and foams just popped out of studying the UGC.... Even if the UGC turns out to be false, it has inspired a lot of interesting math research.","alt_names":["- Unique games conjecture :","...more on Wikipedia about Unique games conjecture","An example of a unique game","Label Cover Formulation","Unique Game Formulation","Unique Games","Unique Games Conjecture","Unique games conjecture","Unique games conjecture - Wikipedia, the free ...","Unique games conjecture - Wikipedia, the free encyclopedia","Unique games conjecture - Wikipedia, the free encyclopedia ...","Unique games conjecture - Wikipedia, the free encyclopediaIn","Unique_games_conjecture","Wikipedia article Unique games conjecture","Wikipedia entry for Unique games conjecture","en.wikipedia.org/wiki/Unique_games_conjecture","http://en.wikipedia.org/wiki/Unique_game","http://en.wikipedia.org/wiki/Unique_games_conjecture","http://en.wikipedia.org/wiki/Unique_game…","unique games conjecture","unique games conjecture (UGC)","yago-res:Unique games conjecture","π i , j : L &rightarrow; L"],"name":"Unique games conjecture","categories":["Approximation algorithms","Computational complexity theory","Computational hardness assumptions","Conjectures","Unsolved problems in computer science"],"tag_line":"In computational complexity theory, the Unique Games Conjecture is a conjecture made by Subhash Khot in 2002."}}
,{"_index":"throwtable","_type":"algorithm","_id":"edge-recombination-operator","_score":0,"_source":{"description":"The edge recombination operator (ERO) is an operator that creates a path that is similar to a set of existing paths (parents) by looking at the edges rather than the vertices. The main application of this is for crossover in genetic algorithms when a genotype with non-repeating gene sequences is needed such as for the travelling salesman problem. It was described by Darrell Whitley and others in 1989.\n^ Whitley, Darrell; Timothy Starkweather; D'Ann Fuquay (1989). \"Scheduling problems and traveling salesman: The genetic edge recombination operator\". International Conference on Genetic Algorithms. pp. 133–140. ISBN 1-55860-066-3.","alt_names":["Comparison with other operators","Edge Recombination Operator","Edge recombination operator","Edge recombination operator - Wikipedia, the free ...","Edge recombination operator - Wikipedia, the free encyclopedia","Edge recombination operator - Wikipedia, the free encyclopedia wikipedia","Simpler description of Edge Recombination","What is algorithm of Edge recombination operator","Wikipedia algorithm for edge recombination","Wikipedia article Edge_recombination_operator","Wikipedia article on Edge recombination operator","Wikipedia entry for Edge recombination operator","edge recombination operator","en.wikipedia.org/wiki/Edge_recombination_operator","http://en.wikipedia.org/wiki/Edge_recombination_operator","yago-res:Edge recombination operator"],"name":"Edge recombination operator","categories":["All articles needing additional references","All articles needing expert attention","Articles needing additional references from June 2011","Articles needing expert attention from June 2011","Articles needing expert attention with no reason or talk parameter","Articles needing unspecified expert attention","Genetic algorithms"],"tag_line":"The edge recombination operator (ERO) is an operator that creates a path that is similar to a set of existing paths (parents) by looking at the edges rather than the vertices."}}
,{"_index":"throwtable","_type":"algorithm","_id":"l-reduction","_score":0,"_source":{"description":"In computer science, particularly the study of approximation algorithms, an L-reduction (\"linear reduction\") is a transformation of optimization problems which linearly preserves approximability features; it is one type of approximation-preserving reduction. L-reductions in studies of approximability of optimization problems play a similar role to that of polynomial reductions in the studies of computational complexity of decision problems.\nThe term L reduction is sometimes used to refer to log-space reductions, by analogy with the complexity class L, but this is a different concept.","alt_names":["- L-reduction :","...Wikipedia L-redukcja","L reduction","L-reduction","L-reduction - Wikipedia, the free encyclopedia","L-reduction Related Content:","L-reduction; it is used under the","L-reductions","L-redukcja","L-환산","O P T ( R ( x ) ) ≤ α O P","What are the properties of L-reduction","Wikipedia (L-reduction)","Wikipedia article L-reduction","Wikipedia article about L-reduction","Wikipedia article on L-reduction","Wikipedia entry for L-reduction","http://en.wikipedia.org/wiki/L-reduction","http://pl.wikipedia.org/wiki/L-redukcja","l-reduction","pl:L-redukcja","yago-res:L-reduction"],"name":"L-reduction","categories":["All stub articles","Approximation algorithms","Computational complexity theory","Theoretical computer science stubs"],"tag_line":"In computer science, particularly the study of approximation algorithms, an L-reduction (\"linear reduction\") is a transformation of optimization problems which linearly preserves approximability features; it is one type of approximation-preserving reduction."}}
,{"_index":"throwtable","_type":"algorithm","_id":"token-reconfiguration","_score":0,"_source":{"description":"In computational complexity theory and combinatorics, the token reconfiguration problem is an optimization problem on a graph with both an initial and desired state for tokens.\nGiven a graph , an initial state of tokens is defined by a subset  of the vertices of the graph; let . Moving a token from vertex  to vertex  is valid if  and  are joined by a path in  that does not contain any other tokens; note that the distance traveled within the graph is inconsequential, and moving a token across multiple edges sequentially is considered a single move. A desired end state is defined as another subset . The goal is to minimize the number of valid moves to reach the end state from the initial state.\n^ Demaine, Erik (Fall 2014). \"Algorithmic Lower Bounds: Fun with Hardness Proofs Lecture 11 Notes\" (PDF).","alt_names":[],"name":"Token reconfiguration","categories":["Approximation algorithms","Computational problems in graph theory","NP-complete problems"],"tag_line":"In computational complexity theory and combinatorics, the token reconfiguration problem is an optimization problem on a graph with both an initial and desired state for tokens."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hardness-of-approximation","_score":0,"_source":{"description":"In computer science, hardness of approximation is a field that studies the algorithmic complexity of finding near-optimal solutions to optimization problems.","alt_names":["- Hardness of approximation :","Hardness Of Approximation","Hardness of approximation","Hardness of approximation - Wikipedia :: The free encyclopedia","Hardness of approximation - Wikipedia, the free encyclopedia","Hardness of approximation - Wikipedia, the free encyclopedia ...","Learn about Hardness of approximation>>>","NP-hard to approximate","Wikipedia article Hardness of approximation","Wikipedia article on Hardness of approximation","Wikipedia entry for Hardness of approximation","hard to approximate","hardness of approximation","hardness results","http://en.wikipedia.org/wiki/Hardness_of_approximation","złożoności przybliżeń","неаппрокисимруемости"],"name":"Hardness of approximation","categories":["All stub articles","Approximation algorithms","Computational complexity theory","Mathematical optimization","Theoretical computer science stubs"],"tag_line":"In computer science, hardness of approximation is a field that studies the algorithmic complexity of finding near-optimal solutions to optimization problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"island-algorithm","_score":0,"_source":{"description":"The island algorithm is an algorithm for performing inference on hidden Markov models, or their generalization, dynamic Bayesian networks. It calculates the marginal distribution for each unobserved node, conditional on any observed nodes.\nThe island algorithm is a modification of belief propagation. It trades smaller memory usage for longer running time: while belief propagation takes O(n) time and O(n) memory, the island algorithm takes O(n log n) time and O(log n) memory. On a computer with an unlimited number of processors, this can be reduced to O(n) total time, while still taking only O(log n) memory.","alt_names":[],"name":"Island algorithm","categories":["Bioinformatics algorithms","Hidden Markov models"],"tag_line":"The island algorithm is an algorithm for performing inference on hidden Markov models, or their generalization, dynamic Bayesian networks."}}
,{"_index":"throwtable","_type":"algorithm","_id":"genetic-algorithms-in-economics","_score":0,"_source":{"description":"Genetic algorithms have increasingly been applied to economics since the pioneering work by John H. Miller in 1986. It has been used to characterize a variety of models including the cobweb model, the overlapping generations model, game theory, schedule optimization and asset pricing. Specifically, it has been used as a model to represent learning, rather than as a means for fitting a model.","alt_names":[],"name":"Genetic algorithms in economics","categories":["Computational economics","Econometrics","Genetic algorithms","Optimization algorithms and methods","Production economics"],"tag_line":"Genetic algorithms have increasingly been applied to economics since the pioneering work by John H. Miller in 1986."}}
,{"_index":"throwtable","_type":"algorithm","_id":"doomsday-rule","_score":0,"_source":{"description":"The Doomsday rule or Doomsday algorithm is a way of calculating the day of the week of a given date. It provides a perpetual calendar because the Gregorian calendar moves in cycles of 400 years.\nThis algorithm for mental calculation was devised by John Conway after drawing inspiration from Lewis Carroll's work on a perpetual calendar algorithm. It takes advantage of each year having a certain day of the week (the doomsday) upon which certain easy-to-remember dates fall; for example, 4/4, 6/6, 8/8, 10/10, 12/12, and the last day of February all occur on the same day of the week in any given year. Applying the Doomsday algorithm involves three steps:\nDetermine the \"anchor day\" for the century.\nUse the anchor day for the century to calculate the doomsday for the year.\nChoose the closest date out of the ones that always fall on the doomsday (e.g. 4/4, 6/6, 8/8), and count the number of days (modulo 7) between that date and the date in question to arrive at the day of the week.\nThis technique applies to both the Gregorian calendar A.D. and the Julian calendar, although their doomsdays will usually be different days of the week.\nSince this algorithm involves treating days of the week like numbers modulo 7, John Conway suggests thinking of the days of the week as \"Noneday\" or \"Sansday\" (for Sunday), \"Oneday\", \"Twosday\", \"Treblesday\", \"Foursday\", \"Fiveday\", and \"Six-a-day\". There are some languages, like Portuguese and Galician who base some of the names of the week days in their positional order as exposed on Names of the days of the week#Numbered days of the week\nThe algorithm is simple enough for anyone with basic arithmetic ability to do the calculations mentally. Conway can usually give the correct answer in under two seconds. To improve his speed, he practices his calendrical calculations on his computer, which is programmed to quiz him with random dates every time he logs on.\n\n","alt_names":["algoritmo Doomsday","Doomsday-Methode","( y + ⌊ y / 4 ⌋ ) mod 7 .","- Doomsday (weekday) :","- Doomsday rule :","-> Read more about Doomsday rule","-> Read the article about 'March 0'","...mehr auf Wikipedia über Doomsday-Methode","...more on Wikipedia about Doomsday rule","...more on Wikipedia about March 0","0 March","0 Marzo","0 de marzo","0 de marzo - Wikipedia, la enciclopedia libre","0 de març","0 mars","0 mars - Wikipédia","0.mars","1 Finding a year's Doomsday","1.1 Why it works","2 Finding the day of the week of","220px-Doomsday_Rule.svg.png","3 Overview of all Doomsdays","3月0日","4 Formula for the Doomsday of a year","5 Cycle","5.1 28-year cycle","6 Doomsdays for some contemporary years","6/6/2011","7 Correspondence with dominical letter","8.1 Example 1 (1985)","8.2 Example 2 (2006)","8.3 Example 3 (other years of the 21st","8.4 Example 4 (other centuries)","9 Julian calendar","AND THIS?!","Algorithm Doomsday","Algorithme Doomsday","Algoritma Hari Kiamat.","Algoritma Kiamat","Algoritmo Doomsday","Algoritmo Doomsday (Português)","Algoritmo Doomsday (português)","Algoritmo Doomsday - Wikipedia","Algoritmo Doomsday - Wikipedia, la enciclopedia libre","Algoritmo Doomsday - Wikipédia, a enciclopédia livre","Algoritmo Doomsday – Wikipédia, a enciclopédia livre","Algoritmo Doomsday.","Algoritmo de Doomsday","Algoritmo del Doomsday","Algorytm Doomsday","Amaze your friends and relatives (or, perchance, worry","Anwendung im ...","Berechnung des Doomsdays","Conway's Doomsday Algorithm","Conway's Doomsday algorithm","Cálculo del Doomsday de un año","Cálculo del día de la semana de una","Dag des oordeels Regel","Dommedag Algoritme","Dooms Day Calculator","Doomsday (weekday)","Doomsday Algorithm","Doomsday Algorithm.","Doomsday Algoritmo","Doomsday Algorytm","Doomsday Regel","Doomsday Rule","Doomsday Rule at Wikipedia","Doomsday algoritam","Doomsday algorithm","Doomsday algorithm - Wikipedia, the free encyclopedia","Doomsday algorithm.","Doomsday algoritme","Doomsday algoritmo","Doomsday for the Win","Doomsday method","Doomsday of a year","Doomsday pravilo","Doomsday pravilo - Wikipedia, slobodna enciklopedija - Википедија ...","Doomsday rule","Doomsday rule - Wikipedia","Doomsday rule - Wikipedia :: The free encyclopedia","Doomsday rule - Wikipedia, the free encyclo","Doomsday rule - Wikipedia, the free encyclopedi...","Doomsday rule - Wikipedia, the free encyclopedia","Doomsday rule - Wikipedia, the free encyclopedia →","Doomsday rule - Wikipedia, the free encyclopediaThe Doomsday","Doomsday rule - Wikipedia, the free encyclopedi…","Doomsday rule - Wikipedia, the free encyclo…","Doomsday rule - Wikipedia, the free ency…","Doomsday rule Wikipedia the free encyclopedia","Doomsday rule from Wikipedia","Doomsday rule – Wikipedia","Doomsday rule – Wikipedia, the free encyclopedia","Doomsday rule( en )","Doomsday rule/algorithm","Doomsday rule: Cycle","Doomsday rule: Example 3 (other years of the","Doomsday rule: Finding a year's Doomsday","Doomsday rule: Finding the day of the week","Doomsday rule: Formula for the Doomsday of a","Doomsday rule: Julian calendar","Doomsday rule: Overview of all Doomsdays","Doomsday rule; it is used under the","Doomsday алгоритма","Doomsday алгоритма.","Doomsday 알고리즘을","Doomsday-Algorithmus","Doomsday-Algorithmus.","Doomsday_(weekday)","Doomsday_algorithm","Doomsday_rule","Doomsdaymethode","Doomsdaymethode ? Wikipedia","Doomsdaymethode in","Doomsdaymethode – Wikipedia","Doomsdays for some contemporary years","Ejemplo 1: Año 2006","El día maldito","Finding a year's Doomsday","Formula for the Doomsday of a year","Information on doomsdays on Wikipedia.","John Conway's Doomsday Algorithm","Läs om kalenderprogram","March 0","March 0 - Wikipedia, the free encyclopedia","March 0 Wikipedia the free encyclopedia","March 0( en )","March_0","Noneday, Oneday, Twosday","Overview of all Doomsdays","Regola Doomsday","Someone, please make sense of this.","TIL that 4/4, 6/6, 8/8","TIL there exists an algorithm for determining what","The Doomsday Algorithm","The Doomsday Rule","The Doomsday Rule.","The Doomsday rule or Doomsday algorithm is a","Thuật toán Doomsday.","View Doomsday rule on Wikipedia","What are some examples of Doomsday algorithm?","What are some examples of Doomsday rule","Wikipedia Algoritmo Doomsday","Wikipedia Doomsday Methode","Wikipedia article 0 de marzo","Wikipedia article 0 de març","Wikipedia article Algoritmo Doomsday","Wikipedia article Doomsday (weekday)","Wikipedia article Doomsday algorithm","Wikipedia article Doomsday pravilo","Wikipedia article Doomsday rule","Wikipedia article Doomsdaymethode","Wikipedia article March 0","Wikipedia article on 0 de marzo","Wikipedia article on Algoritmo Doomsday","Wikipedia article on Doomsday (weekday)","Wikipedia article on Doomsday rule","Wikipedia article on the Doomsday algorithm","Wikipedia article මාර්තු 0","Wikipedia entry for Doomsday rule","Wikipedia entry for March 0","Wikipedia on Doomsday Rule","Wikipedia è la vostra amica","Wikipedia-Artikel Doomsday-Methode","Wikipedia-Artikel Doomsdaymethode","Wikipedia-Seite zu 'Doomsday-Methode'","Wikipedia-Seite zu 'Doomsdaymethode'","Wikipedia: '0 mars'","Wikipedia: '0.3.'","Wikipedia: 'Algoritmo Doomsday'","Wikipedia: 'Algoritmo_Doomsday'","Wikipedia: 'Doomsday pravilo'","Wikipedia: 'Doomsday rule'","Wikipedia: 'Doomsdaymethode'","Wikipedia: '둠스데이 알고리즘'","Wikipedia: '둠스데이_알고리즘'","Wikipedia:Doomsday_rule","[edit] Why it works","algorithme de Doomsday","algorithmes Doomsday.","algoritma Hari Kiamat","algoritme doomsday","algoritmo Doomsday.","algoritmo de Doomsday","algoritmo del Doomsday","art Doomsday","artículo de Wikipedia Algoritmo Doomsday","artículo del día del juicio","base doomsday","ca:0 de març","calculated from the date","de:Doomsdaymethode","do the calculation mentally","dommedagsalgoritmen","doomsday algorithm","doomsday algorithm, which are based on the concept","doomsday method","doomsday rule","doomsday rule wikipedia the free encyclopedia","ein bisschen Kopfrechnen üben","en.wikipedia.org/wiki/Dooms... ...","en.wikipedia.org/wiki/Doomsday_(weekday)","en.wikipedia.org/wiki/Doomsday_algorithm","en.wikipedia.org/wiki/Doomsday_rule","en.wikipedia.org: Doomsday rule - Wikipedia, the free","en:Doomsday rule","es:Algoritmo Doomsday","fall on Friday","geeft je alle wiskundige formules","has that power","http://bit.ly/fs8BHI","http://bit.ly/lZQIVq","http://de.wikipedia.org/wiki/Doomsday-Methode","http://de.wikipedia.org/wiki/Doomsdaymet","http://de.wikipedia.org/wiki/Doomsdaymethode","http://en.wikipedia....msday_algorithm","http://en.wikipedia.org/wiki/Doomsday algorithm","http://en.wikipedia.org/wiki/Doomsday_%28weekday%29","http://en.wikipedia.org/wiki/Doomsday_(weekday)","http://en.wikipedia.org/wiki/Doomsday_(w…","http://en.wikipedia.org/wiki/Doomsday_Algorithm","http://en.wikipedia.org/wiki/Doomsday_algorithm","http://en.wikipedia.org/wiki/Doomsday_al…","http://en.wikipedia.org/wiki/Doomsday_ru","http://en.wikipedia.org/wiki/Doomsday_rule","http://en.wikipedia.org/wiki/Doomsday_rule#Finding_the_day_of_the_week_of_a_given_calendar_date","http://en.wikipedia.org/wiki/Doomsday_rule#Julian_calendar","http://en.wikipedia.org/wiki/Doomsday_rule#Overview_of_all_Doomsdays","http://en.wikipedia.org/wiki/Doomsday_ru…","http://en.wikipedia.org/wiki/March_0","http://es.wikipedia.org/wiki/0_de_marzo","http://es.wikipedia.org/wiki/Algorit...roducci.C3","http://es.wikipedia.org/wiki/Algoritmo_Doomsday","http://es.wikipedia.org/wiki/Algoritmo_Doomsday#Introducci.C3","http://es.wikipedia.org/wiki/Algoritmo_D…","http://es.wikipedia.org/wi​ki/Algoritmo_Doomsday","http://fr.wikipedia.org/wiki/0_mars","http://pt.wikipedia.org/wiki/Algoritmo_Doomsday","http://sh.wikipedia.org/wiki/Doomsday_pravilo","in depth explanation","ko:둠스데이 알고리즘","l'Algoritme Doomsday","l'algoritmo Doomsday di Conway","l'algoritmo di Doomsday.","mirar el algoritmo DoomsDay","pt:Algoritmo Doomsday","rule for finding the day of the week","sh:Doomsday pravilo","si:මාර්තු 0","simple:March 0","sv:0 mars","swiftly determine the day of the week of","the Algorithm","the Doomsday Algorithm","the Doomsday algorithm","the Doomsday algorithm for calculating the day of","the calendar loops every 400 years","the cycle of Doomsdays","the doomsday algorithm","the rank number of its Doomsday","third method","thuật toán Doomsday","thuật toán ngày tận thế","w:pt:Algoritmo Doomsday","wikipedia./Doomsday_rule","wikipedia:Doomsday algorithm","you can do something pretty close to that","Ã Â®ÂŸÃ Â¯Â‚Ã Â®Â","článek Doomsday","Правило Судный день","Судный день Алгоритм","алгоритм Doomsday","මාර්තු 0 - Wikipedia","මාර්තු 0 - විකිපීඩ","මාර්තු 0 - විකිපීඩà","මාර්තු 0 - විකිපීඩියා, නිදහස් විශ්වකෝෂය","ขั้น ตอน วิธี โลกาวินาศ.","วิธี Doomsday","“algoritmo del día del fin del mundo”","› The Doomsday Rule","末日算法","末日规则","終末アルゴリズム","둠스데이 알고리즘","둠스데이 알고리즘 - 위키백과, 우리 모두의 백과사전","둠스데이 알고리즘(Doomsday algorithm)","둠즈데이 룰","위키 피 디아 문서 둠스데이 알고리즘","종말의 알고리즘"],"name":"Doomsday rule","categories":["1973 introductions","All articles with unsourced statements","Articles with unsourced statements from January 2008","Calendar algorithms","Gregorian calendar","Julian calendar"],"tag_line":"The Doomsday rule or Doomsday algorithm is a way of calculating the day of the week of a given date."}}
,{"_index":"throwtable","_type":"algorithm","_id":"mutation-(genetic-algorithm)","_score":0,"_source":{"description":"Mutation is a genetic operator used to maintain genetic diversity from one generation of a population of genetic algorithm chromosomes to the next. It is analogous to biological mutation. Mutation alters one or more gene values in a chromosome from its initial state. In mutation, the solution may change entirely from the previous solution. Hence GA can come to better solution by using mutation. Mutation occurs during evolution according to a user-definable mutation probability. This probability should be set low. If it is set too high, the search will turn into a primitive random search.\nThe classic example of a mutation operator involves a probability that an arbitrary bit in a genetic sequence will be changed from its original state. A common method of implementing the mutation operator involves generating a random variable for each bit in a sequence. This random variable tells whether or not a particular bit will be modified. This mutation procedure, based on the biological point mutation, is called single point mutation. Other types are inversion and floating point mutation. When the gene encoding is restrictive as in permutation problems, mutations are swaps, inversions, and scrambles.\nThe purpose of mutation in GAs is preserving and introducing diversity. Mutation should allow the algorithm to avoid local minima by preventing the population of chromosomes from becoming too similar to each other, thus slowing or even stopping evolution. This reasoning also explains the fact that most GA systems avoid only taking the fittest of the population in generating the next but rather a random (or semi-random) selection with a weighting toward those that are fitter.\nFor different genome types, different mutation types are suitable:\nBit string mutation\n\nThe mutation of bit strings ensue through bit flips at random positions.\n\nExample:\n\nThe probability of a mutation of a bit is , where  is the length of the binary vector. Thus, a mutation rate of  per mutation and individual selected for mutation is reached.\n\nFlip Bit\nThis mutation operator takes the chosen genome and inverts the bits (i.e. if the genome bit is 1, it is changed to 0 and vice versa).\nBoundary\nThis mutation operator replaces the genome with either lower or upper bound randomly. This can be used for integer and float genes.\nNon-Uniform\nThe probability that amount of mutation will go to 0 with the next generation is increased by using non-uniform mutation operator. It keeps the population from stagnating in the early stages of the evolution. It tunes solution in later stages of evolution. This mutation operator can only be used for integer and float genes.\nUniform\nThis operator replaces the value of the chosen gene with a uniform random value selected between the user-specified upper and lower bounds for that gene. This mutation operator can only be used for integer and float genes.\nGaussian\nThis operator adds a unit Gaussian distributed random value to the chosen gene. If it falls outside of the user-specified lower or upper bounds for that gene, the new gene value is clipped. This mutation operator can only be used for integer and float genes.","alt_names":["- Mutation (genetic algorithm) :","-> Read the article about 'Mutation (genetic algorithm)'","...Wikipedia Mutacja w algorytmie ewolucyjnym","...mehr auf Wikipedia über Mutation (genetischer Algorithmus)","...more on Wikipedia about Mutation (genetic algorithm)","Mutació (algorisme genètic)","Mutación (computación evolutiva)","Mutation (Genetic Algorithm)","Mutation (genetic algorithm)","Mutation (genetic algorithm) - Wikipedia, the free ...","Mutation (genetic algorithm) - Wikipedia, the free encyclopedia","Mutation (genetic algorithm) - Wikipedia, the free encyclopedia ...","Mutation (genetischer Algorithmus)","Mutation (genetischer Algorithmus) – ...","Mutation (genetischer Algorithmus) – Wikipedia","Mutation (mutacije)","Mutation genetic algorithm","Mutation genetic algorithm Wikipedia the free encyclopedia","Mutation_(genetic_algorithm)","Mutation_(genetischer_Algorithmus)","Mutations-Funktion","Mutație favorabilă","Source Wikipedia.org Arcticle - Mutation (genetic algorithm)","WP: Mutation","Wikipedia : Mutation","Wikipedia article ''Mutation (genetic algorithm)''","Wikipedia article Mutación (computación evolutiva)","Wikipedia article Mutation (genetic algorithm)","Wikipedia article Mutation_(genetic_algorithm)","Wikipedia article on Mutación (computación evolutiva)","Wikipedia article on Mutation (genetic algorithm)","Wikipedia entry for Mutation (genetic algorithm)","Wikipedia-Artikel Mutation (genetischer Algorithmus)","Wikipedia-Seite zu 'Mutation (genetischer Algorithmus)'","artículo de Wikipedia Mutacion (computacion evolutiva)","artículo de Wikipedia Mutación (computación evolutiva)","ca:Mutació (algorisme genètic)","de:Mutation (genetischer Algorithmus)","el:Χρωμοσωματική μετάλλαξη","en.wikipedia.org/...Mutation_(genetic_algorithm)","en.wikipedia.org/wiki/Mutation_(genet...","es:Mutación (computación evolutiva)","http://de.wikipedia.org/wiki/Mu tation_(genetischer_Algorithmus","http://de.wikipedia.org/wiki/Mutatio...Algorithmus%29","http://de.wikipedia.org/wiki/Mutation_%28genetischer_Algorithmus%29","http://de.wikipedia.org/wiki/Mutation_(genetischer_Algorithmus)","http://el.wikipedia.org/wiki/Χρωμοσωματική_μετάλλαξη","http://el.wikipedia.org/wiki/Χρωμοσωμική_μετάλλαξη","http://en.wikipedia.org/wiki/Mutatio...c_algorithm%29","http://en.wikipedia.org/wiki/Mutation_%28genetic_algorithm%29","http://en.wikipedia.org/wiki/Mutation_(genetic_algorithm)","http://pl.wikipedia.org/wiki/Mutacja_w_algorytmie_ewolucyjnym","mutation (genetic algorithm)","mutation functions","mutation,","operatori de mutatie","pl:Mutacja w algorytmie ewolucyjnym","Χρωμοσωμική μετάλλαξη"],"name":"Mutation (genetic algorithm)","categories":["Genetic algorithms"],"tag_line":"Mutation is a genetic operator used to maintain genetic diversity from one generation of a population of genetic algorithm chromosomes to the next."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sha-2","_score":0,"_source":{"description":"SHA-2 (Secure Hash Algorithm 2) is a set of cryptographic hash functions designed by the NSA. SHA stands for Secure Hash Algorithm. Cryptographic hash functions are mathematical operations run on digital data; by comparing the computed \"hash\" (the output from execution of the algorithm) to a known and expected hash value, a person can determine the data's integrity. For example, computing the hash of a downloaded file and comparing the result to a previously published hash result can show whether the download has been modified or tampered with. A key aspect of cryptographic hash functions is their collision resistance: nobody should be able to find two different input values that result in the same hash output.\nSHA-2 includes significant changes from its predecessor, SHA-1. The SHA-2 family consists of six hash functions with digests (hash values) that are 224, 256, 384 or 512 bits: SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256.\nSHA-256 and SHA-512 are novel hash functions computed with 32-bit and 64-bit words, respectively. They use different shift amounts and additive constants, but their structures are otherwise virtually identical, differing only in the number of rounds. SHA-224 and SHA-384 are simply truncated versions of the first two, computed with different initial values. SHA-512/224 and SHA-512/256 are also truncated versions of SHA-512, but the initial values are generated using the method described in FIPS PUB 180-4. SHA-2 was published in 2001 by the NIST as a U.S. federal standard (FIPS). The SHA-2 family of algorithms are patented in US 6829355 . The United States has released the patent under a royalty-free license.\nIn 2005, an algorithm emerged for finding SHA-1 collisions in about 2000-times fewer steps than was previously thought possible. Although (as of 2015) no example of a SHA-1 collision has been published yet, the security margin left by SHA-1 is weaker than intended, and its use is therefore no longer recommended for applications that depend on collision resistance, such as digital signatures. Although SHA-2 bears some similarity to the SHA-1 algorithm, these attacks have not been successfully extended to SHA-2.\nCurrently, the best public attacks break preimage resistance for 52 rounds of SHA-256 or 57 rounds of SHA-512, and collision resistance for 46 rounds of SHA-256, as shown in the Cryptanalysis and validation section below.","alt_names":[],"name":"SHA-2","categories":["All articles containing potentially dated statements","All articles with dead external links","All articles with unsourced statements","Articles containing potentially dated statements from 2013","Articles with dead external links from November 2012","Articles with example pseudocode","Articles with unsourced statements from December 2015","Checksum algorithms","Cryptographic hash functions","National Security Agency cryptography"],"tag_line":"SHA-2 (Secure Hash Algorithm 2) is a set of cryptographic hash functions designed by the NSA."}}
,{"_index":"throwtable","_type":"algorithm","_id":"search-based-software-engineering","_score":0,"_source":{"description":"Search-based software engineering (SBSE) applies metaheuristic search techniques such as genetic algorithms, simulated annealing and tabu search to software engineering problems. Many activities in software engineering can be stated as optimization problems. Optimization techniques of operations research such as linear programming or dynamic programming are mostly impractical for large scale software engineering problems because of their computational complexity. Researchers and practitioners use metaheuristic search techniques to find near-optimal or \"good-enough\" solutions.\nSBSE problems can be divided into two types:\nblack-box optimization problems, for example, assigning people to tasks (a typical combinatorial optimization problem).\nwhite-box problems where operations on source code need to be considered.","alt_names":["SBSE","Ingeniería del software basada en b...","Ingeniería del software basada en búsqueda","Otimização em Engenharia de Software","Otimização em engenharia de software","Otimização em engenharia de software - Wikipédia, a enciclopédia","Otimização em engenharia de software – Wikipédia, a ...","SbSe","Search Based Software Engineering","Search based software engineering","Search-based Software Engineering","Search-based software engineering","Search-based software engineering - Wikipedia, the free ...","Search-based software engineering - Wikipedia, the free encyclopedia","Search-based_software_engineering","Searchbased software engineering","Searchbased software engineering Wikipedia the free encyclopedia","What is the brief history of Search based","Wikipedia article Otimização em engenharia de software","Wikipedia article Search Based Software Engineering","Wikipedia entry for Search-based software engineering","http://en.Liarpedia.org/wiki/Search-based_software_engineering","http://en.wikipedia.org/wiki/Search-based_software_engineering","http://en.wikipedia.org/wiki/Search_Base","http://en.wikipedia.org/wiki/Search_Based_Software_Engineering","http://es.wikipedia.org/wiki/Ingenier%C3%ADa_del_software_basada_en_b","metaheuristic search techniques","pt:Otimização_em_engenharia_de_software"],"name":"Search-based software engineering","categories":["2001 introductions","All articles with unsourced statements","Articles with unsourced statements from October 2013","Genetic algorithms","Optimization algorithms and methods","Pages containing cite templates with deprecated parameters","Program analysis","Search algorithms","Software articles needing expert attention","Software engineering","Software quality","Software testing","Use dmy dates from November 2011"],"tag_line":"Search-based software engineering (SBSE) applies metaheuristic search techniques such as genetic algorithms, simulated annealing and tabu search to software engineering problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"genetic-fuzzy-systems","_score":0,"_source":{"description":"Genetic fuzzy systems are fuzzy systems constructed by using genetic algorithms or genetic programming, which mimic the process of natural evolution, to identify its structure and parameter.\nWhen it comes to automatically identifying and building a fuzzy system, given the high degree of nonlinearity of the output, traditional linear optimization tools have several limitations. Therefore, in the framework of soft computing, genetic algorithms (GAs) and genetic programming (GP) methods have been used successfully to identify structure and parameters of fuzzy systems.","alt_names":["- Genetic fuzzy system :","-> Read the article about 'Genetic fuzzy systems'","Genetic Fuzzy Systems","Genetic Fuzzy systems - Wikipedia, the free encyclopedia","Genetic fuzzy system","Genetic fuzzy systems","Genetic fuzzy systems - Wikipedia, the free encyclopedia","Genetic learning of fuzzy rule base","Sistemas genéticos difusos (en inglés)","View Genetic Fuzzy Systems on Wikipedia","Wikipedia article Genetic fuzzy system","Wikipedia article on Genetic fuzzy system","Wikipedia entry for Genetic fuzzy systems","genetic fuzzy systems wikipedia the free encyclopedia","http://en.Liarpedia.org/wiki/Genetic_fuzzy_systems","http://en.wikipedia.org/wiki/Genetic_Fuz","http://en.wikipedia.org/wiki/Genetic_Fuzzy_Systems","http://en.wikipedia.org/wiki/Genetic_fuzzy_systems","yago-res:Genetic fuzzy systems"],"name":"Genetic fuzzy systems","categories":["All Wikipedia articles needing context","All pages needing cleanup","Computational linguistics","Genetic algorithms","Wikipedia articles needing context from October 2009","Wikipedia introduction cleanup from October 2009"],"tag_line":"Genetic fuzzy systems are fuzzy systems constructed by using genetic algorithms or genetic programming, which mimic the process of natural evolution, to identify its structure and parameter."}}
,{"_index":"throwtable","_type":"algorithm","_id":"genetic-memory-(computer-science)","_score":0,"_source":{"description":"In computer science, genetic memory refers to an artificial neural network combination of genetic algorithm and the mathematical model of sparse distributed memory. It can be used to predict weather patterns. Genetic memory and genetic algorithms have also gained an interest in the creation of artificial life.\n^ Rogers, David (ed. Touretzky, David S.) (1989). Advances in neural information processing systems: Weather prediction using a genetic memory. Los Altos, Calif: M. Kaufmann Publishers. pp. 455–464. ISBN 1-55860-100-7. \n^ Rocha LM, Hordijk W (2005). \"Material representations: From the genetic code to the evolution of cellular automata\". Artificial Life 11 (1-2): 189–214. doi:10.1162/1064546053278964. PMID 15811227.","alt_names":["Genetic memory (computer science)","Genetic memory (computer science) - Wikipedia :: The free encyclopedia","Genetic memory (computer science) - Wikipedia, the free ...","Genetic_memory_%28computer_science%29","Genetic_memory_(computer_science)","Wikipedia article on Genetic memory (computer science)","http://en.wikipedia.org/wiki/Genetic memory (computer","http://en.wikipedia.org/wiki/Genetic_memory_(computer_science)"],"name":"Genetic memory (computer science)","categories":["All stub articles","Computer science stubs","Genetic algorithms"],"tag_line":"In computer science, genetic memory refers to an artificial neural network combination of genetic algorithm and the mathematical model of sparse distributed memory."}}
,{"_index":"throwtable","_type":"algorithm","_id":"quality-control-and-genetic-algorithms","_score":0,"_source":{"description":"The combination of quality control and genetic algorithms led to novel solutions of complex quality control design and optimization problems. Quality control is a process by which entities review the quality of all factors involved in production. Quality is the degree to which a set of inherent characteristics fulfils a need or expectation that is stated, general implied or obligatory. Genetic algorithms are search algorithms, based on the mechanics of natural selection and natural genetics.","alt_names":["Quality control and genetic algorithms","Quality control and genetic algorithms - Wikipedia, the free","Wikipedia article Quality Control using Genetic Algorithms","Wikipedia article Quality control and genetic algorithms","Wikipedia article Quality_control_and_genetic_algorithms","Wikipedia entry for Quality control and genetic algorithms","en.wikipedia.org/wiki/Quality_control...","en.wikipedia.org/wiki/Quality_control_and_genetic_algorithms","http://en.wikipedia.org/wiki/Quality control and","http://en.wikipedia.org/wiki/Quality_control_and_genetic_algorithms"],"name":"Quality control and genetic algorithms","categories":["Genetic algorithms","Quality control"],"tag_line":"The combination of quality control and genetic algorithms led to novel solutions of complex quality control design and optimization problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"damm-algorithm","_score":0,"_source":{"description":"In error detection, the Damm algorithm is a check digit algorithm that detects all single-digit errors and all adjacent transposition errors. It was presented by H. Michael Damm in 2004.\n\n","alt_names":[],"name":"Damm algorithm","categories":["Algebraic structures","CS1 German-language sources (de)","CS1 errors: external links","Checksum algorithms","Group theory","Latin squares"],"tag_line":"In error detection, the Damm algorithm is a check digit algorithm that detects all single-digit errors and all adjacent transposition errors."}}
,{"_index":"throwtable","_type":"algorithm","_id":"depth-limited-search","_score":0,"_source":{"description":"In computer science depth-limited search is an algorithm to explore the vertices of a graph. It is a modification of depth-first search and is used for example in the iterative deepening depth-first search algorithm.","alt_names":["&vert; V &vert; + &vert; E &vert;","-> Read the article about 'Depth-limited search'","...mehr auf Wikipedia über Beschränkte Tiefensuche","Algorithm (formal)","Anwendung findet die Beschränkte Tiefensuche im Algorithmus der","Begrensd diepte-eerst zoeken","Beschränkte Tiefensuche","Beschränkte Tiefensuche - Wikipedia","Beschränkte_Tiefensuche","Depth Limited Search","Depth Limited Search Wikipedia The Free Encyclopedia","Depth limited search","Depth-Limited-Search","Depth-limited search","Depth-limited search - Wikipedia :: The free encyclopedia","Depth-limited search - Wikipedia, the free encyclopedia","Depth-limited search - Wikipedia, the free encyclopedia ...","Depth-limited search Algorithm","Depth-limited search by Wikipedia","Depth-limited search from Wikipedia","Implementation in C# .Net","What are Depth-limited search's properties","Wiki: Ang lalim-limitado-search","Wiki: Depth-limited-Suche","Wiki: Depth-limited-search","Wiki: Profundidad limitada de la búsqueda de","Wiki: Profundidade limitada pesquisa","Wiki: Sâu-hạn-tìm kiếm","Wiki: Tingkatan-terbatas-search","Wiki: profondeur limitée de recherche","Wiki: Глубина ограниченный поиск","Wiki: เชิง ลึก จำกัด การ ค้นหา","Wiki:Depth-limited-search","Wikipedia article Depth-limited search","Wikipedia artikel Begrensd diepte-eerst zoeken","Wikipedia entry for Depth-limited search","Wikipedia-Artikel Beschränkte Tiefensuche","Wikipedia-Seite zu 'Beschränkte Tiefensuche'","Wikipediaで「深さ制限探索」を調べる","[Depth-limited search (DLS)]","begrensd diepte-eerst zoeken","de:Beschränkte Tiefensuche","depth-limited search","en.wikipedia.org/wiki/Depth-limited_search","http://de.wikipedia.org/wiki/Beschr%C3%A4nkte_Tiefensuche","http://en.Liarpedia.org/wiki/Depth-limited_search","http://en.wikipedia.org/wiki/Depth-limit","http://en.wikipedia.org/wiki/Depth-limited search","http://en.wikipedia.org/wiki/Depth-limited_search","http://nl.wikipedia.org/wiki/Begrensd_diepte-eerst","http://nl.wikipedia.org/wiki/Begrensd_diepte-eerst_zoeken","iterative depth-first search / depth-limited search","ja:深さ制限探索","limited depth search","nl:Begrensd diepte-eerst zoeken","yago-res:Depth-limited search","ウィキペディアの記事 深さ制限探索","ウィキ：深さ制限探索","深さ制限探索","深さ制限探索 - Wikipedia","維基：深度有限搜索","维基：深度有限搜索","위키 : 깊이 제한된 검색"],"name":"Depth-limited search","categories":["All articles lacking in-text citations","Articles lacking in-text citations from June 2013","Graph algorithms","Search algorithms"],"tag_line":"In computer science depth-limited search is an algorithm to explore the vertices of a graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"coreset","_score":0,"_source":{"description":"In computational geometry, a coreset is a small set of points that approximates the shape of a larger point set, in the sense that applying some geometric measure to the two sets (such as their minimum bounding box volume) results in approximately equal numbers. Many natural geometric optimization problems have coresets that approximate an optimal solution to within a factor of 1 + ε, that can be found quickly (in linear time or near-linear time), and that have size bounded by a function of 1/ε independent of the input size, where ε is an arbitrary positive number. When this is the case, one obtains a linear-time or near-linear time approximation scheme, based on the idea of finding a coreset and then applying an exact optimization algorithm to the coreset. Regardless of how slow the exact optimization algorithm is, for any fixed choice of ε, the running time of this approximation scheme will be O(1) plus the time to find the coreset.","alt_names":["Coreset","Coreset - Wikipedia, the free encyclopedia","Coresets","Wikipedia article Coreset","Wikipedia article on Coreset","Wikipedia entry for Coreset","answer for that","coreset","coreset wikipedia the free encyclopedia","coresets","http://en.wikipedia.org/wiki/Coreset"],"name":"Coreset","categories":["Algorithms and data structures stubs","All stub articles","Computational geometry","Computer science stubs"],"tag_line":"In computational geometry, a coreset is a small set of points that approximates the shape of a larger point set, in the sense that applying some geometric measure to the two sets (such as their minimum bounding box volume) results in approximately equal numbers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"heap's-algorithm","_score":0,"_source":{"description":"Heap's algorithm generates all possible permutations of N objects. It was first proposed by B. R. Heap in 1963. The algorithm minimizes movement: it generates each permutation from the previous one by interchanging a single pair of elements; the other N−2 elements are not disturbed. In a 1977 review of permutation-generating algorithms, Robert Sedgewick concluded that it was at that time the most effective algorithm for generating permutations by computer.","alt_names":[],"name":"Heap's algorithm","categories":["Combinatorial algorithms","Permutations"],"tag_line":"Heap's algorithm generates all possible permutations of N objects."}}
,{"_index":"throwtable","_type":"algorithm","_id":"algorithmic-version-for-szemerédi-regularity-partition","_score":0,"_source":{"description":"A Simple Algorithm for Constructing Szemerédi's Regularity Partition is a paper by Alan M. Frieze and Ravi Kannan giving an algorithmic version of the Szemerédi regularity lemma to find an ε-regular partition of a given graph.","alt_names":[],"name":"Algorithmic version for Szemerédi regularity partition","categories":["Graph algorithms","Mathematics papers"],"tag_line":"A Simple Algorithm for Constructing Szemerédi's Regularity Partition is a paper by Alan M. Frieze and Ravi Kannan giving an algorithmic version of the Szemerédi regularity lemma to find an ε-regular partition of a given graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"kernighan–lin-algorithm","_score":0,"_source":{"description":"This article is about the heuristic algorithm for the graph partitioning problem. For a heuristic for the traveling salesperson problem, see Lin–Kernighan heuristic.\nKernighan–Lin is a O(n2 log(n)) heuristic algorithm for solving the graph partitioning problem. The algorithm has important applications in the layout of digital circuits and components in VLSI.","alt_names":[],"name":"Kernighan–Lin algorithm","categories":["Combinatorial algorithms","Combinatorial optimization","Heuristic algorithms"],"tag_line":"This article is about the heuristic algorithm for the graph partitioning problem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"tompkins–paige-algorithm","_score":0,"_source":{"description":"The Tompkins–Paige algorithm is a computer algorithm for generating all permutations of a finite set of objects.","alt_names":[],"name":"Tompkins–Paige algorithm","categories":["All articles covered by WikiProject Wikify","All articles with too few wikilinks","Articles covered by WikiProject Wikify from March 2013","Articles with too few wikilinks from March 2013","Combinatorial algorithms","Permutations"],"tag_line":"The Tompkins–Paige algorithm is a computer algorithm for generating all permutations of a finite set of objects."}}
,{"_index":"throwtable","_type":"algorithm","_id":"prim's-algorithm","_score":0,"_source":{"description":"In computer science, Prim's algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. The algorithm operates by building this tree one vertex at a time, from an arbitrary starting vertex, at each step adding the cheapest possible connection from the tree to another vertex.\nThe algorithm was developed in 1930 by Czech mathematician Vojtěch Jarník and later rediscovered and republished by computer scientists Robert C. Prim in 1957 and Edsger W. Dijkstra in 1959. Therefore, it is also sometimes called the DJP algorithm, Jarník's algorithm, the Prim–Jarník algorithm, or the Prim–Dijkstra algorithm.\nOther well-known algorithms for this problem include Kruskal's algorithm and Borůvka's algorithm. These algorithms find the minimum spanning forest in a possibly disconnected graph; in contrast, the most basic form of Prim's algorithm only finds minimum spanning trees in connected graphs. However, running Prim's algorithm separately for each connected component of the graph, it can also be used to find the minimum spanning forest. In terms of their asymptotic time complexity, these three algorithms are equally fast for sparse graphs, but slower than other more sophisticated algorithms. However, for graphs that are sufficiently dense, Prim's algorithm can be made to run in linear time, meeting or improving the time bounds for other algorithms.","alt_names":["Prim's minimal spanning tree algorithm","Prim's algorithm","Prim's algorithm - Wikipedia, the free encyclopedia","Prim's Algorithm","الگوریتم پریم","(Прыма-Ярніка-)Дэйкстры","*Algoritmo de *Prim","- Prim's algorithm :","-> Read the article about 'Prim's algorithm'","...Wikipedia Algorithme de Prim","...Wikipedia Algoritmo de Prim","...Wikipedia Algoritmo di Prim","...Wikipedia Algorytm Prima","...Wikipedia Prims algoritm","...mehr auf Wikipedia über Algorithmus von Prim","...more on Wikipedia about Prim's algorithm","7.1 Prim`s algorithm",": http://fr.wikipedia.org/wiki/Algorithme_de_Prim.","Algorithme de Prim","Algorithme de Prim - Wikip?dia","Algorithme de Prim - Wikipédia","Algorithmus Von Prim","Algorithmus von Prim","Algorithmus von Prim - Wikipedia","Algorithmus von Prim in","Algorithmus von Prim – Wikipedia","Algorithmus_von_Prim","Algoritma Prim","Algoritma Prim - Wikipedia bahasa Indonesia, ensiklopedia bebas","Algoritma Prim :: Wikipedia Bahasa Indonesia","Algoritme van Prim","Algoritmo Prim","Algoritmo de PRIM para encontrar árboles abarcadores mínimos","Algoritmo de Prim","Algoritmo de Prim (Wikipedia):","Algoritmo de Prim - Wikipedia, la enciclopedia libre","Algoritmo de Prim - Wikipédia, a enciclopédia livre","Algoritmo de Prim – Wikipédia, a enciclopédia livre","Algoritmo de Prim:","Algoritmo di Prim","Algoritmo di Prim - Wikipedia","Algoritmo_di_Prim","Algoritmul lui Prim","Algoritmul lui Prim - Wikipedia","Algoritmul lui Prim :http://ro.wikipedia.org/wiki","Algorytm Prima","Algorytm Prima – Wikipedia, wolna encyklopedia","Algorytm_Prima","Ejemplo de ejecución del algoritmo","El algoritmo de Prim","Grafo a utlizar (Extraido de Wikipedia)","Http://en.wikipedia.org/wiki/Prim% 27s% 5Falgorithm","In computer science, Prim's algorithm is a greedy","Jarník algorithm","Jarník?v algoritmus","Jarníkův algoritmus","Jarníkův algoritmus - Wikipedie","L'algorithme de Prim","O(|V|²)","PRIM)","Prim Algorithm","Prim Algorithm 0.svg","Prim Wiki","Prim algorithm","Prim algorithm @ Wikipedia","Prim algoritmas?","Prim algoritması","Prim algoritması - Vikipedi","Prim algoritması - Vikipedi - Wikipedia","Prim algoritmus","Prim algorytm","Prim er","Prim má","Prim s algorithm Wikipedia the free encyclopedia","Prim segun Wiki","Prim%27s_algorithm","Prim&#39;s algorithm - Wikipedia, the free encyclopedia","Prim's","Prim's Alg","Prim's Algorithm (actually Jarník's Algorithm)","Prim's Algorithm - Wikipedia, The Free Encyclopedia","Prim's Algorithm Wiki","Prim's Algorithmus","Prim's Algortithm","Prim's Minimal Spanning Tree Algorithm","Prim's Run","Prim's algorithm - Wikipedia :: The free encyclopedia","Prim's algorithm - Wikipedia, the free ...","Prim's algorithm - Wikipedia, the free encyclopedia wikipedia.org","Prim's algorithm @ Wikipedia","Prim's algorithm by Wikipedia","Prim's algorithm description from Wikipedia","Prim's algorithm on minimum spanning tree (MST)","Prim's algorithm wiki","Prim's algorithm,","Prim's algorithm: Example","Prim's algoritme","Prim's performance","Prim-Algorithmus","Prim-Dijkstra","Prim-Dijkstra-Jarnik algorithm","Prim-Jarnik algorithm","Prim-Jernik-Dijkstra","Prim;v algoritmus","Primin","Primin algoritmi","Primov algoritem - Wikipedija, prosta enciklopedija","Primov algoritmus","Prims Algorithm","Prims Algorithmus","Prims algorithm","Prims algoritm","Prims algoritme","Prim´s algorithm","Primのアルゴリズム","Primのアルゴリズムは、","Primのアルゴリズムを","Prim演算法","Prim的","Prim算法","This is our original weighted graph. The numbers","Thumbnail of screenshot of Prim's algorithm - Wikipedia, the","W: Prim's algorithm","What is the description of DJP algorithm?","What is the description of Prim algorithm?","What is the description of Prim-Jarník algorithm","Wiki - Primov algoritem","Wiki : Prim's algorithm","Wikipedia Prim's","Wikipedia article Algorithme de Prim","Wikipedia article Algoritmo de Prim","Wikipedia article Algorytm Prima","Wikipedia article Jarníkův algoritmus","Wikipedia article Prim algorithm","Wikipedia article Prim's algorithm","Wikipedia article Prim-Jarnik algorithm","Wikipedia article Primov algoritem","Wikipedia article on Algoritmo de Prim","Wikipedia article الگوریتم پریم","Wikipedia artikel Algoritme van Prim","Wikipedia-Artikel Algorithmus von Prim","Wikipedia-Seite zu 'Algorithmus von Prim'","Wikipedia: Algorithmus von Prim","Wikipedia: Prim","Wikipedia: Prim's algorithm","Wikipedia::Prim_algorithm","Wikipedia:Algoritmo_di_Prim","Wikipedia:Prim's_algorithm","Wikipediaで「プリムのアルゴリズム」を調べる","[ teorie Jarník ]","[1] http://en.wikipedia.org/wiki/Prim's_algorithm","[2] Prim's algorithm to find a minimum spanning","[E.5] http://en.wikipedia.org/wiki/Prim","algorithme de Prim","algorithmus von prim","algoritma Prim","algoritma prim wikipedia bahasa indonesia ensiklopedia bebas","algoritme van Prim","algoritmo che porta il suo nome","algoritmo de Prim","algoritmo de prim","algoritmo di Prim","algorytm Prima","artigo da Wikipédia Algoritmo de Prim","artículo de Wikipedia Algoritmo de Jarnik","artículo de Wikipedia Algoritmo de Prim","cs:Jarníkův algoritmus","de:Algorithmus von Prim","description of Prim's algorithm in Wikipedia","en.wikipedia.org/wiki/Prim%...","en.wikipedia.org/wiki/Prim%27s_algorithm","en.wikipedia.org/wiki/Prim'...","en.wikipedia.org/wiki/Prim's_algorithm","en:Prim's algorithm","es:Algoritmo de Prim","fa.wikipedia.org/wiki/الگوریتم_پریم","fa:الگوریتم پریم","fr:Algorithme de Prim","he:האלגוריתם של פרים","http://cs.wikipedia.org/wiki/Jarn%C3%ADk","http://de.wikipedia.org/wiki/Algorit..._Prim#Beispiel","http://de.wikipedia.org/wiki/Algorithmus_von_Prim","http://de.wikipedia.org/wiki/Algorithmus…","http://en.wikipedia.org/wiki/Pr im%27s_algorithm","http://en.wikipedia.org/wiki/Prim% 27s% 5Falgorithm","http://en.wikipedia.org/wiki/Prim% 27s_algorithm","http://en.wikipedia.org/wiki/Prim% 27s_algorithm # Proof_of_correctness","http://en.wikipedia.org/wiki/Prim%27s%5Falgorithm","http://en.wikipedia.org/wiki/Prim%27s_","http://en.wikipedia.org/wiki/Prim%27s_a ... xample_run","http://en.wikipedia.org/wiki/Prim%27s_algo-","http://en.wikipedia.org/wiki/Prim%27s_algorit...","http://en.wikipedia.org/wiki/Prim%27s_algorithm","http://en.wikipedia.org/wiki/Prim%27s_algorithm#Example","http://en.wikipedia.org/wiki/Prim%27s_algorithm#Proof_of_correctness","http://en.wikipedia.org/wiki/Prim%27s_algorithm.","http://en.wikipedia.org/wiki/Prim%27s_al…","http://en.wikipedia.org/wiki/Prim's_algo…","http://en.wikipedia.org/wiki/Prim-Jarnik algorithm","http://en.wikipedia.org/wiki/Prim-Jarnik_algorithm","http://en.wikipedia.org/wiki/Prim_algorithm","http://en.wikipedia.org/wiki/Prim％27s_algorithm＃Proof_of_correctness","http://en.wikipedia.org/wiki/Prim％の27s_algorithm","http://en.wikipedia.org/wiki/P​rim%27s_algorithm","http://es.wikipedia.org/wiki/Algoritmo_de_Prim","http://fr.wikipedia.org/wiki/Algorithme_de_Prim","http://id.wikipedia.org/wiki/Algoritma_Pri","http://it.wikipedia.org/wiki/Algoritmo_di_Prim","http://nl.wikipedia.org/wiki/Algoritme_van_Prim","http://pl.wikipedia.org/wiki/Algorytm_Prima","http://pt.wikipedia.org/wiki/Algoritmo_de_Prim","http://ru.wikipedia.org/wiki/Алгоритм_Прима","http://sk.wikipedia.org/wiki/Primov_algoritmus","http://sk.wikipedia.org/wiki/P​rimov_algoritmus","http://sl.wikipedia.org/wiki/Primov_algoritem","http://sv.wikipedia.org/wiki/Prims_algoritm","http://tr.wikipedia.org/wiki/Prim_algoritmas%C4%B1","http://zh.wikipedia.org/wiki/Prim%E6%BC","id:Algoritma Prim","it.wikipedia.org/wiki/Algoritmo_di_Prim","it:Algoritmo di Prim","ja:プリム法","ko:프림 알고리즘","l'algorithme de Prim","m Wikipedia::Prim_algorithm.","nl:Algoritme van Prim","no:Prims algoritme","origem = array( 1 => 1,1,2,2,2","pl:Algorytm Prima","prim's algorithm","prim-algorithmus","prims algorithm","primów","pseudocode algorithm on Wikipedia","pt.wikipedia.org/wiki/Algoritmo_de_Prim","pt:Algoritmo de Prim","ro:Algoritmul lui Prim","ru:Алгоритм Прима","seda joonist","sk:Primov algoritmus","sl:Primov algoritem","sr:Примов алгоритам","sv:Prims algoritm","to Prim","tr:Prim algoritması","uk:Алгоритм Прима","w:Algorytm Prima","w:Prim's algorithm","wiki:Prim%27s_algorithm","wikipedia algorytm Prim","wikipedia: Prim's algorithm","zh:普林演算法","über den Algorithmus von Prim","Алгоритм Прима","Алгоритм Прима — Википедия","Алгоритм Прима(ВИКИ)","Д иид ЛЛ вКл д Кгж Лл ЛШж","Намиране на МПД с Прим","Призмы","Примов алгоритам","באלגוריתם של Prim","האלגוריתם של פרים","האלגוריתם של פרים – ויקיפדיה","الگوريتم پريم","الگوریتم پریم - ویکیپدیا","شرح الگوریتم","هزینه زمانی","रस्मी","रस्मी एल्गोरिथ्म","रस्मी या","প্রিম","“Prim's Algorithm”","♦ Prim's algorithm - Wikipedia, the free encyclopedia","「プリム法」をWikipediaで調べる","プリムのを","プリムのアルゴリズム - Wikipedia","プリム法","プリム法 - Wikipedia","文字表述","普林演算法","普林演算法- 维基百科，自由的百科全书","普里姆","普里姆算法","維基百科的文章“ Prim演算法”","維基百科的文章“ 普林演算法”","维基百科的文章“ Prim演算法”","维基百科的文章“ 普林演算法”","위키 피 디아 문서 프림 알고리즘","위키 피 디아 문서 프림의 알고리즘","프림 알고리즘","프림스","프림알고리즘","ﾌﾟﾘﾑのｱﾙｺﾞﾘｽﾞﾑ-wikipedia","ﾌﾟﾘﾑ法-wikipedia"],"name":"Prim's algorithm","categories":["Articles containing proofs","Articles containing video clips","CS1 Czech-language sources (cs)","Graph algorithms","Spanning tree"],"tag_line":"In computer science, Prim's algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"flooding-algorithm","_score":0,"_source":{"description":"A flooding algorithm is an algorithm for distributing material to every part of a graph. The name derives from the concept of inundation by a flood.\nFlooding algorithms are used in computer networking and graphics. Flooding algorithms are also useful for solving many mathematical problems, including maze problems and many problems in graph theory.","alt_names":["-> Leggi l'articolo completo su Flooding","-> Read more about Flooding algorithm","...mehr auf Wikipedia über Flooding-Algorithmus","...more on Wikipedia about Flooding algorithm","1 Disadvantages of Flooding","2 Advantages of Flooding","Advantages of Flooding","Algoritmo de inundação","Algoritmoj de inundo","Algoritmos D'inundación","Algoritmos de inundación","Algorítmos de inundação","Cerca flooding in Wikipedia Italia","Disadvantages of Flooding","Eine technische Version des Verfahrens im Netzwerkkontext: Flooding","Flooding - Wikipedia","Flooding Algorithm","Flooding algorithm","Flooding algorithm - Wikipedia :: The free encyclopedia","Flooding algorithm - Wikipedia, the free encyclopedia","Flooding algorithm by Wikipedia","Flooding algorithm on wikipedia.org","Flooding algorithm; it is used under the","Flooding อัลกอริทึม","Flooding-Algorithmus","Flooding-Algorithmus – Wikipedia","Flooding_algorithm","What are some examples of Flooding algorithm","Wikipedia (Algoritmo de inundação)","Wikipedia (Flooding algorithm)","Wikipedia article Algoritmo de inundação","Wikipedia article Flooding algorithm","Wikipedia article on Flooding algorithm","Wikipedia entry for Flooding algorithm","Wikipedia l'articolo Flooding","Wikipedia-Artikel Flooding-Algorithmus","Wikipedia-Seite zu 'Flooding-Algorithmus'","Wikipédia artigo Floodfill","article Flooding algorithm","de.wikipedia.org/wiki/Flooding-Algorithmus","flood like","flooding algorithm","http://de.wikipedia.org/wiki/Flooding-Al","http://de.wikipedia.org/wiki/Flooding-Algorithmus","http://en.wikipedia.org/wiki/Flooding_al","http://en.wikipedia.org/wiki/Flooding_algorithm","http://en.wikipedia.org/wiki/Flooding_al…","http://it.wikipedia.org/wiki/Flooding","inundación como","zaplaven","フラッディング(flooding)"],"name":"Flooding algorithm","categories":["All stub articles","Computer science stubs","Graph algorithms","Routing algorithms"],"tag_line":"A flooding algorithm is an algorithm for distributing material to every part of a graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"jump-point-search","_score":0,"_source":{"description":"In computer science, Jump Point Search (JPS) is an optimization to the A* search algorithm pathfinding algorithm for uniform-cost grids. It reduces symmetries in the search procedure by means of graph pruning, eliminating certain nodes in the grid based on assumptions that can be made about the current node's neighbors, as long as certain conditions relating to the grid are satisfied. As a result, the algorithm can consider long \"jumps\" along straight (horizontal, vertical and diagonal) lines in the grid, rather than the small steps from one grid position to the next that ordinary A* considers.\nJump point search preserves A*'s optimality, while potentially reducing its running time by an order of magnitude.\n\n","alt_names":[],"name":"Jump point search","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Game artificial intelligence","Graph algorithms","Search algorithms"],"tag_line":"In computer science, Jump Point Search (JPS) is an optimization to the A* search algorithm pathfinding algorithm for uniform-cost grids."}}
,{"_index":"throwtable","_type":"algorithm","_id":"misra-&-gries-edge-coloring-algorithm","_score":0,"_source":{"description":"The Misra & Gries edge coloring algorithm is a polynomial time algorithm in graph theory that finds an edge coloring of any graph. The coloring produces uses at most  colors, where  is the maximum degree of the graph. This is optimal for some graphs, and by Vizing's theorem it uses at most one color more than the optimal for all others.\nIt was first published by Jayadev Misra and David Gries in 1992. It is a simplification of a prior algorithm by Béla Bollobás.\nThis algorithm is the fastest known almost-optimal algorithm for edge coloring, executing in  time. A faster time bound of  was claimed in a 1985 technical report by Gabow et al., but this has never been published.\nIn general, optimal edge coloring is NP-complete, so it is very unlikely that a polynomial time algorithm exists. There are however exponential time exact edge coloring algorithms that give an optimal solution.\n\n","alt_names":[],"name":"Misra & Gries edge coloring algorithm","categories":["Graph algorithms","Graph coloring"],"tag_line":"The Misra & Gries edge coloring algorithm is a polynomial time algorithm in graph theory that finds an edge coloring of any graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"goal-node-(computer-science)","_score":0,"_source":{"description":"In computer science, a goal node is a node in a graph that meets defined criteria for success or termination.\nHeuristical artificial intelligence algorithms, like A* and B*, attempt to reach such nodes in optimal time by defining the distance to the goal node. When the goal node is reached, A* defines the distance to the goal node as 0 and all other nodes' distances as positive values.","alt_names":["- Goal node :","Goal Node (Computer Science)","Goal node","Goal node (computer science)","Goal node (computer science) - Wikipedia :: The free encyclopedia","Goal node (computer science) - Wikipedia, the free ...","Goal node (computer science) - Wikipedia, the free encyclopedia","Goal node computer science","Goal_node","Wikipedia article Goal node","Wikipedia entry for Goal node (computer science)","goal node","http://en.wikipedia.org/wiki/Goal_node_%28computer_science%29","http://en.wikipedia.org/wiki/Goal_node_(computer_science)","node.","yago-res:Goal_node_(computer_science)"],"name":"Goal node (computer science)","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Graph algorithms"],"tag_line":"In computer science, a goal node is a node in a graph that meets defined criteria for success or termination."}}
,{"_index":"throwtable","_type":"algorithm","_id":"euler-tour-technique","_score":0,"_source":{"description":"The Euler tour technique (ETT), named after Leonhard Euler, is a method in graph theory for representing trees. The tree is viewed as a directed graph that contains two directed edges for each edge in the tree. The tree can then be represented as a Eulerian circuit of the directed graph, known as the Euler tour representation (ETR) of the tree. The ETT allows for efficient, parallel computation of solutions to common problems in algorithmic graph theory. It was introduced by Tarjan and Vishkin in 1984.","alt_names":["Euler tour technique","Euler tour technique - Wikipedia, the free encyclopedia","Euler tour technique by Wikipedia","http://en.wikipedia.org/wiki/Euler_tour_technique"],"name":"Euler tour technique","categories":["Graph algorithms","Parallel computing"],"tag_line":"The Euler tour technique (ETT), named after Leonhard Euler, is a method in graph theory for representing trees."}}
,{"_index":"throwtable","_type":"algorithm","_id":"path-based-strong-component-algorithm","_score":0,"_source":{"description":"In graph theory, the strongly connected components of a directed graph may be found using an algorithm that uses depth-first search in combination with two stacks, one to keep track of the vertices in the current component and the second to keep track of the current search path. Versions of this algorithm have been proposed by Purdom (1970), Munro (1971), Dijkstra (1976), Cheriyan & Mehlhorn (1996), and Gabow (2000); of these, Dijkstra's version was the first to achieve linear time.\n\n","alt_names":[],"name":"Path-based strong component algorithm","categories":["Graph algorithms","Graph connectivity"],"tag_line":"In graph theory, the strongly connected components of a directed graph may be found using an algorithm that uses depth-first search in combination with two stacks, one to keep track of the vertices in the current component and the second to keep track of the current search path."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rocha–thatte-cycle-detection-algorithm","_score":0,"_source":{"description":"Rocha–Thatte algorithm is a distributed algorithm in graph theory for detecting cycles on large-scale directed graphs based on the bulk synchronous message passing abstraction. This algorithm for detecting cycles by message passing is suitable to be implemented in distributed graph processing systems, and it is also suitable for implementations in systems for disk-based computations, such as the GraphChi, where the computation is mainly based on secondary memory. Disk-based computations are necessary when we have a single computer for processing large-scale graphs, and the computation exceeds the primary memory capacity.\n\n","alt_names":[],"name":"Rocha–Thatte cycle detection algorithm","categories":["Graph algorithms"],"tag_line":"Rocha–Thatte algorithm is a distributed algorithm in graph theory for detecting cycles on large-scale directed graphs based on the bulk synchronous message passing abstraction."}}
,{"_index":"throwtable","_type":"algorithm","_id":"edmonds'-algorithm","_score":0,"_source":{"description":"In graph theory, a branch of mathematics, Edmonds' algorithm or Chu–Liu/Edmonds' algorithm is an algorithm for finding a spanning arborescence of minimum weight (sometimes called an optimum branching). It is the directed analog of the minimum spanning tree problem. The algorithm was proposed independently first by Yoeng-jin Chu and Tseng-hong Liu (1965) and then by Jack Edmonds (1967).","alt_names":[],"name":"Edmonds' algorithm","categories":["Graph algorithms"],"tag_line":"In graph theory, a branch of mathematics, Edmonds' algorithm or Chu–Liu/Edmonds' algorithm is an algorithm for finding a spanning arborescence of minimum weight (sometimes called an optimum branching)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"travelling-salesman-problem","_score":0,"_source":{"description":"The travelling salesman problem (TSP) asks the following question: Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city? It is an NP-hard problem in combinatorial optimization, important in operations research and theoretical computer science.\n\nTSP is a special case of the travelling purchaser problem and the Vehicle routing problem.\nIn the theory of computational complexity, the decision version of the TSP (where, given a length L, the task is to decide whether the graph has any tour shorter than L) belongs to the class of NP-complete problems. Thus, it is possible that the worst-case running time for any algorithm for the TSP increases superpolynomially (perhaps, specifically, exponentially) with the number of cities.\nThe problem was first formulated in 1930 and is one of the most intensively studied problems in optimization. It is used as a benchmark for many optimization methods. Even though the problem is computationally difficult, a large number of heuristics and exact methods are known, so that some instances with tens of thousands of cities can be solved completely and even problems with millions of cities can be approximated within a small fraction of 1%.\nThe TSP has several applications even in its purest formulation, such as planning, logistics, and the manufacture of microchips. Slightly modified, it appears as a sub-problem in many areas, such as DNA sequencing. In these applications, the concept city represents, for example, customers, soldering points, or DNA fragments, and the concept distance represents travelling times or cost, or a similarity measure between DNA fragments. The TSP also appears in astronomy, as astronomers observing many sources will want to minimise the time spent slewing the telescope between the sources. In many applications, additional constraints such as limited resources or time windows may be imposed.","alt_names":["traveling salesman tour","Caixeiro Viajante","TSPは","so einfach","http://en.wikipedia.org/wiki/Traveling_","http://ru.wikipedia.org/wiki/%D0%97%...91","the travelling salesman","The Traveling Salesman","Travelling Salesman problem","TSP on Wikipedia","Traveling salesman problem","traveling salesmen","heuristic solutions","viajante de comercio","Traveling Salesman problem","WP's","travelling salesperson problem","traveling salesman problem","travelling salesman problem","Traveling Salesman","Travelling Salesman","selbst bestimmen","the travelling salesman problem","Travelling Salesman Problem","Travelling salesman problem - Wikipedia, the free encyclopedia","Traveling Salesman Problem","Problem des Handlungsreisenden","'Handlungsreisenden Problematik","'Traveling Salesman Problem'","'Travelling Salesman Problem","'Travelling Salesman Problem'","'el problema del viajero'","'traveling salesman problem'","'travelling salesman problem","'travelling salesman problem'","(http://en.wikipedia.org/wiki/Traveling salesman problem","(problema do caixeiro viajante)","(traveling salesman problem)","*kleine Empfehlung sei*",", Traveling Salesman Problem","- Traveling salesman problem :","-> Leggi tutto l'articolo su 'Problema del commesso","...Wikipedia Problem komiwojażera","...Wikipedia Problema del commesso viaggiatore","...Wikipedia Problema del viajante","...Wikipedia Problema do caixeiro viajante","...Wikipedia Problème du voyageur de commerce","...mehr auf Wikipedia über Problem des Handlungsreisenden","...more on Wikipedia about Travelling salesman problem","04 Wikipedia: Traveling Salesman Problem.","1 Sprendimo sudėtingumas","2 Tikslūs sprendimai","2.1 As a graph problem","2.2 Asymmetric and symmetric","2.3 With metric distances","2.4 Non-metric distances","2.5 Related problems","3 Computing a solution","3 Euristiniai algoritmai","3. Travelling salesman problem - Wikipedia, the free encyclopedia","3.1 Artimiausio kaimyno metodas","3.1 Computational complexity","3.1.1 Complexity of approximation","3.2 Exact algorithms","3.2 Pigiausios jungties algoritmas","3.3 2-jų pasirinktųjų sukeitimo algoritmas","3.3 Heuristic and approximation algorithms","3.3.1 C*****tructive heuristics","3.3.1 Constructive heuristics","3.3.2 Iterative improvement","3.3.3 Randomised improvement","3.3.3.1 Ant colony optimization","3.3.3.1 Example: Using inversion to","3.3.3.1 Example: Using inversion to find an","3.3.3.2 Ant colony optimization","3.4 Special cases","3.4.1 Metric TSP","3.4.2 Euclidean TSP","3.4.3 Asymmetric TSP","3.4.3.1 Solving by conversion to","3.4.3.1 Solving by conversion to Symmetric TSP","3.5 Benchmarks","4 Human performance on TSP","4. Travelling salesman problem - Wikipedia, the free encyclopedia","5 TSP path length for random pointset in","5.1 Lower bound","5.2 Upper bound","6 Analyst's traveling salesman problem","85900 points",">> mehr unter Wikipedia",">>>Problem des Handlungsreisenden<<<",">tsp","A handbook for travelling salesmen from 1832 mentions","APPROX-TSP-TOUR","Abschnitts Heuristiken","Agente Viajero","Agente viajero","Algorithm of Traveling Salesperson Problem (click to go","Algorithm of Traveling Salesperson Problem.","Als er n steden zijn die een handelsreiziger","Applegate (2006)","Article on Wikipedia about TSP","Asymmetric Travelling Salesman Problem","Az utazó ügynök problémája","Az utazó ügynök problémája - Wikipédia","Az utazó ügynök problémája - Wikipédia http://hu.wikipedia","B. http://de.wikipedia.org/wiki/Problem_des_Handlungsreisenden","Bibliografia1","Bài toán người bán hàng","Caixeiro viajante","Commesso Viaggiatore","Computers solve it by comparing the length of","Computing a solution","Das Problem des Handlungsreisenden","Das Problem des Handlungsreisenden (TSP)","Das Problem des Handlungsreisenden auch Rundreiseproblem, engl. Traveling","Das Problem des Handlungsreisenden bei Wikipedia","Das Traveling Salesman Problem (etwas unglücklich ins deutsche","Das Travelling Salesman Problem","Das ist nicht so einfach ...","Den handelsresandes problem","Dolaşan satıcı","El Problema del Viajante","El problema del viajante","El problema del viajante de comercio","Euclidean TSP","Euclidean Traveling Salesman Problem","Euclidean traveling salesman","Euclidean traveling salesman problem","Ez az un. Utazóügynök-probléma","For most efficient canvassing...","Freshman Travelling Problem","Geschäftsreisender Problem","Gezgin Satıcı Problemi","Gezgin satıcı problemi","Grenzen der Berechenbarkeit","Hamiltonpfad","Handelsreizigersprobleem","Handelsreizigersprobleem - Wikipedia","Handelsresandeproblemet","Handelsresandeproblemet - Wikipedia","Handelsrèziguhrsprobleim","Handelsrèziguhrsproblèm","Handlungsreisen","Handlungsreisenden","Handlungsreisenden-Problems","Handlungsreisenden/Travling Salesman-Probleme","Handlungsreisender","Here is the wikipedia take on it.","Here you will find different ideas concerning the","Het handelsreizigers probleem","Heurisitk eröffnen","How to Optimize Life Plans, According to Traveling","Human performance on TSP","Il problema del commesso viaggiatore","In de Nederlandse Wikipedia","Interesting reading link for reference","Just pick up a map, draw it's route","Kauppamatkustajan ongelma","Kauppamatkustajan ongelman","Keliaujančio pirklio uždavinys","Keliaujančio pirklio uždavinys – Vikipedija","Le problème du vayageur de commerce","Le problème du voyageur de commerce","Le voyageur de commerce","Learn about Travelling salesman problem>>>","Lösung von TSP-Algorithmus,","MST-doubling heuristic","Mais sobre o Problema","Masalah salesman keliling","Mathy!","Meer over het handelsreizigersprobleem","Methods to solve it","Metric TSP","Metric TSP problem","Metric traveling salesman","N-P vollstaendige Probleme","NP completo del Travelling Salesman","NP-hard probleem","Nope, salesman","O Problema do Caixeiro Viajante (em inglês) - Wikipedia","On &ETH;&sup2;&ETH;&cedil;&ETH;&ordm;&ETH","Peek into Wikipedia","Podróż problemu sprzedawca","Prize Collecting TSP","Probl?me du voyageur de commerce - Wikip?dia","Problem Travelling Salesman","Problem des Handelsreisenden","Problem des Handlungdreisenden (TSP)","Problem des Handlungs-reisenden","Problem des Handlungsreisenden (Traveling Salesman Problem)","Problem des Handlungsreisenden (Wikipedia)","Problem des Handlungsreisenden - Traveling Salesman","Problem des Handlungsreisenden - Wikipedia","Problem des Handlungsreisenden ? Wikipedia","Problem des Handlungsreisenden Wikipedia","Problem des Handlungsreisenden â€“ Wikipedia","Problem des Handlungsreisenden – ...","Problem des Handlungsreisenden – Wikipedia","Problem des Handlungsreisenden − Wikipedia","Problem des Handlungsreisenden.","Problem des Handlungsreisernden","Problem des Hanldungsreisenden","Problem eines Handlungsreisenden","Problem komiwojazera – Wikipedia, wolna encyklopedia","Problem komiwojażera","Problem komiwojażera (TSP)","Problem komiwojażera Podróży","Problem komiwojażera – Wikipedia, wolna encyklopedia","Problem komiwojażera – Wikipedia, wolna…","Problem_des_Handlungsreisenden","Problem_des_Handlungsreisenden (Traveling Salesman)","Problema commesso viaggiatore","Problema de Rutas del Vendedor","Problema del Commesso Viaggiatore","Problema del Viajante","Problema del Viajante (TSP)","Problema del Viajante de Comercio","Problema del [Vendedor] Viajante","Problema del commesso viaggiatore","Problema del commesso viaggiatore - Wikipedia","Problema del vendedor viajero","Problema del vendedor viajero (TSP)","Problema del viajante","Problema del viajante - Wikipedia, la enciclopedia libre","Problema del viajante de comercio","Problema del viatjant de comerç","Problema do Caixeiro Viajante","Problema do Caixeiro-Viajante","Problema do Caixeiro-viajante","Problema do caixeiro viajante","Problema do caixeiro viajante - Wikip","Problema do caixeiro viajante - Wikipedia","Problema do caixeiro viajante - WikipÃ©dia","Problema do caixeiro viajante - Wikipédia, a enciclopédia livre","Problema do caixeiro viajante ? Wikip?dia, a enciclop","Problema do caixeiro viajante – Wikipédia, a enciclopédia livre","Problema viajante viajar","Problema_del_commesso_viaggiatore","Problems des Handelsreisenden","Problems des Handlungsreisenden","Problems des Handlungsreisenden (TSP)","Problemu Komiwojażera","ProblÃ¨me du voyageur de commerce - WikipÃ©dia","Problème du Voyageur de Commerce","Problème du voyageur de commerce","Problème du voyageur de commerce - Wikipédia","Problème du voyageur de commerce - Wikipédia http://fr","Problém obchodného cestujúceho","Problém obchodného cestujúceho - Wikipédia","Problém obchodního cestujícího","Problém obchodního cestujícího (TSP)","Problém obchodního cestujícího - Wikipedie","Problí¨me du voyageur de commerce","R-devel July - December archive Re: 1998: tsp","Read More About travelling salesman problem - wikipedia the","Read More bài toán người bán hàng – wikipedia","Read More travelling salesman problem wikipedia the free","Rejs Sælger Problem (TSP)","Rejser sælger problem","RouteXL","Rundreiseprobleme Problem","Salesman Travelling","Saltzaile ibiltariaren ebazkizun","Screenshot http://de.wikipedia.org/wiki/Problem_des_Handlungsreisenden","Sebuah cerita","Seyahat Eden Satıcı Problemi","Seyyar Satıcı Problemi","Seyyar satıcı","Seyyar satıcı problemi","Seyyar satıcı problemi - Vikipedi","So einfach ist das alles nicht.","Such a problem is NP-Hard","T SP-approx. link see 3.4.1","TRAVELLING SALESMAN","TRAVELLING SALESMAN PROBLEM - WIKIPEDIA, THE FREE ENCYCLOPED...","TRAVELLING SALESMAN PROBLEM - WIKIPEDIA, THE...","TSP (Travelling Salesman Problem)","TSP (Wiki)","TSP (旅行推銷員問題)","TSP - the traveling salesman problem","TSP Wikipedia article","TSP Wikipedia page","TSP Wikipedia vstup","TSP algorithme de résolution,","TSP at Wikipedia","TSP bei wikipedia","TSP entrada de la Wikipedia","TSP giải quyết các thuật toán,","TSP on Wiki","TSP path length","TSP path length for random pointset in a","TSP problem","TSP problems","TSP resolver algoritmo,","TSP risolvere l'algoritmo,","TSP solving algorithm","TSP voce di Wikipedia","TSP wejścia Wikipedia","TSP Википедии","TSP алгоритма решения,","TSP 문제","TSP 알고리즘을 해결,","TSP's","TSP(Traveling Salesman Problem)","TSP-Problem","TSP-Wiki","TSP-approx. link see 3.4.1","TSPのアルゴリズムを解く","TSP問題求解算法","TSP的百科条目","TSP问题求解算法","Taliban Salesman Problem","The JSamba applet was developed at the Georgia","The Salesman Problem","The Traveling Salesman Problem. Click here to learn","The Traveling Salesman problem, a famous np-hard","The Travelling Salesman","The Travelling Salesman Problem","The Travelling Salesman Problem (wikilink)","The Travelling Salesman problem","The traveling salesman problem","The traveling salesman problem, a classic example of","The traveling salesman problem.","The traveling salesmen problem","The travelling salesman","The travelling salesman problem","The travelling salesman problem is an example of","This is not a trivial problem.","This problem may be harder than you realize","Tr4v3ll1n6 Salesm4n Problem","Travalling Salesman Problem","Travel Salesman problem","Traveling ...","Traveling Saleman Problem","Traveling Sales Person","Traveling Salesman Problem !","Traveling Salesman Problem (Brute-Force Lösung)","Traveling Salesman Problem (TSP)","Traveling Salesman Problem (Wikipedia)","Traveling Salesman Problem - TSP","Traveling Salesman Problem - Wikipedia","Traveling Salesman Problem - Wikipedia, The Free Encyclopedia","Traveling Salesman Problem / Problem des Handlungsreisenden","Traveling Salesman Problem,","Traveling Salesman Problem.","Traveling Salesman Problem..","Traveling Salesman page","Traveling Salesman problem.","Traveling Salesman's Problem","Traveling Salesperson Problem","Traveling Salesperson Problem (TSP)","Traveling Santa Claus Problem","Traveling Soal Tenaga penjual","Traveling masalah salesman","Traveling sales man problem","Traveling salesman problem - Wikipedia, the free encyclopedia","Traveling salesman problem - Wikipediathe free encyclopedia","Traveling salesman problem#Exact algorithms","Traveling salesman theory","Traveling salesmans Problem","Traveling salesperson - Wikipedia entry","Traveling sælger problem","Traveling-Salesman Problem (TSP)","Traveling-Salesman-Problem","Traveling-Salesman-Problem - Wikipedia","Traveling-Salesman-Probleme","Traveling_salesman_problem","Travelling > Salesman","Travelling Saleman Problem","Travelling Sales Man Problem","Travelling Sales Problem","Travelling Salesman Prob (TSP)","Travelling Salesman Problem (TSP)","Travelling Salesman Problem - Simple English Wikipedia, The Free","Travelling Salesman Problem - Simple English Wikipedia, the","Travelling Salesman Problem - Simple English Wikipedia, the ...","Travelling Salesman Problem - Simple English Wikipedia, the free","Travelling Salesman Problem - TSP","Travelling Salesman Problem - Wikipedia","Travelling Salesman Problem - Wikipedia, The Free Encyclopedia","Travelling Salesman Problem Simple English Wikipedia The Free","Travelling Salesman Problem Simple English Wikipedia the - result","Travelling Salesman Problem Simple English Wikipedia the free","Travelling Salesman Problem Wikipedia The Free Encyclopedia","Travelling Salesman Problem on Wikipedia Simple English","Travelling Salesman Problem(TSP)","Travelling Salesman Problem)","Travelling Salesman Problem]","Travelling Salesman Problems","Travelling Salesman overview.","Travelling Salesman!","Travelling Salesman's Problem","Travelling Salesman-Problem","Travelling Salesmen","Travelling Salesmen Problem","Travelling Salesperson - Wikipedia","Travelling Salesperson Problem","Travelling Salesperson Problem (TSP)","Travelling Salesperson problem","Travelling Salesperson problems","Travelling ale man problem Wikipedia the free encyclopedia","Travelling salesman Problem - Simple English Wikipedia, the ...","Travelling salesman probleem","Travelling salesman problem","Travelling salesman problem - Simple English Wikipedia, the ...","Travelling salesman problem - Wikipedia","Travelling salesman problem - Wikipedia, the","Travelling salesman problem - Wikipedia, the free ...","Travelling salesman problem - Wikipedia, the free encyclopedia ...","Travelling salesman problem - Wikipedia, the free encyclopediaThe","Travelling salesman problem - Wikipedia, the free..","Travelling salesman problem - Wikipedia, the free…","Travelling salesman problem - Wikipedia,...","Travelling salesman problem ...","Travelling salesman problem Wikipedia the free encyclopedia","Travelling salesman problem Wikipedia the free encyclopedia - result","Travelling salesman problem by Wikipedia","Travelling salesman problem on Wikipedia","Travelling salesman problem – Wikipedia, the free encyclopedia","Travelling salesman problem →","Travelling salesman problem, the free encyclopedia - Wiki...","Travelling salesman problem.","Travelling salesman problem: Related problems","Travelling salesman.","Travelling salesmen problem","Travelling salesperson problem","Travelling-Salesman","Travelling-Salesman Problem","Travelling-Salesman-Problem","Travelling-Salesman-Problems","Travelling_Salesperson","Travelling_salesman_problem","Travelling_salesman_problem#Euclidean_TSP","UsuÃ¡rio:CelsoS/trabalho 4/Rascunho do Trabalho","Usuário:CelsoS/trabalho 4/Rascunho do Trabalho 4","Utazó Ügynökkel","Utazóügynök-probléma","Utazóügynök-probléma - Wikipédia","Vendedor Ambulante","Vendedor Viajero","Vendedor viajero","Viaggiare problema del commesso","Viaggio Salesman Problem","Viajante de Comercio","Viajar problema del agente","Viajar problema del vendedor","Vikipedi'deki Seyyar satıcı problemi","Voyageur de commerce","W.R. Hamilton and the Traveling Salesman","What is the history of Generalized traveling salesman","What is the history of Salesman problem?","What is the history of Traveling salesman problem","What is the history of Tsp problem?","Why are humans apparently good at solving the","Wiki TSP","Wiki-szócikket","Wiki: Traveling Salesman Problem","Wikipedia - Travelling salesman problem - Heuristic and approximation algorithms","Wikipedia : Problème_du_voyageur_de_commerce","Wikipedia : Traveling salesman problem","Wikipedia : 巡回セールスマン問題","Wikipedia Eintrag TSP","Wikipedia TSP article","Wikipedia TSP entry","Wikipedia TSP indrejse","Wikipedia TSP item","Wikipedia article Problema do caixeiro viajante","Wikipedia article Traveling salesman problem","Wikipedia article on Problema del vendedor viajero","Wikipedia article on Problema del viajante","Wikipedia article on Problema del viajero","Wikipedia article on Traveling salesman problem","Wikipedia article on Travelling salesperson problem","Wikipedia article Задача коммивояжёра","Wikipedia article Задача комівояжера","Wikipedia article مسألة الرحالة التاجر","Wikipedia article مسئله فروشنده دورهگرد","Wikipedia artikel Handelsreizigersprobleem","Wikipedia entry for Travelling salesman problem","Wikipedia entry on TSP","Wikipedia l'articolo Traveling salesman problem","Wikipedia on Traveling Salesman Tour problem","Wikipedia page on TSP","Wikipedia's description of the travelling salesman problem","Wikipedia-Artikel Problem des Handlungsreisenden","Wikipedia-Artikel Traveling Salesman Problem","Wikipedia-Artikel Traveling-Salesman-Problem","Wikipedia-Artikel Travelling Salesman Problem","Wikipedia-Eintrag zum TSP","Wikipedia-Seite zu 'Problem des Handlungsreisenden'","Wikipedia/TSP","Wikipedia: Kauppamatkustajan ongelma","Wikipedia: Problem des Handelsreisenden","Wikipedia: Problem des Handlungsreisenden","Wikipedia: Problem des Handlungsreisenden (Traveling Salesman Problem)","Wikipedia: Travelling Salesman Problem","Wikipedia:Traveling Salesman Problem","Wikipediaで「巡回セールスマン問題」を調べる","WikipediaのTSPのエントリ","Wikipedia（巡回セールスマン問題）","Working on applying an algorithmic solution to the","`El Problema del Viajante.","a Travelling salesman","a class of math problems","a lot more about the TSP on wikipedia","a lot of methods","a really hard problem","a salesman who travels around","a solution to the travelling salesman problem","a sua rota de viagens","a traveling salesman who needs to plan their","a very famous problem","absolutely not a solution of the TSP","advising a travelling salesman","algoritma TSP","algoritma pemecahan TSP,","algoritmo del commesso viaggiatore","an easy one based on minimum spanning trees","ar:مسألة الرحالة التاجر","artigo da Wikipédia Problema do caixeiro viajante","artículo de Wikipedia Problema del agente viajero","asymmetric Traveling Salesman Problem","berühmtes Problem der Informatik","bidaiariaren problema","bài toán hành trình của người bán hàng","bài toán người bán hàng","c i j ≤ c i k + c k","ca:Problema del viatjant de comerç","caixeiro viajante","caso del commesso viaggiatore","caxeiro viajante","cities that I want to visit each of","classic optimization problem","classic traveling salesman problem","computational complexity of the travelling salesman problem","computer science of combinatorial optimisation","could have driven less","cs:Problém obchodního cestujícího","das Problem des Handlungsreisenden","dc0090c7236170940e61c4572 ...","de.wikipedia.org/wik...s_Handlungsreisenden","de.wikipedia.org/wiki/Problem_des_Handlungsreisenden","de.wikipedia.org/wiki/Problem_des_Handlungsreisenden#Er.C3.B6ffnungsverfahren","de:Problem des Handlungsreisenden","definition of a TSP from Wikipedia","del commesso viaggiatore","den handelsreisendes problem","den handelsresandes problem","described a simulation of an ant colony","discussion on algorithms for NP-hard problems","doesn't need to be symmetric","du lịch người bán hàng","du voyageur de commerce","e travelling salesman problem","el problema del viajante","el problema del viajante de comercio","el problema del viajero","en.wikipedia.org/...Travelling_salesman_problem","en.wikipedia.org/wik...ing_salesman_problem","en.wikipedia.org/wiki/Travelin ...","en.wikipedia.org/wiki/Traveling_salesman_problem","en.wikipedia.org/wiki/Travelling_sale...","en.wikipedia.org/wiki/Travelling_salesman_pro blem","en.wikipedia.org/wiki/Travelling_salesman_problem","en.wikipedia.org/wiki/Travelling···_problem","en.wikipedia.org/​wiki/​Traveling_salesman_problem","en:Travelling salesman problem","es.wikipedia.org/wiki/Problema_del_viajante","es:Problema del viajante","eu:Saltzaile ibiltariaren ebazkizun","exact symetric algorithm","extremely tough problem","fa:مسئله فروشنده دورهگرد","figure out trips","finding the Hamiltonian cycle with the least weight","fr:Problème du voyageur de commerce","gein probleim","gezgin satıcı","gezgin satıcı problemini(Travelling Salesman)","gèn problèm","handelsreisendeproblemet","handelsreiziger probleem","handelsreizigerprobleem","handelsreizigers algoritme","handelsreizigersprobleem","handelsrejsende problem","handelsrejsende problemet","handelsresandeproblemet","handlungsreisende","he traveling salesman problem","he:בעיית הסוכן הנוסע","het Travelling Salesman Problem","heurísticas más simples y efectivas para mejorar","hochmathematische Problem des Handlungsreisenden,","how should a salesman travel","http://bit.ly/1bKAe","http://cs.wikipedia.org/wiki/Probl%C3%A9m_obchodn","http://cs.wikipedia.org/wiki/Problém_obchodního_cestujícího","http://de.wikipedia.org/wiki/..._Handlungsreisenden","http://de.wikipedia.org/wiki/P...sreisenden","http://de.wikipedia.org/wiki/Pr oblem_des_Handlungsreisenden","http://de.wikipedia.org/wiki/Proble...dlungsreisenden","http://de.wikipedia.org/wiki/Problem...Metrisches_TSP","http://de.wikipedia.org/wiki/Problem...lungsreisenden","http://de.wikipedia.org/wiki/Problem...sungsverfahren","http://de.wikipedia.org/wiki/Problem_de ... sreisenden","http://de.wikipedia.org/wiki/Problem_des","http://de.wikipedia.org/wiki/Problem_des_","http://de.wikipedia.org/wiki/Problem_des_Handlungsre...","http://de.wikipedia.org/wiki/Problem_des_Handlungsreisenden","http://de.wikipedia.org/wiki/Problem_des_Handlungsreisenden#Exakte_L.C3","http://de.wikipedia.org/wiki/Problem_des_Handlungsreisenden#Geschichte","http://de.wikipedia.org/wiki/Problem_des_Handlungsreisenden)","http://de.wikipedia.org/wiki/Problem_des_Handlungsreisenden.","http://de.wikipedia.org/wiki/Problem_des…","http://de.wikipedia.org/wiki/ProblemdesHandlungsreisenden","http://de.wikipedia.org/wiki/Traveli","http://de.wikipedia.org/wiki/Traveli...mplexit.C3","http://de.wikipedia.org/wiki/Traveling-Salesman-Problem","http://de.wikipedia.org/wiki/Traveling_Salesman_Problem","http://de.wikipedia.org/wiki/Traveling_Salesman_Problem#L.C3","http://de.wikipedia.org/wiki/Travell...lesman_Problem","http://de.wikipedia.org/wiki/Travelling_Salesman_Problem","http://de.wikipedia.org/wiki/Travelling_Salesperson","http://en.wikipedia .org/wiki/ Traveling_ salesman_ problem","http://en.wikipedia....alesman_Problem","http://en.wikipedia....alesman_problem","http://en.wikipedia....blem#Metric_TSP","http://en.wikipedia.org/w...esman_problem#NP-hardness","http://en.wikipedia.org/wiki/T.....an_problem","http://en.wikipedia.org/wiki/T...blem","http://en.wikipedia.org/wiki/T...lling_salesman_problem","http://en.wikipedia.org/wiki/Trav-","http://en.wikipedia.org/wiki/Travel...alesman_problem","http://en.wikipedia.org/wiki/Traveli...act_algorithms","http://en.wikipedia.org/wiki/Traveli...blem_statement","http://en.wikipedia.org/wiki/Traveli...lem#Heuristics","http://en.wikipedia.org/wiki/Traveli...lem_statement]","http://en.wikipedia.org/wiki/Traveling salesman -","http://en.wikipedia.org/wiki/Traveling_ … P-hardness","http://en.wikipedia.org/wiki/Traveling_s alesman_problem#Human_performance_on_TSP","http://en.wikipedia.org/wiki/Traveling_s...","http://en.wikipedia.org/wiki/Traveling_sa...roblem","http://en.wikipedia.org/wiki/Traveling_sal...alesman_problem","http://en.wikipedia.org/wiki/Traveling_salesm...","http://en.wikipedia.org/wiki/Traveling_salesma n_problem","http://en.wikipedia.org/wiki/Traveling_salesman_pr oblem","http://en.wikipedia.org/wiki/Traveling_salesman_problem","http://en.wikipedia.org/wiki/Traveling_salesman_problem#Ant_colony_optimisation","http://en.wikipedia.org/wiki/Traveling_salesman_problem#Approximation","http://en.wikipedia.org/wiki/Traveling_salesman_problem#Euclidean_TSP","http://en.wikipedia.org/wiki/Traveling_salesman_problem#Heuristic_and_approximation_algorithms","http://en.wikipedia.org/wiki/Traveling_salesman_problem#Heuristics","http://en.wikipedia.org/wiki/Traveling_salesman_problem#NP-hardness","http://en.wikipedia.org/wiki/Traveling_salesman_problem#Special_cases","http://en.wikipedia.org/wiki/Traveling_salesman_problem(...)","http://en.wikipedia.org/wiki/Traveling_salesman_problem...","http://en.wikipedia.org/wiki/Traveling_s…","http://en.wikipedia.org/wiki/Travell...act_algorithms","http://en.wikipedia.org/wiki/Travell...ed_improvement","http://en.wikipedia.org/wiki/Travell...lesman_problem","http://en.wikipedia.org/wiki/Travelling ... algorithms","http://en.wikipedia.org/wiki/Travelling ... an_problem","http://en.wikipedia.org/wiki/Travelling ... cial_cases","http://en.wikipedia.org/wiki/Travelling ... e_solution","http://en.wikipedia.org/wiki/Travelling Salesman Problem","http://en.wikipedia.org/wiki/Travelling … an_problem","http://en.wikipedia.org/wiki/Travelling% 5Fsalesman% 5Fproblem","http://en.wikipedia.org/wiki/Travelling%5Fsalesman%5Fproblem","http://en.wikipedia.org/wiki/Travelling_ Related information","http://en.wikipedia.org/wiki/Travelling_..","http://en.wikipedia.org/wiki/Travelling_Salesman_Problem","http://en.wikipedia.org/wiki/Travelling_sa...xact_algorithms","http://en.wikipedia.org/wiki/Travelling_sales...","http://en.wikipedia.org/wiki/Travelling_salesman_","http://en.wikipedia.org/wiki/Travelling_salesman_p roblem","http://en.wikipedia.org/wiki/Travelling_salesman_p...","http://en.wikipedia.org/wiki/Travelling_salesman_prob","http://en.wikipedia.org/wiki/Travelling_salesman_proble...","http://en.wikipedia.org/wiki/Travelling_salesman_problem","http://en.wikipedia.org/wiki/Travelling_salesman_problem#Algorithms","http://en.wikipedia.org/wiki/Travelling_salesman_problem#Ant_colony_optimization","http://en.wikipedia.org/wiki/Travelling_salesman_problem#Ant_colony_optimization)","http://en.wikipedia.org/wiki/Travelling_salesman_problem#As_a_graph_problem","http://en.wikipedia.org/wiki/Travelling_salesman_problem#Computational_complexity","http://en.wikipedia.org/wiki/Travelling_salesman_problem#Computing_a_solution","http://en.wikipedia.org/wiki/Travelling_salesman_problem#Constructive_heuristics","http://en.wikipedia.org/wiki/Travelling_salesman_problem#Euclidean_TSP","http://en.wikipedia.org/wiki/Travelling_salesman_problem#Exact_algorithms","http://en.wikipedia.org/wiki/Travelling_salesman_problem#Example_letting_the_inversion_operator_find_a_good_solution","http://en.wikipedia.org/wiki/Travelling_salesman_problem#Heuristic_and_approximation_algorithms","http://en.wikipedia.org/wiki/Travelling_salesman_problem#Metric_TSP","http://en.wikipedia.org/wiki/Travelling_salesman_problem#NP-hardness","http://en.wikipedia.org/wiki/Travelling_salesman_problem#Related_problems","http://en.wikipedia.org/wiki/Travelling_salesman_problem#cite_note-3","http://en.wikipedia.org/wiki/Travelling_salesman_problem#cite_ref-0","http://en.wikipedia.org/wiki/Travelling_salesman_problem.","http://en.wikipedia.org/wiki/Travelling％5Fsalesman％5Fproblem","http://es.wikipedia.org/wiki/Problem...ndedor_viajero","http://es.wikipedia.org/wiki/Problema_del_vendedor_viajero","http://es.wikipedia.org/wiki/Problema_del_viajante","http://es.wikipedia.org/wiki/P​roblema_del_viajante","http://fi.wikipedia.org/wiki/Kauppamatkustajan_ongelma","http://fr.wikipedia.org/wiki/Probl [...] e_commerce","http://fr.wikipedia.org/wiki/Probl%C...ur_de_commerce","http://fr.wikipedia.org/wiki/Probl%C3%A8me_du_v","http://fr.wikipedia.org/wiki/Probl%C3%A8me_du_voyageur_de_co","http://fr.wikipedia.org/wiki/Probl%C3%A8me_du_voyageur_de_commerce","http://fr.wikipedia.org/wiki/Probl`eme_du_voyageur_de_commerce","http://fr.wikipedia.org/wiki/Problème_du_voyageur_de_commerce","http://fr.wikipedia.org/wiki/Problème_du_voyageur_de_commerce...","http://he.wikipedia.org/wiki/בעיית_הסוכן_הנוסע","http://hu.wikipedia.org/wiki/Utaz%C3%B3","http://it.wikipedia.org/wiki/Proble...sso_viaggiatore","http://it.wikipedia.org/wiki/Problem...computazionale","http://it.wikipedia.org/wiki/Problem...so_viaggiatore","http://it.wikipedia.org/wiki/Problema_del_commesso_viaggiatore","http://it.wikipedia.org/wiki/Traveling_salesman_problem","http://ja.wikipedia.org/wiki/巡回セールスマン問題","http://nl.wikipedia.org/wiki/Handelsreizigersprobl","http://nl.wikipedia.org/wiki/Handelsreizigersprobleem","http://pl.wikipedia....em_komiwojażera","http://pl.wikipedia.org/wiki/Problem_komiwoja%C5","http://pl.wikipedia.org/wiki/Problem_komiwoja%C5%BCera","http://pl.wikipedia.org/wiki/Problem_komiwojażera","http://pt.wikipedia.org/wiki/Problem...xeiro_viajante","http://pt.wikipedia.org/wiki/Problema_d ... o_viajante","http://pt.wikipedia.org/wiki/Problema_do...","http://pt.wikipedia.org/wiki/Problema_do_caixeiro_viajante","http://pt.wikipedia.org/wiki/Problema_do_caixeiro_viajante#Defini.C3","http://ru.wikipedia....ча_коммивояжёра","http://ru.wikipedia.org/wiki/Задача_комм...","http://ru.wikipedia.org/wiki/Задача_коммивояжера","http://ru.wikipedia.org/wiki/Задача_коммивояжёра","http://ru.wikipedia.org/wiki/Задача_о_коммивояжёре","http://simple.wikipedia.org/wiki/Travelling_Salesman_Problem","http://sk.wikipedia.org/wiki/Probl%C3%A","http://sk.wikipedia.org/wiki/Probl%C3%A9m_obchodn","http://sk.wikipedia.org/wiki/Problém_obchodného_cestujúceho","http://sl.wikipedia.org/wiki/Problem_trgovskega_potnika","http://sv.wikipedia.org/wiki/Handelsresandeproblemet","http://sv.wikipedia.org/wiki/Handelsresandeproblemet#Exempel_p.C3","http://tr.wikipedia.org/wiki/Dola%C5...t","http://tr.wikipedia.org/wiki/Seyyar_sat%C4%B1c","http://www.eurolinkva.com/goto/aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmF2ZWxsaW5nX3NhbGVzbWFuX3Byb2JsZW0=","http://zh.wikipedia.org/wiki/旅行推销员问题","http://zh.wikipedia.org/zh-cn/TSP","http://zh.wikipedia.org/zh-hk/%25E6%2597","http:/en.wikipedia.org/wiki/Travelling_salesman_problem","hu:Az utazó ügynök problémája","il TSP per forza bruta, con una decina","it.wikipedia.org/wiki/Problema_del_commesso_viaggiatore","it:Problema del commesso viaggiatore","kauppamatkustajan ongelma","kauppamatkustajan ongelmaa","kauppamatkustajan ongelman","keliaujančio pirklio","keliaujančio prekeivio","ko:외판원 문제","komiwojażer","komiwojażera","kutsaritang","l (Nilsson, 198","la problématique du voyageur de commerce","la solución de TSP algoritmo,","le probleme du voyageur de commerce","le problème du voyageur de commerce","le voyageur de commerce","least traveling","lt:Keliaujančio pirklio uždavinys","lunga ricerca","masalah Travelling Salesman","masalah pedagang keliling,","masalah salesman keliling.","modern approximations","most efficient route for multiple locations","n-path algorithms","na: <http://cs.wikipedia.org/wiki/Probl%C3","nice heuristics","nl.wikipedia.org/wiki/Handelsreizigersprobleem","nätverksanalys","o caminho mais curto numa rota com várias","o problema do caixeiro viajante","o, <http://cs.wikipedia.org/wiki/Probl%","obchodního cestujícího","one of the hardest problems in all of","opposite of the Traveling Salesman","optimale Route","optimization version of TSP","optimized by a graph theorist","optimizing a traveling salesman's route","optimizing itinerary efficiency,","order O(n!)","paglalakbay","paglalakbay problema tindero","paglalakbay tindero","particular brand of Traveling Salesman Problem","pedagang keliling","perfect accuracy","pl.wikipedia.org/wiki/Problem_komiwoja%C5%BCera","podróżującego sprzedawcy","podróży sprzedawca problem","pointed this out to me","postman tour","poszukiwanie minimalnego cyklu Hamiltona w pełnym grafie ważonym","potential solutions","potujočega trgovca","potujoči krošnjar","problem komiwojazera","problem komiwojażera","problem komiwojażera jest NP","problem putujućeg trgovca","problem statement for the TSP","problem trgovskega potnika","problema Traveling Venditore","problema Viajando vendedor","problema Viajar vendedor","problema comis-voiajorului","problema commesso viaggiatore","problema commesso viaggiatore (TSP)","problema de caixeiro viajante","problema de viajante de comercio (TSP - Traveling Salesman","problema del Commesso Viaggiatore(TSP)","problema del agente de viaje","problema del agente viajero","problema del comerciant","problema del commesso Viaggiare","problema del commesso di viaggio","problema del commesso viaggiatore","problema del commesso viaggiatore,","problema del marrón viajante","problema del vendedor","problema del vendedor ambulante","problema del vendedor ambulante,","problema del vendedor viajero","problema del vendedor viajero,","problema del viajante","problema del viajante de comercio","problema del viajante de comercio (TSP), mediante algoritmo","problema del viajero","problema do caixeiro","problema do caixeiro viajante","problema do caixeiro viajante simétrico (PCV)","problema do caixeiro viajante,","problema do vendedor viajante","problema sa paglalakbay sa tindero,","problema venditore viaggio","probleme du voyageur du commerce","problemem komiwojażera","problemie komiwojażera","problemu komiwojażera","problème de commis voyageur","problème du voyageur de commerce","problème du voyageur de commerce,","problème du voyageur du commerce","problème du voyageur! de commerce","problém obchodného cestujúceho","problém obchodního cestujícího","problému obchodního cestujícího","pt.wikipedia.org​/wiki​/Problema_do_caixeiro_viajant...","quello del commesso viaggiatore","raveling sales man","raveling salesman problem. I","reisenden Vertreters","reisiva müügimehe ülesandega","reizende verkoper probleem","reizende vertegenwoordiger probleem","rejsende sælger problemet","rejser sælger problemet","roblema del commesso viaggiatore","ru.wikipedia.org/...ча_коммивояжёра","ru.wikipedia.org/wiki/Задача_коммивояжера","ru.wikipedia.org/…а_коммивояжёра","rupedia:Задача коммивояжёра","rändava müügimehe","sagt uns die große Allwissende","salesman problem","salesman with a problem","seyyar satıcı problemi","simple.wikipedia.org/wiki/Trav ...","simple.wikipedia.org/wiki/Travelling_Salesman_Problem","sprzedawcy problem podróży","target=_self>Traveling Salesman","the 2-approximation algorithm that came before it","the Traveling Salesman Problem","the Travelling Salesman Problem","the Travelling Salesman Problem (TSP)","the Travelling Salesman problem","the shortest tour of a group of cities","the traveling salesman problem","the traveling-salesman problem","the travelling salesman's problem (TSP)","their biggest problem?","travel sales man","travel the shortest route","traveling Salesman","traveling road crew problem","traveling saleman's problem","traveling sales man problem","traveling salesman algorithm","traveling salesman conundrum","traveling salesman of the problem","traveling salesman path","traveling salesman proble","traveling salesman problem (TSP)","traveling salesman problem of mathematics","traveling salesman problem.","traveling salesman problem:","traveling salesman problems","traveling salesman route","traveling salesman type problems","traveling salesman's","traveling salesman's problem","traveling salesperson problem","traveling-salesman problem","travelling Salesman","travelling salesman (TSP)","travelling salesman (or saleswoman) problem (TSP)","travelling salesman heuristics","travelling salesman problem (TSP)","travelling salesman problem simple english wikipedia the free","travelling salesman problem wikipedia the free encyclopedia","travelling salesman problems","travelling salesmanOk, it's not quite the travelling","travelling-salesman problems","travelling-salesman-like","travelling-salesman-type problem","ttp://en.wikipedia.org/wiki/Traveling\\_salesman\\_problem","utazó ügynök","utazó ügynök problémája","utazó ügynök problémára","utazó-ügynök","utazóügynök-probléma","various heuristics","vendedor viajero","veselé počítání","viajante del problema","viajantes de comercio","viatjant de comerç","voyageur de","voyageur de commerce","voyageur du problème","voyageurs de commerce","vraagstuk van de handelsreiziger","vấn đề Travelling Salesman","vấn đề bán hàng du lịch","vấn đề người bán hàng du lịch","vấn đề nhân viên bán hàng","vấn đề nhân viên bán hàng du lịch","vấn đề nhân viên bán hàng đi du","w:Problem des Handlungsreisenden","w:Traveling salesman problem","w:Travelling salesman problem","wikipedia entry for TSP","współczesnych aproksymacji","zagadnieniu komiwojażera","znajdowanie najkrótszej trasy łączącej pewną liczbę miast","«El problema del viajante de comercio».","· Travelling salesman problem - Wikipedia, the free encyclopedia","â€œtraveling salesman problem.â€","úlohu obchodního cestujícího","úlohy obchodního cestujícího","Đi du lịch nhân viên bán hàng vấn","đi du lịch","πρόβλημα του περιοδεύοντος πωλητή","πρόβλημα του πλανόδιου πωλητή","Задача комивояжёра","Задача коммивояжера","Задача коммивояжера в немецкой википедии","Задача коммивояжёра","Задача коммивояжёра — Википедия","Задача комівояжера","Задача_коммивояжёра","Задаче коммивояжера","Задачи Коммивояжёра","Задачи коммивояжёра","Коммивояжер проблема","На виккипедии","Проблем трговачког путника","Продавец Путешествия задачи (ТСП)","Путешественник проблемы","Путешествия продавец проблемы","Тravelling salesman problem","ТСП","евристични алгоритми","задача коммивояжера","задача коммивояжера,","задача коммивояжёра","задача о коммивояжёре","задаче коммивояжера","задачей коммивояжёра","задачи коммивояжера","задачи коммивояжера (рос.)","задачи коммивояжера,","задачи коммивояжера.","задачи коммивояжёра","задачу коммивояжера","задачу коммивояжёра","задачу о коммивояжере","задачі","задачі комівояжера","известны эвристики лучше","коммивояжера","коммивояжера Путешествия проблемы","коммиевояжера","проблема за най-краткия маршрут на търговския пътник","проблемой коммивояжера Путешествие","проблемы коммивояжера","путешествия проблема продавца","באנגלית (יותר מפורט)","בעיה הסוכן הנוסע","בעיית הסוכן הנוסע","בעיית הסוכן הנוסע – ויקיפדיה","הסוכן הנוסע","ויקיפדיה - 'בעיית הסוכן הנוסע'","رﺟﺎﺗﻟا ﺔﻟﺎﺣرﻟا ﺔﻟﮐﺷﻣ","فروشنده دوره گرد","فروشنده دوره گرد(traveling salesman)","فروشندهی سیار","مرد مسافر دستفروش","مسآله فروشنده","مسآله فروشنده ی دورگرد","مسآله فروشندهی دورگرد","مسئله فروشنده دوره گرد","مسئله فروشنده دورهگرد","مسئله فروشنده دورهگرد - ویکیپدیا","مساله مرد فروشنده دوره گرد در ویکیپدیا (فارسی","مشكلة البائع المتجول","ملعقة شاي","कहा था यात्रा विक्रेता समस्या","ट्रॅव्हलिंग सेल्समन","तक नहीं यात्रा","यात्रा विक्रेता समस्या","விக்கிப்பீடியா பக்கம்","การเดินทางพนักงานขายปัญหา","ปัญหา การ เดินทาง","ปัญหา พนักงาน ขาย","ปัญหา พนักงาน ขาย เดินทาง","ปัญหาการเดินทางของเซลล์แมน","ปัญหาการเดินทางพนักงานขาย","ปัญหาพนักงานขายเดินทาง","พนักงาน ขาย เดินทาง","เดินทาง พนักงาน ขาย","แก้ไข ปัญหา พนักงาน ขาย เดินทาง","“Problema del Viajante de Comercio” (TSP)","“The Traveling Salesman”","“Travelling Salesman Problem”","“problema do caixeiro-viajante”","“problemă a comisului voiajor”","“traveling salesman problem.”","“traveling salesman problem”","„Problém obchodního cestujícího“","„keliaujančio prekeivio“","„problema comis-voiajorului”","「巡回セールスマン問題」","「巡回セールスマン問題」をWikipediaで調べる","ウィキペディアの記事 巡回セールスマン問題","トラベリングセールスマン問題","巡回","巡回サラリーマン問題","巡回セールスマン","巡回セールスマン(Traveling Salesman)","巡回セールスマンは、","巡回セールスマン問題","巡回セールスマン問題 (TSP)","巡回セールスマン問題 - Wiki...","巡回セールスマン問題 - Wikipedia","巡回セールスマン問題 – Wikipedia","巡回セールスマン問題(1)","巡回セールスマン問題/Wikipedia","巡回セールスマン問題を","巡回セールスマン問題を旅する","巡回セールスマン問題（TSP）を","巡回セールスマン問題（ウィキペディア）","巡回旅行商问题","巡回ｾｰﾙｽﾏﾝ(Traveling Salesman)","巡回ｾｰﾙｽﾏﾝ問題","巡回ｾｰﾙｽﾏﾝ問題-wikipedia","旅行商","旅行商問題","旅行商问题","旅行商问题（TSP）","旅行巡回セールスマン問題","旅行推銷員問題","旅行推销员问题","旅行推销员问题- 维基百科，自由的百科全书","旅行推�Š·員問題- 維基百科，自由的百科全書","旅行的推销员问题","維基百科的文章“ TSP ”","維基百科的文章“ 旅行商问题”","維基百科的文章“ 旅行推销员问题”","维基百科的文章“ TSP ”","维基百科的文章“ 旅行商问题”","维基百科的文章“ 旅行推销员问题”","行街推銷員","销售人员出行问题","문제를 여행 판매원","세일즈맨 여행 문제","여행 세일즈맨","여행 세일즈맨 문제","여행 세일즈맨 문제를","여행 세일즈맨 문제의","외판원","외판원 문제","외판원 문제(Travelling Salesman Problem)","외판원 문제를","외판원 문제보기"],"name":"Travelling salesman problem","categories":["Commons category with local link same as on Wikidata","Computational problems in graph theory","Graph algorithms","Hamiltonian paths and cycles","NP-complete problems","NP-hard problems","Operations research","Pages containing cite templates with deprecated parameters","Travelling salesman problem","Use dmy dates from July 2012"],"tag_line":"The travelling salesman problem (TSP) asks the following question: Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city?"}}
,{"_index":"throwtable","_type":"algorithm","_id":"external-sorting","_score":0,"_source":{"description":"External sorting is a term for a class of sorting algorithms that can handle massive amounts of data. External sorting is required when the data being sorted do not fit into the main memory of a computing device (usually RAM) and instead they must reside in the slower external memory (usually a hard drive). External sorting typically uses a hybrid sort-merge strategy. In the sorting phase, chunks of data small enough to fit in main memory are read, sorted, and written out to a temporary file. In the merge phase, the sorted subfiles are combined into a single larger file.\n\n","alt_names":["external merge sort","-> Read more about External sorting","...Wikipedia Ordenamiento externo","...Wikipedia Sortowanie zewnętrzne","...more on Wikipedia about External sorting","1 External mergesort","1.1 Multiple passes","1.2 Tuning performance","2 Other algorithms","Algorithmus im Wiki","Algoritmos de ordenamiento externo","Ekstera ordigo","Exterior sorting","External Sort","External Sorting","External Sorting (Wikipedia)","External Sorting - Wikipedia, The Free Encyclopedia","External marge","External sort","External sortin","External sorting","External sorting - Wikipedia, the free encyclop...","External sorting - Wikipedia, the free encyclopedia","External sorting - Wikipedia, the free encyclopediaThat example","External sorting - class of sorting algorithms that can","External sorting algoritmhs","External_sort","External_sorting","Externes Sortieren","Externy mergesort","Mouse Hover Me =>external sort","N-merge","N-way merge","Nウェイのマージ","Ordenamiento Externo","Ordenamiento externo","Ordenamiento externo - Wikipedia, la enciclopedia libre","Reference: External sorting","Sortowanie zewnętrzne","View External sorting on Wikipedia","Wikipedia External Sorting article","Wikipedia article Ekstera ordigo","Wikipedia article External sort","Wikipedia article External sorting","Wikipedia article sa mga panlabas na Pag-aayos","Wikipedia entry for External sorting","Wikipedia-Artikel zu Externe Sortierung","Wikipedia-Artikel über externe Sortierung","Wikipedia: External sorting","Wikipedia: External sotring","algoritmo de ordenación externo","algoritmo de ordenamiento externo","article de Wikipedia sur External Sorting","articolo di Wikipedia su estero Ordinamento","articolo di Wikipedia su ordinamento esterno","artigo da Wikipedia sobre externas Seleção","artikel di wikipedia Sorting Eksternal","artykuł w Wikipedii Sortowanie zewnętrzne","artículo de Wikipedia Ordenamiento externo","artículo de Wikipedia sobre la clasificación externa","artículo de wikipedia sobre externos Clasificación","bài viết trên wikipedia ngoài Sắp xếp","de clasificación externa","di ordinamento esterno","ekstern Sortering","ekstern sortere","ekstern sortering","eksterne fusionere slags","eksterne sortering","en.wikipedia.org/...External_sort","en.wikipedia.org/...External_sorting","en.wikipedia.org/wiki/External_sorting","especie externa","esterno merge sort","externa de clasificación","externa de fusiones tipo","external merge","external merge sorting","external sort","external sort-merge","external sorting","external sorting algorithm","externe Sortierung","externe merge sort","externe sorteren","externe sortieren","externen Mergesort","externo clasificación","hardware sorter","http://en.wikipedia....xternal_sorting","http://en.wikipedia.org/wiki/External_so","http://en.wikipedia.org/wiki/External_sort","http://en.wikipedia.org/wiki/External_sorting","http://en.wikipedia.org/wiki/External_sorting#External_merge_sort","http://en.wikipedia.org/wiki/External_sorting#Tuning_performance","http://en.wikipedia.org/wiki/External_sorting.","http://en.wikipedia.org/wiki/External_sorting...","http://en.wikipedia.org/wiki/External_so…","http://en.wikipedia.org/…xternal_sort","http://es.wikipedia.org/wiki/Ordenamiento_externo","http://pl.wikipedia.org/wiki/Sortowanie_zewn%C4%99trzne","http://pl.wikipedia.org/wiki/Sortowanie_zewn%C4%99tżne","k-way sort","la clasificación externa","large files while using little memory","ordenar grandes cantidades de datos","ordenação externa","ordinamento esterno","setřídit","sorting a dataset too large to fit in","sortowania zewnętrznego","sortowanie zewnętrzne","vnější sloučit druh","vnější třídění","vnější řazení","vnějšího Seřadit","wen:External sorting","wikipedia article on External Sorting","wikipedia artikel over het externe Sorteren","wikipedia článek o vnější třídění","zewnętrzna sortowania","zewnętrznych seryjnej rodzaju","zewnętrznych sortowania","zewnętrznych sortowanie","Википедии статью Внешняя сортировка","Википедии статью о внешней сортировки","Внешняя сортировка","внешней сортировки","внешней сортировки слиянием","внешние сортировки","внешнюю сортировку","внешняя сортировка в ВИКИ","статья из Википедии о внешней сортировки","מיון חיצוני","מיון חיצוני – ויקיפדיה","“external processing” technique","其他算法","外部の","外部のソート","外部のソートを","外部の並べ替え","外部ソート","外部ソートは","外部ソートマージ","外部合并排序","外部并归排序","外部排序百科上的文章","外部排序的定义","对外部排序","條維基外部排序","，N路"],"name":"External sorting","categories":["All articles with unsourced statements","Articles with unsourced statements from October 2015","External memory algorithms","Sorting algorithms"],"tag_line":"External sorting is a term for a class of sorting algorithms that can handle massive amounts of data."}}
,{"_index":"throwtable","_type":"algorithm","_id":"gnome-sort","_score":0,"_source":{"description":"Gnome sort (or Stupid sort) is a sorting algorithm originally proposed by Dr. Hamid Sarbazi-Azad (Professor of Computer Engineering at Sharif University of Technology) in 2000 and called \"stupid sort\" (not to be confused with bogosort), and then later on described by Dick Grune and named \"gnome sort\" from the observation that it is \"how a gnome sorts a line of flower pots.\" It is a sorting algorithm which is similar to insertion sort, except that moving an element to its proper place is accomplished by a series of swaps, as in bubble sort. It is conceptually simple, requiring no nested loops. The average, or expected, running time is O(n2), but tends towards O(n) if the list is initially almost sorted.\nThe algorithm always finds the first place where two adjacent elements are in the wrong order, and swaps them. It takes advantage of the fact that performing a swap can introduce a new out-of-order adjacent pair only next to the two swapped elements. It does not assume that elements forward of the current position are sorted, so it only needs to check the position directly previous to the swapped elements.","alt_names":["'s Описание Википедии","- Gnome sort :","-> Read the article about 'Gnome sort'","...Wikipedia Gnome sort","...mehr auf Wikipedia über Gnomesort","...more on Wikipedia about Gnome sort","1. Gnome sort - Wikipedia, the free encyclopedia","6. Gnome sort - Wikipedia","7. Gnome sort – Wikipédia, a enciclopédia livre","8. Gnome sort - Wikipedia, la enciclopedia libre","Cüce sıralaması","Gnome Sort","Gnome Sort algorithm on Wikipedia","Gnome sort","Gnome sort - Wikipedia","Gnome sort - Wikipedia, la enciclopedia libre","Gnome sort - Wikipedia, the free encyclopedia","Gnome/Stupid","GnomeSorter","Gnome_sort","Gnomesort","Gnomesort bei der wikipedia","Gnomesort:","Kertitörpe-rendezés","Leprechaun-sort","Sortowanie gnoma","Wikiartikel zu Gnomesort","Wikipedia (Gnome sort)","Wikipedia - Gnome sort","Wikipedia article Gnome sort","Wikipedia article Sortowanie gnoma","Wikipedia article about Gnome sort","Wikipedia article on Gnome sort","Wikipedia article Գաճաճային դասակարգում","Wikipedia entry for Gnome sort","Wikipedia on Gnome sort","Wikipedia's Beskrivelse","Wikipedia-Artikel Gnomesort","Wikipedia-Seite zu 'Gnomesort'","Wikipedia: GnomeSort","Wikipedia:Gnome_sort","Wikipédia artigo Gnome sort","arriba-abajo y luego abajo-arriba","article Gnome sort","artigo da Wikipédia Gnome sort","artículo de Wikipedia Gnome sort","de beschrijving Wikipedia","der Wikipedia Beschreibung","en.wikipedia.org/Gnome_sort","en.wikipedia.org/wiki/Gnome_sort","gnome sort","gnome-sort","http://de.wikipedia.org/wiki/Gnomesort","http://en.wikipedia....wiki/Gnome_sort","http://en.wikipedia.org/wiki/Gnome_sort","http://es.wikipedia.org/wiki/Gnome_sort","http://hu.wikipedia.org/wiki/Kerti_t%C3%B6rpe","http://it.wikipedia.org/wiki/Gnome_sort","http://pl.wikipedia.org/wiki/Sortowanie_gnoma","http://pt.wikipedia.org/wiki/Gnome_sort","http://ru.wikipedia.org/wiki/Гномья_сортировка","http://tinyurl.com/453zvs","la Descripción de Wikipedia","wp:Gnome_sort","Гномья сортировка","Если он ссылается на Википедию, то в неё","Сортування гнома","Գաճաճային ...","Գաճաճային դասակարգում","مرتبسازی گورزاد","مرتبسازی گورزاد - ویکیپدیا","کوتوله ای","گورزاد","ノームソート","ノームソート - Wikipedia","ﾉｰﾑｿｰﾄ-wikipedia"],"name":"Gnome sort","categories":["All articles needing additional references","Articles needing additional references from August 2010","Articles needing additional references from November 2015","Comparison sorts","Sorting algorithms","Stable sorts"],"tag_line":"Gnome sort (or Stupid sort) is a sorting algorithm originally proposed by Dr. Hamid Sarbazi-Azad (Professor of Computer Engineering at Sharif University of Technology) in 2000 and called \"stupid sort\" (not to be confused with bogosort), and then later on described by Dick Grune and named \"gnome sort\" from the observation that it is \"how a gnome sorts a line of flower pots.\""}}
,{"_index":"throwtable","_type":"algorithm","_id":"tarjan's-strongly-connected-components-algorithm","_score":0,"_source":{"description":"Tarjan's Algorithm is an algorithm in graph theory for finding the strongly connected components of a graph. It runs in linear time, matching the time bound for alternative methods including Kosaraju's algorithm and the path-based strong component algorithm. Tarjan's Algorithm is named for its discoverer, Robert Tarjan.\n\n","alt_names":["Tarjan's algorithm","Tarjan's","Tarjan's strongly connected components algorithm","-> Leggi tutto l'articolo su 'Algoritmo di Tarjan","...mehr auf Wikipedia über Algorithmus von Tarjan zur","Algorithme de Tarjan","Algorithme de Tarjan - Wikipédia","Algorithmus von Tarjan aus Wikipedia","Algorithmus von Tarjan zur Bestimmung starker ...","Algorithmus von Tarjan zur Bestimmung starker Zusammenhangskomponenten","Algorithmus von Tarjan zur... zur Bestimmung starker...","Algorithmus_von_Tarjan_zur_Bestimmung_starker_Zusammenhangskomponenten","Algoritmo de Tarjan na Wikipedia","Algoritmo di Tarjan per le componenti fortemente connesse","Algoritmul lui Tarjan","Connected Components Algorithm","Targan's algorithm","Targan算法","Tarjan algoritmus","Tarjan er","Tarjan er stærkt forbundet komponent algoritme","Tarjan es","Tarjan is","Tarjan je","Tarjan je silně spojen součást algoritmu","Tarjan jest","Tarjan s strongly connected components algorithm Wikipedia the","Tarjan strongly connected components algorithm","Tarjan è","Tarjan&#039;s strongly connected components algorithm - Wikipedia","Tarjan's Algorithm","Tarjan's SCC algorithm","Tarjan's algorithm.","Tarjan's algoritme","Tarjan's starken Zusammenhangskomponente Algorithmus","Tarjan's strongly connected component algorithm","Tarjan's strongly connected components algorithm - Wikipedia ...","Tarjan's strongly connected components algorithm - Wikipedia, the ...","Tarjan's strongly connected components algorithm - Wikipedia, the free","Tarjan's strongly connected components algorithm - Wikipedia,...","Tarjan's strongly connected components algorithm by Wikipedia","Tarjan's strongly connected components algorithm.","Tarjan-Algorithmus","Tarjans algorithm","Tarjan的","Tarjan的强连通分量的算法","Tarjan的算法","Tarjan算法- 维基百科，自由的百科全书","What are remarks of Tarjan's strongly connected components","Wikipedia article Tarjan's strongly connected components algorithm","Wikipedia sur Algorithme de Tarjan","Wikipedia-Artikel Algorithmus von Tarjan zur Bestimmung starker","Wikipedia-Seite zu 'Algorithmus von Tarjan zur Bestimmung","aangesloten component Tarjan's sterk algoritme","algorithme de Tarjan","algorytmu Tarjan","componente algoritmo fortemente connessi gli Tarjan","do this efficiently","el algoritmo de Tarjan","en:Tarjan's strongly connected components algorithm","firmemente vinculado Tarjan algoritmo de componente","here is one way","http://de.wikipedia.org/wiki/Algorit...ngskomponenten","http://de.wikipedia.org/wiki/Algorithmus_von_Tarjan_zur_Bestimmung_starker_Zusammenhangskomponenten","http://en.wikipedia....nents_algorithm","http://en.wikipedia.org...ted_components_algorithm","http://en.wikipedia.org/wiki/Tar-","http://en.wikipedia.org/wiki/Tarjan%...ents_algorithm","http://en.wikipedia.org/wiki/Tarjan%27s ... _algorithm","http://en.wikipedia.org/wiki/Tarjan%27s … _algorithm","http://en.wikipedia.org/wiki/Tarjan%27s_..._algorithm","http://en.wikipedia.org/wiki/Tarjan%27s_st...nents_algorithm","http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_com-","http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_al gorithm","http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm","http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm.","http://en.wikipedia.org/wiki/Tarjan%E2%80","http://en.wikipedia.org/wiki/Tarjan&...ents_algorithm","http://en.wikipedia.org/wiki/Tarjan's","http://en.wikipedia.org/wiki/Tarjan's_","http://en.wikipedia.org/wiki/Tarjan's_...nents_algorithm","http://en.wikipedia.org/wiki/Tarjan's_s ... _algorithm","http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm","http://en.wikipedia.org/wiki/Tarjan...nents_algorithm","http://it.wikipedia.org/wiki/Algoritmo_di_Tarjan_per_le_componenti_fortemente_connesse","http://it.wikipedia.org/wiki/Algoritmo_di_Tarjan_per_le_componenti_fortemente_connesse#Implementazione_in_Java","jest silnie związana Tarjan algorytm element","l'algoritmo di Tarjan","strongly_connected_components_algorithm","strongly_connected_components_algorithm.","tarjan's","thm. http://en.wikipedia.","zh:Tarjan算法","Алгоритм Тарьян","Алгоритм Тарьяна","Алгоритъма на Tarjan в wikipedia","Тарьян на","компонент алгоритма Тарьян в сильно связных","タージャンの","タージャンのアルゴリズムを","タージャンの強連結成分のアルゴリズムが","强连通子图的Tarjan 算法"],"name":"Tarjan's strongly connected components algorithm","categories":["Articles with example pseudocode","Graph algorithms","Graph connectivity"],"tag_line":"Tarjan's Algorithm is an algorithm in graph theory for finding the strongly connected components of a graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"widest-path-problem","_score":0,"_source":{"description":"In graph algorithms, the widest path problem, also known as the bottleneck shortest path problem or the maximum capacity path problem, is the problem of finding a path between two designated vertices in a weighted graph, maximizing the weight of the minimum-weight edge in the path.\nFor instance, if the graph represents connections between routers in the Internet, and the weight of an edge represents the bandwidth of a connection between two routers, the widest path problem is the problem of finding an end-to-end path between two Internet nodes that has the maximum possible bandwidth. The weight of the minimum-weight edge is known as the capacity or bandwidth of the path. As well as its applications in network routing, the widest path problem is also an important component of the Schulze method for deciding the winner of a multiway election, and has been applied to digital compositing, metabolic analysis, and the computation of maximum flows. It is possible to adapt most shortest path algorithms to compute widest paths, by modifying them to use the bottleneck distance instead of path length. However, in many cases even faster algorithms are possible.\nA closely related problem, the minimax path problem, asks for the path that minimizes the maximum weight of any of its edges. It has applications that include transportation planning. Any algorithm for the widest path problem can be transformed into an algorithm for the minimax path problem, or vice versa, by reversing the sense of all the weight comparisons performed by the algorithm, or equivalently by replacing every edge weight by its negation.","alt_names":["- Widest path problem :","Widest path problem","Widest path problem - Wikipedia, the free encyclopedia","Widest path problem by Wikipedia","en.wikipedia.org/wiki/Widest_path_problem","http://en.wikipedia.org/wiki/Widest_path_problem","minimax path","widest path","widest path problem","widest path problem - Wikipedia, the free encyclopedia"],"name":"Widest path problem","categories":["CS1 French-language sources (fr)","Computational problems in graph theory","Graph algorithms","Network theory","Polynomial-time problems"],"tag_line":"In graph algorithms, the widest path problem, also known as the bottleneck shortest path problem or the maximum capacity path problem, is the problem of finding a path between two designated vertices in a weighted graph, maximizing the weight of the minimum-weight edge in the path."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bitonic-sorter","_score":0,"_source":{"description":"Bitonic mergesort is a parallel algorithm for sorting. It is also used as a construction method for building a sorting network. The algorithm was devised by Ken Batcher. The resulting sorting networks consist of  comparators and have a delay of , where  is the number of items to be sorted.\nA sorted sequence is a monotonically non-decreasing (or non-increasing) sequence. A bitonic sequence is a sequence with  for some , or a circular shift of such a sequence.","alt_names":["- Bitonic sorter :","...more on Wikipedia about Bitonic sorter","Batcher Sort","Batcher sort","Batcher sorting network","Bitonic Sort","Bitonic Sorter","Bitonic sort","Bitonic sorte","Bitonic sorter","Bitonic sorter - Wikipedia, the free encyclopedia","Bitonic sorter Wikipedia the free encyclopedia","Bitonic sorter from Wikipedia","Bitonic sorters","Bitonic sorting","Bitonic_sorter","Read More bitonic sorter wikipedia the free encyclopedia","Wikipedia (Bitonic sorter)","Wikipedia article Batcher sort","Wikipedia article Bitonic sort","Wikipedia article Bitonic sorter","Wikipedia article on Bitonic sorter","Wikipedia entry for Bitonic sorter","bitonic algorithm","bitonic merge sort","bitonic mergesort","bitonic sort","bitonic sorter","bitonic sorting","bitonic sorting network","en.wikipedia.org/wiki/Bitonic_sorter","http://en.wikipedia.org/wiki/Bitonic_sor","http://en.wikipedia.org/wiki/Bitonic_sor...","http://en.wikipedia.org/wiki/Bitonic_sort","http://en.wikipedia.org/wiki/Bitonic_sorter","双调排序网络"],"name":"Bitonic sorter","categories":["Sorting algorithms"],"tag_line":"Bitonic mergesort is a parallel algorithm for sorting."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sma*","_score":0,"_source":{"description":"SMA* or Simplified Memory Bounded A* is a shortest path algorithm based on the A* algorithm. The main advantage of SMA* is that it uses a bounded memory, while the A* algorithm might need exponential memory. All other characteristics of SMA* are inherited from A*.","alt_names":["- SMA* :","SMA*","SMA* - Wikipedia","SMA* - Wikipedia, the free encyclopedia","SMA* by Wikipedia","Search games. The Simplified Memory-Bounded Algorithm (SMA","Simplified Memory-Bounded Algorithm","Simplified Memory-Bounded Algorithm SMA*","Simplified Memory-Bounded Algorithm – Wikipedia","Simplified_Memory-Bounded_Algorithm","Wikipedia article Algorytm SMA*","Wikipedia article SMA*","Wikipedia article on SMA*","Wikipedia entry for SMA*","Wikipedia-Artikel Simplified Memory-Bounded Algorithm","http://de.wikipedia.org/wiki/Simplified_Memory-Bounded_Algorithm","http://en.wikipedia.org/wiki/SMA*","http://pl.wikipedia.org/wiki/Algorytm_SMA*","yago-res:SMA*"],"name":"SMA*","categories":["All articles needing additional references","All articles needing expert attention","All articles that are too technical","Articles needing additional references from March 2015","Articles needing expert attention from November 2009","Articles with example pseudocode","Game artificial intelligence","Graph algorithms","Routing algorithms","Search algorithms","Wikipedia articles that are too technical from November 2009"],"tag_line":"SMA* or Simplified Memory Bounded A* is a shortest path algorithm based on the A* algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"adaptive-heap-sort","_score":0,"_source":{"description":"The adaptive heap sort is a sorting algorithm that is similar to heap sort, but uses a randomized binary search tree to structure the input according to any preexisting order. The randomized binary search tree is used to select candidates that are put into the heap, so the heap doesn't need to keep track of all elements. Adaptive heap sort is a part of the adaptive sorting family.\nThe first adaptive heapsort was Dijkstra's Smoothsort.","alt_names":["Adaptive Heap-Sort","Adaptive heap sort","Adaptive heap sort - Wikipedia :: The free encyclopedia","Adaptive heap sort - Wikipedia, the free encyclopedia","Adaptive heap sort - Wikipedia, the free encyclopedia ...","Heap sort adaptativo","Wikipedia (Adaptive heap sort)","Wikipedia article Adaptive heap sort","Wikipedia article Heap sort adaptativo","Wikipedia entry for Adaptive heap sort","adaptive heap sort","http://en.Liarpedia.org/wiki/Adaptive_heap_sort","http://en.wikipedia.org/wiki/Adaptive_he","http://en.wikipedia.org/wiki/Adaptive_heap_sort"],"name":"Adaptive heap sort","categories":["Algorithms and data structures stubs","All stub articles","Comparison sorts","Computer science stubs","Heaps (data structures)","Sorting algorithms"],"tag_line":"The adaptive heap sort is a sorting algorithm that is similar to heap sort, but uses a randomized binary search tree to structure the input according to any preexisting order."}}
,{"_index":"throwtable","_type":"algorithm","_id":"binary-prioritization","_score":0,"_source":{"description":"Binary Prioritization is a sorting algorithm which prioritizes to-do tasks.\nUnlike other binary sort methods (e.g. binary search) this method assumes that the deferred work will be prioritized in a later process, but their order is not relevant in the first iteration. The faster processing of classified and important tasks is achieved by reducing the cost of sorting by not sorting the subset of the less important tasks. In each iteration, the cost is reduced by the sorted elements.\n\n","alt_names":[],"name":"Binary prioritization","categories":["All articles lacking sources","All orphaned articles","Articles lacking sources from October 2013","Data processing","Orphaned articles from October 2013","Sorting algorithms"],"tag_line":"Binary Prioritization is a sorting algorithm which prioritizes to-do tasks."}}
,{"_index":"throwtable","_type":"algorithm","_id":"internal-sort","_score":0,"_source":{"description":"An internal sort is any data sorting process that takes place entirely within the main memory of a computer. This is possible whenever the data to be sorted is small enough to all be held in the main memory. For sorting larger datasets, it may be necessary to hold only a chunk of data in memory at a time, since it won’t all fit. The rest of the data is normally held on some larger, but slower medium, like a hard-disk. Any reading or writing of data to and from this slower media can slow the sortation process considerably. This issue has implications for different sort algorithms.\nSome common internal sorting algorithms include:\nBubble Sort\nInsertion Sort\nQuick Sort\nHeap Sort\nRadix Sort\nSelection sort\nConsider a Bubblesort, where adjacent records are swapped in order to get them into the right order, so that records appear to “bubble” up and down through the dataspace. If this has to be done in chunks, then when we have sorted all the records in chunk 1, we move on to chunk 2, but we find that some of the records in chunk 1 need to “bubble through” chunk 2, and vice versa (i.e., there are records in chunk 2 that belong in chunk 1, and records in chunk 1 that belong in chunk 2 or later chunks). This will cause the chunks to be read and written back to disk many times as records cross over the boundaries between them, resulting in a considerable degradation of performance. If the data can all be held in memory as one large chunk, then this performance hit is avoided.\nOn the other hand, some algorithms handle external sorting rather better. A Merge sort breaks the data up into chunks, sorts the chunks by some other algorithm (maybe bubblesort or Quick sort) and then recombines the chunks two by two so that each recombined chunk is in order. This approach minimises the number or reads and writes of data-chunks from disk, and is a popular external sort method.","alt_names":["Internal Sorting","Internal sort","Internal sort - Wikipedia, the free encyclopedia","Internal sorting","Wikipedia article Internal sorting","Wikipedia entry for Internal sort","clasificación interna","http://en.Liarpedia.org/wiki/Internal_sort","http://en.wikipedia.org/wiki/Internal_so","http://en.wikipedia.org/wiki/Internal_sort","http://en.wikipedia.org/wiki/Internal_so…","internal sort","internal sorting","interne Sortierung","interne sortering","ordinamento interno","vnitřní třídění","wewnętrznego sortowania","yago-res:Internal sort","Внутренняя сортировка","Внутренняя сортировка — Википедия","の内部ソート"],"name":"Internal sort","categories":["All articles to be merged","Articles to be merged from March 2012","Sorting algorithms"],"tag_line":"An internal sort is any data sorting process that takes place entirely within the main memory of a computer."}}
,{"_index":"throwtable","_type":"algorithm","_id":"adaptive-coding","_score":0,"_source":{"description":"Adaptive coding refers to variants of entropy encoding methods of lossless data compression. They are particularly suited to streaming data, as they adapt to localized changes in the characteristics of the data, and don't require a first pass over the data to calculate a probability model. The cost paid for these advantages is that the encoder and decoder must be more complex to keep their states synchronized, and more computational power is needed to keep adapting the encoder/decoder state.\nAlmost all data compression methods involve the use of a model, a prediction of the composition of the data. When the data matches the prediction made by the model, the encoder can usually transmit the content of the data at a lower information cost, by making reference to the model. This general statement is a bit misleading as general data compression algorithm would include the popular LZW and LZ77 algorithms, which are hardly comparable to compression techniques typically called adaptive. Run length encoding and the typical JPEG compression with run length encoding and predefined Huffman codes do not transmit a model. A lot of other methods adapt their model to the current file and need to transmit it in addition to the encoded data, because both the encoder and the decoder need to use the model.\nIn adaptive coding, the encoder and decoder are instead equipped with a predefined meta-model about how they will alter their models in response to the actual content of the data, and otherwise start with a blank slate, meaning that no initial model needs to be transmitted. As the data is transmitted, both encoder and decoder adapt their models, so that unless the character of the data changes radically, the model becomes better-adapted to the data its handling and compresses it more efficiently approaching the efficiency of the static coding.\n\n","alt_names":["- Adaptive coding :","-> Read more about Adaptive coding","...more on Wikipedia about Adaptive coding","Adaptive Entropy Coder","Adaptive coding","Adaptive coding - Wikipedia :: The free encyclopedia","Adaptive coding - Wikipedia, the free encyclopedia","Adaptive coding Wikipedia the free encyclopedia","Adaptive coding; it is used under the","Adaptive method","Read More adaptive coding wikipedia the free encyclopedia","Wikipedia article Adaptive coding","Wikipedia article on Adaptive coding","Wikipedia entry for Adaptive coding","adaptive coding","http://en.wikipedia.org/wiki/Adaptive_coding"],"name":"Adaptive coding","categories":["All articles lacking sources","Articles lacking sources from June 2009","Lossless compression algorithms"],"tag_line":"Adaptive coding refers to variants of entropy encoding methods of lossless data compression."}}
,{"_index":"throwtable","_type":"algorithm","_id":"adam7-algorithm","_score":0,"_source":{"description":"Adam7 is an interlacing algorithm for raster images, best known as the interlacing scheme optionally used in PNG images. An Adam7 interlaced image is broken into seven subimages, which are defined by replicating this 8×8 pattern across the full image.\n\nThe subimages are then stored in the image file in numerical order.\nAdam7 uses seven passes and operates in both dimensions, compared to only four passes in the vertical dimension used by GIF. This means that an approximation of the entire image can be perceived much more quickly in the early passes, particularly if interpolation algorithms such as bicubic interpolation are used.","alt_names":["Adam7","- Adam7 algorithm :","...mehr auf Wikipedia über Adam7","...more on Wikipedia about Adam7 algorithm","120px-Adam7_pass_4.gif","220px-Adam7_make_awesome_face.gif","Adam7 Algorithm","Adam7 Algorithm Wikipedia The Free Encyclopedia","Adam7 Algorithmus","Adam7 algorithm","Adam7 algorithm - Wikipedia, the free encyclopedia","Adam7 algorithm from Wikipedia","Adam7 algoritme","Adam7 algoritmu","Adam7 algorytm","Adam7 bei der wikipedia","Adam7 interlacing","Adam7 ist ein Algorithmus zum","Adam7 алгоритма","Adam7 – Wikipedia","Adam7_algorithm","Adam7_passes.gif","Adam7算法","Algorithme Adam7","Algorithme Adam7 - Wikipédia","An illustration of Adam7","An illustration of Adam7 interlacing over a 16","Interlacing (Adam7)","PNG-style interlacing","W plikach png także przeplot Adam7 jest bardzo","What is the history of Adam7 algorithm","Wikipedia article ''Adam7 algorithm''","Wikipedia article Adam7 algorithm","Wikipedia article Algorithme Adam7","Wikipedia entry for Adam7 algorithm","Wikipedia-Artikel Adam7","Wikipedia-Seite zu 'Adam7'","algoritmo Adam7","fr:Algorithme Adam7","http://de.wikipedia.org/wiki/Adam7","http://en.wikipedia.org/wiki/Adam7_algor","http://en.wikipedia.org/wiki/Adam7_algorithm","http://fr.wikipedia.org/wiki/Algorithme_Adam7","http://pl.wikipedia.org/wiki/Adam7","http://ru.wikipedia.org/wiki/Adam7","переплетения","インターレースを","아담7 알고리즘","위키 피 디아 문서 아담7 알고리즘"],"name":"Adam7 algorithm","categories":["Image compression","Lossless compression algorithms"],"tag_line":"Adam7 is an interlacing algorithm for raster images, best known as the interlacing scheme optionally used in PNG images."}}
,{"_index":"throwtable","_type":"algorithm","_id":"integer-sorting","_score":0,"_source":{"description":"In computer science, integer sorting is the algorithmic problem of sorting a collection of data values by numeric keys, each of which is an integer. Algorithms designed for integer sorting may also often be applied to sorting problems in which the keys are floating point numbers or text strings. The ability to perform integer arithmetic on the keys allows integer sorting algorithms to be faster than comparison sorting algorithms in many cases, depending on the details of which operations are allowed in the model of computing and how large the integers to be sorted are.\nThe classical integer sorting algorithms of bucket sort, counting sort, and radix sort are widely used and practical. Much of the subsequent research on integer sorting algorithms has focused less on practicality and more on theoretical improvements in their worst case analysis, and the algorithms that come from this line of research are not believed to be practical for current 64-bit computer architectures, although experiments have shown that some of these methods may be an improvement on radix sorting for data with 128 or more bits per key. Additionally, for large data sets, the near-random memory access patterns of many integer sorting algorithms can handicap them compared to comparison sorting algorithms that have been designed with the memory hierarchy in mind.\nInteger sorting provides one of the six benchmarks in the DARPA High Productivity Computing Systems Discrete Mathematics benchmark suite, and one of eleven benchmarks in the NAS Parallel Benchmarks suite.","alt_names":["- Integer sorting :","Integer Sort","Integer sorting","Integer sorting - Wikipedia, the free encyclopedia","Integer sorting; it is used under the","http://en.wikipedia.org/wiki/Integer_sorting","integer sorting"],"name":"Integer sorting","categories":["Sorting algorithms"],"tag_line":"In computer science, integer sorting is the algorithmic problem of sorting a collection of data values by numeric keys, each of which is an integer."}}
,{"_index":"throwtable","_type":"algorithm","_id":"qsort","_score":0,"_source":{"description":"qsort is a C standard library function that implements a polymorphic sorting algorithm for arrays of arbitrary objects according to a user-provided comparison function. It is named after the \"quicker sort\" algorithm (a quicksort variant due to R. S. Scowen), which was originally used to implement it in the Unix C library, although the C standard does not require it to implement quicksort.\nImplementations of the qsort function achieve polymorphism, the ability to sort different kinds of data, by taking a function pointer to a three-way comparison function, as well as a parameter that specifies the size of its individual input objects. The C standard requires the comparison function to implement a total order on the items in the input array.\nA qsort function was in place in Version 3 Unix of 1973, but was then an assembler subroutine. A C version, with roughly the interface of the standard C version, was in-place in Version 6 Unix. It was rewritten in 1983 at Berkeley. The function was standardized in ANSI C (1989).","alt_names":[],"name":"Qsort","categories":["All stub articles","C standard library","Software engineering stubs","Sorting algorithms"],"tag_line":"qsort is a C standard library function that implements a polymorphic sorting algorithm for arrays of arbitrary objects according to a user-provided comparison function."}}
,{"_index":"throwtable","_type":"algorithm","_id":"quantum-sort","_score":0,"_source":{"description":"A quantum sort is any sorting algorithm that runs on a quantum computer. Any comparison-based quantum sorting algorithm would take at least  steps, which is already achievable by classical algorithms. Thus, for this task, quantum computers are no better than classical ones. However, in space-bounded sorts, quantum algorithms outperform their classical counterparts.","alt_names":["...more on Wikipedia about Quantum sort","Quantum sort","Quantum sort - Wikipedia, the free encyclopedia","Wikipedia article ''Quantum sort''","Wikipedia entry for Quantum sort","http://en.Liarpedia.org/wiki/Quantum_sort","http://en.wikipedia.org/wiki/Quantum_sor","http://en.wikipedia.org/wiki/Quantum_sort","yago-res:Quantum sort"],"name":"Quantum sort","categories":["All stub articles","Quantum information science","Sorting algorithms","Theoretical computer science stubs"],"tag_line":"A quantum sort is any sorting algorithm that runs on a quantum computer."}}
,{"_index":"throwtable","_type":"algorithm","_id":"splaysort","_score":0,"_source":{"description":"In computer science, splaysort is an adaptive comparison sorting algorithm based on the splay tree data structure.\n^ Moffat, Alistair; Eddy, Gary; Petersson, Ola (July 1996), \"Splaysort: Fast, Versatile, Practical\", Software Practice and Experience 26 (7): 781–797, doi:10.1002/(SICI)1097-024X(199607)26:7<781::AID-SPE35>3.3.CO;2-2","alt_names":[],"name":"Splaysort","categories":["Sorting algorithms"],"tag_line":"In computer science, splaysort is an adaptive comparison sorting algorithm based on the splay tree data structure."}}
,{"_index":"throwtable","_type":"algorithm","_id":"vector-quantization","_score":0,"_source":{"description":"Vector quantization (VQ) is a classical quantization technique from signal processing that allows the modeling of probability density functions by the distribution of prototype vectors. It was originally used for data compression. It works by dividing a large set of points (vectors) into groups having approximately the same number of points closest to them. Each group is represented by its centroid point, as in k-means and some other clustering algorithms.\nThe density matching property of vector quantization is powerful, especially for identifying the density of large and high-dimensioned data. Since data points are represented by the index of their closest centroid, commonly occurring data have low error, and rare data high error. This is why VQ is suitable for lossy data compression. It can also be used for lossy data correction and density estimation.\nVector quantization is based on the competitive learning paradigm, so it is closely related to the self-organizing map model and to sparse coding models used in deep learning algorithms such as autoencoder.","alt_names":["Vektorquantisierung","-> Read the article about 'Vector quantization'","...Wikipedia Quantification vectorielle","...more on Wikipedia about Vector quantization","2.1 Use in data compression","2.2 Video codecs based on vector quantization","2.3 Audio codecs based on vector quantization","Ihre Vektor-Input-Quantisierung","Publication: · Book","Quantification vectorielle - Wikipédia","VQ codebook","Vector Kvantisering","Vector Quantization","Vector kwantyzacji","Vector quantization","Vector quantization - Wikipedia, the free encyclopedia","Vector quantization; it is used under the","Vector quantizzazione","Vector_quantization","Vectorkwantisatie","Vektorquantisierer","Vektorquantisierung ? Wikipedia","What training does Vector Quantization have","What training does Vector Quantization have?","Wikipedia : ベクトル量子化","Wikipedia article Vector Quantization","Wikipedia article Vector quantization","Wikipedia article Vectorkwantisatie","Wikipedia article Vektorquantisierung","Wikipedia article on Vector Quantization","Wikipedia entry for Vector quantization","Wikipedia has the obligatory article","Wikipedia sur Quantification vectorielle","Wikipedia-Artikel Vektorquantisierung","Wikipedia-Seite zu 'Vektorquantisierung'","Wikipedia.jp:ベクトル量子化","Wikipedia: Vector quantization","Wikipedia:Vector_quantization","Wikipediaで「ベクトル量子化」を調べる","cuantización vectorial de su entrada.","de:Vektorquantisierung","en.wikipedia.org/wiki/Vector_quantization","en:vector quantization","http://de.wikipedia.org/wiki/Vektorquant","http://de.wikipedia.org/wiki/Vektorquantisierung","http://en.wikipedia.org/wiki/Vector_quan","http://en.wikipedia.org/wiki/Vector_quantization","http://fr.wikipedia.org/wiki/Quantification_vectorielle","ja:ベクトル量子化","l'article de Wikipédia Quantification vectorielle","quantification vectorielle","quantize vektor masukan Anda.","vecteur de quantification de vos commentaires.","vector de cuantización","vector quantiser","vector quantization","vector quantization (VQ)","vector quantization compression","vector quantize your input","vector quantizers","vector_quantization","vectores cuantificar su aportación","vectorkwantisatie","vektorová kvantizace","vetor quantizar sua entrada.","vettoriale quantizzare il vostro input.","вектора квантования ваш ввод.","векторное квантование","векторным квантованием","सदिश परिमाणीकरण","『ベクトル量子化』の解説","ウィキペディアの記事 ベクトル量子化","ベクトル入力量子化する","ベクトル量子化","ベクトル量子化 - Wikipedia","矢量量化你的輸入","矢量量化你的输入","벡터 귀하의 의견을 quantize","ﾍﾞｸﾄﾙ量子化","ﾍﾞｸﾄﾙ量子化-wikipedia"],"name":"Vector quantization","categories":["Articles to be expanded from February 2009","Incomplete lists from August 2008","Lossy compression algorithms"],"tag_line":"Vector quantization (VQ) is a classical quantization technique from signal processing that allows the modeling of probability density functions by the distribution of prototype vectors."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dictionary-coder","_score":0,"_source":{"description":"A dictionary coder, also sometimes known as a substitution coder, is a class of lossless data compression algorithms which operate by searching for matches between the text to be compressed and a set of strings contained in a data structure (called the 'dictionary') maintained by the encoder. When the encoder finds such a match, it substitutes a reference to the string's position in the data structure.","alt_names":["dictionary codes","- Dictionary coder :","-> Read more about Dictionary coder","...more on Wikipedia about Dictionary coder","<span style=font-size:small;>dictionary encoder approach","Compresión por sustitución (Wikipedia)","Dictionary Coder","Dictionary Coders","Dictionary Encoding","Dictionary Table Encoded","Dictionary coder","Dictionary coder - Wikipedia, the free encyclopedia","Dictionary coder Wikipedia the free encyclopedia","Dictionary coder on wikipedia.org","Dictionary coder; it is used under the","Dictionary coders","Dictionary_coder","Encoder Wörterbuch","Kodowanie słownikowe","Kodowanie słownikowe – Wikipedia, wolna encyklopedia","Slovníkové techniky kompresie","Source Wikipedia.org Arcticle - Dictionary coder","Stringersatzverfahren","What are some examples of Dictionary coder","What are some examples of Dictionary coder?","Wikipedia article Dictionary coder","Wikipedia article on Dictionary coder","Wikipedia entry for Dictionary coder","Wikipedia-Artikel Stringersatzverfahren","Wikipedia-Artikel Wörterbuchkompression","Wikipedia-Seite zu 'Stringersatzverfahren'","Wikipedia-Seite zu 'Wörterbuchkompression'","Wikipedia: Compresión por sustitución","Wörterbuch Ansatz Kompression","Wörterbuch Coder","Wörterbuch Kompression","Wörterbuch-Codierer,","Wörterbuchkompression","Wörterbuchkompression in","Wörterbuchverfahren","approccio di compressione dizionario","approche de compression dictionnaire","article Dictionary coder","building up a dictionary","coder พจนานุกรม","codeur dictionnaire","codificador dicionário","codificatore dizionario","diccionario codificador","diccionario de compresión","diccionario de compresión de enfoque","dicionário codificador","dicionário de compressão abordagem","dictionary approach compression","dictionary coder","dictionary coders","dictionary coding","dictionary compression","dictionary encoder approach","dictionary encoding","dictionary-coder-LZ methods","dizionario coder","en.wikipedia.org/wiki/Dictionary_coder","encoder dizionario","encoder woordenboek","http://de.wikipedia.org/wiki/W%C3%B6rterbuchkompression","http://de.wikipedia.org/wiki/Wörterbuchkompression","http://en.wikipedia....ictionary_coder","http://en.wikipedia.org/wiki/Dictionary_coder","http://en.wikipedia.org/wiki/Dictionary_coder#","http://pl.wikipedia.org/wiki/Kodowanie_s%C5%82ownikowe","http://ru.wikipedia.org/wiki/Метод_сжатия_с_использованием_словаря","kamus coder","kompresi approach kamus","ordbog coder","phương pháp nén từ điển","r”. http://en.wikipedia.org/wiki/Dictionary_","simple dictionary coder","slovník kompresní","słownikowej kompresji danych","từ điển coder","woordenboek coder","Метод сжатия с использованием словаря","Метод сжатия с использованием словаря — Википедия","Словарные методы","кодер словарь,","кодировщик словарь","метод сжатия с использованием словаря","речниковите методи","словаре сжатия подход","словарного сжатия","словарь кодер","словарь сжатия","सांकेतिक शब्दों में बदलनेवाला शब्दकोश","วิธีการบีบอัดพจนานุกรม","の圧縮とmemory","字典压缩","字典的压缩方法","字典的壓縮方法","字典编码器","符号化辞書","編碼字典","编码字典","辞書エンコーダ","辞書コーダ","사전 접근 압축","사전 코더를"],"name":"Dictionary coder","categories":["All articles needing additional references","Articles needing additional references from September 2014","Lossless compression algorithms"],"tag_line":"A dictionary coder, also sometimes known as a substitution coder, is a class of lossless data compression algorithms which operate by searching for matches between the text to be compressed and a set of strings contained in a data structure (called the 'dictionary') maintained by the encoder."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fee-method","_score":0,"_source":{"description":"In mathematics, the FEE method is the method of fast summation of series of a special form. It was constructed in 1990 by E. A. Karatsuba and was called FEE—Fast E-function Evaluation—because it makes it possible fast computations of the Siegel  -functions, and in particular, \nA class of functions, which are 'similar to the exponential function' was given the name 'E-functions' by Siegel. Among these functions are such special functions as the hypergeometric function, cylinder, spherical functions and so on.\nUsing the FEE, it is possible to prove the following theorem\nTheorem: Let  be an elementary Transcendental function, that is the exponential function, or a trigonometric function, or an elementary algebraic function, or their superposition, or their inverse, or a superposition of the inverses. Then\n\nHere  is the complexity of computation (bit) of the function  with accuracy up to  digits,  is the complexity of multiplication of two -digit integers.\nThe algorithms based on the method FEE include the algorithms for fast calculation of any elementary Transcendental function for any value of the argument, the classical constants e,  the Euler constant  the Catalan and the Apéry constants, such higher transcendental functions as the Euler gamma function and its derivatives, the hypergeometric, spherical, cylinder (including the Bessel) functions and some other functions for algebraic values of the argument and parameters, the Riemann zeta function for integer values of the argument and the Hurwitz zeta function for integer argument and algebraic values of the parameter, and also such special integrals as the integral of probability, the Fresnel integrals, the integral exponential function, the trigonometric integrals, and some other integrals for algebraic values of the argument with the complexity bound which is close to the optimal one, namely\n\nAt present, only the FEE makes it possible to calculate fast the values of the functions from the class of higher transcendental functions, certain special integrals of mathematical physics and such classical constants as Euler's, Catalan's and Apéry's constants. An additional advantage of the method FEE is the possibility of parallelizing the algorithms based on the FEE.","alt_names":["- FEE method :","FEE method","FEE method - Wikipedia, the free encyclopedia","Fee Method","The FEE method","Wikipedia article FEE method","Wikipedia article on The FEE method","Wikipedia entry for FEE method","en.wikipedia.org/wiki/FEE_method","http://en.wikipedia.org/wiki/FEE_method","http://ru.wikipedia.org/wiki/Метод_БВЕ","Метод БВЕ"],"name":"FEE method","categories":["Computer arithmetic algorithms","Numerical analysis","Pi algorithms","Vague or ambiguous time from August 2011"],"tag_line":"In mathematics, the FEE method is the method of fast summation of series of a special form."}}
,{"_index":"throwtable","_type":"algorithm","_id":"chain-code","_score":0,"_source":{"description":"A chain code is a lossless compression algorithm for monochrome images. The basic principle of chain codes is to separately encode each connected component, or \"blob\", in the image.\nFor each such region, a point on the boundary is selected and its coordinates are transmitted. The encoder then moves along the boundary of the region and, at each step, transmits a symbol representing the direction of this movebment.\nThis continues until the encoder returns to the starting position, at which point the blob has been completely described, and encoding continues with the next blob in the image.\nThis encoding method is particularly effective for images consisting of a reasonably small number of large connected components.","alt_names":["- Chain code :","...mehr auf Wikipedia über Freeman-Code","Chain Code","Chain code","Chain code - Wikipedia :: The free encyclopedia","Chain code - Wikipedia, the free encyclopedia","Chain code; it is used under the","Chain codes","Chain_code","Freeman-Code","Freeman-Code – Wikipedia","Melbourne Chains","Wikipedia article Chain code","Wikipedia article on Chain code","Wikipedia entry for Chain code","Wikipedia-Artikel Freeman-Code","Wikipedia-Artikel Kettencode","Wikipedia-Seite zu 'Freeman-Code'","Wikipedia: Freeman-Code","chain code","chain codes","en:Chain code","http://de.wikipedia.org/wiki/Freeman-Cod","http://de.wikipedia.org/wiki/Freeman-Code","http://en.wikipedia.org/wiki/Chain_code","http://es.wikipedia.org/wiki/Chain_code","yago-res:Chain code","Řetězový kód"],"name":"Chain code","categories":["Image compression","Lossless compression algorithms"],"tag_line":"A chain code is a lossless compression algorithm for monochrome images."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ut-video-codec-suite","_score":0,"_source":{"description":"UT Video Codec Suite is a fast, lossless video codec, developed by Takeshi Umezawa and released under the free GNU General Public License.\nThe algorithm of UT video builds on the Huffman code to.\nUT video was as an alternative to HuffYUV developed which allows for better compression and has appeared both as x86 and x64 than build. It can handle the color spaces YUV422 (ULY2), RGB (ULRG), RGBA (Ulra) and, most recently, YUV420 bypass (ULY0). Due to its support for multithreading this codec is also capable of HDTV material to encode in real time. However, this is a good support for the SSE2 -Befehlssatzes on the main processor required because Umezawa reblogged this instruction set used for optimization.\nUT video uses the following FOURCC codes: ULY0, ULY2, ULRA, ULRG.","alt_names":[],"name":"Ut Video Codec Suite","categories":["2008 software","All articles lacking sources","All orphaned articles","All stub articles","Articles lacking sources from April 2015","Free video codecs","Lossless compression algorithms","Orphaned articles from August 2015","Television technology stubs"],"tag_line":"UT Video Codec Suite is a fast, lossless video codec, developed by Takeshi Umezawa and released under the free GNU General Public License."}}
,{"_index":"throwtable","_type":"algorithm","_id":"context-tree-weighting","_score":0,"_source":{"description":"The context tree weighting method (CTW) is a lossless compression and prediction algorithm by Willems, Shtarkov & Tjalkens 1995. The CTW algorithm is among the very few such algorithms that offer both theoretical guarantees and good practical performance (see, e.g. Begleiter, El-Yaniv & Yona 2004). The CTW algorithm is an “ensemble method,” mixing the predictions of many underlying variable order Markov models, where each such model is constructed using zero-order conditional probability estimators.","alt_names":["- Context Tree Weighting method :","- Context tree weighting :","Context Tree Weighting method","Context tree weighting","Context tree weighting - Wikipedia, the free encyclopedia","Context tree weighting; it is used under the","Context_Tree_Weighting_method","Context_tree_weighting","Wikipedia article Context Tree Weighting method","Wikipedia article Context tree weighting","Wikipedia article on Context Tree Weighting method","Wikipedia article on Context tree weighting","Wikipedia: Context tree weighting","context tree weighting","context tree weighting algorithm (CTW)","http://en.wikipedia.org/wiki/Context_Tree_Weighting_method","http://en.wikipedia.org/wiki/Context_tre","http://en.wikipedia.org/wiki/Context_tree_weighting","http://en.wikipedia.org/wiki/Context_tree_weighting#","http://en.wikipedia.org/wiki/Context_tree_weighti…","http://en.wikipedia.org/wiki/Context_tre…"],"name":"Context tree weighting","categories":["All stub articles","Computer science stubs","Lossless compression algorithms"],"tag_line":"The context tree weighting method (CTW) is a lossless compression and prediction algorithm by Willems, Shtarkov & Tjalkens 1995."}}
,{"_index":"throwtable","_type":"algorithm","_id":"package-merge-algorithm","_score":0,"_source":{"description":"The package-merge algorithm is an O(nL)-time algorithm for finding an optimal length-limited Huffman code for a given distribution on a given alphabet of size n, where no code word is longer than L. It is a greedy algorithm, and a generalization of Huffman's original algorithm. Package-merge works by reducing the code construction problem to the binary coin collector's problem.","alt_names":["Description of the Package-Merge Algorithm","Package merge algorithm","Package merge algorithm Wikipedia the free encyclopedia","Package-Merge","Package-merge algorithm","Package-merge algorithm - Wikipedia :: The free encyclopedia","Package-merge algorithm - Wikipedia, the free encyclopedia","Package-merge algorithm - Wikipedia, the free encyclopedia ...","Performance Improvements and Generalizations","The Coin Collector's Problem","The Package-merge-algorithm","Wikipedia article Package-merge algorithm","Wikipedia page?.","en.wikipedia.org/wiki/Package-merge_algorithm","http://en.wikipedia.org/wiki/Package-mer","http://en.wikipedia.org/wiki/Package-merge_algorithm","http://en.wikipedia.org/wiki/Package−merge_algorithm","package merge alorithm","package-merge","package-merge algorithm","英語版 Wikipedia の記事"],"name":"Package-merge algorithm","categories":["Coding theory","Lossless compression algorithms"],"tag_line":"The package-merge algorithm is an O(nL)-time algorithm for finding an optimal length-limited Huffman code for a given distribution on a given alphabet of size n, where no code word is longer than L. It is a greedy algorithm, and a generalization of Huffman's original algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"microsoft-video-1","_score":0,"_source":{"description":"Microsoft Video 1 or MS-CRAM is an early lossy video compression and decompression algorithm (codec) that was released with version 1.0 of Microsoft's Video for Windows in November 1992. It is based on MotiVE, a vector quantization codec which Microsoft licensed from Media Vision. In 1993, Media Vision marketed the Pro Movie Spectrum, an ISA board that captured video in both raw and MSV1 formats (the MSV1 processing was done in hardware on the board).\n^ \"Troubleshooting Video Codecs in Windows 95\". Support.microsoft.com. 2006-11-15. Retrieved 2009-10-25.","alt_names":[],"name":"Microsoft Video 1","categories":["All articles with topics of unclear notability","All stub articles","Articles with topics of unclear notability from September 2011","Film and video technology","Lossy compression algorithms","Microsoft","Multimedia software stubs","Video codecs"],"tag_line":"Microsoft Video 1 or MS-CRAM is an early lossy video compression and decompression algorithm (codec) that was released with version 1.0 of Microsoft's Video for Windows in November 1992."}}
,{"_index":"throwtable","_type":"algorithm","_id":"quicktime-graphics","_score":0,"_source":{"description":"QuickTime Graphics is a lossy video compression and decompression algorithm (codec) developed by Apple Inc. and first released as part of QuickTime 1.x in the early 1990s. The codec is also known by the name Apple Graphics and its FourCC SMC. The codec operates on 8-bit palettized RGB data. The bit-stream format of QuickTime Graphics has been reverse-engineered and a decoder has been implemented in the projects XAnim and libavcodec.","alt_names":[],"name":"QuickTime Graphics","categories":["Apple Inc. software","Lossy compression algorithms","Video codecs"],"tag_line":"QuickTime Graphics is a lossy video compression and decompression algorithm (codec) developed by Apple Inc. and first released as part of QuickTime 1.x in the early 1990s."}}
,{"_index":"throwtable","_type":"algorithm","_id":"methods-of-computing-square-roots","_score":0,"_source":{"description":"In numerical analysis, a branch of mathematics, there are several square root algorithms or methods of computing the principal square root of a nonnegative real number. For the square roots of a negative or complex number, see below.\nFinding  is the same as solving the equation . Therefore, any general numerical root-finding algorithm can be used. Newton's method, for example, reduces in this case to the so-called Babylonian method:\n\nGenerally, these methods yield approximate results. To get a higher precision for the root, a higher precision for the square is required and a larger number of steps must be calculated.","alt_names":["http://es.wikipedia.org/wiki/Cálculo_de_…","Computing square roots","http://fr.wikipedia.org/wiki/M%C3%A9thode_de_H","módszer","Babylonian method","Heron's method","Heron-Verfahren","Methods of computing square roots - Wikipedia, the free","' p …","- Babylonian method :","- Heron's method :","- Methods of computing square roots :","-> Leggi tutto l'articolo su 'Metodi per il","...Wikipedia Calcolo della radice quadrata","...mehr auf Wikipedia über Babylonisches Wurzelziehen","...more on Wikipedia about Methods of computing square","1 Rough estimation","10 methods documented to compute square roots","2 Babylonian method","208b9af589f89b3e80308430eb82 ...","300px-Babylonian_method.svg.png",": Someone with an interest in the history of","Abschnitt im WikiPedia","Algoritmo Babilónico","Algoritmo calcolo radice quadrata - Click here!","Algoritmo de Newton","Alternate Methods of Calculating Square Roots","Approximations that depend on IEEE representation","Arrel quadrada Babilònica","Babilońską","Bablyonian Method","Babylonialainen metodi","Babylonian Algorithm","Babylonian Method","Babylonian algorithm","Babylonian calculation","Babylonian fixed-point iteration","Babylonian method of computing square root","Babylonian method; it is used under the","Babylonian_method","Babylonische Methode","Babylonische Wurzelziehen","Babylonisches Wurzelziehen","Babylonisches Wurzelziehen - Wikipedia","Babylonisches_Wurzelziehen","Bakhsali Approximation","Bakhshali Approximation","Bakhshali approximation","Bakhshali aproximación","Bisecting intervals","Bitte nicht überanstrengen beim Informationen suchen :roll:","Calcolo della radice quadrata","Calcolo della radice quadrata - Wikipedia","Common software methods","Computing Roots at Wikipedia","Computing Square roots - Wikipedia","Computing continued fractions of square roots","Computing square roots babylon style","Computing square roots.","Cálculo de la raíz cuadrada","Cálculo de la raíz cuadrada - Wikipedia, la enciclopedia","Cálculo de la raíz cuadrada ...","Cómo resolver raíces cuadradas","Das Heron-Verfahren","Digit by digit calculation","Digit-by-digit_calculation","ESTE TÓPICO","En la wiki se","Exponential identity","Fast Methods to Approximate Square Roots","Fler spännande metoder","Formas de resolver la raíz cuadrada","Fracciones continuas periódicas","HERON-Verfahren","Heron Verfahren","Heron square root extraction method","Heron's Method","Heron-Iterationen","Heron-Methode","Heron-Verfahren ? Wikipedia","Heron-Verfahren – Wikipedia","Heron-Verfahrens","Heronverfahren","Heronverfahren (Wikipedia)","I mean, thats what wiki says anyway","Informationen zum Heron-Verfahren","It resembles long division","Learn about Methods of computing square roots>>>","Link to Wiki to see a list","Log base 2 approximation and Newton's Method","Log base 2 approximation and Newtons Method","Method_of_computing_square_roots","Methods Of Computing Square","Methods Of Computing Square Roots Wikipedia The Free","Methods of Comparing square roots","Methods of Computing Square Roots","Methods of Computing Square Roots (Wikipedia)","Methods of calculating Square roots.","Methods of computing square roots","Methods of computing square roots - Wikipedia","Methods of computing square roots - Wikipedia ...","Methods of computing square roots - Wikipedia :: The free","Methods of computing square roots - Wikipedia, the ...","Methods of computing square roots ...","Methods of computing square roots Wikipedia the free","Methods of computing square roots#Continued fraction expansion","Methods of computing square roots: Approximations that depend","Methods of computing square roots; it is used","Methods of computing the square root","Methods_of_computing_square_roots","Metode Babylonian","Metodi per il calcolo della radice quadrata","Metodi per il calcolo della radice quadrata - Wikipedia","Metodi_per_il_calcolo_della_radice_quadrata","Metody obliczania pierwiastka kwadratowego","Méthode de Héron - Wikipédia","Método de resolución","No, actually they don't","Perfect square roots table","Radicis extractio","Reciprocal square root","Resolver raiz cuadrada","Rough estimation","Some possible choices","Square And Square Root Calculator","Square Root Methods","Square root approximation","Taking Square Root without a calculator","Taylor-series for square-roots","TaylorApproximation","This article is simply the definition of what","This article presents and explains several methods which","This is the way I was taught","This would be very slow","Try any of these methods","Veranschaulichung Heron","Walsh's fast reciprocal method","Ways of calculating square roots.","Wikipedia (Methods of computing square roots)","Wikipedia - Heron-Verfahren","Wikipedia - Heronverfahren","Wikipedia article Babylonian method","Wikipedia article Bakhshali approximation","Wikipedia article Heron's method","Wikipedia article Methods of computing square roots","Wikipedia article Méthode de Héron","Wikipedia article on Cálculo de la raíz cuadrada","Wikipedia article on Formas de resolver la raíz","Wikipedia article on Methods of computing square roots","Wikipedia article on square-root computing methods","Wikipedia entry for Methods of computing square roots","Wikipedia l'articolo Metodi per il calcolo della","Wikipedia link Jemidiah posted","Wikipedia-Artikel Babylonisches Wurzelziehen","Wikipedia-Artikel Heron-Methode","Wikipedia-Artikel Heron-Verfahren","Wikipedia-Artikel Heronverfahren","Wikipedia-Artikel zu babylonischem Wurzelziehen","Wikipedia-Seite zu 'Heron-Verfahren'","Wikipedia-Seite zu 'Heronverfahren'","Wikipedia: Babylonian Method","Wikipedia: Methods of Computing Square Roots","Wikipedia: Methods of computing square roots","Wikipediaで「開平法」を調べる","Wurzelzieher","a lot of different ways to calculate a","a n + 1 = S + m n + 1 d","a square root by hand","abylonian method","algorithme de Babylone","algorithmic methods","algoritmo di Bombelli","ar:طرق حوسبة الجذور التربيعية","army of alternatives","artículo de Wikipedia Calculo de la raiz cuadrada","artículo de Wikipedia Cálculo de la raíz cuadrada","artículo de Wikipedia Formas de resolver la raíz","available algorithms","ba6a2474b05605a21f41eb6683c6 ...","babylon method","babylonischen Wurzelziehen","babylonisches Wurzelziehen","calcolare una radice quadrata","calcular a raiz quadrada","calcular una raíz cuadrada","calculer une racine carrée,","compute a square root","cool trick","da Babilonia","de.wikipedia.org/wiki/Babylonisches_Wurzelziehen","de.wikipedia.org/wiki/Heron-Verfahren","de.wikipedia.org/wiki/Heronverfahren","decimal (base 10) method","describes a couple","description sur Wikipedia (en)","desde Babilonia","digit by digit","digit by digit calculation","digit-by-digit algorithm for computation of square","digit-by-digit algorithm for square roots","digit-by-digit method to calculate square-root","digit-by-digit method, such as the duplex","dit Engelse artikel","double sqrt13( int n ) { // double a = (eventually the","een algoritme","eine Quadratwurzel","en.wikipedia.org/...hods_of_computing_square_roots","en.wikipedia.org/wiki/Babylonian_method#Babylon...","en.wikipedia.org/wiki/Babylonian_method#Babylonian_method","en.wikipedia.org/wiki/Methods_of_comp...","en.wikipedia.org/wiki/Methods_of_computing_square_roots","es.wikipedia.org/wiki/C%C3%A1lculo_de_la_ra%C3","es:Cálculo de la raíz cuadrada","es:Formas de resolver la raíz cuadrada","explicación brillante","ez remélem segít","formas de resolver la raíz cuadrada","fr.wikipedia.org/wiki/M%C3%A9thode_de_H%C3","fr:Méthode de Héron","he:הוצאת שורש ריבועי","heronverfahren","hi:वर्गमूल निकालने की विधियाँ","how to find square roots","http//de.wikipedia.org/wiki/Babylonisches_Wurzelziehen","http//de.wikipedia.org/wiki/Heron-Verfahren","http://de.wikipedia....Heron-Verfahren","http://de.wikipedia.org/wiki/Ba bylonisches_Wurzelziehen","http://de.wikipedia.org/wiki/Babylonisches_Wurzelziehen","http://de.wikipedia.org/wiki/Babylonisch…","http://de.wikipedia.org/wiki/He ron-Verfahren","http://de.wikipedia.org/wiki/He ronverfahren","http://de.wikipedia.org/wiki/Heron-V...ng_in_Software","http://de.wikipedia.org/wiki/Heron-Verf ... Verfahrens","http://de.wikipedia.org/wiki/Heron-Verfa","http://de.wikipedia.org/wiki/Heron-Verfahren","http://de.wikipedia.org/wiki/Heron-Verfahren#Implementierung_in_Software","http://de.wikipedia.org/wiki/Heron-Verfahren#Konvergenz","http://de.wikipedia.org/wiki/Heron-Verfahren#Verallgemeinerung_des_Verfahrens","http://de.wikipedia.org/wiki/Heron-Verfa…","http://de.wikipedia.org/wiki/Heronverfahren","http://de.wikipedia.org/wiki/Heronverfah…","http://en....onian_method#Babylonian_method","http://en.wikipedia....em_.28base_2.29","http://en.wikipedia....ng_square_roots","http://en.wikipedia....s#Second_method","http://en.wikipedia.org...f_computing_square_roots","http://en.wikipedia.org/w...of_computing_square_roots","http://en.wikipedia.org/wiki/Babylon...ylonian_method","http://en.wikipedia.org/wiki/Babylonian ... ian_method","http://en.wikipedia.org/wiki/Babylonian … ian_method","http://en.wikipedia.org/wiki/Babylonian_me...bylonian_method","http://en.wikipedia.org/wiki/Babylonian_method","http://en.wikipedia.org/wiki/Babylonian_method#Babylonian_method","http://en.wikipedia.org/wiki/Babylonian_method#Convergence","http://en.wikipedia.org/wiki/Babylonian_method#Digit_by_digit_calculation","http://en.wikipedia.org/wiki/Heron%2...ylonian_method","http://en.wikipedia.org/wiki/Heron%27s_method#Babylonian_method","http://en.wikipedia.org/wiki/Heron's_method#Babylonian_method","http://en.wikipedia.org/wiki/M..._square_roots#Rough_estimation","http://en.wikipedia.org/wiki/Method...ng_square_roots","http://en.wikipedia.org/wiki/Methods of computing","http://en.wikipedia.org/wiki/Methods...","http://en.wikipedia.org/wiki/Methods..._.28base_10","http://en.wikipedia.org/wiki/Methods...g_square_roots","http://en.wikipedia.org/wiki/Methods...it_calculation","http://en.wikipedia.org/wiki/Methods...lonian_method.","http://en.wikipedia.org/wiki/Methods...m_.28base_2","http://en.wikipedia.org/wiki/Methods...ntial_identity","http://en.wikipedia.org/wiki/Methods...onian_metho d","http://en.wikipedia.org/wiki/Methods...representation","http://en.wikipedia.org/wiki/Methods...tion_expansion","http://en.wikipedia.org/wiki/Methods...wton_iteration","http://en.wikipedia.org/wiki/Methods...ylonian_method","http://en.wikipedia.org/wiki/Methods_of ... _expansion","http://en.wikipedia.org/wiki/Methods_of ... alculation","http://en.wikipedia.org/wiki/Methods_of ... esentation","http://en.wikipedia.org/wiki/Methods_of ... uare_roots","http://en.wikipedia.org/wiki/Methods_of … alculation","http://en.wikipedia.org/wiki/Methods_of … esentation","http://en.wikipedia.org/wiki/Methods_of … uare_roots","http://en.wikipedia.org/wiki/Methods_of_...uare_roots","http://en.wikipedia.org/wiki/Methods_of_co...git_calculation","http://en.wikipedia.org/wiki/Methods_of_co...ng_square_roots","http://en.wikipedia.org/wiki/Methods_of_co...s#Second_method","http://en.wikipedia.org/wiki/Methods_of_comp...l_.28base_10","http://en.wikipedia.org/wiki/Methods_of_compu...","http://en.wikipedia.org/wiki/Methods_of_computing_...","http://en.wikipedia.org/wiki/Methods_of_computing_squar e_roots","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Approximations_that_depend_on_IEEE_representation","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Bakhshali_approximation","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_.28base_2","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_.28base_2","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Continued...","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Continued_fraction_expansion","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Decimal_.28base_10","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Digit-by","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Digit_by_digit_calculation","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Duplex_method_for_extracting_a_square_root","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Exponential_identity","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Iterative_methods_for_reciprocal_square_roots","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Pell.27s_equation","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Rough_estimation","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Second_method","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Taylor_series","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Vedic_Duplex_method_for_extracting_a_square_root","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots.","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots...","http://en.wikipedia.org/wiki/Methods_of_computing_square_roots~~V","http://en.wikipedia.org/wiki/M​ethods_of_computing_square_roo​ts","http://es.wikipedia.org/wiki/C%C3%A1lculo_de_la_ra","http://es.wikipedia.org/wiki/Calculo_de_…","http://es.wikipedia.org/wiki/Formas_...237;z_cuadrada","http://es.wikipedia.org/wiki/Formas_de_ ... z_cuadrada","http://es.wikipedia.org/wiki/Formas_de_resolver_la_ra%C3%ADz_cuadrada","http://es.wikipedia.org/wiki/Formas_de_r…","http://fr.wikipedia.org/wiki/Méthode_de_Héron","http://he.wikipedia.org/wiki/הוצאת_שורש_ריבועי","http://it.wikipedia.org/wiki/Calcolo...adice_quadrata","http://it.wikipedia.org/wiki/Calcolo_de ... babilonese","http://it.wikipedia.org/wiki/Calcolo_della_radice_quadrata","http://it.wikipedia.org/wiki/Calcolo_della_radice_quadrata#Calcolo_della_radice_quadrata_di_un_intero:_algoritmo","http://it.wikipedia.org/wiki/Metodi_...adice_quadrata","http://it.wikipedia.org/wiki/Metodi_per ... e_quadrata","http://it.wikipedia.org/wiki/Metodi_per_...babilonese","http://it.wikipedia.org/wiki/Metodi_per_il_calcolo_della_r ...","http://it.wikipedia.org/wiki/Metodi_per_il_calcolo_della_radice_quadrata","http://it.wikipedia.org/wiki/Metodi_per_il_calcolo_della_radice_quadrata#Metodo_babilonese","http://it.wikipedia.org/wiki/Metodi_per_…","http://it.wikipedia.org/wiki/calcolo_del...","http://it.wikipedia.​org/wiki/Calcolo_del​la_radice_quadrata","http://it.wikipedia.​org/wiki/Metodi_per_​il_calcolo_della_rad​ice_quadrata","http://ja.wikipedia.org/wiki/開平法","http://pl.wikipedia.org/wiki/Metody_obliczania_pierwiastka_kw...","http://pl.wikipedia.org/wiki/Metody_obliczania_pierwiastka_kwadratowego","http://ru.wikipedia.org/wiki/Итерационна...","implement square root","infinite fraction method","it:Calcolo della radice quadrata","it:Metodi per il calcolo della radice quadrata","iterative fraction method","ja:開平法","l'algorithme de Babylone,","la:Radicis extractio","list of methods for computing square roots","long hand ways","lot of ways","lots of algorithms","menghitung akar kuadrat","method of computing square roots using the IEEE","methods of computing square roots","methods of computing square roots wikipedia the free","methods of computing the square root","metodi di calcolo","mètode d'Heron o Babilònic","méthode de Heron","méthode de Héron","méthode de Héron d'Alexandrie","méthode de héron","método babilônio","nach Heron","newton-method","non e' affatto cosi'","notoriously processor intensive","nur den Näherungswert 17/12 berechnet","od Babilonu","od Babylonu","one of the algorhythms listed on wikipedia","one of the algorhythms listed on wikipedia.","pl:Metody obliczania pierwiastka kwadratowego","reciprocal square root","root extraction algorithm","ru.wikipedia.org/wiki/Итерационная_форму...","ru:Итерационная формула Герона","section on the Vedic duplex method","seit Babylon","siden Babylon","since Babylon","sinds Babel","special case of square roots","this helpful.","this page, about different ways to find square","tomto článku Wikipedie","top)","triviale Beispiel","ttp://en.wikipedia.org/wiki/Babylonian_method#Babylonian_method","tính toán một căn bậc","used anciently with numbers","using a manual method","various iterative algorithms","w:Methods of computing square roots","w:Methods of computing square roots#Binary (base","ways to approximate a square root","wiki - methods of computing square roots","wiki piemērs","wiki: Babylonian method","éthode de Héron","Вавилонския метод","Википедии статью Итерационная формула Герона","Итерационная формула Герона","вычисления квадратного корня","вікіпедзіі","довольно хорошо объясняется","итерационной формулой Герона","итерационной формулы Герона","палічбавы альгарытм вылічэньня квадратнага кораня","с Вавилоном","էստեղ նայի","הוצאת שורש ריבועי","הוצאת שורש ריבועי – ויקיפדיה","ויקיפדיה - 'הוצאת שורש ריבועי'","שורש בינארי","طرق حوسبة الجذور التربيعية","คำนวณ ราก ที่ สอง","− http://en.wikipedia.org/wiki/Methods_of_computing_square_roots","「筆算による開平法」","ウィキペディアの記事 開平法","バビロニアの平方根","バビロン以来","巴比伦以来","平方根を計算","計算平方根","计算平方根","開平法","開平法 - Wikipedia","開平法 - Wikipedia:","開平法-wikipedia","開法とは？","바빌로니아 법","위키 피 디아 문서 바빌로니아 법","제곱근을 계산하려면,하지만"],"name":"Methods of computing square roots","categories":["All articles needing expert attention","All articles that are too technical","All articles that may contain original research","Articles needing expert attention from September 2012","Articles that may contain original research from January 2012","Computer arithmetic algorithms","Pages using web citations with no URL","Root-finding algorithms","Wikipedia articles that are too technical from September 2012"],"tag_line":"In numerical analysis, a branch of mathematics, there are several square root algorithms or methods of computing the principal square root of a nonnegative real number."}}
,{"_index":"throwtable","_type":"algorithm","_id":"banker's-algorithm","_score":0,"_source":{"description":"The Banker's algorithm, sometimes referred to as the avoidance algorithm, is a resource allocation and deadlock avoidance algorithm developed by Edsger Dijkstra that tests for safety by simulating the allocation of predetermined maximum possible amounts of all resources, and then makes an \"s-state\" check to test for possible deadlock conditions for all other pending activities, before deciding whether allocation should be allowed to continue.\nThe algorithm was developed in the design process for the THE operating system and originally described (in Dutch) in EWD108. When a new process enters a system, it must declare the maximum number of instances of each resource type that it may ever claim; clearly, that number may not exceed the total number of resources in the system. Also, when a process gets all its requested resources it must return them in a finite amount of time.\n\n","alt_names":["Banker's Algorithm","Banker's algorithm - Wikipedia, the free encyclopedia","http://en.wikipedia.org/wiki/Banker's_algorithm","Banker's algorithm","...Wikipedia Algoritmo del banchiere","...Wikipedia Algoritmo del banquero","...mehr auf Wikipedia über Bankieralgorithmus","...more on Wikipedia about Banker's algorithm","Algorisme del banquer","Algorisme del banquer - Viquipèdia","Algorithme du banquier","Algorithme du banquier - Wikip?dia","Algorithme du banquier - Wikipédia","Algoritmo bancario","Algoritmo del Banchiere","Algoritmo del Banquero","Algoritmo del banchiere","Algoritmo del banquero","Algoritmo del banquero - Wikipedia, la enciclopedia libre","Algoritmo del banquero - Wikipedia, la enciclopedia libreEl Algoritmo","Algoritmo do banqueiro","Algoritmo do banqueiro â€“ WikipÃ©dia, a enciclopÃ","Algorytm Bankiera","Algorytm bankiera","Bank-Algorithmus","Banker Algorithm","Banker Algorithmus","Banker Algorytm","Banker S Algorithm Wikipedia The Free Encyclopedia","Banker s algorithm Wikipedia the free encyclopedia","Banker Алгоритм","Banker%27s_algorithm","Banker's","Banker's Algorithmus","Banker's algorithm - Wikipedia :: The free encyclopedia","Banker's algorithm: Requests","Banker-Algorithmus","Bankers Algorithm","Bankers Safety Algorithm","Bankers algorithm","Bankers algoritme","Bankier-Algorithmus","Bankieralgorithmus","Bankieralgorithmus – Wikipedia","Bankiersalgorithmus","Bankirjev algoritem","Bankár algoritmus","Bankárov algoritmus","Bankérov algoritmus","Bankéřův algoritmus","Dijkstra bankéř algoritmus","Dijkstra's algoritme bankier","Dijkstra's banker's algorithm","Dijkstra-Algorithmus Bankier","Dijkstras Bankørens algoritme","Dijkstraの銀行のアルゴリズムを","Dijkstra的银行家算法","Einam čia jei vis dar neaišku.","Link – 2","What is algorithm of Banker's algorithm?","What is algorithm of Bankers' algorithm?","Wikipedia article Algorithme du banquier","Wikipedia article Algoritmo do banqueiro","Wikipedia article Algorytm bankiera","Wikipedia article Banker's algorithm","Wikipedia article Bankers algorithm","Wikipedia l'articolo Algoritmo del banchiere","Wikipedia-Artikel Bankier-Algorithmus","Wikipedia-Artikel Bankieralgorithmus","Wikipedia-Artikel Bankiersalgorithmus","Wikipedia-Seite zu 'Bankieralgorithmus'","Wikipedia-zh","[11] Banker's algorithm","algoritme van bankier","algoritmo de banco","algoritmo de banquero","algoritmo del banchiere","algoritmo del banquero","algoritmo di banca","algorytm bankiera","article Banker's algorithm","artículo de Wikipedia Algoritmo del banquero","bancario algoritmo","banchiere algoritmo","banchiere l'algoritmo di Dijkstra","banker's algorithm","bankers algorithm","bankier algorytm Dijkstry","bankmand's algoritme","bankéř algoritmus","bankéřův algoritmus","bankéřův problém","banquero del algoritmo de Dijkstra","ca:Algorisme del banquer","de:Bankieralgorithmus","en.wikipedia.org/wiki/Banker%27s_algorithm","en:Banker's_algorithm","es:Algoritmo del banquero","fr:Algorithme du banquier","http://de.wikipedia.org/wiki/Bankieralgo","http://de.wikipedia.org/wiki/Bankieralgorithmus","http://en.wikipedia.org/wiki/Banker%27s_algorithm","http://en.wikipedia.org/wiki/Banker%27s_algorithm#Pseudo","http://en.wikipedia.org/wiki/Banker%27s_algorithm#Safe_and_Unsafe_States","http://en.wikipedia.org/wiki/Bankers_algorithm","http://es.wikipedia.org/wiki/Algoritmo_del_banquero","http://fr.wikipedia.org/wiki/Algorithme_du_banquier","http://hu.wikipedia.org/wiki/Bank%C3%A1r_algoritmus","http://it.wikipedia.org/wiki/Algoritmo_del_banchiere","http://pl.wikipedia.org/wiki/Algorytm_bankiera","hu:Bankár algoritmus","it:Algoritmo del banchiere","ja:銀行家のアルゴリズム","pl:Algorytm bankiera","política del banquero","pt:Algoritmo do Banqueiro","pt:Algoritmo do banqueiro","sk:Bankárov algoritmus","the Banker's Algorithm","the banker's algorithm","uk:Алгоритм банкіра","wikipedia:Banker's algorithm","zh:银行家算法","Алгоритм банкира","банк алгоритма","банкира Алгоритм Дейкстры","в алгоритме Banker","นายแบงก์ คอยตรวจจับ การอับจน","バンカーのアルゴリズムを","銀行のアルゴリズム","銀行家のアルゴリズム","銀行家のアルゴリズム - Wikipedia","銀行家のｱﾙｺﾞﾘｽﾞﾑ-wikipedia","银行家算法","银行家算法- 维基百科，自由的百科全书","银行的算法"],"name":"Banker's algorithm","categories":["All articles with unsourced statements","Articles with example pseudocode","Articles with unsourced statements from October 2015","Concurrency control algorithms","Dutch inventions"],"tag_line":"The Banker's algorithm, sometimes referred to as the avoidance algorithm, is a resource allocation and deadlock avoidance algorithm developed by Edsger Dijkstra that tests for safety by simulating the allocation of predetermined maximum possible amounts of all resources, and then makes an \"s-state\" check to test for possible deadlock conditions for all other pending activities, before deciding whether allocation should be allowed to continue."}}
,{"_index":"throwtable","_type":"algorithm","_id":"parallel-algorithm","_score":0,"_source":{"description":"In computer science, a parallel algorithm, as opposed to a traditional serial algorithm, is an algorithm which can be executed a piece at a time on many different processing devices, and then combined together again at the end to get the correct result.\nMany parallel algorithms are executed concurrently – though in general concurrent algorithms are a distinct concept – and thus these concepts are often conflated, with which aspect of an algorithm is parallel and which is concurrent not being clearly distinguished. Further, non-parallel, non-concurrent algorithms are often referred to as \"sequential algorithms\", by contrast with concurrent algorithms.","alt_names":["۹ پیوندهای خارجی","Paralleler_Algorithmus","parallel algorithms","Parallel algorithm","- Concurrent algorithm :","- Parallel algorithm :","- Parallel algorithms :","-> Read the article about 'Parallel algorithm'","...mehr auf Wikipedia über Paralleler Algorithmus","...more on Wikipedia about Parallel algorithm","1. Parallel algorithm - Wikipedia, the free encyclopedia","Algoritmi de calcul paralel - Wikipedia","Algoritmo paralelo","Algoritmo paralelo - Wikipedia, la enciclopedia libre","Algoritmos paralelos","Algoritmos paralelos:","Algorytm równoległy","Algorytm równoległy – Wikipedia, wolna encyklopedia","Concurrent algorithm","Parallel Algorithm","Parallel algorithm - Wikipedia :: The free encyclopedia","Parallel algorithm - Wikipedia, the free encyclopedia","Parallel algorithm Wikipedia the free encyclopedia - result","Parallel algorithm; it is used under the","Parallel algorithms","Parallel algorithms on wikipedia","Parallel computer programs","Parallele Algorithmen","Paralleler Algorithmus","Paralleler Algorithmus in","Paralleler Algorithmus – Wikipedia","Párhuzamos algoritmus","Wikipedia Algoritmos paralelos","Wikipedia article Algoritmo paralelo","Wikipedia article Parallel algorithm","Wikipedia article Parallel algorithms","Wikipedia article Párhuzamos algoritmus","Wikipedia article on Algoritmo paralelo","Wikipedia article on Algoritmos paralelos","Wikipedia entry for Parallel algorithm","Wikipedia-Artikel Paralleler Algorithmus","Wikipedia-Seite zu 'Paralleler Algorithmus'","Wikipediaで「並列アルゴリズム」を調べる","a deep and difficult question","ain't easy","algoritmos en paralelo","algoritmos paralelos","arallel algorithm,","arallel algorithms","arallelizes better","artículo de Wikipedia Algoritmo paralelo","artículo de Wikipedia Algoritmos paralelos","concurrent algorithm","concurrent algorithms","en.wikipedia.org/wiki/Parallel_algorithm","en:Parallel algorithms","http://de.wikipedia.org/wiki/Paralleler_","http://de.wikipedia.org/wiki/Paralleler_Algorithmus","http://en.wikipedia.org/wiki/Parallel_al","http://en.wikipedia.org/wiki/Parallel_algorithm","http://en.wikipedia.org/wiki/Parallel_algorithms","http://en.wikipedia.org/wiki/Parallel_al…","http://es.wikipedia.org/wiki/Algoritmo_paralelo","http://es.wikipedia.org/wiki/Algoritmos_paralelos","http://hu.wikipedia.org/wiki/P%C3%A1rhuzamos_algoritmus","http://pl.wikipedia.org/wiki/Algorytm_r%C3%B3wnoleg","http://tinyurl.com/3ss2tb","juego en paralelo","lgoritmos paralelos","look up parallel algorithms in an encyclopedia","paralelizado","paralelização de algoritmos","parallel algorithm","parallel algorithm - Wikipedia, the free encyclopedia","parallel computer program","parallel computer programs","parallel_algorithm","parallele Algorithmen","parallelen Algorithmen","paralleler Algorithmen","parallelises better","parallelisierbare","parallelizes better","parallélisés","programas de ordenador paralelos","równoległymi","serial and parallel algorithms","w:Parallel algorithms","zrównoleglanie","Паралельний алгоритм — Вікіпедія","Параллельный алгоритм","Параллельный алгоритм — Википедия","новых технологий","параллелизма в программировании","параллельном программировании","الگوریتم مواØ²ی - ویکیپدیا","الگوریتم موازی","الگوریتم موازی - ویکیپدیا","جزء بندی","خوارزمية متوازية","طراحی ...","طراحی های ...","مشکلات ...","۱ طراحی الگوریتم های موازی","۲ مشکلات موجود در طراحی الگوریتم های موازی","۳ طراحی های علمی","۴ جزء بندی","۵ ارتباطات","۶ انباشتگی","۷ نقشه بندی","۸ پیوند ها","“Parallel algorithm - Wikipedia, the free encyclopedia”, en.wikipedia","並列アルゴリズム","並列アルゴリズム - Wikipedia","並列ｱﾙｺﾞﾘｽﾞﾑ-wikipedia","병렬 알고리즘"],"name":"Parallel algorithm","categories":["All articles needing additional references","All articles to be expanded","Articles needing additional references from November 2012","Articles to be expanded from February 2014","Concurrent algorithms","Distributed algorithms","Parallel computing"],"tag_line":"In computer science, a parallel algorithm, as opposed to a traditional serial algorithm, is an algorithm which can be executed a piece at a time on many different processing devices, and then combined together again at the end to get the correct result."}}
,{"_index":"throwtable","_type":"algorithm","_id":"prefix-sum","_score":0,"_source":{"description":"In computer science, the prefix sum, scan, or cumulative sum of a sequence of numbers x0, x1, x2, ... is a second sequence of numbers y0, y1, y2, ..., the sums of prefixes (running totals) of the input sequence:\ny0 = x0\ny1 = x0 + x1\ny2 = x0 + x1+ x2\n...\nFor instance, the prefix sums of the natural numbers are the triangular numbers:\n\nPrefix sums are trivial to compute in sequential models of computation, by using the formula yi = yi − 1 + xi to compute each output value in sequence order. However, despite their ease of computation, prefix sums are a useful primitive in certain algorithms such as counting sort, and they form the basis of the scan higher-order function in functional programming languages. When datasets are stored in Fenwick trees, prefix sums can be calculated in O(log) time. Prefix sums of large datasets can be computed in using Fenwick tree. Prefix sums have also been much studied in parallel algorithms, both as a test problem to be solved and as a useful primitive to be used as a subroutine in other parallel algorithms.\nAbstractly, a prefix sum requires only a binary associative operator ⊕, making it useful for many applications from calculating well-separated pair decompositions of points to string processing. \nMathematically, the operation of taking prefix sums can be generalized from finite to infinite sequences; in that context, a prefix sum is known as a partial sum of a series. Prefix summation or partial summation form linear operators on the vector spaces of finite or infinite sequences; their inverses are finite difference operators.","alt_names":["'scan'","- Prefix sum :","Parallel Prefix Sum","Parallel prefix sum @ wikipedia","Parallel prefix sum @ wikipedia.","Pr%C3%A4fixsumme bei der wikipedia","Prefix Sum","Prefix Sum on wikipedia","Prefix sum","Prefix sum - Wikipedia, the free encyclopedia","Prefix sum Wikipedia the free encyclopedia","Prefix sum Wikipedia the free encyclopedia - result","Prefix sum from Wikipedia","Prefix_sum","Präfixsumme","WWW: http://en.wikipedia.org/wiki/Prefix_sum","Wikipedia article Prefix sum","Wikipedia entry for Prefix sum","Wikipedia-Artikel Präfixsumme","en.wikipedia.org/wiki/Prefix_sum","http://de.wikipedia.org/wiki/Pr%C3%A4fixsumme","http://en.wikipedia....wiki/Prefix_sum","http://en.wikipedia.org/wiki/Prefix_sum","parallel prefix-sum","parallel sum prefix","parallel-prefix-sum","prefix scan algorithm","prefix sum","prefix sum.","prefix sums","wikipedia:Prefix_sum"],"name":"Prefix sum","categories":["CS1 Russian-language sources (ru)","CS1 errors: external links","CS1 uses Russian-language script (ru)","Concurrent algorithms","Higher-order functions"],"tag_line":"In computer science, the prefix sum, scan, or cumulative sum of a sequence of numbers x0, x1, x2, ... is a second sequence of numbers y0, y1, y2, ..., the sums of prefixes (running totals) of the input sequence:\ny0 = x0\ny1 = x0 + x1\ny2 = x0 + x1+ x2\n...\nFor instance, the prefix sums of the natural numbers are the triangular numbers:\n\nPrefix sums are trivial to compute in sequential models of computation, by using the formula yi = yi − 1 + xi to compute each output value in sequence order."}}
,{"_index":"throwtable","_type":"algorithm","_id":"shifting-nth-root-algorithm","_score":0,"_source":{"description":"The shifting nth root algorithm is an algorithm for extracting the nth root of a positive real number which proceeds iteratively by shifting in n digits of the radicand, starting with the most significant, and produces one digit of the root on each iteration, in a manner similar to long division.","alt_names":["http://de.wikipedia.org/wiki/Schriftlich…","Worteltrekken","( B y + β ) n ≤ B n x + α","- Shifting nth-root algorithm :","-> Read the article about 'Shifting nth root algorithm","...Wikipedia Algorithme de décalage n-racines","...mehr auf Wikipedia über Schriftliches Wurzelziehen","...more on Wikipedia about Shifting nth-root algorithm","Algorithme de décalage de racine n-ième","Algorithme de décalage n-racines","Hand Wuzeln Ziehen","Hiern Wiki Link","Learn about Shifting nth root algorithm>>>","Schriftliche Wurzelziehen","Schriftliches Radizieren - Wikipedia","Schriftliches Wurzelziehen","Schriftliches Wurzelziehen - Wikipedia","Schriftliches Wurzelziehen ? Wikipedia","Schriftliches Wurzelziehen bei WP","Schriftliches Wurzelziehen in der englischen Wikipedia","Schriftliches Wurzelziehen – Wikipedia","Schriftliches_Wurzelziehen","Shifting nth Root algorithm","Shifting nth root algorithm","Shifting nth root algorithm - Wikipedia","Shifting nth root algorithm - Wikipedia :: The free encyclopedia","Shifting nth root algorithm - Wikipedia, the free encyclopedia","Shifting nth root algorithm.","Shifting nth-root algorithm","Shifting nth-root algorithm - Wikipedia","Shifting nth-root algorithm - Wikipedia, the free encyclopedia","Shifting_nth-root_algorithm","So rechnet man das ;-)","What is algorithm of Shifting nth root algorithm","Wikipedia article Shifting nth-root algorithm","Wikipedia article Worteltrekken","Wikipedia article about Shifting nth-root algorithm","Wikipedia artikel Worteltrekken","Wikipedia entry for Shifting nth root algorithm","Wikipedia-Artikel Schriftliches Radizieren","Wikipedia-Artikel Schriftliches Wurzelziehen","Worteltrekken - Wikipedia","Wurzel 2 berechnen","de.wikipedia.org/wik...tliches_Wurzelziehen","de.wikipedia.org/wiki/Schriftliches_Wurzelziehen","de:Schriftliches Wurzelziehen","en.wikipedia.org/wiki/Shifting_nth-root_algorithm#Paper-and","en:Shifting nth root algorithm","fr:Algorithme de décalage n-racines","http//de.wikipedia.org/wiki/Schriftliches_Radizieren","http//de.wikipedia.org/wiki/Schriftliches_Wurzelziehen","http://de.wikipedia.org/wiki/Sc hriftliches_Wurzelziehen","http://de.wikipedia.org/wiki/Sc hriftliches_Wurzelziehen#Darste","http://de.wikipedia.org/wiki/Sc hriftliches_Wurzelziehen#Kubikw","http://de.wikipedia.org/wiki/Sc hriftliches_Wurzelziehen#Verfah","http://de.wikipedia.org/wiki/Sc hriftliches_Wurzelziehen#Vierte","http://de.wikipedia.org/wiki/Schriftliches_Radizieren","http://de.wikipedia.org/wiki/Schriftliches_Wurzelziehen","http://en.wikipedia....-root_algorithm","http://en.wikipedia.org/wiki/Shiftin...root_algorithm","http://en.wikipedia.org/wiki/Shifting_n ... _algorithm","http://en.wikipedia.org/wiki/Shifting_nt","http://en.wikipedia.org/wiki/Shifting_nth-root_algorithm","http://en.wikipedia.org/wiki/Shifting_nth_root_algor...","http://en.wikipedia.org/wiki/Shifting_nth_root_algorithm","http://en.wikipedia.org/wiki/Shifting_nt…","http://fr.wikipedia.org/wiki/Algorithme_de_d%C3%A9calage_n","http://nl.wikipedia.org/wiki/Worteltrekken","http://nl.wikipedia.org/wiki/Worteltrekken...g_worteltrekken","händisch","interested in this","nl:Worteltrekken","nth root algorithim","schriftliche wurzelziehen","schriftlichen Wurzelziehen","schriftliches Wurzelziehen","shifting nth-root algorithm","trekken van een wortel","wikipedia: handmatig worteltrekken","written evolution in the English Wikipedia"],"name":"Shifting nth root algorithm","categories":["All articles lacking sources","Articles lacking sources from May 2010","Computer arithmetic algorithms","Root-finding algorithms"],"tag_line":"The shifting nth root algorithm is an algorithm for extracting the nth root of a positive real number which proceeds iteratively by shifting in n digits of the radicand, starting with the most significant, and produces one digit of the root on each iteration, in a manner similar to long division."}}
,{"_index":"throwtable","_type":"algorithm","_id":"paxos-(computer-science)","_score":0,"_source":{"description":"Paxos is a family of protocols for solving consensus in a network of unreliable processors. Consensus is the process of agreeing on one result among a group of participants. This problem becomes difficult when the participants or their communication medium may experience failures.\nConsensus protocols are the basis for the state machine replication approach to distributed computing, as suggested by Leslie Lamport and surveyed by Fred B. Schneider. State machine replication is a technique for converting an algorithm into a fault-tolerant, distributed implementation. Ad-hoc techniques may leave important cases of failures unresolved. The principled approach proposed by Lamport et al. ensures all cases are handled safely.\nThe Paxos protocol was first published in 1989 and named after a fictional legislative consensus system used on the Paxos island in Greece. It was later published as a journal article in 1998.\nThe Paxos family of protocols includes a spectrum of trade-offs between the number of processors, number of message delays before learning the agreed value, the activity level of individual participants, number of messages sent, and types of failures. Although no deterministic fault-tolerant consensus protocol can guarantee progress in an asynchronous network (a result proven in a paper by Fischer, Lynch and Paterson), Paxos guarantees safety (consistency), and the conditions that could prevent it from making progress are difficult to provoke.\nPaxos is usually used where durability is required (for example, to replicate a file or a database), in which the amount of durable state could be large. The protocol attempts to make progress even during periods when some bounded number of replicas are unresponsive. There is also a mechanism to drop a permanently failed replica or to add a new replica.","alt_names":[],"name":"Paxos (computer science)","categories":["All articles with unsourced statements","Articles with unsourced statements from September 2009","Distributed algorithms","Fault-tolerant computer systems"],"tag_line":"Paxos is a family of protocols for solving consensus in a network of unreliable processors."}}
,{"_index":"throwtable","_type":"algorithm","_id":"edge-chasing","_score":0,"_source":{"description":"In computer science, edge-chasing is an algorithm for deadlock detection in distributed systems.\nWhenever a process A is blocked for some resource, a probe message is sent to all processes A may depend on. The probe message contains the process id of A along with the path that the message has followed through the distributed system. If a blocked process receives the probe it will update the path information and forward the probe to all the processes it depends on. Non-blocked processes may discard the probe.\nIf eventually the probe returns to process A, there is a circular waiting loop of blocked processes, and a deadlock is detected. Efficiently detecting such cycles in the “wait-for graph” of blocked processes is an important implementation problem.","alt_names":["-> Read more about Edge chasing","-> Read the article about 'Edge chasing'","Edge chasing","Edge chasing - Wikipedia, the free encyclopedia","Wikipedia article ''Edge chasing''","Wikipedia article Edge chasing","Wikipedia article on Edge chasing","Wikipedia entry for Edge chasing","edge chasing","http://en.wikipedia.org/wiki/Edge_chasin","http://en.wikipedia.org/wiki/Edge_chasing","yago-res:Edge chasing"],"name":"Edge chasing","categories":["All articles lacking sources","Articles lacking sources from December 2009","Distributed algorithms"],"tag_line":"In computer science, edge-chasing is an algorithm for deadlock detection in distributed systems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"snapshot-algorithm","_score":0,"_source":{"description":"The snapshot algorithm is an algorithm used in distributed systems for recording a consistent global state of an asynchronous system. The algorithm discussed here is also known as the Chandy–Lamport algorithm, after Leslie Lamport and K. Mani Chandy.","alt_names":["Schnappschussalgorithmus","- Snapshot algorithm :","-> Read more about Snapshot algorithm","-> Read the article about 'Snapshot algorithm'","...more on Wikipedia about Snapshot algorithm","Chady i Lamport","Chandy-Lamport Algorithm","Chandy-Lamport auf Wikipedia (en)","Chandy-Lamport-Algorithmus auf Wikipedia (de)","Learn about Snapshot algorithm>>>","Snapshot algorithm","Snapshot algorithm - Wikipedia :: The free encyclopedia","Snapshot algorithm - Wikipedia, the free encyclopedia","Snapshotalgorithmus","What is Snapshot algorithm","Wikipedia article Snapshot algorithm","Wikipedia entry for Snapshot algorithm","Wikipedia-Artikel Schnappschussalgorithmus","Wikipedia-Artikel Snapshotalgorithmus","Wikipedia-Seite zu 'Schnappschussalgorithmus'","[4] Snapshot algorithm","de.wikipedia.org/wiki/Schnappschussalgorithmus","en.wikipedia.org/wiki/Snapshot_algorithm","en:Snapshot algorithm","http://de.wikipedia.org/wiki/Schnappschussalgorithmus","http://de.wikipedia.org/wiki/Snapshotalgorithmus","http://en.wikipedia.org/wiki/Snapshot_al","http://en.wikipedia.org/wiki/Snapshot_algorithm","snapshot algorithm","stanu globalnego","wikipedia:Snapshot algorithm"],"name":"Snapshot algorithm","categories":["Distributed algorithms"],"tag_line":"The snapshot algorithm is an algorithm used in distributed systems for recording a consistent global state of an asynchronous system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ticket-lock","_score":0,"_source":{"description":"In computer science, a ticket lock is a synchronization mechanism, or locking algorithm, that is a type of spinlock that uses \"tickets\" to control which thread of execution is allowed to enter a critical section.\n\n","alt_names":["- Ticket lock :","Ticket lock","Ticket lock - Wikipedia :: The free encyclopedia","Ticket lock - Wikipedia, the free encyclopedia","What is the overview of Ticket lock","Wikipedia article ''Ticket lock''","Wikipedia article Ticket lock","Wikipedia article on Ticket lock","en.wikipedia.org/Ticket_lock","en.wikipedia.org/wiki/Ticket_lock","http://en.wikipedia.org/wiki/Ticket_lock","ticket lock"],"name":"Ticket lock","categories":["All articles containing potentially dated statements","Articles containing potentially dated statements from July 2010","Concurrency control algorithms","Pages using citations with accessdate and no URL"],"tag_line":"In computer science, a ticket lock is a synchronization mechanism, or locking algorithm, that is a type of spinlock that uses \"tickets\" to control which thread of execution is allowed to enter a critical section.\n\n"}}
,{"_index":"throwtable","_type":"algorithm","_id":"modular-exponentiation","_score":0,"_source":{"description":"Modular exponentiation is a type of exponentiation performed over a modulus. It is useful in computer science, especially in the field of public-key cryptography.\nThe operation of modular exponentiation calculates the remainder when an integer b (the base) raised to the eth power (the exponent), be, is divided by a positive integer m (the modulus). In symbols, given base b, exponent e, and modulus m, the modular exponentiation c is: c ≡ be (mod m).\nFor example, given b = 5, e = 3 and m = 13, the solution c = 8 is the remainder of dividing 53 = 125 by 13.\nGiven integers b and e, and a positive integer m, a unique solution c exists with the property 0 ≤ c < m.\nModular exponentiation can be performed with a negative exponent e by finding the modular multiplicative inverse d of b modulo m using the extended Euclidean algorithm. That is:\n where e < 0 and \nModular exponentiation similar to the one described above are considered easy to compute, even when the numbers involved are enormous. On the other hand, computing the discrete logarithm – that is, the task of finding the exponent e when given b, c, and m – is believed to be difficult. This one-way function behavior makes modular exponentiation a candidate for use in cryptographic algorithms.","alt_names":["- Modular exponentiation :","-> Read more about Modular exponentiation","...Wikipedia Exponentiation modulaire","...mehr auf Wikipedia über Diskrete Exponentialfunktion","...more on Wikipedia about Modular exponentiation","4. More on modular arithmetic with negative exponents","4f96ca0f45e17cc1a89889e42f04f7 ...","An efficient method: the right-to-left binary","Diskrete Exponentialfunktion","Diskrete Exponentialfunktion - Wikipedia","Diskrete Exponentialfunktion in","Diskrete Exponentialfunktion – Wikipedia","Diskrete_Exponentialfunktion","Eksponen modular","Elevamento a potenza modulare","Exponenciació modular","Exponenciació modular - Viqu...","Exponenciación modular","Exponenciação modular","Exponentiation Modular","Exponentiation modulaire","Exponentiation modulaire (fr)","Exponentiation modulaire - W...","Exponentiation modulaire - Wikipedia","Exponentiation modulaire - Wikipédia","L'exponentiation modulaire","Lũy thừa kiểu mô-đun","Memory-efficient method","Modulaire machtsverheffing","Modular Exponentiation","Modular Exponentiation - Wikipedia, The Free Encyclopedia","Modular Exponentiation - Wikipedia, the free encyclopedia","Modular Exponentiation:","Modular Lũy thừa","Modular exponentation","Modular exponentiation","Modular exponentiation (en)","Modular exponentiation - Wikipedia","Modular exponentiation - Wikipedia, the free encyclopedia","Modular exponentiation Wikipedia the free encyclopedia","Modular exponentiation – Wikipedia, the free encyclopedia","Modular exponentiation; it is used under the","Modular_exponentiation","Modulare Exponentiation","Modulare_Exponentiation","Modulare_Exponentiation bei der wikipedia","Module Exponentiation","Moduláris hatványozás","Montgomery Modular Exponentiation","RSA暗号プログラム","Right - to - left binary method","Right-To-Left Binary Method","Right-to-left Binary Method","Right-to-left binary ...","Right-to-left binary method","Source Wikipedia.org Arcticle - Modular exponentiation","Straightforward method","Wiki: Modular exponentiation","Wikipedia : べき剰余","Wikipedia article Modular exponentiation","Wikipedia article about Modular exponentiation","Wikipedia article on Modular exponentiation","Wikipedia entry for Modular exponentiation","Wikipedia 冪剰余","Wikipedia, Modular exponentiation","Wikipedia-Artikel Diskrete Exponentialfunktion","Wikipedia-Artikel Modulare Exponentiation","Wikipedia-Seite zu 'Diskrete Exponentialfunktion'","Wikipedia: Diskrete Exponentialfunktion","Wikipedia: Modular exponentiation","Wikipedia: Right-to-left binary method","Wikipedia:modular exponentiation","Wikipediaで「べき剰余」を調べる","Wikipediaで「冪剰余」を調べる","a exponenciação modular","bináris hatványozás","c ≡ b e ( mod m )","ca:Exponenciació modular","da destra a sinistra metodo binario","de derecha a izquierda método binario","de:Diskrete Exponentialfunktion","direita para a esquerda método binário","direito de método binário esquerdo","diritto di metodo binario sinistro","diskrete (oder binäre) Exponentation","diskrete Exponentialfunktion","diskrete Exponentialfunktionen","do that faster","droit de méthode binaire gauche","efficient method of doing large modular exponentiation.","ehttp://en.wikipedia.org/wiki/Modular_exponentiation","elevamento a potenza modulare","en.wikipedia.org/wiki/Modular_exponentiation","exponenciació modular","exponenciación modular","exponenciação modular","exponenciação modular,","exponentiation modulaire","exponentiation modular","exponentiation modulo n","exponentiation 모듈을","exponents modulo","exponenţiere modular","fast modular exponentiation","fast modular exponentiation method","fr:Exponentiation modulaire","geldt het volgende","http://de.wikipedia.org/wiki/Diskret...entialfunktion","http://de.wikipedia.org/wiki/Diskrete_Ex","http://de.wikipedia.org/wiki/Diskrete_Exponentialfunktion","http://de.wikipedia.org/wiki/Modulare_Exponentiation","http://en.Liarpedia.org/wiki/Modular_exponentiation","http://en.wikipedia...._exponentiation","http://en.wikipedia.org/wiki/Modular exponentiation","http://en.wikipedia.org/wiki/Modular%5Fexponentiation#Right","http://en.wikipedia.org/wiki/Modular...nary_Algorithm","http://en.wikipedia.org/wiki/Modular\\_exponentiation","http://en.wikipedia.org/wiki/Modular_ex ... _Algorithm","http://en.wikipedia.org/wiki/Modular_ex ... ary_method","http://en.wikipedia.org/wiki/Modular_ex … ary_method","http://en.wikipedia.org/wiki/Modular_exp","http://en.wikipedia.org/wiki/Modular_exp...","http://en.wikipedia.org/wiki/Modular_expon...inary_algorithm","http://en.wikipedia.org/wiki/Modular_exponent","http://en.wikipedia.org/wiki/Modular_exponent...","http://en.wikipedia.org/wiki/Modular_exponentiation","http://en.wikipedia.org/wiki/Modular_exponentiation#An_efficient_method:_the_Right_to_Left_Binary_Algorithm","http://en.wikipedia.org/wiki/Modular_exponentiation#An_efficient_method:_the_right","http://en.wikipedia.org/wiki/Modular_exponentiation#Memory-efficient_method","http://en.wikipedia.org/wiki/Modular_exponentiation#Right-to","http://en.wikipedia.org/wiki/Modular_exp…","http://en.wikipedia.org/wiki/Modular_exp…t_binary_method","http://fr.wikipedia.org/wiki/Exponentiation_modulaire","implemented efficiently","ja:べき剰余","ja:冪剰余","l'article de Wikipédia Exponentiation modulaire","l'elevamento a potenza modulare","l'exponentiation modulaire,","la exponenciación modular","lũy thừa kiểu mô-đun","modulair machtsverheffen","modulaire machtsverheffing","modular exponentation","modular exponentiation","modular exponentiation wikipedia the free encyclopedia","modular exponentiation.","modular exponentiations","modular-exponentiation","modulare Exponentiation","modulare Potenzierung","modularen Exponentiation","modularnim potenciranjem","modulární umocňování","modulære eksponentiation","modułowe potęgowanie","modułowych potęgowanie","modüler üs alma","much faster algorithm","negative modular exponent","page on modular exponentiation","potència modular","powermod function","rechts nach links binären Methode","right-to-left binary method","una página dedicada a la exponenciación modular","van rechts naar links binaire methode","von rechts nach links binary-Methode","wiki - Modular exponentialiation","wikipedia - modular exp","wikipedia:冪剰余","yago-res:Modular exponentiation","zu sehen hier!","Модульное возведение в степень","алгоритм побыстрее","возведение модульных","модульного возведения в степень","модульного возведения в степень,","модульное возведение в степень","модульной возведение в степень","модульный возведения","справа налево бинарный метод","справа налево метод двоичного","ยกกำลัง modular","とても素早く","べ ​​き乗剰余","べき乗剰余","べき乗剰余演算を","べき剰余","べき剰余 - Wikipedia","ウィキペディアの記事 冪剰余","メソッドのバイナリ左から右へ","モジュラー指数","モジュール式のべき乗","从右到左的二进制方法","冪剰余","冪剰余 - Wikipedia","冪剰余-wikipedia","冪剰余（Wikipedia）","右至左的二进制方法","左バイナリ法の権利","模冪","模块化的求幂","模幂","模指数","模指数运算","模指數運算","모듈식 지수","모듈형 exponentiation","모듈화 exponentiation","﻿modular functions﻿"],"name":"Modular exponentiation","categories":["Cryptographic algorithms","Modular arithmetic","Number theoretic algorithms"],"tag_line":"Modular exponentiation is a type of exponentiation performed over a modulus."}}
,{"_index":"throwtable","_type":"algorithm","_id":"substitution-permutation-network","_score":0,"_source":{"description":"In cryptography, an SP-network, or substitution-permutation network (SPN), is a series of linked mathematical operations used in block cipher algorithms such as AES (Rijndael). Other ciphers that use SPNs are 3-Way, SAFER, SHARK, and Square.\nSuch a network takes a block of the plaintext and the key as inputs, and applies several alternating \"rounds\" or \"layers\" of substitution boxes (S-boxes) and permutation boxes (P-boxes) to produce the ciphertext block. The S-boxes and P-boxes transform (sub-)blocks of input bits into output bits. It is common for these transformations to be operations that are efficient to perform in hardware, such as exclusive or (XOR) and bitwise rotation. The key is introduced in each round, usually in the form of \"round keys\" derived from it. (In some designs, the S-boxes themselves depend on the key.)\nDecryption is done by simply reversing the process (using the inverses of the S-boxes and P-boxes and applying the round keys in reversed order).\nAn S-box substitutes a small block of bits (the input of the S-box) by another block of bits (the output of the S-box). This substitution should be one-to-one, to ensure invertibility (hence decryption). In particular, the length of the output should be the same as the length of the input (the picture on the right has S-boxes with 4 input and 4 output bits), which is different from S-boxes in general that could also change the length, as in DES (Data Encryption Standard), for example. An S-box is usually not simply a permutation of the bits. Rather, a good S-box will have the property that changing one input bit will change about half of the output bits (or an avalanche effect). It will also have the property that each output bit will depend on every input bit.\nA P-box is a permutation of all the bits: it takes the outputs of all the S-boxes of one round, permutes the bits, and feeds them into the S-boxes of the next round. A good P-box has the property that the output bits of any S-box are distributed to as many S-box inputs as possible.\nAt each round, the round key (obtained from the key with some simple operations, for instance, using S-boxes and P-boxes) is combined using some group operation, typically XOR.\nA single typical S-box or a single P-box alone does not have much cryptographic strength: an S-box could be thought of as a substitution cipher, while a P-box could be thought of as a transposition cipher. However, a well-designed SP network with several alternating rounds of S- and P-boxes already satisfies Shannon's confusion and diffusion properties:\nThe reason for diffusion is the following: If one changes one bit of the plaintext, then it is fed into an S-box, whose output will change at several bits, then all these changes are distributed by the P-box among several S-boxes, hence the outputs of all of these S-boxes are again changed at several bits, and so on. Doing several rounds, each bit changes several times back and forth, therefore, by the end, the ciphertext has changed completely, in a pseudorandom manner. In particular, for a randomly chosen input block, if one flips the i-th bit, then the probability that the j-th output bit will change is approximately a half, for any i and j, which is the Strict Avalanche Criterion. Vice versa, if one changes one bit of the ciphertext, then attempts to decrypt it, the result is a message completely different from the original plaintext -- SP ciphers are not easily malleable.\nThe reason for confusion is exactly the same as for diffusion: changing one bit of the key changes several of the round keys, and every change in every round key diffuses over all the bits, changing the ciphertext in a very complex manner.\nEven if an attacker somehow obtains one plaintext corresponding to one ciphertext -- a known-plaintext attack, or worse, a chosen plaintext or chosen-ciphertext attack -- the confusion and diffusion make it difficult for the attacker to recover the key.\nAlthough a Feistel network that uses S-boxes (such as DES) is quite similar to SP networks, there are some differences that make either this or that more applicable in certain situations. For a given amount of confusion and diffusion, an SP network has more \"inherent parallelism\" and so — given a CPU with a large number of execution units — can be computed faster than a Feistel network.  CPUs with few execution units — such as most smart cards — cannot take advantage of this inherent parallelism. Also SP ciphers require S-boxes to be invertible (to perform decryption); Feistel inner functions have no such restriction and can be constructed as one-way functions.\n\n","alt_names":["Substitution-permutation network - Wikipedia, the free encyclopedia","SP-network","substitution-permutation network","...Wikipedia Rete a sostituzione e permutazione","...Wikipedia Réseau de substitution-permutation","...Wikipedia Substitutions-permutationskrypto","...more on Wikipedia about Substitution-permutation network","Rete a sostituzione e permutazione","Réseau de substitution permutation","Réseau de substitution-permutation - Wikipédia","Réseaux de subtitution/permutation","S and P blocks","SP-networks","SP-nät","SP-сеть","SP-сеть — Википедия","SP-сетями","SPN構造","SPN構造 - Wikipedia","SPN構造-wikipedia","See http://en.wikipedia.org/wiki/Substitution-permutation_network","Substitusjon/permutasjon-chiffer","Substitusjon/permutasjon-chiffer - Wikipedia","Substitution Permutation Network","Substitution permutation network","Substitution-Permutation Network","Substitution-permutation network","Substitution-permutation network - Simple English Wikipedia, the","Substitution-permutation network - Wikipedia, the free ...","Substitution-permutation network - Wikipedia, the free encyclopedia ...","Substitution-permutation network by Wikipedia","Substitution-permutation network from Wikipedia","Substitution-permutation networks","Substitution-permutation_network","Substitutions-Permutations-Netzwerk","Wikipedia (Substitution-permutation network)","Wikipedia article SP-network","Wikipedia article on Substitution-permutation network","Wikipedia entry for Substitution-permutation network","Wikipedia sur Réseau de substitution-permutation","Wikipedia:Rete_a_sostituzione_e_permutazione","Wikipediaで「SPN構造」を調べる","en.wikipedia.org/wiki/Substitution-permutation_network","feistel chiffer","http://en.wikipedia.org/wiki/SP-network","http://en.wikipedia.org/wiki/Substituti ... on_network","http://en.wikipedia.org/wiki/Substitution-permutat ...","http://en.wikipedia.org/wiki/Substitution-permutation_network","http://ja.wikipedia.org/wiki/SPN%E6%A7","http://sv.wikipedia.org/wiki/Substitutions-permutationskrypto","ja:SPN構造","l'article de Wikipédia SPN","no:Substitusjon/permutasjon-chiffer","rete a sostituzione e permutazione","ru:SP-сеть","réseaux de substitution-permutation","simple.wikipedia.org/wiki/Substitution-permutation_network","simple:Substitution-permutation network","stitution-permutation","substitution permutation","substitution permutation network","substitution permutation network.","substitution-permutation network,","substitution-permutation networks","substitūciju-permutāciju","sv:Substitutions-permutationskrypto","Википедии статью SP-сеть","подстановочно-перестановочная сеть","подстановочно-перестановочной сети","ウィキペディアの記事 SPN構造","置换-组合架构","置换-组合架構","置換-組合架構","置換-組合架構，而"],"name":"Substitution-permutation network","categories":["Block ciphers","Cryptographic algorithms","Permutations"],"tag_line":"In cryptography, an SP-network, or substitution-permutation network (SPN), is a series of linked mathematical operations used in block cipher algorithms such as AES (Rijndael)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"time-based-one-time-password-algorithm","_score":0,"_source":{"description":"Time-based One-time Password Algorithm (TOTP) is an algorithm that computes a one-time password from a shared secret key and the current time. It has been adopted as Internet Engineering Task Force standard RFC 6238, is the cornerstone of Initiative For Open Authentication (OATH), and is used in a number of two factor authentication systems.\nTOTP is an example of a hash-based message authentication code (HMAC). It combines a secret key with the current timestamp using a cryptographic hash function to generate a one-time password. The timestamp typically increases in 30-second intervals, so passwords generated close together in time from the same secret key will be equal.\nIn a typical two-factor authentication application, user authentication proceeds as follows: a user will enter username and password into a website or other server, generate a one-time password for the server using TOTP running locally on a smartphone or other device, and type that password into the server as well. The server will then also run TOTP to verify the entered one-time password. For this to work, the clocks of the user's device and the server need to be roughly synchronized (the server will typically accept one-time passwords generated from timestamps that differ by ±1 from the client's timestamp). A single secret key, to be used for all subsequent authentication sessions, must have been shared between the server and the user's device over a secure channel ahead of time. If some more steps are carried out, the user can also authenticate the server using TOTP.","alt_names":["TOTP - Time-based One-time Password Algorithm","TOTP token","TOTP wiki","TOTP(Time-based One Time Password)","Time-based One-time Password Algorithm","Time-based One-time Password Algorithm - Wikipedia, the","Time-based One-time Password Algorithmes","What is the history of TOTP - Time-based","http://en.wikipedia.org/wiki/TOTP_-_Time-base","http://en.wikipedia.org/wiki/TOTP_-_Time-based_One","http://en.wikipedia.org/wiki/Time-ba...word_Algorithm","http://en.wikipedia.org/wiki/Time-based ... _Algorithm","http://en.wikipedia.org/wiki/Time-based_One-time_Password_Al","http://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm","yago-res:Time-based One-time Password Algorithm"],"name":"Time-based One-time Password Algorithm","categories":["All pages needing cleanup","Articles needing cleanup from April 2014","Computer access control","Cryptographic algorithms","Internet protocols","Wikipedia list cleanup from April 2014"],"tag_line":"Time-based One-time Password Algorithm (TOTP) is an algorithm that computes a one-time password from a shared secret key and the current time."}}
,{"_index":"throwtable","_type":"algorithm","_id":"generating-primes","_score":0,"_source":{"description":"In computational number theory, a variety of algorithms make it possible to generate prime numbers efficiently. These are used in various applications, for example hashing, public-key cryptography, and search of prime factors in large numbers.\nFor relatively small numbers, it is possible to just apply trial division to each successive odd number. Prime sieves are almost always faster.","alt_names":["...more on Wikipedia about Prime sieve","Generating Primes","Generating primes","Generating primes - Wikipedia :: The free encyclopedia","Generating primes - Wikipedia, the free encyclopedia","Generating primes; it is used under the","Here's something to start your learning about the","Prime number sieve","Prime sieve","Prime sieves","Primzahlsieb","Wikipedia article Generating primes","Wikipedia article Prime number sieve","Wikipedia article Prime sieve","Wikipedia entry for Generating primes","different strategies","en.wikipedia.org/wiki/Generating_primes#Prime_sieves","generate primes","http://en.wikipedia.org/wiki/Generating_primes","http://en.wikipedia.org/wiki/Generating_primes#Large_primes","http://en.wikipedia.org/wiki/Prime_sieve","other sieves","peneira prime.","perdana saringan.","prime Sieb.","prime number sieve.","prime number sieves","prime sieves","secur!ty","setaccio prime.","sieving technique","standard methods for generating large primes","sàng số nguyên tố.","tamis Premier.","tamiz prime.","Википедии статью Случайное простое число","Премьер-сит.","Случайное простое число","Случайное простое число — Википедия","зачем нужны длинные простые числа","случайное простое число","случайным простым числом","случайных простых чисел","случайных простых числа","এই উইকিপেজ টা","กระชอน สำคัญ.","的主要筛","的主要篩","首相ふるい","총리 쪽에서"],"name":"Generating primes","categories":["Cryptographic algorithms","Number theoretic algorithms","Prime numbers"],"tag_line":"In computational number theory, a variety of algorithms make it possible to generate prime numbers efficiently."}}
,{"_index":"throwtable","_type":"algorithm","_id":"crypto++","_score":0,"_source":{"description":"Crypto++ (also known as CryptoPP, libcrypto++, and libcryptopp) is a free and open source C++ class library of cryptographic algorithms and schemes written by Wei Dai. Crypto++ has been widely used in academia, student projects, open source and non-commercial projects, as well as businesses. Released in 1995, the library fully supports 32-bit and 64-bit architectures for many major operating systems and platforms, including Android (using STLport), Apple (Mac OS X and iOS), BSD, Cygwin, IBM AIX and S/390, Linux, MinGW, Solaris, Windows, Windows Phone and Windows RT. The project also supports compilation under C++03 and C++11, a variety of compilers and IDEs, including Borland Turbo C++, Borland C++ Builder, Clang, CodeWarrior Pro, GCC (including Apple's GCC), Intel C++ Compiler (ICC), Microsoft Visual C/C++, and Sun Studio.\n\n","alt_names":["Crypto++ - Wikipedia, the free encyclopedia","Crypto++#Performance","crypto++ - Wikipedia, the free encyclopedia","en.wikipedia.org/wiki/Crypto%2B%2B","http://en.Liarpedia.org/wiki/Crypto%2B%2B","http://en.wikipedia.org/wiki/Crypto%2B%2B","yago-res:Crypto++"],"name":"Crypto++","categories":["All pages needing cleanup","Articles needing cleanup from November 2015","Articles with attributed pull quotes","Articles with sections that need to be turned into prose from November 2015","C++ libraries","Cryptographic algorithms","Cryptographic software","Free computer libraries","Pages using citations with accessdate and no URL","Pages using web citations with no URL"],"tag_line":"Crypto++ (also known as CryptoPP, libcrypto++, and libcryptopp) is a free and open source C++ class library of cryptographic algorithms and schemes written by Wei Dai."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pollard's-p-−-1-algorithm","_score":0,"_source":{"description":"Pollard's p − 1 algorithm is a number theoretic integer factorization algorithm, invented by John Pollard in 1974. It is a special-purpose algorithm, meaning that it is only suitable for integers with specific types of factors; it is the simplest example of an algebraic-group factorisation algorithm.\nThe factors it finds are ones for which the number preceding the factor, p − 1, is powersmooth; the essential observation is that, by working in the multiplicative group modulo a composite number N, we are also working in the multiplicative groups modulo all of N's factors.\nThe existence of this algorithm leads to the concept of safe primes, being primes for which p − 1 is two times a Sophie Germain prime q and thus minimally smooth. These primes are sometimes construed as \"safe for cryptographic purposes\", but they might be unsafe — in current recommendations for cryptographic strong primes (e.g. ANSI X9.31), it is necessary but not sufficient that p − 1 has at least one large prime factor. Most sufficiently large primes are strong; if a prime used for cryptographic purposes turns out to be non-strong, it is much more likely to be through malice than through an accident of random number generation. This terminology is considered obsolete by the cryptography industry. [1]","alt_names":[],"name":"Pollard's p − 1 algorithm","categories":["Integer factorization algorithms"],"tag_line":"Pollard's p − 1 algorithm is a number theoretic integer factorization algorithm, invented by John Pollard in 1974."}}
,{"_index":"throwtable","_type":"algorithm","_id":"supersingular-isogeny-key-exchange","_score":0,"_source":{"description":"Supersingular isogeny Diffie–Hellman key exchange (SIDH) is a post-quantum public key cryptographic algorithm used to establish a secret key between two parties over an otherwise insecure communications channel. It was designed to resist cryptanalytic attack by an adversary in possession of a quantum computer. Because the SIDH has key sizes, computations and forward security protection similar to that of the widely supported elliptic curve Diffie–Hellman key exchange it is a natural candidate to replace Diffie-Hellman and elliptic curve Diffie-Hellman in the face of a growing quantum computer threat.\n\n","alt_names":[],"name":"Supersingular isogeny key exchange","categories":["Cryptographic algorithms"],"tag_line":"Supersingular isogeny Diffie–Hellman key exchange (SIDH) is a post-quantum public key cryptographic algorithm used to establish a secret key between two parties over an otherwise insecure communications channel."}}
,{"_index":"throwtable","_type":"algorithm","_id":"securelog","_score":0,"_source":{"description":"In cryptology, SecureLog is an algorithm used to convert digital data into trusted data that can be verified if the authencity is questioned. SecureLog is used in IT solutions that generates data to support compliance regulations like SOX.\n\n","alt_names":["SecureLog","SecureLog - Wikipedia, the free encyclopedia","What is the operation of SecureLog","Wikipedia article SecureLog","Wikipedia entry for SecureLog","http://en.wikipedia.org/wiki/SecureLog","yago-res:SecureLog"],"name":"SecureLog","categories":["All orphaned articles","Cryptographic algorithms","Orphaned articles from October 2013"],"tag_line":"In cryptology, SecureLog is an algorithm used to convert digital data into trusted data that can be verified if the authencity is questioned."}}
,{"_index":"throwtable","_type":"algorithm","_id":"nsa-product-types","_score":0,"_source":{"description":"Product types refers to nomenclature that has been used by the U.S. National Security Agency (NSA) to rank cryptographic products or algorithms by level of certification. The terminology is defined in the National Information Assurance Glossary (CNSSI No. 4009) which defines Type 1, Type 2, products and Type 3, and Type 4 algorithms.","alt_names":[],"name":"NSA product types","categories":["All stub articles","Cryptographic algorithms","Cryptography stubs","National Security Agency encryption devices","Type 1 encryption algorithms"],"tag_line":"Product types refers to nomenclature that has been used by the U.S. National Security Agency (NSA) to rank cryptographic products or algorithms by level of certification."}}
,{"_index":"throwtable","_type":"algorithm","_id":"quadratic-sieve","_score":0,"_source":{"description":"The quadratic sieve algorithm (QS) is an integer factorization algorithm and, in practice, the second fastest method known (after the general number field sieve). It is still the fastest for integers under 100 decimal digits or so, and is considerably simpler than the number field sieve. It is a general-purpose factorization algorithm, meaning that its running time depends solely on the size of the integer to be factored, and not on special structure or properties. It was invented by Carl Pomerance in 1981 as an improvement to Schroeppel's linear sieve.\n^ Carl Pomerance, Analysis and Comparison of Some Integer Factoring Algorithms, in Computational Methods in Number Theory, Part I, H.W. Lenstra, Jr. and R. Tijdeman, eds., Math. Centre Tract 154, Amsterdam, 1982, pp 89-139.","alt_names":["- MPQS :","- Quadratic sieve :","-> Read more about Quadratic sieve","...Wikipedia Crible quadratique","...mehr auf Wikipedia über Quadratisches Sieb","...more on Wikipedia about Quadratic sieve","2 次ふるい","Crible quadratique","Crible quadratique - Wikipédia","Crivello quadratico","How QS optimizes finding congruences","Kvadratikus Szitát","Kwadratische zeef","Kwadratische zeef - Wikipedia","MPQS","Multiple Polynomial Quadratic Sieve","Neliöseula","O e log n log log n = L","Quadratic Number Sieve","Quadratic Sieve","Quadratic Sieve - Wikipedia, The Free Encyclopedia","Quadratic Sieve @ Wikipedia","Quadratic Sieve algorithm","Quadratic Sieve; it is used under the","Quadratic sieve","Quadratic sieve (QS)","Quadratic sieve - Wikipedia, the free encyclopedia","Quadratic sieve Wikipedia the free encyclopedia","Quadratic sieve – Wikipedia, the free encyclopedia","Quadratic sieve; it is used under the","Quadratic छलनी","Quadratic_sieve","Quadratische Sieb","Quadratischen Sieb","Quadratischen Siebs","Quadratisches Sieb","Quadratisches Sieb – Wikipedia","Quadratisches_Sieb","Sito kwadratowe","Sito kwadratowe – Wikipedia, wolna encyklopedia","What are implementations of Multiple Polynomial Quadratic Sieve","Wikipedia article Quadratic Sieve","Wikipedia article Quadratic sieve","Wikipedia article about MPQS","Wikipedia article on MPQS","Wikipedia article on Quadratic Sieve","Wikipedia article on Quadratic sieve","Wikipedia article נפה ריבועית","Wikipedia entry for Quadratic sieve","Wikipedia's Quadratic Sieve page","Wikipedia-Artikel Quadratisches Sieb","Wikipedia-Seite zu 'Quadratisches Sieb'","Wikipedia:Quadratic sieve","a 2007 algorithm","a65d9686eef83e953e96c61cfcd087 ...","c9bc1ce7fff972cae2532476990e ...","cc638723aa7066d69ce91490fd536d ...","criba cuadrática","crible quadratique","crivello quadratico","de.wikipedia.org/wiki/Quadratisches_Sieb#Siebschritt","de:Quadratisches Sieb","e) square Sieve","ec09b0d8e325960d76f1ceffb16d8d ...","en.wikipedia.org/...Quadratic_sieve","en.wikipedia.org/wiki/Quadratic_sieve","fastest algorithm with a rigorous costing","fi:Neliöseula","fr:Crible quadratique","he:נפה ריבועית","http://de.wikipedia.org/wiki/Quad... sches_Sieb","http://de.wikipedia.org/wiki/Quadratisches_Sieb","http://en.wikipedia....Quadratic_sieve","http://en.wikipedia.org/wiki/Quadrat...ess_by_sieving","http://en.wikipedia.org/wiki/Quadrat...of_basic_sieve","http://en.wikipedia.org/wiki/Quadratic_Sieve","http://en.wikipedia.org/wiki/Quadratic_s","http://en.wikipedia.org/wiki/Quadratic_sieve","http://en.wikipedia.org/wiki/Quadratic_sieve#Parameters_from_realistic_example","http://en.wikipedia.org/wiki/Quadratic_s…","http://fr.wikipedia.org/wiki/Crible_quadratique","http://it.wikipedia.org/wiki/Crivello_quadratico","http://nl.wikipedia.org/wiki/Kwadratische_zeef","http://pl.wikipedia.org/wiki/Sito_kwadratowe","http://ru.wikipedia.org/wiki/Метод_квадратичного_решета","i) Quadratisches Sieb","it:Crivello quadratico","ko:이차 체","kwadratische zeef","multiple polynomial quadratic sieve","nl:Kwadratische zeef","pl:Sito kwadratowe","quadratic field sieve","quadratic sieve","quadratischen Siebs","quadratisches Sieb","ru:Метод квадратичного решета","sito kwadratowe","the multiple-polynomial quadratic sieve algorithm","the self-initializing quadratic sieve","wikipedia of Quadratic sieve","Квадратичного Решета","Метод квадратичного решета","квадратично сито","הנפה הריבועית","ויקיפדיה - 'נפה ריבועית'","נפה ריבועית","נפה ריבועית – ויקיפדיה","二次ふるい","二次筛选","因數分解演算法"],"name":"Quadratic sieve","categories":["Integer factorization algorithms"],"tag_line":"The quadratic sieve algorithm (QS) is an integer factorization algorithm and, in practice, the second fastest method known (after the general number field sieve)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"trial-division","_score":0,"_source":{"description":"Trial division is the most laborious but easiest to understand of the integer factorization algorithms. The essential idea behind trial division tests to see if an integer n, the integer to be factored, can be divided by each number in turn that is less than n. For example, for the integer n = 12, the only numbers that divide it are 1,2,3,4,6,12. Selecting only the largest powers of primes in this list gives that 12 = 3 × 4.","alt_names":["Trial Division","trial division","...Wikipedia Divisions successives","...mehr auf Wikipedia über Probedivision","...more on Wikipedia about Trial division","<http://de.wikipedia.org/wiki/Probedivision>","Divisions successives","Divisions successives - Wikipedia","Divisions successives - Wikipédia","Divisions successives - Wikipédia http://fr.wikipedia.org/wiki","División por tentativa","División por tentativa - Wikipedia, la enciclopedia libre","Ein nützlicher Beitrag wäre dieser.","Factorització per prova de divisions","Factorització per prova de divisions - Viquipèdia","Probedivision","Probedivision ? Wikipedia","Probedivision – Wikipedia","Probedivisionen","Trial Division - Wikipedia, The Free Encyclopedia","Trial Factoring","Trial division","Trial division - Wikipedia, the free encyclopedia","Trial divisor","Trial_division","What is method of Trial division","What is method of Trial division?","Wikipedia article ''Trial division''","Wikipedia article Trial division","Wikipedia article Trial divisor","Wikipedia article on Trial division","Wikipedia entry for Trial division","Wikipedia-Artikel Probedivision","Wikipedia-Artikel Unvollständige Probedivision","Wikipedia-Seite zu 'Probedivision'","Wikipedia: Trial division","a) Trial Division","artículo de Wikipedia Division por tentativa","artículo de Wikipedia División por tentativa","ca:Factorització per prova de divisions","de:Probedivision","divisiones sucesivas","división por tentativa","elementaren Algorithmus","en.wikipedia.org/wiki/Trial_division","es:División por tentativa","fa:امتحان تقسیم","http://de.wikipedia.org/wiki/Probedivisi","http://de.wikipedia.org/wiki/Probedivision","http://de.wikipedia.org/wiki/Probedivisi…","http://de.wikipedia.org/wiki/Unvollst%C3%A4ndige_Probedivision","http://en.Liarpedia.org/wiki/Trial_division","http://en.wikipedia.org/wiki/Trial division","http://en.wikipedia.org/wiki/Trial_divis","http://en.wikipedia.org/wiki/Trial_division","http://en.wikipedia.org/wiki/Trial_divis…","http://en.wikipedia.org/wikiTrial_division","http://es.wikipedia.org/wiki/Divisi%C3%B3n_por_tentativa","http://fr.wikipedia.org/wiki/Divisions_successives","http://ru.wikipedia.org/wiki/Перебор_дел...","http://ru.wikipedia.org/wiki/Перебор_делителей","método de divisiones sucesivas","ru:Перебор делителей","sous la racine carrée du nombre","trial division algorithm","trial divisions","trial divisor","w:Перебор делителей","Википедии статью Перебор делителей","Перебор делителей","перебор делителей","перебора делителей","עד השורש","امتحان تقسیم","維基百科的文章“ 試除法”","維基百科的文章“ 试除法”","試除法","试除法","试除法- 维基百科，自由的百科全书"],"name":"Trial division","categories":["All articles lacking in-text citations","Articles lacking in-text citations from March 2014","Articles with example Python code","Division (mathematics)","Integer factorization algorithms"],"tag_line":"Trial division is the most laborious but easiest to understand of the integer factorization algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"canopy-clustering-algorithm","_score":0,"_source":{"description":"The canopy clustering algorithm is an unsupervised pre-clustering algorithm introduced by Andrew McCallum, Kamal Nigam and Lyle Ungar in 2000. It is often used as preprocessing step for the K-means algorithm or the Hierarchical clustering algorithm. It is intended to speed up clustering operations on large data sets, where using another algorithm directly may be impractical due to the size of the data set.\nThe algorithm proceeds as follows, using two thresholds  (the loose distance) and  (the tight distance), where  .\nBegin with the set of data points to be clustered.\nRemove a point from the set, beginning a new 'canopy'.\nFor each point left in the set, assign it to the new canopy if the distance less than the loose distance .\nIf the distance of the point is additionally less than the tight distance , remove it from the original set.\nRepeat from step 2 until there are no more data points in the set to cluster.\nThese relatively cheaply clustered canopies can be sub-clustered using a more expensive but accurate algorithm.\nAn important note is that individual data points may be part of several canopies. As an additional speed-up, an approximate and fast distance metric can be used for 3, where a more accurate and slow distance metric can be used for step 4.\nSince the algorithm uses distance functions and requires the specification of distance thresholds, its applicability for high-dimensional data is limited by the curse of dimensionality. Only when a cheap and approximative – low-dimensional – distance function is available, the produced canopies will preserve the clusters produced by K-means.\n\n","alt_names":["Canopy Clustering","Canopy clustering","Canopy clustering algorithm","Canopy clustering algorithm - Wikipedia, the free encyclopedia","Canopy clustering algorithm - Wikipedia, the free encyclopedia ...","Canopy clustering algorithm by Wikipedia","Canopy clustering algorithm →","Canopy-clustering","What are benefits for Canopy Clustering Algorithm","Wikipedia (Canopy clustering algorithm)","Wikipedia article Canopy clustering algorithm","Wikipedia entry for Canopy clustering algorithm","canopy clustering","http://en.wikipedia.org/wiki/Canopy_clu … _algorithm","http://en.wikipedia.org/wiki/Canopy_clus","http://en.wikipedia.org/wiki/Canopy_clusterin...","http://en.wikipedia.org/wiki/Canopy_clustering_algorithm","yago-res:Canopy clustering algorithm"],"name":"Canopy clustering algorithm","categories":["Algorithms and data structures stubs","All articles with dead external links","All stub articles","Articles with dead external links from September 2015","Computer science stubs","Data clustering algorithms","Statistical algorithms"],"tag_line":"The canopy clustering algorithm is an unsupervised pre-clustering algorithm introduced by Andrew McCallum, Kamal Nigam and Lyle Ungar in 2000."}}
,{"_index":"throwtable","_type":"algorithm","_id":"information-bottleneck-method","_score":0,"_source":{"description":"The information bottleneck method is a technique in information theory introduced by Naftali Tishby et al. for finding the best tradeoff between accuracy and complexity (compression) when summarizing (e.g. clustering) a random variable X, given a joint probability distribution between X and an observed relevant variable Y. Other applications include distributional clustering, and dimension reduction. In a well defined sense it generalized the classical notion of minimal sufficient statistics from parametric statistics to arbitrary distributions, not necessarily of exponential form. It does so by relaxing the sufficiency condition to capture some fraction of the mutual information with the relevant variable Y.\nThe compressed variable is  and the algorithm minimizes the following quantity\n\nwhere  are the mutual information between  and  respectively, and  is a Lagrange multiplier.","alt_names":["...more on Wikipedia about Information bottleneck method","9156d01d3add45ecb46d2f367e935 ...","Information Bottleneck Method","Information bottleneck method","Information bottleneck method - Wikipedia :: The free encyclopedia","Information bottleneck method - Wikipedia, the free ...","Information bottleneck method - Wikipedia, the free encyclopedia","Information bottleneck method - Wikipedia, the free encyclopedia ...","Information bottleneck method by Wikipedia","Information bottleneck method from Wikipedia","Wikipedia article ''Information bottleneck method''","Wikipedia entry for Information bottleneck method","Wikipedia:Information_bottleneck_method","http://en.wikipedia.org/wiki/Information_bottleneck_method","information bottleneck","information bottleneck method","information processing bottleneck","yago-res:Information bottleneck method"],"name":"Information bottleneck method","categories":["Data clustering algorithms","Multivariate statistics"],"tag_line":"The information bottleneck method is a technique in information theory introduced by Naftali Tishby et al."}}
,{"_index":"throwtable","_type":"algorithm","_id":"birch","_score":0,"_source":{"description":"BIRCH (balanced iterative reducing and clustering using hierarchies) is an unsupervised data mining algorithm used to perform hierarchical clustering over particularly large data-sets. An advantage of BIRCH is its ability to incrementally and dynamically cluster incoming, multi-dimensional metric data points in an attempt to produce the best quality clustering for a given set of resources (memory and time constraints). In most cases, BIRCH only requires a single scan of the database.\nIts inventors claim BIRCH to be the \"first clustering algorithm proposed in the database area to handle 'noise' (data points that are not part of the underlying pattern) effectively\", beating DBSCAN by two months. The algorithm received the SIGMOD 10 year test of time award in 2006.\n^ a b Zhang, T.; Ramakrishnan, R.; Livny, M. (1996). \"BIRCH: an efficient data clustering method for very large databases\". Proceedings of the 1996 ACM SIGMOD international conference on Management of data - SIGMOD '96. pp. 103––114. doi:10.1145/233269.233324. \n^ \"2006 SIGMOD Test of Time Award\".","alt_names":[],"name":"BIRCH","categories":["Data clustering algorithms","Wikipedia articles needing clarification from December 2014"],"tag_line":"BIRCH (balanced iterative reducing and clustering using hierarchies) is an unsupervised data mining algorithm used to perform hierarchical clustering over particularly large data-sets."}}
,{"_index":"throwtable","_type":"algorithm","_id":"williams'-p-+-1-algorithm","_score":0,"_source":{"description":"In computational number theory, Williams' p + 1 algorithm is an integer factorization algorithm, one of the family of algebraic-group factorisation algorithms. It was invented by Hugh C. Williams in 1982.\nIt works well if the number N to be factored contains one or more prime factors p such that p + 1 is smooth, i.e. p + 1 contains only small factors. It uses Lucas sequences to perform exponentiation in a quadratic field.\nIt is analogous to Pollard's p − 1 algorithm.","alt_names":["Williams' p + 1 algorithm","Williams' p + 1 algorithm - Wikipedia, the free encyclopedia","...more on Wikipedia about Williams' p plus 1","P + 1","P+1","P+1 алгоритм","P+1 метод Уильямса","Wikipedia article ''Williams' p plus 1 algorithm''","Wikipedia article Williams' p + 1 algorithm","Wikipedia article Williams' p plus 1 algorithm","William's p plus 1 algorithm","Williams p 1 algorithm Wikipedia the free encyclopedia","Williams' P + 1 Algorithm - Wikipedia, The Free Encyclopedia","Williams' p 1 algorithm - Wikipedia, ...","Williams' p plus 1 algorithm","Williams' p+1 algorithm","d) Williams p+1 factorization","en.wikipedia.org/wiki/Williams%27_p_%2B_1_algorithm","http://en.wikipedia.org/wiki/Williams%27_p_%2B_1_algorithm","p + 1","p + 1 method","p 1 method"],"name":"Williams' p + 1 algorithm","categories":["Integer factorization algorithms"],"tag_line":"In computational number theory, Williams' p + 1 algorithm is an integer factorization algorithm, one of the family of algebraic-group factorisation algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"run-time-algorithm-specialisation","_score":0,"_source":{"description":"In computer science, run-time algorithm specialization is a methodology for creating efficient algorithms for costly computation tasks of certain kinds. The methodology originates in the field of automated theorem proving and, more specifically, in the Vampire theorem prover project.\nThe idea is inspired by the use of partial evaluation in optimising program translation. Many core operations in theorem provers exhibit the following pattern. Suppose that we need to execute some algorithm  in a situation where a value of  is fixed for potentially many different values of . In order to do this efficiently, we can try to find a specialization of  for every fixed , i.e., such an algorithm , that executing  is equivalent to executing .\nThe specialized algorithm may be more efficient than the generic one, since it can exploit some particular properties of the fixed value . Typically,  can avoid some operations that  would have to perform, if they are known to be redundant for this particular parameter . In particular, we can often identify some tests that are true or false for , unroll loops and recursion, etc.","alt_names":["Data-and-algorithm specialisation","Data-and-algorithm specialization","Difference from partial evaluation","Run time algorithm specialisation","Run-time algorithm specialisation","Run-time algorithm specialisation - Wikipedia, the free encyclopedia","Run-time_algorithm_specialisation","Specialisation with compilation","Specialising compiler","Specialization with compilation","Specializing compiler","Suggested: run-time algorithm specialisation","Wikipedia article Run-time algorithm specialisation","Wikipedia article Specialising compiler","Wikipedia article on Run-time algorithm specialisation","Wikipedia article on Specialising compiler","Wikipedia article on Specializing compiler","Wikipedia entry for Run-time algorithm specialisation","http://en.wikipedia.org/wiki/Run-time_al","http://en.wikipedia.org/wiki/Run-time_algorithm_specialisation","http://en.wikipedia.org/wiki/Specializing_compiler","run-time algorithm specialisation","runtime algorithm specialization","runtime-specialization","specializing compiler","動的コンパイラ","動的ｺﾝﾊﾟｲﾗ","特化コンパイラ","特化ｺﾝﾊﾟｲﾗ"],"name":"Run-time algorithm specialisation","categories":["Algorithms","Software optimization"],"tag_line":"In computer science, run-time algorithm specialization is a methodology for creating efficient algorithms for costly computation tasks of certain kinds."}}
,{"_index":"throwtable","_type":"algorithm","_id":"reservoir-sampling","_score":0,"_source":{"description":"Reservoir sampling is a family of randomized algorithms for randomly choosing a sample of k items from a list S containing n items, where n is either a very large or unknown number. Typically n is large enough that the list doesn't fit into main memory.\n\n","alt_names":["Reservoir Sampling","Reservoir Sampling algorithm","Reservoir sampling","Reservoir sampling - Wikipedia","Reservoir sampling - Wikipedia, the free encyclopedia","Wikipedia article Reservoir sampling","Wikipedia entry for Reservoir sampling","depósito de muestreo","el muestreo depósito","en.wikipedia.org/...Reservoir_sampling","en.wikipedia.org/wiki/Reservoir_sampling","http://en.wikipedia.org/wiki/Reservoir_sampli...","http://en.wikipedia.org/wiki/Reservoir_sampling","il campionamento serbatoio","pobierania próbek zbiornika","reservoir algorithms","reservoir bemonstering","reservoir sampler","reservoir sampling","reservoir stikprøver","resorvoir sampling","serbatoio di campionamento","yago-res:Reservoir sampling","zbiornika pobierania próbek","водохранилища выборки","резервуара выборки","水塘抽樣- 维基百科，自由的百科全书","水库采样","蓄水池抽样（Reservoir Sampling）"],"name":"Reservoir sampling","categories":["Algorithms","All articles needing expert attention","Analysis of algorithms","Articles needing expert attention from February 2010","Articles needing expert attention with no reason or talk parameter","Computing articles needing expert attention","Probabilistic complexity theory"],"tag_line":"Reservoir sampling is a family of randomized algorithms for randomly choosing a sample of k items from a list S containing n items, where n is either a very large or unknown number."}}
,{"_index":"throwtable","_type":"algorithm","_id":"algorithm-characterizations","_score":0,"_source":{"description":"Algorithm characterizations are attempts to formalize the word algorithm. Algorithm does not have a generally accepted formal definition. Researchers are actively working on this problem. This article will present some of the \"characterizations\" of the notion of \"algorithm\" in more detail.\nThis article is a supplement to the article Algorithm.","alt_names":["- Algorithm characterizations :","Algorithm Characterizations Wikipedia The Free Encyclopedia","Algorithm characterizations","Algorithm characterizations - Wikipedia :: The free encyclopedia","Algorithm characterizations - Wikipedia, the free encyclopedia","Algorithm characterizations - Wikipedia, the free encyclopedia3 Characterizations","Algorithm characterizations - Wikipedia, the free encyclopedia:","Algorithm characterizations Wikipedia the free encyclopedia","Algorithm_characterizations","John R. Searle and Daniel Dennett","Source Wikipedia.org Arcticle - Algorithm characterizations","Why general-recursive functions rather than primitive-recursive","Wikipedia article Algorithm characterizations","Wikipedia article about Algorithm characterizations","Wikipedia article on Algorithm characterizations","Wikipedia entry for Algorithm characterizations","Wikipedia: Algorithm characterizations","algorithm characterizations","http://en.wikipedia.org/wiki/Algorit...racterizations","http://en.wikipedia.org/wiki/Algorithm_c","http://en.wikipedia.org/wiki/Algorithm_characterizations","yago-res:Algorithm characterizations"],"name":"Algorithm characterizations","categories":["Algorithms","All articles to be expanded","All articles with empty sections","All articles with specifically marked weasel-worded phrases","Articles to be expanded from January 2014","Articles to be expanded from June 2008","Articles with empty sections from January 2014","Articles with specifically marked weasel-worded phrases from February 2013","Computability theory","Formal methods","Models of computation","Pages using duplicate arguments in template calls"],"tag_line":"Algorithm characterizations are attempts to formalize the word algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"metis","_score":0,"_source":{"description":"METIS is a software package for graph partitioning that implements various multilevel algorithms.\nMETIS' multilevel approach has three phases and comes with several algorithms for each phase:\nCoarsen the graph by generating a sequence of graphs G0, G1, ..., GN, where G0 is the original graph and for each 0 ≤ i ≤ j ≤ N, the number of vertices in Gi is greater than the number of vertices in Gj.\nCompute a partition of GN\nProject the partition back through the sequence in the order of GN, ..., G0, refining it with respect to each graph.\nThe final partition computed during the third phase (the refined partition projected onto G0) is a partition of the original graph.","alt_names":[],"name":"METIS","categories":["Algorithms","Algorithms and data structures stubs","All articles covered by WikiProject Wikify","All articles with too few wikilinks","All stub articles","Articles covered by WikiProject Wikify from December 2013","Articles with too few wikilinks from December 2013","Computational problems in graph theory","Computer science stubs"],"tag_line":"METIS is a software package for graph partitioning that implements various multilevel algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lossy-count-algorithm","_score":0,"_source":{"description":"The lossy count algorithm is an algorithm to identify elements in a data stream whose frequency count exceed a user-given threshold. The frequency computed by this algorithm is not always accurate, but has an error threshold that can be specified by the user. The run time space required by the algorithm is inversely proportional to the specified error threshold, hence larger the error, the smaller the footprint. It was created by eminent computer scientists Rajeev Motwani and Gurmeet Singh Manku. This algorithm finds huge application in computations where data takes the form of a continuous data stream instead of a finite data set, for e.g. network traffic measurements, web server logs, clickstreams.","alt_names":[],"name":"Lossy Count Algorithm","categories":["Algorithms"],"tag_line":"The lossy count algorithm is an algorithm to identify elements in a data stream whose frequency count exceed a user-given threshold."}}
,{"_index":"throwtable","_type":"algorithm","_id":"generalized-distributive-law","_score":0,"_source":{"description":"The generalized distributive law (GDL) is a general message passing algorithm devised by Srinivas M. Aji and Robert J. McEliece. It is a synthesis of the work of many authors in the information theory, digital communications, signal processing, statistics, and artificial intelligence communities. This article is based on a semi-tutorial by Srinivas M. Aji and Robert J. McEliece with the same title.","alt_names":[],"name":"Generalized distributive law","categories":["Algorithms","All articles lacking in-text citations","All articles needing additional references","Articles lacking in-text citations from June 2012","Articles needing additional references from June 2012","Artificial intelligence","Digital signal processing","Graphical models","Information theory","Wikipedia articles needing clarification from June 2015"],"tag_line":"The generalized distributive law (GDL) is a general message passing algorithm devised by Srinivas M. Aji and Robert J. McEliece."}}
,{"_index":"throwtable","_type":"algorithm","_id":"manhattan-address-algorithm","_score":0,"_source":{"description":"The Manhattan address algorithm is used to estimate the number of the closest cross street for a given building number on the island of Manhattan. The algorithm is given in any print telephone directory  as well as on numerous web pages and in New York City guide books.","alt_names":["Manhattan Address Algorithm","Manhattan address algorithm","Manhattan address algorithm - Wikipedia :: The free encyclopedia","Manhattan address algorithm - Wikipedia, the free encyclopedia","Manhattan address algorithm - Wikipedia, the free encyclopedia ...","Welcome to Manhattan College","Wikipedia article Manhattan address algorithm","Wikipedia article on Manhattan address algorithm","http://en.wikipedia.org/wiki/Manhattan address algorithm","http://en.wikipedia.org/wiki/Manhattan_address_algorithm"],"name":"Manhattan address algorithm","categories":["Algorithms","Streets in Manhattan"],"tag_line":"The Manhattan address algorithm is used to estimate the number of the closest cross street for a given building number on the island of Manhattan."}}
,{"_index":"throwtable","_type":"algorithm","_id":"domain-reduction-algorithm","_score":0,"_source":{"description":"Domain reduction algorithms are algorithms used to reduce constraints and degrees of freedom in order to provide solutions for partial differential equations.\n^ Chan, Tony F. \"Introduction\". Third International Symposium on Domain Decomposition Methods for Partial Differential Equations. SIAM. p. xv. ISBN 978-0-89871-253-7. Retrieved 24 January 2015.","alt_names":[],"name":"Domain reduction algorithm","categories":["Algorithms","All stub articles","Computer programming stubs"],"tag_line":"Domain reduction algorithms are algorithms used to reduce constraints and degrees of freedom in order to provide solutions for partial differential equations."}}
,{"_index":"throwtable","_type":"algorithm","_id":"predictor–corrector-method","_score":0,"_source":{"description":"In mathematics, particularly numerical analysis, a predictor–corrector method is an algorithm that proceeds in two steps. First, the prediction step calculates a rough approximation of the desired quantity. Second, the corrector step refines the initial approximation using another means.","alt_names":[],"name":"Predictor–corrector method","categories":["Algorithms","Numerical analysis"],"tag_line":"In mathematics, particularly numerical analysis, a predictor–corrector method is an algorithm that proceeds in two steps."}}
,{"_index":"throwtable","_type":"algorithm","_id":"chandy-misra-haas-algorithm:resource-model","_score":0,"_source":{"description":"K. Mani Chandy, Jayadev Misra and Laura M Haas devise Chandy Misra Haas algorithm for Resource model. It checks whether there is any deadlock in a distributed system or not.","alt_names":[],"name":"Chandy-Misra-Haas Algorithm:Resource Model","categories":["Algorithms"],"tag_line":"K. Mani Chandy, Jayadev Misra and Laura M Haas devise Chandy Misra Haas algorithm for Resource model."}}
,{"_index":"throwtable","_type":"algorithm","_id":"blast","_score":0,"_source":{"description":"In bioinformatics, BLAST for Basic Local Alignment Search Tool is an algorithm for comparing primary biological sequence information, such as the amino-acid sequences of different proteins or the nucleotides of DNA sequences. A BLAST search enables a researcher to compare a query sequence with a library or database of sequences, and identify library sequences that resemble the query sequence above a certain threshold.\nDifferent types of BLASTs are available according to the query sequences. For example, following the discovery of a previously unknown gene in the mouse, a scientist will typically perform a BLAST search of the human genome to see if humans carry a similar gene; BLAST will identify sequences in the human genome that resemble the mouse gene based on similarity of sequence. The BLAST algorithm and program were designed by Stephen Altschul, Warren Gish, Webb Miller, Eugene Myers, and David J. Lipman at the National Institutes of Health and was published in the Journal of Molecular Biology in 1990 and cited over 50,000 times.\n^ Altschul, Stephen; Gish, Warren; Miller, Webb; Myers, Eugene; Lipman, David (1990). \"Basic local alignment search tool\". Journal of Molecular Biology 215 (3): 403–410. doi:10.1016/S0022-2836(05)80360-2. PMID 2231712.","alt_names":["blast wikipedia the free encyclopedia","BLAST","NCBI-BLAST","- BLAST :","-> Leggi l'articolo completo su BLAST","...Wikipedia BLAST (Bioinformática)","...mehr auf Wikipedia über BLAST-Algorithmus","...more on Wikipedia about BLAST","BLAST (","BLAST (Basic Local Alignment Search Tool)","BLAST (FR)","BLAST (WikiPedia)","BLAST (wikipedia)","BLAST (生物資訊學) -","BLAST (生物資訊學) - 維基百科,自由的百科全書","BLAST (生物資訊學) - 维基百科,自由的百科全书","BLAST - Sequence detection in genome dbs","BLAST - Wikipedia","BLAST - Wikipedia :: The free encyclopedia","BLAST - Wikipedia, The Free Encyclopedia","BLAST - Wikipedia, la enciclopedia libre","BLAST - Wikipedia, the free ...","BLAST - Wikipedia, the free encyclopedi","BLAST - Wikipedia, the free encyclopedia","BLAST - Wikipedia, the free encyclopedia - Wikipedia","BLAST - Wikipedia, the free encyclopedia In bioinformatics, B","BLAST - Wikipedia, the free encyclopedia... Warren Gish, and","BLAST - Wikipedia, the free encyclopediaIn bioinformatics, B","BLAST - Wikipedia, the free encyclopediaNucleotide-nucleotide BLAST","BLAST - WikipediaBLAST (B asic L ocal A","BLAST - Wikipédia, a enciclopédia livre","BLAST -wikipedia","BLAST Algorithm for Seq Alignment","BLAST Algorithmus – Wikipedia","BLAST Wikipedia The Free Encyclopedia","BLAST Wikipedia entry","BLAST Wikipedia entry.","BLAST Wikipedia the free encyclopedia","BLAST Wikipedia, the free encyclopedia","BLAST algorithm","BLAST and","BLAST and friends","BLAST description","BLAST for implementation of sequence alignments","BLAST in Wikipedia","BLAST is a mathematical algorithm","BLAST match","BLAST on Wikipedia","BLAST on wikipedia.org","BLAST pattern-discovery algorithm","BLAST se","BLAST search","BLAST |","BLAST – Wikipedia tiếng Việt","BLAST – Wikipédia, a enciclopédia livre","BLAST — Википедия","BLAST+","BLAST,","BLAST- Wikipedia, the free encyclopedia","BLAST-Algorithmus","BLAST-Algorithmus ? Wikipedia","BLAST-Algorithmus Wikipedia","BLAST-Algorithmus in","BLAST-Algorithmus â€“ Wikipedia","BLAST-Algorithmus – Wikipedia","BLAST-Programms","BLAST-sökningar","BLAST-wikipedia","BLAST.","BLAST; it is used under the","BLASTP","BLASTed","BLASTp","BLASTとは？ (Wikipediaへのリンク)","BLASTについての続きを読む(Wikipedia)。","BLAST와","Basic Local Alignment Search Tool","Basic Local Alignment Search Tool (BLAST)","Basic Local Alignment Search Tool - Wikipédia","Basic local alignment search tool","Basic local alignment search tool - Wikipedia","Basic_Local_Alignment_Search_Tool","Blast - Wikipedia","Blast - Wikipedia, The Free Encyclopedia","Blast en Wikipedia","BlastX","BlastZ","Definición de BLAST más completo","Encyclopedia: BLAST","Http://en.wikipedia.org/wiki/BLAST","LAST,","Learn about BLAST>>>","Les mer om Blast","Lexikon: BLAST-Algorithmus - ComputerBase","Nucleotide 6-frame translation-protein (blastx) ... conserved evolutionarily","PSI-BLAST","Read More about blast wikipedia the free encyclopedia","Read More blast wikipedia the free encyclopedia","Search BLAST on Wikipedia","The main idea of BLAST is that there","WIK: BLAST","When performing a BLAST on NCBI, the results","Wikipedia : BLAST","Wikipedia BLAST","Wikipedia BLAST link","Wikipedia article BLAST","Wikipedia article Basic Local Alignment Search Tool","Wikipedia article Basic local alignment search tool","Wikipedia article PSI-BLAST","Wikipedia article about BLAST","Wikipedia article about PSI-BLAST","Wikipedia article on BLAST","Wikipedia article on PSI-BLAST","Wikipedia artikel BLAST","Wikipedia entry on BLAST","Wikipedia l'articolo BLAST","Wikipedia l'articolo Basic Local Alignment Search Tool","Wikipedia l'articolo Basic local alignment search tool","Wikipedia's BLAST article","Wikipedia-Artikel BLAST-Algorithmus","Wikipedia-Seite zu 'BLAST-Algorithmus'","Wikipedia: BLAST","Wikipedia:BLAST","Wikipedia:PSI-BLAST","Wikipediaで「BLAST」を調べる","Wikipedia日本語版 - Blast","[18] BLAST","[21] Blast – family of programs","[22] Blast – Algorithm","[3] BLAST – definition","[4] BLAST – definition","article BLAST","artículo de Wikipedia BLAST","artículo de Wikipedia Blast","blastall","ca:BLAST","de BLAST","de.wikipedia.org/ wiki/BLAST-Algorithmus","de:BLAST-Algorithmus","en.wikipedia.org/ wiki/BLAST","en.wikipedia.org/BLAST","en.wikipedia.org/wiki/BLAST","en.wikipedia.org/wiki/BLAST ...","es.wikipedia.org/ wiki/BLAST","es:BLAST","fa:بلاست","fr:Basic Local Alignment Search Tool","homology search,","http://de.wikipedia.org/wiki/BLAST-Algor","http://de.wikipedia.org/wiki/BLAST-Algorithmus","http://en.wikipedia.org/.../BLAST","http://en.wikipedia.org/wiki/BLAST","http://en.wikipedia.org/wiki/BLAST#Algorithm","http://en.wikipedia.org/wiki/BLAST#BLAST","http://en.wikipedia.org/wiki/BLAST#Program","http://en.wikipedia.org/wiki/BLAST#Progr…","http://en.wikipedia.org/wiki/BLAST.","http://en.wikipedia.org/wiki/PSI-BLAST","http://es.wikipedia.org/wiki/BLAST","http://fr.wikipedia.org/wiki/Basic_Local_Alignment_Search_Tool","http://it.wikipedia.org/wiki/BLAST","http://ja.wikipedia.org/wiki/BLAST","http://ja.wikipedia.org/wiki/BLASTのthumbnail","http://ja.wikipedia.org/wiki/Basic_Local_Alignment_Search_Tool","http://nl.wikipedia.org/wiki/BLAST","http://no.wikipedia.org/wiki/Blast","http://ppt.cc/1duT","http://ru.wikipedia.org/wiki/BLAST","http://sv.wikipedia.org/wiki/BLAST","http://zh.wikipedia.org/wiki/BLAST_(%E7%94","is:BLAST","ja:BLAST","l'article de Wikipédia Basic Local Alignment Search","logiciel Blast","n12:BLAST","nl:BLAST","no:Blast","p S ≥ x = 1 - exp - e - λ x","pt:BLAST","ru:BLAST","sv:BLAST","ttp://ja.wikipedia.org/wiki/BLAST","ungap-BLAST","vi:BLAST","zh:BLAST (生物資訊學)","Википедии статью BLAST","بلاست - ویکیپدیا","ब्लास्ट","“BLAST - Wikipedia, the free encyclopedia”, en.wikipedia.org","「BLAST」をWikipediaで調べる","のBLAST","ウィキペディアの記事 Basic Local Alignment Search Tool","維基百科的文章“ BLAST (生物資訊學) ”","维基百科的文章“ BLAST (生物資訊學) ”"],"name":"BLAST","categories":["All articles needing additional references","All articles with unsourced statements","Articles needing additional references from December 2015","Articles with unsourced statements from August 2012","Bioinformatics algorithms","Bioinformatics software","Computational phylogenetics","Laboratory software","Public domain software"],"tag_line":"In bioinformatics, BLAST for Basic Local Alignment Search Tool is an algorithm for comparing primary biological sequence information, such as the amino-acid sequences of different proteins or the nucleotides of DNA sequences."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ukkonen's-algorithm","_score":0,"_source":{"description":"In computer science, Ukkonen's algorithm is a linear-time, online algorithm for constructing suffix trees, proposed by Esko Ukkonen in 1995.\nThe algorithm begins with an implicit suffix tree containing the first character of the string. Then it steps through the string adding successive characters until the tree is complete. This order addition of characters gives Ukkonen's algorithm its \"on-line\" property. The original algorithm presented by Peter Weiner proceeded backward from the last character to the first one from the shortest to the longest suffix. A simpler algorithm was found by Edward M. McCreight, going from the longest to the shortest suffix.\nThe naive implementation for generating a suffix tree going forward requires O(n2) or even O(n3) time complexity in big O notation, where n is the length of the string. By exploiting a number of algorithmic techniques, Ukkonen reduced this to O(n) (linear) time, for constant-size alphabets, and O(n log n) in general, matching the runtime performance of the earlier two algorithms.","alt_names":["...more on Wikipedia about Ukkonen algorithm","Algorithme d'Ukkonen","Ukkonen algorithm","Ukkonen''s algorithm","Ukkonen's Algorithm","Ukkonen's Linear-Time Algorithm For Suffix Tree Creation","Ukkonen's algorithm","Ukkonen's algorithm - Wikipedia, the free ...","Ukkonen's algorithm - Wikipedia, the free encyclopedia","Ukkonen's algorithm; it is used under the","Wikipedia article Algorytm Ukkonena","Wikipedia article Ukkonen's algorithm","en.wikipedia.org/wiki/Ukkonen%27s_algorithm","en.wikipedia.org/wiki/Ukkonen's_algorithm","http://en.wikipedia.org/wiki/Ukkone...","http://en.wikipedia.org/wiki/Ukkonen%27s_algorithm","http://en.wikipedia.org/wiki/Ukkonen's_algorithm","http://pl.wikipedia.org/wiki/Algorytm_Ukkonena","Укконен","алгоритма укконена"],"name":"Ukkonen's algorithm","categories":["Algorithms on strings","All stub articles","Bioinformatics algorithms","Computer science stubs","Substring indices"],"tag_line":"In computer science, Ukkonen's algorithm is a linear-time, online algorithm for constructing suffix trees, proposed by Esko Ukkonen in 1995."}}
,{"_index":"throwtable","_type":"algorithm","_id":"karloff–zwick-algorithm","_score":0,"_source":{"description":"The Karloff–Zwick algorithm, in computational complexity theory, is a randomised approximation algorithm taking an instance of MAX-3SAT Boolean satisfiability problem as input. If the instance is satisfiable, then the expected weight of the assignment found is at least 7/8 of optimal. It provides strong evidence (but not a mathematical proof) that the algorithm performs equally well on arbitrary MAX-3SAT instances. Howard Karloff and Uri Zwick presented the algorithm in 1997.\nFor the related MAX-E3SAT problem, in which all clauses in the input 3SAT formula are guaranteed to have exactly three literals, the simple randomized approximation algorithm which assigns a truth value to each variable independently and uniformly at random satisfies 7/8 of all clauses in expectation, irrespective of whether the original formula is satisfiable. Further, this simple algorithm can also be easily derandomized using the method of conditional expectations. The Karloff–Zwick algorithm, however, does not require the restriction that the input formula should have three literals in every clause.\nBuilding upon previous work on the PCP theorem, Johan Håstad showed that, assuming P ≠ NP, no polynomial-time algorithm for MAX 3SAT can achieve a performance ratio exceeding 7/8, even when restricted to satisfiable instances of the problem in which each clause contains exactly three literals. Both the Karloff–Zwick algorithm and the above simple algorithm are therefore optimal in this sense.","alt_names":[],"name":"Karloff–Zwick algorithm","categories":["Algorithms and data structures stubs","All stub articles","Approximation algorithms","CS1 errors: chapter ignored","Computer science stubs","Probabilistic complexity theory"],"tag_line":"The Karloff–Zwick algorithm, in computational complexity theory, is a randomised approximation algorithm taking an instance of MAX-3SAT Boolean satisfiability problem as input."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sequential-algorithm","_score":0,"_source":{"description":"In computer science, a sequential algorithm or serial algorithm is an algorithm that is executed sequentially – once through, from start to finish, without other processing executing – as opposed to concurrently or in parallel. The term is primarily used to contrast with concurrent algorithm or parallel algorithm; most standard computer algorithms are sequential algorithms, and not specifically identified as such, as sequentialness is a background assumption. Concurrency and parallelism are in general distinct concepts, but they often overlap – many distributed algorithms are both concurrent and parallel – and thus \"sequential\" is used to contrast with both, without distinguishing which one. If these need to be distinguished, the opposing pairs sequential/concurrent and serial/parallel may be used.\n\"Sequential algorithm\" may also refer specifically to an algorithm for decoding a convolutional code.","alt_names":["Serial algorithm"],"name":"Sequential algorithm","categories":["Algorithms","Algorithms and data structures stubs","All stub articles","Computer science stubs"],"tag_line":"In computer science, a sequential algorithm or serial algorithm is an algorithm that is executed sequentially – once through, from start to finish, without other processing executing – as opposed to concurrently or in parallel."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sequential-pattern-mining","_score":0,"_source":{"description":"Sequential Pattern mining is a topic of data mining concerned with finding statistically relevant patterns between data examples where the values are delivered in a sequence. It is usually presumed that the values are discrete, and thus time series mining is closely related, but usually considered a different activity. Sequential pattern mining is a special case of structured data mining.\nThere are several key traditional computational problems addressed within this field. These include building efficient databases and indexes for sequence information, extracting the frequently occurring patterns, comparing sequences for similarity, and recovering missing sequence members. In general, sequence mining problems can be classified as string mining which is typically based on string processing algorithms and itemset mining which is typically based on association rule learning.","alt_names":[],"name":"Sequential pattern mining","categories":["Bioinformatics","Bioinformatics algorithms","Data mining"],"tag_line":"Sequential Pattern mining is a topic of data mining concerned with finding statistically relevant patterns between data examples where the values are delivered in a sequence."}}
,{"_index":"throwtable","_type":"algorithm","_id":"gap-reduction","_score":0,"_source":{"description":"In computational complexity theory, a gap reduction is a reduction to a particular type of decision problem, known as a c-gap problem. Such reductions provide information about the hardness of approximating solutions to optimization problems. In short, a gap problem refers to one wherein the objective is to distinguish between cases where the best solution is above one threshold from cases where the best solution is below another threshold, such that the two thresholds have a gap in between. Gap reductions can be used to demonstrate inapproximability results, as if a problem may be approximated to a better factor than the size of gap, then the approximation algorithm can be used to solve the corresponding gap problem.","alt_names":[],"name":"Gap reduction","categories":["All articles needing expert attention","All articles that are too technical","Approximation algorithms","Articles needing expert attention from December 2014","Computational problems","Pages using web citations with no URL","Wikipedia articles that are too technical from December 2014"],"tag_line":"In computational complexity theory, a gap reduction is a reduction to a particular type of decision problem, known as a c-gap problem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pairwise-algorithm","_score":0,"_source":{"description":"A Pairwise Algorithm  is an algorithmic technique with its origins in Dynamic programming. Pairwise algorithms have several uses including comparing a protein profile (a residue scoring matrix for one or more aligned sequences) against the three translation frames of a DNA strand, allowing frameshifting. The most remarkable feature of PairWise as compared to other Protein-DNA alignment tools is that PairWise allows frameshifting during alignment.\n^ Birney, E.; Thompson, J.; Gibson, T. (1996). \"PairWise and SearchWise: Finding the optimal alignment in a simultaneous comparison of a protein profile against all DNA translation frames\". Nucleic Acids Research 24 (14): 2730–2739. doi:10.1093/nar/24.14.2730. PMC 145991. PMID 8759004.","alt_names":[],"name":"Pairwise Algorithm","categories":["Bioinformatics algorithms"],"tag_line":"A Pairwise Algorithm  is an algorithmic technique with its origins in Dynamic programming."}}
,{"_index":"throwtable","_type":"algorithm","_id":"simulation-algorithms-for-coupled-devs","_score":0,"_source":{"description":"Given a coupled DEVS model, simulation algorithms are methods to generate the model's legal behaviors, which are a set of trajectories not to reach illegal states. (see behavior of a Coupled DEVS model.) [Zeigler84] originally introduced the algorithms that handle time variables related to lifespan  and elapsed time  by introducing two other time variables, last event time, , and next event time  with the following relations:\n\nand\n\nwhere  denotes the current time. And the remaining time,\n\nis equivalently computed as\n\n, apparently .\nBased on these relationships, the algorithms to simulate the behavior of a given Coupled DEVS are written as follows.","alt_names":[],"name":"Simulation algorithms for coupled DEVS","categories":["Algorithms"],"tag_line":"Given a coupled DEVS model, simulation algorithms are methods to generate the model's legal behaviors, which are a set of trajectories not to reach illegal states."}}
,{"_index":"throwtable","_type":"algorithm","_id":"neighbor-joining","_score":0,"_source":{"description":"In bioinformatics, neighbor joining is a bottom-up (agglomerative) clustering method for the creation of phylogenetic trees, created by Naruya Saitou and Masatoshi Nei in 1987. Usually used for trees based on DNA or protein sequence data, the algorithm requires knowledge of the distance between each pair of taxa (e.g., species or sequences) to form the tree.","alt_names":[],"name":"Neighbor joining","categories":["All articles with unsourced statements","Articles containing Japanese-language text","Articles with unsourced statements from November 2012","Bioinformatics algorithms","Computational phylogenetics","Data clustering algorithms","Phylogenetics"],"tag_line":"In bioinformatics, neighbor joining is a bottom-up (agglomerative) clustering method for the creation of phylogenetic trees, created by Naruya Saitou and Masatoshi Nei in 1987."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fitness-function","_score":0,"_source":{"description":"A fitness function is a particular type of objective function that is used to summarise, as a single figure of merit, how close a given design solution is to achieving the set aims.\nIn particular, in the fields of genetic programming and genetic algorithms, each design solution is commonly represented as a string of numbers (referred to as a chromosome). After each round of testing, or simulation, the idea is to delete the 'n' worst design solutions, and to breed 'n' new ones from the best design solutions. Each design solution, therefore, needs to be awarded a figure of merit, to indicate how close it came to meeting the overall specification, and this is generated by applying the fitness function to the test, or simulation, results obtained from that solution.\nThe reason that genetic algorithms cannot be considered to be a lazy way of performing design work is precisely because of the effort involved in designing a workable fitness function. Even though it is no longer the human designer, but the computer, that comes up with the final design, it is the human designer who has to design the fitness function. If this is designed badly, the algorithm will either converge on an inappropriate solution, or will have difficulty converging at all.\nMoreover, the fitness function must not only correlate closely with the designer's goal, it must also be computed quickly. Speed of execution is very important, as a typical genetic algorithm must be iterated many times in order to produce a usable result for a non-trivial problem.\nFitness approximation may be appropriate, especially in the following cases:\nFitness computation time of a single solution is extremely high\nPrecise model for fitness computation is missing\nThe fitness function is uncertain or noisy.\nTwo main classes of fitness functions exist: one where the fitness function does not change, as in optimizing a fixed function or testing with a fixed set of test cases; and one where the fitness function is mutable, as in niche differentiation or co-evolving the set of test cases.\nAnother way of looking at fitness functions is in terms of a fitness landscape, which shows the fitness for each possible chromosome.\nDefinition of the fitness function is not straightforward in many cases and often is performed iteratively if the fittest solutions produced by GA are not what is desired. In some cases, it is very hard or impossible to come up even with a guess of what fitness function definition might be. Interactive genetic algorithms address this difficulty by outsourcing evaluation to external agents (normally humans).","alt_names":["fitness functions","Fitnessfunktion","fitness function","(Read More) A mating pool is a concept","- Fitness function :","...mehr auf Wikipedia über Fitnessfunktion","...more on Wikipedia about Fitness (genetic algorithm)","...more on Wikipedia about Fitness function","Fitness (genetic algorithm)","Fitness Function","Fitness Score","Fitness function","Fitness function - Wikipedia :: The free encyclopedia","Fitness function - Wikipedia, the free encyclopedia","Fitness functions","Fitness-Funktion","Fitness_function","Fitnessfunctie","Fitnessfunktion in","Fitnessfunktion – Wikipedia","Funció d'aptitud (algori...","Wikipedia : Fitness function","Wikipedia : Genetic operator","Wikipedia : 適応度関数","Wikipedia article Fitness (genetic algorithm)","Wikipedia article Fitness function","Wikipedia article Fitness_function","Wikipedia article on Fitness function","Wikipedia entry for Fitness function","Wikipedia-Artikel Fitness-Funktion","Wikipedia-Artikel Fitnessfunktion","Wikipedia-Seite zu 'Fitness-Funktion'","Wikipedia-Seite zu 'Fitnessfunktion'","Wikipedia: Fitness Function","Wikipediaで「フィットネス関数」を調べる","Wikipediaで「適応度関数」を調べる","ca:Funció d'aptitud (algorisme genètic)","chức năng tập thể dục","de:Fitnessfunktion","en.wikipedia.org/wiki/Fitness_(geneti...","en.wikipedia.org/wiki/Fitness_(genetic_algorithm)","en.wikipedia.org/wiki/Fitness_function","fitness functio","fitness funkcija","fitness-functie","fitness-funktion","fitnessfunctie","fonction d'adaptation","fonction de fitnes","función de adecuación","función de aptitud","fungsi fitness.","funzione di fitness","função de adequação","g, economics, chemistry, manufacturing,","http://de.wikipedia.org/wiki/Fitness-Funktion","http://de.wikipedia.org/wiki/Fitnessfunk","http://de.wikipedia.org/wiki/Fitnessfunktion","http://en.wikipedia.org/wiki/Fitness_(genetic_algorithm)","http://en.wikipedia.org/wiki/Fitness_fun","http://en.wikipedia.org/wiki/Fitness_function","http://nl.wikipedia.org/wiki/Fitnessfunctie","itness function","ja:適応度関数","nl:Fitnessfunctie","tp://en.wikipedia.org/wiki/Fitness_function","uygunluk","Фітнес-функція","функции фитнеса.","फिटनेस समारोह","ฟังก์ชัน ออกกำลัง กาย","健身功能","適応度関数","適応度関数 - Wikipedia","適応度関数-wikipedia","적합성 함수를","ﾌｨｯﾄﾈｽ関数-wikipedia"],"name":"Fitness function","categories":["All articles lacking in-text citations","Articles lacking in-text citations from May 2015","Genetic algorithms"],"tag_line":"A fitness function is a particular type of objective function that is used to summarise, as a single figure of merit, how close a given design solution is to achieving the set aims."}}
,{"_index":"throwtable","_type":"algorithm","_id":"upgma","_score":0,"_source":{"description":"UPGMA (Unweighted Pair Group Method with Arithmetic Mean) is a simple agglomerative (bottom-up) hierarchical clustering method. It is one of the most popular methods in ecology for the classification of sampling units (such as vegetation plots) on the basis of their pairwise similarities in relevant descriptor variables (such as species composition). In bioinformatics, UPGMA is used for the creation of phenetic trees (phenograms). In a phylogenetic context, UPGMA assumes a constant rate of evolution (molecular clock hypothesis), and is not a well-regarded method for inferring relationships unless this assumption has been tested and justified for the data set being used. UPGMA was initially designed for use in protein electrophoresis studies, but is currently most often used to produce guide trees for more sophisticated phylogenetic reconstruction algorithms.\nThe UPGMA algorithm constructs a rooted tree (dendrogram) that reflects the structure present in a pairwise similarity matrix (or a dissimilarity matrix).\nAt each step, the nearest two clusters are combined into a higher-level cluster. The distance between any two clusters A and B is taken to be the average of all distances between pairs of objects \"x\" in A and \"y\" in B, that is, the mean distance between elements of each cluster:\n\nThe method is generally attributed to Sokal and Michener. A trivial implementation of the algorithm to construct the UPGMA tree has  time complexity, and using a heap for each cluster to keep its distances from other cluster reduces its time to . Fionn Murtagh presented some other approaches for special cases, a  time algorithm by Day and Edelsbrunner for k-dimensional data that is optimal  for constant k, and another  algorithm for restricted inputs, when \"the anglomerative strategy satisfies the reducibility property.\"\n\n","alt_names":["*UPGMA","- UPGMA :","...Wikipedia UPGMA","...more on Wikipedia about UPGMA","Average linkage clustering","Learn about UPGMA>>>","Read More upgma wikipedia the free encyclopedia","UPGMA","UPGMA - Wikipedia, the free encyclopedia","UPGMA by Wikipedia","UPGMA clustering","UPGMA |","UPGMA-Algorithmus","UPGMA-wikipedia","UPGMA; it is used under the","UPGMA@","Unweighted Pair Group Method with Arithmetic Mean - Wikip","Unweighted Pair Group Method with Arithmetic Mean - Wikipédia","Unweighted Pair Group Method with Arithmetic mean","Unweighted Pair Group Method with Arithmetic mean in","Unweighted Pair Group Method with Arithmetic mean – Wikipedia","Unweighted Pair Group Method...","Unweighted_Pair_Group_Method_with_Arithmetic_mean","Wikipedia article UPGMA","Wikipedia article Unweighted Pair Group Method with Arithmetic","Wikipedia article about UPGMA","Wikipedia article on UPGMA","Wikipedia entry for UPGMA","Wikipedia sur UPGMA","Wikipedia-Artikel UPGMA","Wikipedia-Artikel Unweighted Pair Group Method with Arithmetic","Wikipedia-Artikel WPGMA","Wikipedia-Seite zu 'UPGMA'","Wikipedia-Seite zu 'Unweighted Pair Group Method with","Wikipediaで「UPGMA」を調べる","ca:UPGMA","de:Unweighted Pair Group Method with Arithmetic mean","en.wikipedia.org/wiki/UPGMA","fr:Unweighted Pair Group Method with Arithmetic Mean","http://de.wikipedia.org/wiki/Un weighted_Pair_Group_Method_with _Arithmetic_mean","http://de.wikipedia.org/wiki/Unweighted_","http://de.wikipedia.org/wiki/Unweighted_Pair_Group_Method_with_Arithmetic_mean","http://en.wikipedia.org/wiki/UPGMA","http://fr.wikipedia.org/wiki/UPGMA","http://fr.wikipedia.org/wiki/Unweighted_Pair_Group_Method_with_Arithmetic_Mean","ja:非加重結合法","l'article de Wikipédia UPGMA","méthode UPGMA","savoir comment il a été construit","ウィキペディアの記事 UPGMA","ウィキペディアの記事 非加重結合法","非加重結合法","非加重結合法 - Wikipedia","非加重結合法-wikipedia"],"name":"UPGMA","categories":["All stub articles","Bioinformatics","Bioinformatics algorithms","Bioinformatics stubs","Computational phylogenetics","Data clustering algorithms","Phylogenetics"],"tag_line":"UPGMA (Unweighted Pair Group Method with Arithmetic Mean) is a simple agglomerative (bottom-up) hierarchical clustering method."}}
,{"_index":"throwtable","_type":"algorithm","_id":"inheritance-(genetic-algorithm)","_score":0,"_source":{"description":"In genetic algorithms, inheritance is the ability of modeled objects to mate, mutate (similar to biological mutation), and propagate their problem solving genes to the next generation, in order to produce an evolved solution to a particular problem. The selection of objects that will be inherited from in each successive generation is determined by a fitness function, which varies depending upon the problem being addressed.\nThe traits of these objects are passed on through chromosomes by a means similar to biological reproduction. These chromosomes are generally represented by a series of genes, which in turn are usually represented using binary numbers. This propagation of traits between generations is similar to the inheritance of traits between generations of biological organisms. This process can also be viewed as a form of reinforcement learning, because the evolution of the objects is driven by the passing of traits from successful objects which can be viewed as a reward for their success, thereby promoting beneficial traits.\n^ a b Russell, Stuart J.; Norvig, Peter (1995). Artificial Intelligence: A Modern Approach. Englewood Heights, NJ: Prentice-Hall.","alt_names":["-> Read the article about 'Inheritance (genetic algorithm)'","...more on Wikipedia about Inheritance (genetic algorithm)","Inheritance (dedovanje)","Inheritance (genetic algorithm)","Inheritance (genetic algorithm) - Wikipedia :: The free encyclopedia","Inheritance genetic algorithm","Inheritance genetic algorithm Wikipedia the free encyclopedia","Source Wikipedia.org Arcticle - Inheritance (genetic algorithm)","Wikipedia article ''Inheritance (genetic algorithm)''","Wikipedia article Inheritance (genetic algorithm)","Wikipedia entry for Inheritance (genetic algorithm)","http://en.wikipedia.org/wiki/Inheritance_(genetic_algorithm)","yago-res:Inheritance_(genetic_algorithm)"],"name":"Inheritance (genetic algorithm)","categories":["All orphaned articles","Genetic algorithms","Orphaned articles from April 2013"],"tag_line":"In genetic algorithms, inheritance is the ability of modeled objects to mate, mutate (similar to biological mutation), and propagate their problem solving genes to the next generation, in order to produce an evolved solution to a particular problem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"parallel-metaheuristic","_score":0,"_source":{"description":"Parallel metaheuristic is a class of techniques that are capable of reducing both the numerical effort and the run time of a metaheuristic. To this end, concepts and technologies from the field of parallelism in computer science are used to enhance and even completely modify the behavior of existing metaheuristics. Just as it exists a long list of metaheuristics like evolutionary algorithms, particle swarm, ant colony optimization, simulated annealing, etc. it also exists a large set of different techniques strongly or loosely based in these ones, whose behavior encompasses the multiple parallel execution of algorithm components that cooperate in some way to solve a problem on a given parallel hardware platform.","alt_names":[],"name":"Parallel metaheuristic","categories":["All accuracy disputes","All articles lacking in-text citations","All articles needing additional references","All articles with specifically marked weasel-worded phrases","Articles lacking in-text citations from June 2015","Articles needing additional references from June 2015","Articles with disputed statements from June 2015","Articles with specifically marked weasel-worded phrases from April 2012","Genetic algorithms","Mathematical optimization","Optimization algorithms and methods","Search algorithms","Wikipedia articles needing clarification from June 2015","Wikipedia articles with possible conflicts of interest from June 2015"],"tag_line":"Parallel metaheuristic is a class of techniques that are capable of reducing both the numerical effort and the run time of a metaheuristic."}}
,{"_index":"throwtable","_type":"algorithm","_id":"clonal-selection-algorithm","_score":0,"_source":{"description":"In artificial immune systems, Clonal selection algorithms are a class of algorithms inspired by the clonal selection theory of acquired immunity that explains how B and T lymphocytes improve their response to antigens over time called affinity maturation. These algorithms focus on the Darwinian attributes of the theory where selection is inspired by the affinity of antigen-antibody interactions, reproduction is inspired by cell division, and variation is inspired by somatic hypermutation. Clonal selection algorithms are most commonly applied to optimization and pattern recognition domains, some of which resemble parallel hill climbing and the genetic algorithm without the recombination operator.","alt_names":["- Clonal Selection Algorithm :","Clonal Selection Algorithm","Clonal Selection Algorithm - Wikipedia :: The free encyclopedia","Clonal Selection Algorithm - Wikipedia, the free encyclopedia","Clonal Selection Algorithm - Wikipedia, the free encyclopedia ...","Clonal Selection Algorithm Wikipedia the free encyclopedia","Clonal Selection Algorithms","What techniques does Clonal Selection Algorithm have","What techniques does Clonal Selection Algorithm have?","Wikipedia article Clonal Selection Algorithm","Wikipedia entry for Clonal Selection Algorithm","en:Clonal Selection Algorithm","http://en.wikipedia.org/wiki/Clonal_Selection_Algorithm","yago-res:Clonal Selection Algorithm"],"name":"Clonal Selection Algorithm","categories":["Genetic algorithms"],"tag_line":"In artificial immune systems, Clonal selection algorithms are a class of algorithms inspired by the clonal selection theory of acquired immunity that explains how B and T lymphocytes improve their response to antigens over time called affinity maturation."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hyperneat","_score":0,"_source":{"description":"Hypercube-based NEAT, or HyperNEAT, is a generative encoding that evolves artificial neural networks (ANNs) with the principles of the widely used NeuroEvolution of Augmented Topologies (NEAT) algorithm. It is a novel technique for evolving large-scale neural networks utilizing the geometric regularities of the task domain. It uses Compositional Pattern Producing Networks  (CPPNs), which are used to generate the images for Picbreeder.org and shapes for EndlessForms.com. HyperNEAT has recently been extended to also evolve plastic ANNs  and to evolve the location of every neuron in the network.","alt_names":["- HyperNEAT :","Hyper Neat","HyperNEAT","HyperNEAT - Wikipedia, the free encyclopedia","Hypercube-based NeuroEvolution of Augmenting Topologies","Wikipedia article HyperNEAT","Wikipedia article Hyperneat","Wikipedia entry for HyperNEAT","en.wikipedia.org/wiki/HyperNEAT","http://en.wikipedia.org/wiki/HyperNEAT"],"name":"HyperNEAT","categories":["Artificial neural networks","Evolutionary algorithms","Evolutionary computation","Genetic algorithms"],"tag_line":"Hypercube-based NEAT, or HyperNEAT, is a generative encoding that evolves artificial neural networks (ANNs) with the principles of the widely used NeuroEvolution of Augmented Topologies (NEAT) algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cultural-algorithm","_score":0,"_source":{"description":"Cultural algorithms (CA) are a branch of evolutionary computation where there is a knowledge component that is called the belief space in addition to the population component. In this sense, cultural algorithms can be seen as an extension to a conventional genetic algorithm. Cultural algorithms were introduced by Reynolds (see references).","alt_names":["Belief space","CHA-BING!","Cultural Algorithm","Cultural Algorithms","Cultural algorithm","Cultural algorithm - Wikipedia, the free encyclopedia","Cultural algorithm Wikipedia the free encyclopedia","Cultural algorithm from Wikipedia","Cultural algorithms","Pseudo-code for cultural algorithms","What is the population of Cultural algorithm","Wikipedia article Cultural algorithm","Wikipedia article Cultural_algorithm","Wikipedia article on Cultural algorithm","Wikipedia entry for Cultural algorithm","cultural algorithm","cultural algorithm wikipedia the free encyclopedia","cultural algorithms","http://en.wikipedia.org/wiki/Cultural_al","http://en.wikipedia.org/wiki/Cultural_algorithm"],"name":"Cultural algorithm","categories":["Evolutionary algorithms","Genetic algorithms"],"tag_line":"Cultural algorithms (CA) are a branch of evolutionary computation where there is a knowledge component that is called the belief space in addition to the population component."}}
,{"_index":"throwtable","_type":"algorithm","_id":"evolver-(software)","_score":0,"_source":{"description":"Evolver is a software package that allows users to solve a wide variety of optimization problems using a genetic algorithm. Launched in 1990, it was the first commercially available genetic algorithm package for personal computers. The program was originally developed by Axcelis, Inc. and is now owned by Palisade Corporation.","alt_names":["Evolver (Software)","Evolver (software)","Evolver (software) - Wikipedia, the free encyclopedia","Evolver software","Learn about Evolver (software)>>>","Wikipedia article ''Evolver (software)''","Wikipedia article Evolver (software)","Wikipedia entry for Evolver (software)","http://en.wikipedia.org/wiki/Evolver_%28software%29","http://en.wikipedia.org/wiki/Evolver_(software)"],"name":"Evolver (software)","categories":["All stub articles","Genetic algorithms","Software engineering stubs"],"tag_line":"Evolver is a software package that allows users to solve a wide variety of optimization problems using a genetic algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"velvet-assembler","_score":0,"_source":{"description":"Velvet is an algorithm package that has been designed to deal with de novo genome assembly and short read sequencing alignments. This is achieved through the manipulation of de Bruijn graphs for genomic sequence assembly via the removal of errors and the simplification of repeated regions. Velvet has also been implemented inside of commercial packages, such as Geneious, MacVector and BioNumerics.","alt_names":[],"name":"Velvet assembler","categories":["Bioinformatics algorithms","Bioinformatics software","DNA sequencing","Metagenomics software"],"tag_line":"Velvet is an algorithm package that has been designed to deal with de novo genome assembly and short read sequencing alignments."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sha-1","_score":0,"_source":{"description":"In cryptography, SHA-1 (Secure Hash Algorithm 1) is a cryptographic hash function designed by the United States National Security Agency and is a U.S. Federal Information Processing Standard published by the United States NIST. SHA-1 is considered insecure against well-funded opponents, and it is recommended to use SHA-2 or SHA-3 instead.\nSHA-1 produces a 160-bit (20-byte) hash value known as a message digest. A SHA-1 hash value is typically rendered as a hexadecimal number, 40 digits long.\nSHA-1 is a member of the Secure Hash Algorithm family. The four SHA algorithms are structured differently and are named SHA-0, SHA-1, SHA-2, and SHA-3. SHA-0 is the original version of the 160-bit hash function published in 1993 under the name SHA: it was not adopted by many applications. Published in 1995, SHA-1 is very similar to SHA-0, but alters the original SHA hash specification to correct weaknesses that were unknown to the public at that time. SHA-2, published in 2001, is significantly different from the SHA-1 hash function.\nIn 2005, cryptanalysts found attacks on SHA-1 suggesting that the algorithm might not be secure enough for ongoing use. NIST required many applications in federal agencies to move to SHA-2 after 2010 because of the weakness. Although no successful attacks have yet been reported on SHA-2, it is algorithmically similar to SHA-1. In 2012, following a long-running competition, NIST selected an additional algorithm, Keccak, for standardization under SHA-3.\nMicrosoft, Google and Mozilla have all announced that their respective browsers will stop accepting SHA-1 SSL certificates by 2017. Windows XP SP2 and earlier, and Android 2.2 and earlier, do not support SHA2 certificates.\n\n","alt_names":[],"name":"SHA-1","categories":["All articles containing potentially dated statements","All articles needing additional references","All articles with specifically marked weasel-worded phrases","All articles with unsourced statements","Articles containing potentially dated statements from 2013","Articles containing potentially dated statements from October 2015","Articles needing additional references from May 2013","Articles with Chinese-language external links","Articles with DMOZ links","Articles with example pseudocode","Articles with specifically marked weasel-worded phrases from September 2015","Articles with unsourced statements from August 2012","Articles with unsourced statements from December 2015","Articles with unsourced statements from June 2015","Broken hash functions","CS1 errors: dates","Checksum algorithms","Cryptographic hash functions","National Security Agency cryptography"],"tag_line":"In cryptography, SHA-1 (Secure Hash Algorithm 1) is a cryptographic hash function designed by the United States National Security Agency and is a U.S. Federal Information Processing Standard published by the United States NIST."}}
,{"_index":"throwtable","_type":"algorithm","_id":"stochastic-universal-sampling","_score":0,"_source":{"description":"Stochastic universal sampling (SUS) is a technique used in genetic algorithms for selecting potentially useful solutions for recombination. It was introduced by James Baker.\nSUS is a development of fitness proportionate selection (FPS) which exhibits no bias and minimal spread. Where FPS chooses several solutions from the population by repeated random sampling, SUS uses a single random value to sample all of the solutions by choosing them at evenly spaced intervals. This gives weaker members of the population (according to their fitness) a chance to be chosen and thus reduces the unfair nature of fitness-proportional selection methods.\nOther methods like roulette wheel can have bad performance when a member of the population has a really large fitness in comparison with other members. Using a comb-like ruler, SUS starts from a small random number, and chooses the next candidates from the rest of population remaining, not allowing the fittest members to saturate the candidate space.\nDescribed as an algorithm, pseudocode for SUS looks like:\n\nSUS(Population, N)\n    F := total fitness of Population\n    N := number of offspring to keep\n    P := distance between the pointers (F/N)\n    Start := random number between 0 and P\n    Pointers := [Start + i*P | i in [0..(N-1)]]\n    return RWS(Population,Pointers)\n\nRWS(Population, Points)\n    Keep = []\n    i := 0\n    for P in Points\n        while fitness sum of Population[0..i] < P\n            i++\n        add Population[i] to Keep\n    return Keep\n\nWhere Population[0..i] is the set of individuals with array-index 0 to (and including) i.\nHere RWS() describes the bulk of fitness proportionate selection (also known as \"roulette wheel selection\") - in true fitness proportional selection the parameter Points is always a (sorted) list of random numbers from 0 to F. The algorithm above is intended to be illustrative rather than canonical.\n\n","alt_names":["- Stochastic universal sampling :","Stochastic universal sampling","Stochastic universal sampling - Wikipedia, the free encyclopedia","Stochastic universal sampling from Wikipedia","Wikipedia article Stochastic universal sampling","Wikipedia article Stochastic_universal_sampling","Wikipedia article on Stochastic universal sampling","Wikipedia entry for Stochastic universal sampling","en.wikipedia.org/wiki/Stochastic_universal_sampling","en:Stochastic_universal_sampling","http://en.wikipedia.org/wiki/Stochastic universal sampling","http://en.wikipedia.org/wiki/Stochastic_universal_sampling","stochastic universal sampling"],"name":"Stochastic universal sampling","categories":["Genetic algorithms","Pages using citations with accessdate and no URL","Stochastic algorithms"],"tag_line":"Stochastic universal sampling (SUS) is a technique used in genetic algorithms for selecting potentially useful solutions for recombination."}}
,{"_index":"throwtable","_type":"algorithm","_id":"luhn-mod-n-algorithm","_score":0,"_source":{"description":"The Luhn mod N algorithm is an extension to the Luhn algorithm (also known as mod 10 algorithm) that allows it to work with sequences of non-numeric characters. This can be useful when a check digit is required to validate an identification string composed of letters, a combination of letters and digits or even any arbitrary set of characters.","alt_names":["- Luhn mod N algorithm :","Learn about Luhn mod N algorithm>>>","Luhn N mod","Luhn mod N","Luhn mod N algorithm","Luhn mod N algorithm - Wikipedia :: The free encyclopedia","Luhn mod N algorithm - Wikipedia, the free encyclopedia","Luhn mod N algorithm Wikipedia the free encyclopedia","Luhn mod N algorithm: Algorithm","Luhn mod N algorithm: Example","Luhn mod N algorithm: Generation","Luhn mod N algorithm: Implementation","Luhn mod N algorithm: Validation","Luhn mod N algorithm: Weakness","Luhn mod N algoritm","Luhn mod n formula","Luhn_mod_N_algorithm","Luhn는 N이 모드","Mapping characters to code-points","Wikipedia article Luhn mod N Algorithm","Wikipedia article Luhn mod N algorithm","Wikipedia entry for Luhn mod N algorithm","en.wikipedia.org/wiki/Luhn_mod_N_algorithm","generalises to any radix","http://en.wikipedia.org/wiki/Luhn_mod_N_","http://en.wikipedia.org/wiki/Luhn_mod_N_algorithm","yago-res:Luhn mod N algorithm","Лун мод N","は、Nはmodの代わりに","卢恩模ñ","盧恩模ñ"],"name":"Luhn mod N algorithm","categories":["All articles lacking sources","Articles lacking sources from May 2010","Articles with example code","Checksum algorithms","Modular arithmetic"],"tag_line":"The Luhn mod N algorithm is an extension to the Luhn algorithm (also known as mod 10 algorithm) that allows it to work with sequences of non-numeric characters."}}
,{"_index":"throwtable","_type":"algorithm","_id":"astronomical-algorithm","_score":0,"_source":{"description":"Astronomical algorithms are the algorithms used to calculate ephemerides, calendars, and positions (as in celestial navigation or satellite navigation). Examples of large and complex astronomical algorithms are those used to calculate the position of the Moon. A simple example is the calculation of the Julian day.\nNumerical model of solar system discusses a generalized approach to local astronomical modeling. The variations séculaires des orbites planétaires describes an often used model.","alt_names":["- Astronomical algorithm :","-> Read more about Astronomical algorithm","-> Read the article about 'Astronomical algorithm'","...Wikipedia Algoritmo astronómico","...more on Wikipedia about Astronomical algorithm","Algoritmo astronómico","Astronomical Algorithm","Astronomical algorithm","Astronomical algorithm - Wikipedia :: The free encyclopedia","Astronomical algorithm - Wikipedia, the free encyclopedia","Astronomical algorithms","Wikipedia article Algoritmo astronómico","Wikipedia article Astronomical algorithm","Wikipedia article Astronomical algorithms","Wikipedia entry for Astronomical algorithm","Wikipédia artigo Algoritmo astronómico","artigo da Wikipédia Algoritmo astronómico","http://en.wikipedia.org/wiki/Astronomical_algorithm"],"name":"Astronomical algorithm","categories":["Algorithms and data structures stubs","All articles lacking sources","All stub articles","Articles lacking sources from April 2010","Astrodynamics","Astronomy stubs","Calendar algorithms","Computational physics","Computer science stubs"],"tag_line":"Astronomical algorithms are the algorithms used to calculate ephemerides, calendars, and positions (as in celestial navigation or satellite navigation)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"promoter-based-genetic-algorithm","_score":0,"_source":{"description":"The promoter based genetic algorithm (PBGA) is a genetic algorithm for neuroevolution developed by F. Bellas and R.J. Duro in the Integrated Group for Engineering Research (GII) at the University of Coruña, in Spain. It evolves variable size feedforward artificial neural networks (ANN) that are encoded into sequences of genes for constructing a basic ANN unit. Each of these blocks is preceded by a gene promoter acting as an on/off switch that determines if that particular unit will be expressed or not.","alt_names":["PROMOTER BASED GENETIC ALGORITHM","Promoter based genetic algorithm","Promoter based genetic algorithm - Wikipedia, the free encyclopedia","Promoter based genetic algorithm on Wikipedia","Wikipedia article Promoter based genetic algorithm","Wikipedia entry for Promoter based genetic algorithm","en.wikipedia.org/wiki/Promoter_based_genetic_algorithm","http://em.wikipedia.org/wiki/PROMOTER_BASED_GENETIC_ALGORITHM_(PBGA)","http://en.Wikipedia.Org/wiki/PROMOTER_BASED_GENETIC_ALGORITHM_(PBGA)","http://en.wikipedia.org/wiki/PROMOTER_BASED_GENETIC_ALGORITHM_(PBGA)","http://en.wikipedia.org/wiki/Promoter_based_genetic_algorithm","yago-res:Promoter based genetic algorithm"],"name":"Promoter based genetic algorithm","categories":["Artificial neural networks","Evolutionary algorithms","Evolutionary computation","Genetic algorithms"],"tag_line":"The promoter based genetic algorithm (PBGA) is a genetic algorithm for neuroevolution developed by F. Bellas and R.J. Duro in the Integrated Group for Engineering Research (GII) at the University of Coruña, in Spain."}}
,{"_index":"throwtable","_type":"algorithm","_id":"truncation-selection","_score":0,"_source":{"description":"Truncation selection is a selection method used in genetic algorithms to select potential candidate solutions for recombination.\nIn truncation selection the candidate solutions are ordered by fitness, and some proportion, p, (e.g. p = 1/2, 1/3, etc.), of the fittest individuals are selected and reproduced 1/p times. Truncation selection is less sophisticated than many other selection methods, and is not often used in practice. It is used in Muhlenbein's Breeder Genetic Algorithm.\n^ H Muhlenbein, D Schlierkamp-Voosen (1993). \"Predictive Models for the Breeder Genetic Algorithm\". Evolutionary Computation.","alt_names":["Learn about Truncation selection>>>","Truncation selection","Truncation selection - Wikipedia, the free encyclopedia","Wikipedia article Truncation selection","Wikipedia entry for Truncation selection","Wikipedia: Truncation selection","en.wikipedia.org/wiki/Truncation_selection","http://en.wikipedia.org/wiki/Truncation_selection","truncation selection"],"name":"Truncation selection","categories":["All stub articles","Artificial intelligence stubs","Bioinformatics stubs","Computer science stubs","Genetic algorithms"],"tag_line":"Truncation selection is a selection method used in genetic algorithms to select potential candidate solutions for recombination."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sysv-checksum","_score":0,"_source":{"description":"The SYSV checksum algorithm is commonly used, legacy checksum algorithms. It has been implemented in UNIX System V and is also available through the GNU sum command line utility.","alt_names":["- SYSV checksum :","SYSV checksum","SYSV checksum - Wikipedia, the free encyclopedia","SYSV checksum; it is used under the","SYSV_checksum","What are sources of SYSV checksum","Wikipedia article SYSV checksum","Wikipedia article on SYSV checksum","Wikipedia entry for SYSV checksum","http://en.wikipedia.org/wiki/SYSV_checksum","yago-res:SYSV checksum"],"name":"SYSV checksum","categories":["Checksum algorithms"],"tag_line":"The SYSV checksum algorithm is commonly used, legacy checksum algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"a*-search-algorithm","_score":0,"_source":{"description":"In computer science, A* (pronounced as \"A star\" ( listen)) is a computer algorithm that is widely used in pathfinding and graph traversal, the process of plotting an efficiently traversable path between multiple points, called nodes. Noted for its performance and accuracy, it enjoys widespread use. However, in practical travel-routing systems, it is generally outperformed by algorithms which can pre-process the graph to attain better performance, although other work has found A* to be superior to other approaches.\nPeter Hart, Nils Nilsson and Bertram Raphael of Stanford Research Institute (now SRI International) first described the algorithm in 1968. It is an extension of Edsger Dijkstra's 1959 algorithm. A* achieves better performance by using heuristics to guide its search.","alt_names":["Wikipedia article A*","A star","2.1 Special cases","A * search algorithm","есть описание","A Star","the A* algorithm","A* search algorithm","A *","http://ja.wikipedia.org/wiki/A*","A*","A* pathfinding","'A*'","(http://en.wikipedia.org/wiki/A*_search_algorithm","(А*)","* (Star) algorytm wyszukiwania","* (hvězda) vyhledávací algoritmus","* (Звезда) алгоритм поиска","* (звезды) алгоритм","* (звезды) алгоритма","* (ดาว) ขั้น ตอน วิธี","* (스타)","* A (A-star) algoritmo","* Un","* Un algorithme de recherche","* Una","* Wikipedii","* algoritma A","* http://en.wikipedia.org/wiki/A _search_algorithm","* Алгоритм","* алгоритм","* статьи Википедии","* 검색 알고리즘과","* 알고리즘","* 알고리즘은","*-Algorithmus b","*Algoritmo de busca A*","*の","*は、","*を","*検索アルゴリズムの","*（スター）検索アルゴリズムを","*（星）",",http://en.wikipedia.org/wiki/A*_search_algorithm","- A* :","- A* search :","- A* search algorithm :","- IDA* :","-> Leggi tutto l'articolo su 'A*'","-> Read the article about 'A* search algorithm'","-Giải thuật A*","-Star","...Wikipedia A*","...Wikipedia Algorithme A*","...Wikipedia Algorytm A*","...mehr auf Wikipedia über A*-Algorithmus","...more on Wikipedia about A* search algorithm","2 Algorithm description","2 Intuition","2a_search_algorithm% http://en.wikipedia.org/wiki/A","3 Why A* is admissible and computationally optimal","3.1 Relation to uniform-cost search","4 Intuition about why A* is admissible and","5 Intuition about why A* is not computationally","5 Monotonicity","6.1 Special cases","6.2 Implementation details","7 Admissibility and Optimality","8 Complexity","9 Variants of A*",": http://en.wikipedia.org/wiki/A* search algorithm","A * (A Star) Suchalgorithmus","A * (A Star) algoritmo de búsqueda","A * (A Star) algoritmo di ricerca","A * (A Star) søgealgoritme","A * (A Star) zoekalgoritme","A * (A-Stern)-Algorithmus","A * (A-Sterne)-Algorithmus","A * (A-bintang) algoritma","A * (A-estrella) algoritmo,","A * (A-star) algorithme","A * (A-star) algoritmo","A * (A-star) algoritmo,","A * (A-star) algorytm","A * (A-star) thuật toán","A * (A-star), algoritmus","A * (A-ster) algoritme","A * (A-stjernet) algoritme","A * (सितारा) एल्गोरिथ्म","A * Algorithmus","A * Such-Algorithmus","A * algoritme","A * algoritmus","A * se a rch a lgorithm - Wikipedi a","A * search","A * search algorithm - Wikipedia, the free encyclopedia","A * Алгоритм поиска","A *?","A *搜索算法","A *的","A *算法","A - Estrella","A -Algorithmus Wikipedia","A Search Algorithm Wikipedia The Free Encyclopedia","A Star (A*)","A Star Pathfinding","A Star Search Algorithm","A Star algorithm","A Star path finding","A algoritme Wikipedia","A estrella","A good link explaing it in detail","A search algorithm","A search algorithm - Wikipedia, the free encyclopedia","A search algorithm Wikipedia the free encyclopedia","A search algorithm Wikipedia the free encyclopedia - result","A star algorithm","A star description (Wikipedia)","A star search","A star search algorithm","A%2A_search_algorithm","A* ('A' Star)","A* (A Star) search algorithm","A* (A star)","A* (A-Star) algorithm","A* (A-Star) 演算法","A* (A-star)","A* (A-star) algorithm","A* (Star) Search Algorithm","A* (Wikipedia)","A* (a-star) algoritme","A* (clicky)","A* (wikipedia)","A* (エースター) アルゴリズム","A* - Algorithmus","A* - Wikipedia","A* ;","A* <b>search b> algorithm - Wikipedia, the free","A* Algorithm","A* Algorithm -- Wikipedia.org","A* Algorithm Brief","A* Algorithm Wikipedia Entry","A* Algorithm on Wikipedia","A* Algorithmus","A* Algorithmus – Wikipedia","A* Algorythmus","A* Path Finding","A* Pathfinding","A* Pathfinding - Wikipedia","A* Search","A* Search Algorithm","A* Search Algorithm (Wikipedia)","A* Search Algorithm - Wikipedia, The Free Encyclopedia","A* Search Algorithm Wikipedia article","A* Search Algoritm","A* Search algorithm","A* Searching","A* Stepping Algorithm","A* Wayfinding Algorithm","A* Wiki","A* Wikipedia","A* Wikipedia Article","A* algo","A* algorihm","A* algoritam","A* algorithm","A* algorithm page","A* algorithms","A* algoritmas","A* algoritmasıyla","A* algoritme","A* algoritmus","A* algorthim","A* algorythmus","A* alpha star","A* best-first algorithm","A* en Wikipedia","A* en la wikipedia -","A* for shortest path","A* graph search","A* graph search algorithm","A* graph searching algorithm","A* heuristic search algorithm","A* implementation","A* in action","A* is a classic heuristic","A* is your friend.","A* like algorithm","A* on Wikipedia","A* on Wikipedia.","A* on wikipedia","A* optimal pathfinding","A* path","A* path algorithm","A* path finder","A* path finding","A* path finding algorithm","A* path planning algorithm","A* path-finding algorithm","A* path-finding-algorithm","A* pathfinding algorithm","A* pathing algorithm","A* på Wikipedia","A* route-finding","A* router algorithm","A* scheme","A* search","A* search (pathfinding) algorithm","A* search Algorithm","A* search algorithm (Wikipedia)","A* search algorithm - Wikipedia","A* search algorithm - Wikipedia :: The free encyclopedia","A* search algorithm - Wikipedia, the free encyclopedia","A* search algorithm - Wikipedia, the free encyclopedia ...","A* search algorithm - Wikipedia, the free encyclopedia In","A* search algorithm - Wikipedia, the free encyclopedia »","A* search algorithm - Wikipedia, the free encyclopedia ↳","A* search algorithm - Wikipedia, the free encyclopediaIn computer","A* search algorithm - wikipedia, the free encyclopedia","A* search algorithm Wikipedia, the ...","A* search algorithm by Wikipedia","A* search algorithm from Wikipedia","A* search algorithm on Wikipedia (en)","A* search algorithm – Wikipedia, the free encyclopedia","A* search algorithm; it is used under the","A* search algorithms","A* search-wikipedia","A* search.","A* searchalgorithm - Wikipedia, the free encyclopedia","A* searching","A* solver","A* star search algorithm","A* tree search","A* tree search:","A* walking","A* wiki article","A* wikipedia","A* wikipedia article","A* поиск (англ.)","A* アルゴリズム","A* アルゴリズム A* algorithm","A* 搜寻算法","A* 알고리즘","A* 탐색","A*(A-star)","A*(star) search algorithm","A*, Wikipedia","A*-Algorithmus","A*-Algorithmus - Wikipedia","A*-Algorithmus ? Wikipedia","A*-Algorithmus auf Wikipedia (de)","A*-Algorithmus bei Wikipedia","A*-Algorithmus gibt es auf Wikipedia","A*-Algorithmus â€“ Wikipedia","A*-Algorithmus – Wikipedia","A*-Suche","A*-algorithm","A*-algoritme","A*-algoritmi","A*-algoritmi – Wikipedia","A*-algoritmista","A*-search","A*-wikipedia","A*; it is used under the","A*@Wiki","A*Algorithmus","A*Pathing","A*_search","A*_search_algorithm","A*search algorithm","A*とは？ (Wikipediaへのリンク)","A*アルゴリズム","A*アルゴリズム - Wikipedia","A*探索","A*探索アルゴリズム","A*搜寻算法","A*搜寻算法7sk平坦软件园","A*搜尋演算法","A*搜尋算法","A*演算法","A*算法","A*알고리즘","A*（A-star, エースター）探索アルゴリズム","A*（エースター）","A*ｱﾙｺﾞﾘｽﾞﾑ","A-Search","A-Star","A-Star Algo","A-Star Algorythmus","A-Star Search Algorithm","A-Star algorithm","A-Star algoritmu","A-Star search algo on Wikipedia","A-algoritme - Wikipedia","A-algoritme 2 - Wikipedia","A-star (A*) search algorithm","A-star algorithm","A-star algorithmen","A-star algoritms","A-star search (Wikipedia)","A-star search algorithm","A-star search algorithm - Wikipedia","AI pathfinding algorithms","AI: A* algorithm","AStar oder auch A Stern","AStar search algorithm","Agorithme A*","Algorisme A*","Algorithme A *","Algorithme A*","Algorithme A* - Wikip?dia","Algorithme A* - Wikipédia","Algorithme A* en anglais","Algorithme AA","Algoritma A*","Algoritmo A*","Algoritmo A* (A* Algorithm).","Algoritmo A* - Wikipédia, a enciclopédia livre","Algoritmo A* – Wikipédia, a enciclopédia livre","Algoritmo de B@Ãº A *","Algoritmo de Búsqueda de Ruta A*","Algoritmo de b?squeda A* - Wikipedia, la enciclopedia","Algoritmo de bsqueda A* la enciclopedia libre","Algoritmo de búsqueda A*","Algoritmo de búsqueda A* - Wikipedia, la enciclopedia libre","Algoritmul A*","Algorito de búsqueda A*","Algorytm A*","AyStar pathfinding algorithm","A级明星","A＊(エースター)","Easy A*","Ein Link !","Encyclopedia: A* search algorithm","Er wurde das erste Mal 1968 von Peter","Estrategia de búsqueda A*","Example of A* algorithm where nodes are cities","Gi?i thu?t tìm ki?m A","Giải thuật tìm kiếm A*","Giải thuật tìm kiếm A* - Wikipedia tiếng Việt","Giải thuật tìm kiếm A* – Wik...","Giải thuật tìm kiếm A* – Wikipedia tiếng Việt","Here's the Wikipedia article on A*.","IDA Wikipedia the free encyclopedia","IDA Wikipedia the free encyclopedia Wikipedia","IDA%2A","IDA*","IDA* (Iterative Deeping A Star)","IDA* - Iterative deepening depth-first search","IDA* - Wikipedia :: The free encyclopedia","IDA* - Wikipedia, the free encyclopedia","IDA* by Wikipedia","IDA* search","IDA* |","IDA*.","IDA*; it is used under the","Info on the A* algorithm, which can be","Iterative Deepening A* Search","Iterative Deepening A* algorithm","Iterative Deepening A*(IDA*)","Méthode A* dans Wikipedia","Pathfinding algorithm.","Read More About a* search algorithm - wikipedia the","Read More About a* search algorithm wikipedia the","Read More a* search algorithm - wikipedia the free","Read More a* search algorithm wikipedia the free","Recherche de chemin: A*","SATO Yozo: A* - Wikipedia","Shortest Path A* algorithm","The A* search algorithm","The Wikipedia page has some information.","The h(x) part of the f(x","This is how search works.","Use A*","WIKI FTW!!!","Wegfindung mit A*","Weighted_A_star_with_eps_5.gif","What are the properties of A-star algorithm","Wiki A*","Wiki Definição","Wiki on the A* algorithm","Wiki page for A-star Algorithm","Wiki page on A*","Wikipedia - A* Algorithmus","Wikipedia : A*","Wikipedia : A* Algorithm","Wikipedia A * artikel","Wikipedia A * artiklen","Wikipedia A* Algorithmus","Wikipedia A* article","Wikipedia A* search page","Wikipedia A* search page.","Wikipedia A-Star","Wikipedia Article on A*","Wikipedia Artikel zum A*-Algorithmus","Wikipedia article A star","Wikipedia article A* search","Wikipedia article A* search algorithm","Wikipedia article A*-algoritme","Wikipedia article Algorithme A*","Wikipedia article Algoritmo A*","Wikipedia article Algoritmo de búsqueda A*","Wikipedia article Algorytm A*","Wikipedia article Giải thuật tìm kiếm A*","Wikipedia article IDA*","Wikipedia article about A*","Wikipedia article about IDA*","Wikipedia article on A*","Wikipedia article on A* search algorithm","Wikipedia article on Algoritmo de búsqueda A*","Wikipedia article on IDA*","Wikipedia article Ա*","Wikipedia article خوارزمية البحث بأولوية الأفضل","Wikipedia artikel A*","Wikipedia artikel A*-algoritme","Wikipedia de l'algorithme A*","Wikipedia entry for A* search algorithm","Wikipedia entry for IDA*","Wikipedia entry on A*","Wikipedia l'articolo A*","Wikipedia page for A*","Wikipedia page on A* search","Wikipedia tutorial on A*","Wikipedia – A*","Wikipedia's A* page","Wikipedia's pseudocode","Wikipedia-Artikel A*","Wikipedia-Artikel A*-Algorithmus","Wikipedia-Artikel A-Stern-Algorithmus","Wikipedia-Seite zu 'A*-Algorithmus'","Wikipedia.de A*-Algorithmus","Wikipedia.org Encyclopedia - A-star search algorithm","Wikipedia: A*","Wikipedia: A* search algorithm","Wikipedia::A*_search_algorithm","Wikipediaで「A*」を調べる","WikipediaのA*","WikipediaのA*の項","Wikipédia artigo Algoritmo A*","Wikipédia artigo Algoritmo a*","[10] A* search algorithm","a computer algorithm that is widely used in","a search algorithm wikipedia the encyclopedia","a*","a* (pronounced a star)","a* on wikipedia","a* path finding","a* search","a* search algorithm","a* search algorithm - wikipedia, the free encyclopedia","a* search algorithm wikipedia the free encyclopedia","a*(aStar)-algorithmus","algorithm * A","algorithm for navigation","algorithme A *","algorithme A*","algorithms that were made in the 60's","algoritma * A","algoritma A*.","algoritma pencarian A *","algoritmo A *","algoritmo A*","algoritmo A* (A star)","algoritmo de A*","algoritmo de búsqueda A *","algoritmo de búsqueda A*","algoritmo de búsqueda A-estrella","algoritmo de pesquisa *","algoritmos A*","algoritmus A*","algorytm A*","algorytm wyszukiwania drogi","algorytmu A*","an A*","an A* algorithm","ar:خوارزمية *A","ar:خوارزمية البحث بأولوية الأفضل","article A*","article A* sur Wikipédia","article on A*","artigo da Wikipédia Algoritmo A*","artículo * Una Wikipedia","artículo de Wikipedia A*","artículo de Wikipedia Algoritmo de búsqueda A*","asearch","basic A* algorithm","bu tarz bişey","can be viewed as a special case of","cautare de tip A*","cs:A*","de.wikipedia.org/wiki/A%2A-Algorithmus","de.wikipedia.org/wiki/A*","de.wikipedia.org/wiki/A*-Algorithmus","de:A*-Algorithmus","des trucs plus élaborés","diesem Algorithmus","e: http://en.wikipedia.org/wiki/A*_search_algorithm","en.wikipedia.org/...A*_search_algorithm","en.wikipedia.org/A*_search","en.wikipedia.org/wiki/A%2A","en.wikipedia.org/wiki/A%2a_search_algorithm","en.wikipedia.org/wiki/A*","en.wikipedia.org/wiki/A*_se...","en.wikipedia.org/wiki/A*_search_algor...","en.wikipedia.org/wiki/A*_search_algorithm","en.wikipedia.org/wiki/A*_…","en.wikipedia.org/wiki/A-star_search_algorithm","en.wikipedia.org/wiki/A_star","en.wikipedia.org/wiki/IDA*","en:A* search algorithm","es.wikipedia.org/wiki/A*","es:Algoritmo de búsqueda A*","fi:A*-algoritmi","fr.wikipedia.org/wiki/Algorithme_A*","fr:Algorithme A*","h ( x ) ≤ d ( x , y ) + h ( y )","htp://en.wikipedia.org/wiki/A*_search_algorithm","http://cs.wikipedia.org/wiki/A*","http://cs.wikipedia.org/wiki/A*_search","http://de.wikipedia.org/wiki/A% 2A-Algorithmus","http://de.wikipedia.org/wiki/A%2A","http://de.wikipedia.org/wiki/A%2A-Algorithmus","http://de.wikipedia.org/wiki/A%2A]A","http://de.wikipedia.org/wiki/A*","http://de.wikipedia.org/wiki/A* -Algorithmus","http://de.wikipedia.org/wiki/A* -Algorithmus#Beispiel","http://de.wikipedia.org/wiki/A*#Zul....sige_Heuristik","http://de.wikipedia.org/wiki/A*-A lgorithmus","http://de.wikipedia.org/wiki/A*-Algo...mplexit","http://de.wikipedia.org/wiki/A*-Algorithmus","http://de.wikipedia.org/wiki/A*-Algorithmus#Beispiel","http://de.wikipedia.org/wiki/A*-Algorithmus#Heuristiken","http://de.wikipedia.org/wiki/A*-Algorithmus#Nachteile","http://de.wikipedia.org/wiki/A*-Algorithmus.","http://de.wikipedia.org/wiki/A*-Algorithmus. [","http://de.wikipedia.org/wiki/A*-Algorith…","http://de.wikipedia.org/wiki/A-Stern-Algorithmus","http://de.wikipedia.org/wiki/A−Stern−Algorithmus","http://en.wikipedia....ithm#Complexity","http://en.wikipedia.../A*_search_algorithm","http://en.wikipedia.org/wiki/A * _search_algorithm","http://en.wikipedia.org/wiki/A * _search_algorithmを","http://en.wikipedia.org/wiki/A 2a_search_algorithm%","http://en.wikipedia.org/wiki/A _search_algorithm *","http://en.wikipedia.org/wiki/A% 2a_search_algorithm","http://en.wikipedia.org/wiki/A%2A","http://en.wikipedia.org/wiki/A%2A search","http://en.wikipedia.org/wiki/A%2A_search","http://en.wikipedia.org/wiki/A%2A_search_algo...","http://en.wikipedia.org/wiki/A%2A_search_algorithm","http://en.wikipedia.org/wiki/A%2a_search_algorithm","http://en.wikipedia.org/wiki/A*","http://en.wikipedia.org/wiki/A* search algorithm","http://en.wikipedia.org/wiki/A*#Complexi…","http://en.wikipedia.org/wiki/A*#Concepts","http://en.wikipedia.org/wiki/A*#Properties","http://en.wikipedia.org/wiki/A*#Why_A.2A_is_admissible_and_computationally_optimal","http://en.wikipedia.org/wiki/A*.","http://en.wikipedia.org/wiki/A*_...","http://en.wikipedia.org/wiki/A*_sear...#Weighted_A","http://en.wikipedia.org/wiki/A*_sear...thm","http://en.wikipedia.org/wiki/A*_searc...","http://en.wikipedia.org/wiki/A*_search","http://en.wikipedia.org/wiki/A*_search_","http://en.wikipedia.org/wiki/A*_search_algori...","http://en.wikipedia.org/wiki/A*_search_algorith","http://en.wikipedia.org/wiki/A*_search_algorithm","http://en.wikipedia.org/wiki/A*_search_algorithm#Algorithm_description","http://en.wikipedia.org/wiki/A*_search_algorithm#Pseudo_code","http://en.wikipedia.org/wiki/A*_search_algorithm#Pseudocode","http://en.wikipedia.org/wiki/A*_search_algorithm,","http://en.wikipedia.org/wiki/A*_search_algorithm.","http://en.wikipedia.org/wiki/A*_search_a…","http://en.wikipedia.org/wiki/A*_searc…","http://en.wikipedia.org/wiki/A-star_search_al...","http://en.wikipedia.org/wiki/A-star_search_algorithm","http://en.wikipedia.org/wiki/A-star_search_algorithm>A","http://en.wikipedia.org/wiki/A_star","http://en.wikipedia.org/wiki/A~*...","http://en.wikipedia.org/wiki/A−star_search_algorithm","http://en.wikipedia.org/wiki/A％2a_search_algorithm","http://en.wikipedia.org/wiki/A％の2a_search_algorithm","http://en.wikipedia.org/wiki/IDA%2A","http://en.wikipedia.org/wiki/IDA*","http://en.wikipedia.org/wiki/a*","http://en.wikipedia.​org/wiki/A*_search_a​lgorithm","http://es.wikipedia.org/wiki/A%2A","http://es.wikipedia.org/wiki/A*","http://es.wikipedia.org/wiki/Algoritmo_ ... Asqueda_A*","http://es.wikipedia.org/wiki/Algoritmo_de_b%C3%BAsqueda_A","http://es.wikipedia.org/wiki/Algoritmo_de_búsqueda_A*","http://fr.wikipedia.org/wiki/Algorithme_A","http://fr.wikipedia.org/wiki/Algorithme_A%2A","http://fr.wikipedia.org/wiki/Algorithme_A*","http://it.wikipedia.org/wiki/A%2A","http://it.wikipedia.org/wiki/A*","http://ja.wikipedia.org/wiki/A%2Aの","http://ja.wikipedia.org/wiki/A*のthumbnail","http://ko.wikipedia.org/wiki/A*_%EC","http://ko.wikipedia.org/wiki/A*_알고리즘","http://nl.wikipedia.org/wiki/A%2A","http://nl.wikipedia.org/wiki/A*","http://nl.wikipedia.org/wiki/A*-algoritme","http://pl.wikipedia....iki/Algorytm_A*","http://pl.wikipedia.org/wiki/AStar","http://pl.wikipedia.org/wiki/Algorytm_A*","http://pt.wikipedia.org/wiki/Algoritmo_A*","http://ru.wikipedia.org/wiki/Алгоритм_поиска_A*","http://zh.wikipedia.org/wiki/A*%E6%90","http://zh.wikipedia.org/zh-cn/A*%E6","hy:Ա*","isang *","it.wikipedia.org/wiki/A*","it:A*","ja:A*","ko:A* 알고리즘","l'aglorithme A*","l'algo A*","l'algorithme A*","l'algorithme de détermination de chemin AyStar","l'algorithme de pathfinding A*","l'algoritmo di ricerca A *","l'article de Wikipédia Algorithme A*","la page sur A*","lol A Star","looking at A* (A star)","m Wikipedia::A*_search_algorithm","nl:A*-algoritme","one that tries to find the shortest path","pl:Algorytm A*","pseudo code from wikipedia","pseudo código A* que hay en el artículo","pseudocode here","pt.wikipedia.org/wiki/Algoritmo_A*","pt:Algoritmo A*","punny name","read its article on Wikipedia","read this, this is useful","reading this wikipedia page.","recherche A*","ru.wikipedia.org/...%BE%D0%B8%D1%81","ru.wikipedia.org/wiki/А*","ru:Алгоритм поиска A*","search routine called A*","stuff to create for the opposing side","the A* search algorithm","thuật toán A *","thuật toán tìm kiếm A *","tree-based","ttp://en.wikipedia.org/wiki/A*_search_algorithm","ttp://ja.wikipedia.org/wiki/A*","uk:Алгоритм пошуку A*","un *","un articolo * Wikipedia","un buon inizio","vi:Giải thuật tìm kiếm A*","voila,","w:A* search algorithm","weighted A*","weighted A* search","wiki's A* page","wikipedia article for A*","wikipedia article on A*","wikipedia article on the A* algorithm","wikipedia on A*.","wikipedia:A*","writing it yourself","yago-res:IDA*","zh:A*搜寻算法","« A* » (A-star)","» A* algorithm","Α*","А*","А-алгоритма","Алгоритм A*","Алгоритм поиска A*","Алгоритм поиска A* — Википедия","Алгоритм поиска А*","Алгоритм поиска с эвристической функцией","Алгоритм_поиска A*","Алгоритм_поиска_A*","Википедии статью A*","Википедии статью А*","Интересное к прочтению","Функция h(x) должна быть допустимой эвристической оценкой","алгоритм A*","алгоритма A","на большую википедию.","поиска маршрута","прага туры в прагу карловы вары joy карловы","расписан поиск методом A*","Ա*","אלגוריתם A*","جستجوی هوشمندانه *A","एक *","एक * (ए स्टार) एल्गोरिथ्म","विकिपीडिया एक * लेख","सकता विकिपीडिया एक *","हैं *","ขั้น ตอน วิธี การ ค้นหา *","วิธี *","“A* Pathing”","“A* search algorithm - Wikipedia, the free encyclopedia”, en","“A*” (A-star)","“IDA* - Wikipedia, the free encyclopedia”, en.wikipedia.org","“خوارزمية البحث بأولوية الأفضل” A","はA *は、（星）アルゴリズム","アルゴリズムがうまくなるかなり","アルゴリズムは、tvanfosson","ウィキペディアの記事 A*","ウィキペディアの記事 A*アルゴリズム","参考。この宇宙語を解読するのに何時間かかったか。","爱仕达","甲*","的A *","的A *（“阿星”）搜索算法","維基百科的文章“ A* ”","維基百科的文章“ A*搜寻算法”","維基百科的文章“ A*搜尋演算法”","維基百科的文章“ A*搜尋算法”","維基百科～A*_search_algorithm","维基百科的文章“ A* ”","维基百科的文章“ A*搜寻算法”","维基百科的文章“ A*搜尋演算法”","维基百科的文章“ A*搜尋算法”","阿*","阿*（一星）算法","阿*（阿星）","阿*（阿星）算法","위키 피 디아 문서 A* 알고리즘","위키 피 디아 문서 A* 탐색","A* - Wikipedia","（这里"],"name":"A* search algorithm","categories":["All accuracy disputes","Articles with disputed statements from February 2014","Articles with example pseudocode","Combinatorial optimization","Game artificial intelligence","Graph algorithms","Routing algorithms","Search algorithms"],"tag_line":"In computer science, A* (pronounced as \"A star\" ( listen)) is a computer algorithm that is widely used in pathfinding and graph traversal, the process of plotting an efficiently traversable path between multiple points, called nodes."}}
,{"_index":"throwtable","_type":"algorithm","_id":"greedy-algorithm","_score":0,"_source":{"description":"A greedy algorithm is an algorithm that follows the problem solving heuristic of making the locally optimal choice at each stage with the hope of finding a global optimum. In many problems, a greedy strategy does not in general produce an optimal solution, but nonetheless a greedy heuristic may yield locally optimal solutions that approximate a global optimal solution in a reasonable time.\nFor example, a greedy strategy for the traveling salesman problem (which is of a high computational complexity) is the following heuristic: \"At each stage visit an unvisited city nearest to the current city\". This heuristic need not find a best solution, but terminates in a reasonable number of steps; finding an optimal solution typically requires unreasonably many steps. In mathematical optimization, greedy algorithms solve combinatorial problems having the properties of matroids.","alt_names":["http://en.wikipedia.org/wiki/Greedy_algo…","Greedy algorithms","貪婪演算法","greedy forwarding","greedily","greedy approach","greedier","Greedy algorithm","Greedy Algorithm","greedy algorithm","Greedy-Algorithmus","Greedy-Algorithmen","(http://en.wikipedia.org/wiki/Greedy_algorithm","- Exchange algorithm :","- Greedy Algorithm :","- Greedy algorithm :","-> Read the article about 'Greedy algorithm'",". http://it.wikipedia.org/wiki/Algoritmo_greedy.","... di monete di resto utilizzando monete da 100","...Wikipedia Algoritmo ganancioso","...Wikipedia Algoritmo greedy","...Wikipedia Algoritmo voraz","...Wikipedia Algorytm zachłanny","...Wikipedia Girig algoritm","...mehr auf Wikipedia über Greedy-Algorithmus","...more on Wikipedia about Greedy algorithm","1.1 Cases of failure","1.1 When greedy-type algorithms fail","Algorithme glouton","Algorithme glouton - Wikip?dia","Algorithme glouton - Wikipédia","Algorithme pour la coloration ...","Algoritma Greedy.","Algoritmi golosi(da wikipedia)","Algoritmo Voraz- Wikipedia, la enciclopedia libre","Algoritmo ganancioso","Algoritmo greedy","Algoritmo greedy - Wikipedia","Algoritmo guloso","Algoritmo guloso - Wikipédia, a enciclopédia livre","Algoritmo guloso – Wikipédia, a enciclopédia livre","Algoritmo irenskor","Algoritmo voraz","Algoritmo voraz - Wikipedia","Algoritmo voraz - Wikipedia, la enciclopedia libre","Algoritmo voraz - Wikipedia, la enciclopedia libre es.wikipedia","Algoritmo_voraz","Algoritmos Greedy na Wikipedia","Algoritmos Voraces en Wikipedia","Algoritmos greedy","Algoritmos voraces","Algoritmos voraces:","Algorytm zachłanny","Algorytm zachłanny – Wikipedia, wolna encyklopedia","Being Greedy","Definition from Wikipedia of Greedy Algorithms","Exchange algorithm","GREEDY","GREEDY ALGORITHM ANALYSIS","Giải Thuật","Gii thut tham lam ting Vit","Girig algoritm","Giải thuật tham lam","Giải thuật tham lam - Wikipedia tiếng Việt","Greedy Algorithm @ Wikipedia","Greedy Algorithm Wikipedia The Free Encyclopedia","Greedy Algorithm.","Greedy Algorithmen","Greedy Algorithms","Greedy Algorithmus","Greedy Algorithmus – Wikipedia","Greedy Method","Greedy Programming","Greedy Routing","Greedy Search","Greedy algorithm (wikipedia link)","Greedy algorithm - Wikipedia","Greedy algorithm - Wikipedia :: The free encyclopedia","Greedy algorithm - Wikipedia, the free ency","Greedy algorithm - Wikipedia, the free encycl","Greedy algorithm - Wikipedia, the free encyclopedia","Greedy algorithm by Wikipedia","Greedy algorithm- , the free encyclopedia","Greedy algorithm; it is used under the","Greedy method","Greedy search","Greedy strategies","Greedy アルゴリズム","Greedy's algorithm","Greedy-Algorithmus ? Wikipedia","Greedy-Algorithmus Wikipedia","Greedy-Algorithmus in","Greedy-Algorithmus – Wikipedia","Greedy-Algorithmus).","Greedy-Algorithmus.","Greedy-Verfahren","Greedy.","Greedy_Algorithmus","Greedy_algorithm","Greedyalgorithmus","Grådig algoritme","Here is another source about greedy algorithms","Hladový algoritmus","Hladový algoritmus - Wikipedie","Learn about Greedy algorithm>>>","Mohó Algoritmus","Mohó algoritmus","Mohó algoritmus - Wikipédia","Método voraz - Wikipedia","Programación voraz","Programowanie zachłanne","Read Full Greedy algorithm - Wikipedia, the fr.","Refencias","Screenshot http://de.wikipedia.org/wiki/Greedy-Algorithmus","Seite über ihn","Sie zeichnen sich dadurch aus, dass sie schrittweise","Suggested: greedy algorithm","The Greedy Algorithm","The Greedy Algorithm (Wikipedia)","The Greedy Algorithm has guided Economic Policy .... we","Thuật toán tham lam.","Voraces","What are some examples of Greedy algorithm?","What are the different types of Greedy algorithm","What are the different types of Greedy heuristic","Wikipedia (Algoritmo guloso)","Wikipedia (Greedy algorithm)","Wikipedia - Greedy Algorithmen","Wikipedia Algoritmo voraz","Wikipedia article Ahne algoritmi","Wikipedia article Algorithme glouton","Wikipedia article Algoritmo greedy","Wikipedia article Algoritmo guloso","Wikipedia article Algoritmo irenskor","Wikipedia article Algoritmo voraz","Wikipedia article Exchange algorithm","Wikipedia article Giải thuật tham lam","Wikipedia article Greedy algorithm","Wikipedia article Greedy search","Wikipedia article on Algoritmo voraz","Wikipedia article on Algoritmos voraces","Wikipedia article on Exchange algorithm","Wikipedia article on Greedy Algorithm","Wikipedia article on Greedy algorithm","Wikipedia article Жадный алгоритм","Wikipedia article Жадібний алгоритм","Wikipedia article אלגוריתם חמדן","Wikipedia sur Algorithme glouton","Wikipedia über Greedy-Algorithmen","Wikipedia-Artikel Greedy Algorithmus","Wikipedia-Artikel Greedy-Algorithmen","Wikipedia-Artikel Greedy-Algorithmus","Wikipedia-Seite zu 'Greedy Algorithmus'","Wikipedia-Seite zu 'Greedy-Algorithmen'","Wikipedia-Seite zu 'Greedy-Algorithmus'","Wikipedia: Algoritmo Voraz","Wikipedia: Greedy Algorithm","Wikipedia:Algoritmo_greedy","Wikipedia:Greedy_algorithm","Wikipediaで「欲張り法」を調べる","Wikipediaで「貪欲アルゴリズム」を調べる","Wikipediaで「貪欲法」を調べる","Wikipediaで貪欲法","a greedy approach","ahneella algoritmilla","algorithm-speak","algorithme Glouton","algorithme de glouton","algorithme glouton","algorithme glouton).","algorithme glouton.","algoritm greedy","algoritma greedy","algoritma serakah).","algoritmi greedy","algoritmo ganancioso","algoritmo greedy","algoritmo greedy).","algoritmo greedy.","algoritmo guloso","algoritmo voraz","algoritmo voraz).","algoritmo voraz.","algoritmos glotones","algoritmos gulosos","algoritmos voraces","algorytm zachłanny","algorytmu chciwy","algorytmu zachłannego","algorytmy zachłanne","artigo da Wikipédia Algoritmo ganancioso","artículo de Wikipedia Algoritmo greedy","artículo de Wikipedia Algoritmo voraz","artículo de Wikipedia Algoritmos voraces","avidi di ricerca","chamtivé hledání","chamtivý algoritmus","chamtivý algoritmus.","chamtivý výběr majetek","chamtivý způsobem","chciwy nieruchomości wyboru","chciwy wyszukiwania","cs:Hladový algoritmus","de búsqueda codiciosa","de forma voraz","de:Greedy-Algorithmus","e [","eedy b","eedy be","en.wikipedia.org/...Greedy_algorithm","en.wikipedia.org/wiki/Greedy_algorithm","en.wikipedia.org/wiki/Greedy_algorithm#Cases_of_failure","en:Greedy Algorithm","en:Greedy_algorithm","es.wikipedia.org/...Algoritmo_voraz","es:Algoritmo voraz","estrategia voraz","eu:Algoritmo irenskor","exchange algorithms","fa:الگوریتم حریصانه","fi:Ahne algoritmi","forma codiciosa","fr:Algorithme glouton","geedy","gierige Algorithmus","gierige Auswahl Eigenschaft","gierige Suche","gierigen Weise","gloutonne","golosa","greed algorithm","greed algorithm”","greedie","greediness","greedy algorithims","greedy algorithm - Wikipedia, the free encyclopedia","greedy algorithm,","greedy algorithm.","greedy algorithms","greedy algorithms.","greedy algoritme","greedy algoritme.","greedy approaches","greedy behaviour","greedy choice property","greedy heuristic","greedy heuristics","greedy manner","greedy method","greedy on wiki","greedy path","greedy search","greedy search algorithms","greedy solution","greedy solutions are sometimes the exact wrong thing","greedy strategy","greedy,","greedy_algorithm","gretig algoritme","grådig algoritme","grådig måde","grådige søgning","grådige valg ejendom","gulosos","gulzig algoritme","gulzige wijze","has a definition in the computer science world","he:אלגוריתם חמדן","hebzuchtige zoek","heuristics based non-exploratory Depth First Searches","hladový algoritmus","hladový princip","http://cs.wikipedia.org/wiki/Hladov%C3%BD_algoritmus","http://de.wikipedia.org/wiki/Greedy-A...","http://de.wikipedia.org/wiki/Greedy-Algo","http://de.wikipedia.org/wiki/Greedy-Algorithmus","http://de.wikipedia.org/wiki/Greedy_Algorithmus","http://en.wikipedia....reedy_algorithm","http://en.wikipedia.org/wiki/Greedy_algorith","http://en.wikipedia.org/wiki/Greedy_algorithm","http://en.wikipedia.org/wiki/Greedy_algorithm)","http://en.wikipedia.org/wiki/Greedy_algorithm.","http://en.wikipedia.org/wiki/Greedy_search","http://es.wikipedia.org/wiki/Algoritmo_greedy","http://es.wikipedia.org/wiki/Algoritmo_v...","http://es.wikipedia.org/wiki/Algoritmo_voraz","http://es.wikipedia.org/wiki/Algoritmo_v…","http://eu.wikipedia.org/wiki/Algori","http://fr.wikipedia.org/wiki/Algorithme_glouton","http://he.wikipedia.org/wiki/אלגוריתם_חמדן","http://hu.wikipedia.org/wiki/Moh%C3%B3_algoritmus","http://it.wikipedia.org/wiki/Algoritmo_greedy","http://ja.wikipedia.org/wiki/貪欲法","http://pl.wikipedia.org/wiki/Algorytm_zach%C5%82anny","http://pl.wikipedia.org/wiki/Algorytm_zah%C5%82anny","http://pt.wikipedia.org/wiki/Algoritmo_guloso","http://ru.wikipedia.org/wiki/Жадный_алгоритм","http://sv.wikipedia.org/wiki/Girig_algoritm","hu:Mohó algoritmus","it:Algoritmo greedy","ja.wikipedia.org/wiki/貪欲法","ja:貪欲法","kind of greedy algorithm:","ko:탐욕 알고리즘","ko:탐욕적 알고리즘","metoda zachłanna","modo goloso","mohó algoritmus","mohó algoritmusokkal","more sloppy approach decision making process","méthodes gloutonnes","nada de avaricia","no:Grådig algoritme","non-optimal substructure","pagina op deze","pagina su di esso","pl:Algorytm zachłanny","požrešno metodo","propiedad elección codiciosa","proprietà di scelta greedy","pt:Algoritmo guloso","página en ella","ru:Жадный алгоритм","side på det","sk:Pažravý algoritmus","sl:Požrešna metoda","sr:Похлепни алгоритам","strategie gloutonne","strony to","stránky na to","sv:Girig algoritm","th:ขั้นตอนวิธีแบบละโมบ","tham lam thuật toán).","the Wikipedia article on Greedy Algorithms","ttp://en.wikipedia.org/wiki/Greedy_algorithm","uk:Жадібний алгоритм","vi:Giải thuật tham lam","w:Greedy search","wen:Greedy algorithm","wikipedia page for Greedy Algorithms","wikipedia.org - големия брат","zachłannej","zachłanny algorytm","zh:贪心法","«жадными»","«الگوريتم گريدي»","è²��¬²法 - Wikipedia","άπληστες","Википедии статью Жадный алгоритм","Жадные Алгоритмы","Жадные алгоритмы","Жадный алгоритм","Жадный алгоритм — Википедия","Жадібний алгоритм","жадного","жадного алгоритма","жадного алгоритма).","жадного алгоритма.","жадного выбора","жадные алгоритмы","жадные образом","жадные собственности выбора","жадный алгоритм","жадный алгоритм оптимального","жадный алгоритм.","жадный поиск","жадный»","жадным алгоритмом","жадными алгоритмами","жадных алгоритмов оптимизации","жадібних алгоритмів","жадібного","ищет локальные оптимумы на каждом этапе для поиска","страницы на нем","אלגוריתם חמדן","אלגוריתם חמדן – ויקיפדיה","אלגוריתמים חמדניים","באלגוריתמים חמדנים","האלגוריתם החמדני","ויקיפדיה - 'אלגוריתם חמדן'","חמדני","الگوریتم حرصانه","الگوریتم حریصانه","الگوریتم حریصانه - ویکیپدیا","حریص","خورزميات غريدي الموسوعة الحرة","روش حریصانهٔ","پیوند انگلیسی","پیوند فارسی","गए लालची खोज","लालची एल्गोरिथ्म","लालची ढंग से","है लालची","ขั้น ตอน วิธี โลภ).","ขั้นตอนวิธีละโมภ","ขั้นตอนวิธีแบบละโมบ","โลภ ขั้น ตอน วิธี.","“Greedy algorithm - Wikipedia, the free encyclopedia”, en.wikipedia","“greedy algorithm.”","“greedy” algorithm","“greedy” algorithms","ことのページを","グリーディ法","像一个","它网页上","欲を出して计算方","欲張り法","欲張り法 Wikipedia","維基百科的文章“ 貪婪演算法”","維基百科的文章“ 貪心法”","維基百科的文章“ 贪心法”","維基百科的文章“ 饕餮法”","维基百科的文章“ 贪心法”","貪婪演算法(Greedy Algorithm)","貪婪算法","貪心法","貪心法(greedy)","貪心演算法","貪心算法","貪欲なアルゴリズム","貪欲なアルゴリズムを","貪欲な検索","貪欲な選択プロパティは、","貪欲アルゴリズム","貪欲アルゴリズム - Wikipedia","貪欲アルゴリズムの","貪欲アルゴリズムを","貪欲方法","貪欲法","貪欲法 (wikipediaへのリンク)","貪欲法 - Wikipedia","貪欲法-wikipedia","贪婪地","贪婪搜索","贪婪算法","贪婪算法。","贪心法","贪心法- 维基百科，自由的百科全书","贪心演算法","贪心策略","贪心算法","贪心选择属性","饕餮法","그리디 알고리즘","욕심쟁이 알고리즘과","위키 피 디아 문서 그리디 알고리즘","위키 피 디아 문서 탐욕 알고리즘","위키 피 디아 문서 탐욕적 알고리즘","탐욕 알고리즘","탐욕 알고리즘(greedy algorithm)","탐욕 알고리즘)이라.","탐욕법","탐욕적","탐욕적 방법","ｸﾞﾘｰﾃﾞｨ法(詳細)"],"name":"Greedy algorithm","categories":["Combinatorial algorithms","Commons category with local link same as on Wikidata","Matroid theory","Optimization algorithms and methods"],"tag_line":"A greedy algorithm is an algorithm that follows the problem solving heuristic of making the locally optimal choice at each stage with the hope of finding a global optimum."}}
,{"_index":"throwtable","_type":"algorithm","_id":"simplex-algorithm","_score":0,"_source":{"description":"In mathematical optimization, Dantzig's simplex algorithm (or simplex method) is a popular algorithm for linear programming. The journal Computing in Science and Engineering listed it as one of the top 10 algorithms of the twentieth century.\nThe name of the algorithm is derived from the concept of a simplex and was suggested by T. S. Motzkin. Simplices are not actually used in the method, but one interpretation of it is that it operates on simplicial cones, and these become proper simplices with an additional constraint. The simplicial cones in question are the corners (i.e., the neighborhoods of the vertices) of a geometric object called a polytope. The shape of this polytope is defined by the constraints applied to the objective function.","alt_names":["http://es.wikipedia.org/wiki/Algoritmo_s…","Simplex algorithm","симплекс-метод","单纯形算法","Simplex Method","Simplex method","it.wikipedia.org/wiki/Met…","simplex method","- Simplex algorithm :","- Simplex method :","-> Leggi tutto l'articolo su 'Algoritmo del simplesso","-> Read the article about 'Simplex algorithm'","... kann man in das vorher beschriebene simplex tableau","...Wikipedia Algorithme du simplexe","...Wikipedia Algoritmo del simplesso","...Wikipedia Algoritmo simplex","...Wikipedia Algorytm sympleksowy","...mehr auf Wikipedia über Simplex-Verfahren","...more on Wikipedia about Simplex algorithm","1947: Simplex method for linear programming","2. The Simplex Method for Linear Programming","3) SIMPLEX ALGORITHM FROM Wikipedia","59ebc58215354326fafd053492366b ...","Algorithme du simplexe","Algorithme du simplexe - Wikip?dia","Algorithme du simplexe - Wikipédia","Algorithme du simplexe - Wikipédia http://fr.wikipedia.org","Algorithme_du_simplexe","Algoritm simplex","Algoritmo Simplex en Wikipedia","Algoritmo del simplesso","Algoritmo del simplesso - Wikipedia","Algoritmo del simplex","Algoritmo simplex","Algoritmo simplex - Wikipedia, la enciclopedia libre","Algoritmo simplex - Wikipédia, a enciclopédia livre","Algoritmo simplex ? Wikip?dia, a enciclop?dia livre","Algoritmo simplex – Wikipédia, a enciclopédia livre","Algoritmo símplex","Algoritmo símplex - Wikipedia, la enciclopedia libre","Algorytm sympleksowy","Algorytm sympleksowy – Wikipedia, wolna encyklopedia","Canonical tableaux","Dantzig-Wolfe Decomposition","Die Grundidee des Simplex-Verfahrens wurde 1947 von","Download Simplex Method Calculator Code In Visual Basic","External reference: Wikipedia","Good starting point for simplex (see refs. at","L'algorithme de Simplexe","L'algorithme du simplexe","L'algoritmo Simplex","Learn about Simplex algorithm>>>","Metodo del simplesso","Método simplex","Pivot operations","SIMPEX method dalam Linear Programming","Screenshot http://de.wikipedia.org/wiki/Simplex-Verfahren","See Nelder–Mead method for the downhill simplex","Simpelxtableau","Simpleks algoritam","Simplex Algorithm","Simplex Algorithm - Wikipedia","Simplex Algorithm - Wikipedia, The Free Encyclopedia","Simplex Algorithm Discussion","Simplex Algorithm from Wikipedia","Simplex Algorithm in Wikipedia","Simplex Algorithmus","Simplex Algorithmus in der Wikipedia","Simplex Tableau","Simplex algorith","Simplex algorithm - Wikipedia :: The free encyclopedia","Simplex algorithm - Wikipedia, the free encyclopedia","Simplex algorithm Wikipedia the free encyclopedia","Simplex algorithm Wikipedia the free encyclopedia - result","Simplex algorithm Wikipedia, the free ...","Simplex algorithm by Nelder and Mead","Simplex algorithm of Dantzig","Simplex algorithm.","Simplex algoritma","Simplex algoritması","Simplex algoritme","Simplex algoritmen","Simplex algoritmo","Simplex algoritmus","Simplex algoritmus,","Simplex bei Wikipedia","Simplex method - Simplex algorithm","Simplex methods","Simplex metoden","Simplex optimization algorithm","Simplex search","Simplex алгоритма","Simplex- Algorithmus","Simplex-Algorithm","Simplex-Algorithmus","Simplex-Algoritmus","Simplex-Methode","Simplex-Tableau","Simplex-Verfahren","Simplex-Verfahren - Wikipedia","Simplex-Verfahren ? Wikipedia","Simplex-Verfahren â Wikipedia","Simplex-Verfahren â€“ Wikipedia","Simplex-Verfahren – Wikipedia","Simplex-Verfahrens","Simplex-algoritme","Simplex-algoritmen","Simplex-algoritmen - Wikipedia","Simplex-based methods","Simplex-metoden","Simplex_algorithm","Simplex_method","Simplex_search","Simplexalgoritme","Simplexe sur wikipedia","Simplexmethode","Simplexmethode - Wikipedia","Simplexmetoden","Simplexní algoritmus","Simplexová metóda - Wikipédia","Simplexový algoritmus","Simplexový algoritmus - Wikipedie","Simplextableaus","Simplexverfahren","Simplexverfahrens","Simplexアルゴリズム","Surplus Variable","Surplus variable","Surplus variable - Wikipedia, the free encyclopedia","Szimplex módszer,","The Simplex Algorithm for solving linear programming problems","The Simplex Method: Solving Standard Maximization Problems","The Simplex method","What is the example of Surplus variable","What is the example of Surplus variable?","WikiPedia.ja:シンプレックス法","Wikipedia (Algoritmo simplex)","Wikipedia - Simplex Algorithm","Wikipedia - Simplex algorithm","Wikipedia : Simplex Algorithm","Wikipedia Algoritmo simplex","Wikipedia article Algorithme du simplexe","Wikipedia article Algoritmo del simplesso","Wikipedia article Algoritmo simplex","Wikipedia article Algoritmo símplex","Wikipedia article Algorytm sympleksowy","Wikipedia article Simplex algorithm","Wikipedia article Simplex-Verfahren","Wikipedia article Simplexmethode","Wikipedia article Surplus variable","Wikipedia article on Algoritmo simplex","Wikipedia article on Método simplex","Wikipedia article on Simplex search","Wikipedia article on Surplus variable","Wikipedia article Симплекс-метод","Wikipedia article שיטת הסימפלקס","Wikipedia entry for Simplex algorithm","Wikipedia entry for Surplus variable","Wikipedia l'articolo Algoritmo del simplesso","Wikipedia の（線形計画法の）シンプレックス法の解説","Wikipedia-Artikel Simplex-Algorithmus","Wikipedia-Artikel Simplex-Tableau","Wikipedia-Artikel Simplex-Verfahren","Wikipedia-Artikel Simplexverfahren","Wikipedia-Seite zu 'Simplex-Algorithmus'","Wikipedia-Seite zu 'Simplex-Verfahren'","Wikipedia-Seite zu 'Simplexverfahren'","Wikipedia.jp:シンプレックス法","Wikipedia: Simplex-Verfahren","Wikipedia:Metodo_del_simplesso","Wikipedia:Simplex_algorithm","Wikipedia:Surplus_variable","Wikipediaで「シンプレックス法」を調べる","Wikipediaで「単体法」を調べる","Wikipédia artigo Método simplex","[http://en.wikipedia.org/wiki/Simplex_algorithm]","algorisme simplex","algorithme du Simplex","algorithme du Simplexe","algorithme du simplexe","algoritma simpleks","algoritmo Simplex","algoritmo de simplex","algoritmo del Simplesso","algoritmo del Simplex","algoritmo del simplesso","algoritmo del símplex","algoritmo di simplesso","algoritmo simple","algoritmo simplex","algoritmo símplex","algoritmul simplex","algorytm Simplex","algorytm sympleksowy","algorytmu simplex","artigo da Wikipédia Algoritmo simplex","artículo de Wikipedia Algoritmo del simplex","artículo de Wikipedia Método simplex","augemented form of the simplex algorithm","basic feasible solutions","cc89b7e16f7150948987a632e43cc ...","de simplexmethode","de.wikipedia.org/wiki/Simplex-Verfahren","de.wikipedia.org/wiki/Simplexverfahren","den simplex algoritmen","der Simplex-Algorithmus","el algoritmo de símplex","el algoritmo simplex","en.wikipedia.org/...Simplex_algorithm","en.wikipedia.org/wiki/Simplex_algorithm","en:Simplex_method","es.wikipedia.org/wiki/Algoritmo_s%C3%ADmplex","es.wikipedia.org/wiki/Algoritmo_simplex","es:Algoritmo símplex","eu:Simplex algoritmo","extensions of the simplex algorithm","http://cs.wikipedia.org/wiki/Simplexov%C3%BD_algoritmus","http://de.wikipedia.org/wiki/Si mplex-Verfahren","http://de.wikipedia.org/wiki/Simplex-Alg..._Simplexschritt","http://de.wikipedia.org/wiki/Simplex-Algorithmus","http://de.wikipedia.org/wiki/Simplex-Algorithmus#Ein_einzelner_Simplexschritt","http://de.wikipedia.org/wiki/Simplex-Tableau#Das_Simplex","http://de.wikipedia.org/wiki/Simplex-Ver","http://de.wikipedia.org/wiki/Simplex-Ver...#Simplextableau","http://de.wikipedia.org/wiki/Simplex-Ver...eispielrechnung","http://de.wikipedia.org/wiki/Simplex-Verfahren","http://de.wikipedia.org/wiki/Simplex-Verfahren#Beispielrechnung","http://de.wikipedia.org/wiki/Simplex-Verfahren#Simplextableau","http://de.wikipedia.org/wiki/Simplex-Ver…","http://de.wikipedia.org/wiki/Simplexverfahren","http://de.wikipedia.org/wiki/Simplex−Verfahren","http://en.wikipedia....mplex_algorithm","http://en.wikipedia.org/wiki/Simplex_Algorithm","http://en.wikipedia.org/wiki/Simplex_alg","http://en.wikipedia.org/wiki/Simplex_algorith...","http://en.wikipedia.org/wiki/Simplex_algorithm","http://en.wikipedia.org/wiki/Simplex_algorithm (External Link","http://en.wikipedia.org/wiki/Simplex_algorithm#The_simplex_algorithm_in_linear_programming","http://en.wikipedia.org/wiki/Simplex_algorithm#cite_note-0","http://en.wikipedia.org/wiki/Simplex_algorithm) f","http://en.wikipedia.org/wiki/Simplex_algo…","http://en.wikipedia.org/wiki/Simplex_alg…","http://en.wikipedia.org/wiki/Simplex_method","http://en.wikipedia.org/wiki/Simplex_met…","http://en.wikipedia.org/wiki/Simplex_search","http://en.wikipedia.org/wiki/Surplus_var","http://en.wikipedia.org/wiki/Surplus_variable","http://es.wikipedia.org/wiki/Algoritmo_s%C3%ADmplex","http://es.wikipedia.org/wiki/Algoritmo_simplex","http://es.wikipedia.org/wiki/M%C3%A9todo_simplex","http://eu.wikipedia.org/wiki/Simplex_algoritmo","http://eu.wikipedia.org/wiki/Simplex_metodo","http://fr.wikipedia.org/wiki/Algorithme_du_simplexe","http://it.wikipedia....o_del_simplesso","http://it.wikipedia.org/wiki/Algoritmo_del_simplesso","http://it.wikipedia.org/wiki/Metodo_del_simplesso","http://nl.wikipedia.org/wiki/Simplexmethode","http://pl.wikipedia.org/wiki/Algorytm_sympleksowy","http://pl.wikipedia.org/wiki/Metoda_simpleks","http://pt.wikipedia.org/wiki/Algoritmo_simplex","http://ru.wikiped...0%BE%D0%B4","http://ru.wikipedia.org/wiki/Симплекс-ме...","http://ru.wikipedia.org/wiki/Симплекс-метод","http://ru.wikipedia.org/wiki/Симплекс_метод","http://sk.wikipedia.org/wiki/Simplexov%C3%A1_met","http://uk.wikipedia.org/wiki/Симплекс-ме...","ko:심플렉스법","l' algorithme_du_simplexe","l'algoritmo del simplesso","l'algoritmo simplex","lalgoritmo del simplesso","less detail","linear programming simplex problem","méthode du simplexe","método Simplex","método do simplex","método simplex","método símplex","m�todo simplex","più efficiente delle realizzazioni possibili","pt.wikipedia.org/...Algoritmo_simplex","revised simplex method","ro:Algoritm simplex","ro:Algoritmul simplex","ru:Симплекс-метод","sh:Simpleks algoritam","simpleks algoritam","simpleksalgoritmen","simplex algorithm","simplex algorithm of Dantzig","simplex algorithm wikipedia the free encyclopedia","simplex algorithms","simplex algoritme","simplex algoritme van Dantzig","simplex algoritmoa","simplex crawler","simplex methods","simplex search","simplex solver","simplex | Simplex-Verfahren – Wikipedia","simplex метода","simplex-algoritme","simplex-algoritmin","simplex-based","simplexalgoritme","simplexi algoritmi","simplexmethode","simplexní algoritmus","simplexový algoritmus","simplextableau","sk:Simplexová metóda","szimplex módszer","the Simplex Algorithm","the Simplex algorithm","the simplex","the simplex algorithm","thuật toán Simplex","thuật toán đơn giản","two-phase simplex method","van de simplex-algoritme","wiki on Simplex algorithm","» Simplex algorithm (En)","» Simplexová metóda (Sk)","đơn giản","Описание Симплекс-метода","Симпл","Симплекс алгоритм","Симплекс метод","Симплекс-алгоритм","Симплекс-метод","Симплекс-метод (Материал из Википедии)","Симплекс-метод — Википедия","Симплексный алгоритм","алгоритм симплекс","или здесь посмотрите","математически описан метод","простого алгоритма","симплекс-алгоритм","симплекс-метода","симплекс-методе","симплекс-методом","симплекс-методом.","симплексного метода","симплексном методе","симплексный алгоритм","דוגמאות נגדיות","שיטת הסימפלקס","שיטת הסימפלקס – ויקיפדיה","طريقة التبسيط","طريقة التبسيط (برمجة)","طﯾﺳﺑﺗﻟا ﺔﻘﯾرطو","وطريقة التبسيط","सरल एल्गोरिथ्म","ขั้น ตอน วิธี Simplex","วิธี simplex","「シンプレックス法」をWikipediaで調べる","「単体法」についてWikipediaで調査","『シンプレックス法』の解説","ウィキペディアの記事 シンプレックス法","ウィキペディアの記事 単体法","シンプレクスは、","シンプレックスアルゴリズム","シンプレックス法","シンプレックス法 - Wikipedia","シンプレックス法 -wikipedia","シンプレックス法 – Wikipedia","单纯形方法","单纯形法- 维基百科，自由的百科全书","单纯的算法","単体法","単体法 -wikipedia","單純形","單純形法","單純形算法","簡捷法","維基百科的文章“ 簡捷法”","線形計画法で登場するシンプレックス法","線形計画法で登場するｼﾝﾌﾟﾚｯｸｽ法","维基百科的文章“ 簡捷法”","단순 알고리즘은","단순 알고리즘을","단순는","심플렉스법","심플렉스법 - 위키백과, 우리 모두의 백과사전","위키 피 디아 문서 심플렉스법","을 단순","𝐜 B"],"name":"Simplex algorithm","categories":["1947 in computer science","Exchange algorithms","Linear programming","Operations research","Optimization algorithms and methods"],"tag_line":"In mathematical optimization, Dantzig's simplex algorithm (or simplex method) is a popular algorithm for linear programming."}}
,{"_index":"throwtable","_type":"algorithm","_id":"branch-and-bound","_score":0,"_source":{"description":"Branch and bound (BB or B&B) is an algorithm design paradigm for discrete and combinatorial optimization problems, as well as general real valued problems. A branch-and-bound algorithm consists of a systematic enumeration of candidate solutions by means of state space search: the set of candidate solutions is thought of as forming a rooted tree with the full set at the root. The algorithm explores branches of this tree, which represent subsets of the solution set. Before enumerating the candidate solutions of a branch, the branch is checked against upper and lower estimated bounds on the optimal solution, and is discarded if it cannot produce a better solution than the best one found so far by the algorithm.\nThe algorithm depends on the efficient estimation of the lower and upper bounds of a region/branch of the search space and approaches exhaustive enumeration as the size (n-dimensional volume) of the region tends to zero.\nThe method was first proposed by A. H. Land and A. G. Doig in 1960 for discrete programming, and has become the most commonly used tool for solving NP-hard optimization problems. The name \"branch and bound\" first occurred in the work of Little et al. on the traveling salesman problem.","alt_names":["Branch and bound","% http://en.wikipedia.org/wiki/Branch% 5Fand 5Fbound","%% 5Fbound 5Fand http://en.wikipedia.org/wiki/Branch","(«Дерево решений»","- Branch and bound :","-> Read more about Branch and bound","-> Read the article about 'Branch and bound'","...mehr auf Wikipedia über Branch-and-Bound","...more on Wikipedia about Branch and bound","5Fbound http://en.wikipedia.org/wiki/Branch%% 5Fand","Branch & Bound","Branch & Bound Verfahren","Branch & Bound: The Algorithm","Branch & bound","Branch And Bound","Branch and Bound","Branch and Bound Algorithm","Branch and Bound.","Branch and bound - Wikipedia","Branch and bound - Wikipedia, the free encyclopedia","Branch and bound - Wikipedia, the free encyclopedia ...","Branch and bound algorithm","Branch and bound na Wikipedia","Branch and bound searching","Branch and bound wiki","Branch and bound.","Branch and bound; it is used under the","Branch at nakatali.","Branch e bound","Branch en gebonden","Branch i związany","Branch og Bound","Branch og bundet","Branch y envolvente.","Branch&Bound","Branch&bound","Branch-And-Bound-Verfahren","Branch-and-Bound","Branch-and-Bound ? Wikipedia","Branch-and-Bound algorithm","Branch-and-Bound bei der wikipedia","Branch-and-Bound – Wikipedia","Branch-and-Bound-Verfahren","Branch-and-Bound-Verfahrens","Branch-and-bound","Branch-and-bound algorithm","Branch-and-bound from Wikipedia","Branch-and-bound search","BranchAndBound","Branch_and_Bound","Branch_and_Bound bei der wikipedia","Branch_and_bound","Branch_and_bound bei der wikipedia","Cabang dan terikat.","Chi nhánh và ràng buộc.","Ejemplos de problemas usando Ramificación y poda","Metoda větví a mezí","Présentation succinte de la méthode sur Wikipedia","Ramificaci?n y poda - Wikipedia, la enciclopedia libre","Ramificación y Poda","Ramificación y acotación","Ramificación y poda","Ramificación y poda (Branch and bound)","Ramificación y poda - Wikipedia","Ramificación y poda - Wikipedia, la enciclopedia libre","Ramificación y poda wiki","Ramificación_y_poda","S 1 , S 2 , ...","S?paration et ?valuation - Wikip?dia","Sudoku ramificació i poda","Séparation et évaluation","Séparation et évaluation - Wikipédia","Un algorithme par séparation et évaluation, également appelé","What is general description of Branch and bound","Wikipedia (Branch and bound)","Wikipedia : Branch and bound","Wikipedia Ramificación y poda","Wikipedia article Branch and Bound","Wikipedia article Branch and bound","Wikipedia article Branch-and-bound","Wikipedia article Séparation et évaluation","Wikipedia article about Branch-and-bound","Wikipedia article on Branch and Bound","Wikipedia article on Branch and bound","Wikipedia article on Branch-and-bound","Wikipedia article on Ramificación y poda","Wikipedia article Метод гілок і меж","Wikipedia entry on branch and bound","Wikipedia l'articolo Branch and bound","Wikipedia sur Séparation et évaluation","Wikipedia-Artikel Branch and Bound","Wikipedia-Artikel Branch and bound","Wikipedia-Artikel Branch-and-Bound","Wikipedia-Seite zu 'Branch and bound'","Wikipedia-Seite zu 'Branch-and-Bound'","Wikipedia: Branch and Bound","Wikipedia:Branch_and_bound","artículo de Wikipedia Branch and Bound","artículo de Wikipedia Ramificación y acotación","branch & bound","branch & bound optimization","branch and bound","branch and bound algorithm","branch and bound algorithms","branch and bound method","branch-and-bound","branch-and-bound algorithm","branch-bound","branch-n-bound","branch_and_bound","brancher et borner","branché et borné","branży i związane","ca:Sudoku ramificació i poda","cs:Metoda větví a mezí","dal ve sınır","de ramificación y acotación","de.wikipedia.org/wiki/Branch-and-Bound","de.wikipedia.org/wiki/Branch_and_Bound","de:Branch-and-Bound","ed Branch-and-Bound","elágazás korláttal","en.wikipedia.org/...Branch_and_bound","en.wikipedia.org/wiki/Branch_a nd_bound","en.wikipedia.org/wiki/Branch_and_bound","es.wikipedia.org/wiki/Ramificaci%C3%B3n_y_poda","es:Ramificación y poda","fa:شاخه و حد","fr:Séparation et évaluation","gren och bunden","gren og bundet","http://cs.wikipedia.org/wiki/Metoda_v%C4%9Btv","http://de.wikipedia.org/wiki/Branch-and-Bound","http://de.wikipedia.org/wiki/Branch_and_Bound","http://de.wikipedia.org/wiki/Branch_and_bound","http://de.wikipedia.org/wiki/Branch_and_…","http://en.wikipedia.org/wiki/Branch 5Fbound%% 5Fand","http://en.wikipedia.org/wiki/Branch% 5Fand 5Fbound","http://en.wikipedia.org/wiki/Branch% 5Fand% 5Fbound","http://en.wikipedia.org/wiki/Branch% 5Fbound 5Fand","http://en.wikipedia.org/wiki/Branch% 5Fbound% 5Fand","http://en.wikipedia.org/wiki/Branch%5Fand%5Fbound","http://en.wikipedia.org/wiki/Branch_and_","http://en.wikipedia.org/wiki/Branch_and_boun","http://en.wikipedia.org/wiki/Branch_and_bound","http://en.wikipedia.org/wiki/Branch_and_bound (External Link","http://en.wikipedia.org/wiki/Branch_and_bound.","http://en.wikipedia.org/wiki/Branch_and_…","http://en.wikipedia.org/wiki/Branch％5Fand％5Fbound","http://en.wikipedia.org/wiki/Branch％の5Fand","http://es.wikipedia.org/wiki/Branch_and_Bound","http://es.wikipedia.org/wiki/Ramificaci%C3%B3n_y_acotaci","http://es.wikipedia.org/wiki/Ramificaci%C3%B3n_y_poda","http://fr.wikipedia.org/wiki/Branch_and_bound","http://fr.wikipedia.org/wiki/S%C3% [...] 9valuation","http://fr.wikipedia.org/wiki/S%C3%A9paration_et_","http://fr.wikipedia.org/wiki/Séparation_et_évaluation","http://it.wikipedia.org/wiki/Branch_and_bound","http://it.wikipedia.org/wiki/Branch_and_…","http://j.mp/6uKNGm","http://ru.wikipedia.org/wiki/Метод_ветвей_и_границ","it:Branch and bound","ja:分枝限定法","ko:분기 한정법","konárov a medzí","method of branches and boundaries","método de ramificación y poda","oddziału oraz związany","procédure par séparation et évaluation","pt:Branch and bound","ramificación y poda","ru:Метод ветвей и границ","séparation et évaluation","the Branch and Bound algorithm","uk:Метод гілок і меж","vázán pobočky a","větví a mezí","«Дерево решений»","Дерево рішень","Метод ветвей и границ","бранша и обвързани","ветвей и границ","ветвей и границ.","метод ветвей и границ","метода Ветвей и Границ","метода ветвей и границ","методах ветвей и границ","методе ветвей и границ","методом ветвей и границ","отсев подмножеств","شاخه و حد - ویکیپدیا","شاخه و کران","इस्तेमाल किया शाखा","शाखा और बन्धे","สาขา และ ผูกพัน.","ウィキペディアの記事 分枝限定法","ブランチは、バインドされた","分支定界","分枝界限","分枝限定","分枝限定法","分枝限定法 - Wikipedia","分枝限定法(英文)","分枝限定法-wikipedia","分枝限定法とは？ (Wikipediaへのリンク)","支店とバインドされた","科和約束","科和约束","분기 한정법","분기 한정법 - 위키백과, 우리 모두의 백과사전","분기한정법","위키 피 디아 문서 분기 한정법","지점 및 바인딩."],"name":"Branch and bound","categories":["All articles with unsourced statements","Articles with unsourced statements from July 2015","Articles with unsourced statements from September 2015","Combinatorial optimization","Optimization algorithms and methods","Wikipedia articles needing clarification from July 2015"],"tag_line":"Branch and bound (BB or B&B) is an algorithm design paradigm for discrete and combinatorial optimization problems, as well as general real valued problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"verhoeff-algorithm","_score":0,"_source":{"description":"The Verhoeff algorithm is a checksum formula for error detection developed by the Dutch mathematician Jacobus Verhoeff and was first published in 1969. It was the first decimal check digit algorithm which detects all single-digit errors, and all transposition errors involving two adjacent digits, which was at the time thought impossible with such a code.","alt_names":["- Verhoeff algorithm :","Els càlculs i camps Definir","Verhoeff Algorithm","Verhoeff Algorithm Wikipeda Entry","Verhoeff Algorithmus","Verhoeff Algorithmus.","Verhoeff algorithm","Verhoeff algorithm (Wikipedia)","Verhoeff algorithm - Wikipedia :: The free encyclopedia","Verhoeff algorithm - Wikipedia, the free encyclopedia","Verhoeff algorithm Wikipedia the free encyclopedia","Verhoeff algorithm; it is used under the","Verhoeff algoritme","Verhoeff algoritmu","Verhoeff checksum algorithm","Verhoeff алгоритм","Verhoeff एल्गोरिथ्म","Verhoeff 알고리즘을했다.","Verhoeff-algoritme","Verhoeff_algorithm","Verhoeffová","Verhoeffは","Verhoeffアルゴリズム","Verhoeffアルゴリズムを","Verhoeff算法","What is algorithm of Verhoeff algorithm","Wikipedia * - Verhoeff algorithm","Wikipedia - Verhoeff algorithm","Wikipedia article Verhoeff algorithm","Wikipedia article Verhoeff_algorithm","Wikipedia entry for Verhoeff algorithm","algoritma Verhoeff.","algoritmo Verhoeff","algoritmo de Verhoeff.","algorytmu Verhoeff","http://en.wikipedia....hoeff_algorithm","http://en.wikipedia.org/wiki/Verhoeff_al","http://en.wikipedia.org/wiki/Verhoeff_algorit hm","http://en.wikipedia.org/wiki/Verhoeff_algorit...","http://en.wikipedia.org/wiki/Verhoeff_algorithm","l'algorithme de Verhoeff.","l'algoritmo Verhoeff","l'algoritmo Verhoeff.","thuật toán Verhoeff.","yago-res:Verhoeff algorithm","Алгоритм Верхоффа","алгоритм Верхоффа","алгоритма Verhoeff.","ขั้น ตอน วิธี Verhoeff.","費爾赫夫算法","费尔赫夫算法"],"name":"Verhoeff algorithm","categories":["Checksum algorithms","Error detection and correction","Modular arithmetic","Wikipedia articles needing clarification from April 2014"],"tag_line":"The Verhoeff algorithm is a checksum formula for error detection developed by the Dutch mathematician Jacobus Verhoeff and was first published in 1969."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dinic's-algorithm","_score":0,"_source":{"description":"Dinic's algorithm or Dinitz's algorithm is a strongly polynomial algorithm for computing the maximum flow in a flow network, conceived in 1970 by Israeli (formerly Soviet) computer scientist Yefim (Chaim) A. Dinitz. The algorithm runs in  time and is similar to the Edmonds–Karp algorithm, which runs in  time, in that it uses shortest augmenting paths. The introduction of the concepts of the level graph and blocking flow enable Dinic's algorithm to achieve its performance.","alt_names":["- Dinic's algorithm :","Algorithmus von Dinic","Algorithmus von Dinic – Wikipedia","Algorithmus_von_Dinic","Der Algorithmus von Dinic unterscheidet sich vom Edmonds","Dinic","Dinic algorithm Gf1.svg","Dinic algorithm Gf1.svg on the Commons website","Dinic s algorithm - Wikipedia, the free encyclopedia","Dinic&#39;s algorithm - Wikipedia, the free encyclopedia","Dinic's Algorithm","Dinic's algorithm","Dinic's algorithm - Wikipedia, the free ...","Dinic's algorithm - Wikipedia, the free encyclopedia","Dinic's algorithm by Wikipedia","Dinic-Algorithmus","Dinic-Algorithmus - Wikipedia","Dinic-Algorithmus bei Wikipedia","Dinicův algoritmus","Dinitz blocking flow algorithm","What is the history of Dinic's algorithm","Wikipedia-Artikel Algorithmus von Dinic","Wikipedia-Seite zu 'Algorithmus von Dinic'","blocking flow","http://commons.wikimedia.org/wiki/File:Dinic_algorithm_Gf1.svg","http://cs.wikipedia.org/wiki/Dinic%C5%AFv_algoritmus","http://de.wikipedia.org/wiki/Algorithmus_von_Dinic","http://de.wikipedia.org/wiki/Dinic-Algorithmus","http://en.wikipedia.org/wiki/Dinic%27s_algorithm","http://en.wikipedia.org/wiki/Dinic's_algorithm","http://en.wikipedia.org/wiki/Dinic's_algorithm#Example","http://en.wikipedia.org/wiki/Dinitz_blocking_flow_algorithm","http://pl.wikipedia.org/wiki/Algorytm_Dynica","Алгоритм Диница","Алгоритм Диница на ru.wikipedia.org","Ефим Диниц","алгоритм Диница","הו, יש לו עמוד משלו באנגלית.","“Dinic's algorithm - Wikipedia, the free encyclopedia”, en.wikipedia"],"name":"Dinic's algorithm","categories":["Graph algorithms","Network flow"],"tag_line":"Dinic's algorithm or Dinitz's algorithm is a strongly polynomial algorithm for computing the maximum flow in a flow network, conceived in 1970 by Israeli (formerly Soviet) computer scientist Yefim (Chaim) A. Dinitz."}}
,{"_index":"throwtable","_type":"algorithm","_id":"clique-percolation-method","_score":0,"_source":{"description":"The clique percolation method is a popular approach for analyzing the overlapping community structure of networks. The term network community (also called a module, cluster or cohesive group) has no widely accepted unique definition and it is usually defined as a group of nodes that are more densely connected to each other than to other nodes in the network. There are numerous alternative methods for detecting communities in networks, for example, the Girvan–Newman algorithm, hierarchical clustering and modularity maximization.","alt_names":["Clique Percolation Method","Clique percolation method","Clique percolation method - Wikipedia, the free encyclopedia","Clique percolation method - Wikipedia, the free encyclopedia ...","Clique percolation method by Wikipedia","What are applications of Clique Percolation Method","What are the definitions of Clique percolation method","Wikipedia article on Clique percolation method","clique percolation","clique percolation method","http://en.wikipedia.org/wiki/Clique Percolation Method","http://en.wikipedia.org/wiki/Clique_percolation_method","k-clique percolation","yago-res:Clique percolation method"],"name":"Clique percolation method","categories":["Clustering algorithms","Graph algorithms","Network analysis","Networks"],"tag_line":"The clique percolation method is a popular approach for analyzing the overlapping community structure of networks."}}
,{"_index":"throwtable","_type":"algorithm","_id":"color-coding","_score":0,"_source":{"description":"In computer science and graph theory, the method of color-coding efficiently finds k-vertex simple paths, k-vertex cycles, and other small subgraphs within a given graph using probabilistic algorithms, which can then be derandomized and turned into deterministic algorithms. This method shows that many subcases of the subgraph isomorphism problem (an NP-complete problem) can in fact be solved in polynomial time.\nThe theory and analysis of the color-coding method was proposed in 1994 by Noga Alon, Raphael Yuster, and Uri Zwick.","alt_names":["Color-coding","- Color-coding :","Color-coding - Wikipedia, the free encyclopedia","Color-coding on wikipedia.org","Color-coding |","Color-coding; it is used under the","Wikipedia article Color-coding","Wikipedia article on Color-coding","color-coded t","http://en.Liarpedia.org/wiki/2003 Arena Football","http://en.wikipedia.org/wiki/Color-coding","http://en.wikipedia.org/wiki/Color-coding."],"name":"Color-coding","categories":["Graph algorithms"],"tag_line":"In computer science and graph theory, the method of color-coding efficiently finds k-vertex simple paths, k-vertex cycles, and other small subgraphs within a given graph using probabilistic algorithms, which can then be derandomized and turned into deterministic algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"contraction-hierarchies","_score":0,"_source":{"description":"In applied mathematics, the method of contraction hierarchies is a technique to speed up shortest-path routing by first creating precomputed \"contracted\" versions of the connection graph. It can be regarded as a special case of \"highway-node routing\".\nContraction hierarchies can be used to generate shortest-path routes much more efficiently than Dijkstra's algorithm or previous highway-node routing approaches, and is used in many advanced routing techniques. It is publicly available in open source software to calculate routes from one place to another.","alt_names":["Contraction Hierarchies","Contraction hierarchies","Contraction hierarchies - Wikipedia, the free encyclopedia","Contraction hierarchies by Wikipedia","Wikipedia article on Contraction Hierarchies","contraction hierarchies technique","en.wikipedia.org/...Contraction_hierarchies","http://en.wikipedia.org/wiki/Contraction_hierarchies"],"name":"Contraction hierarchies","categories":["Graph algorithms","Routing algorithms"],"tag_line":"In applied mathematics, the method of contraction hierarchies is a technique to speed up shortest-path routing by first creating precomputed \"contracted\" versions of the connection graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"topological-sorting","_score":0,"_source":{"description":"In the field of computer science, a topological sort (sometimes abbreviated toposort) or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. For instance, the vertices of the graph may represent tasks to be performed, and the edges may represent constraints that one task must be performed before another; in this application, a topological ordering is just a valid sequence for the tasks. A topological ordering is possible if and only if the graph has no directed cycles, that is, if it is a directed acyclic graph (DAG). Any DAG has at least one topological ordering, and algorithms are known for constructing a topological ordering of any DAG in linear time.","alt_names":["a lot easier","dependency resolution","*Ordenación *topológica de um *grafo","- Topological sort :","...irected_acyclic_graph.png","...mehr auf Wikipedia über Topologische Sortierung","...more on Wikipedia about Topological sorting","3 Uniqueness","4 Relation to partial orders","4.3 Topological sorting","An efficient (linear) algorithm for topological sorting is","Arten topologischer","Artikel über topologische Sortierung in Wikipedia","Bearbeiten Azyklische Graphen und topologische Sortierungen","DAGの","Daniel J. Lasser","Dependency resolution","Die Aufgabe des topologischen Sortierens ist nun, zu","Jarnagin 1960","Kahn's * pseudo code","Kahn's algorithm","Lecture #18: Topological Sort","Orden topológico","Ordenaci?n topol?gica - Wikipedia, la enciclopedia libre","Ordenaci³#N topol³ de um grafo","Ordenación topológica","Ordenación topológica - Wikipedia, la enciclopedia libre","Ordenación topológica de un grafo","Ordenación topológica para grafos","Ordenação Topológica na Wikipedia","Ordenação topológica","Ordina Topological","Ordina topologica","Ordinamento topologico","Ordinamento topologico - Wikipedia","Phân loại topo","Read More About topological sorting wikipedia the free","Reference: Topological sorting","Relation to partial ...","Sortowanie topologiczne","Sortowanie topologiczne – Wikipedia, wolna encyklopedia","Topologicaal Sort","Topological Ordering","Topological Sort","Topological Sort Wiki","Topological Sorting","Topological ordering","Topological sort","Topological sortieren","Topological sorting","Topological sorting - Wikipedia","Topological sorting - Wikipedia, the free encyclopedia","Topological sorting by Wikipedia","Topological sorting from Wikipedia","Topological sorting of a graph","Topological sorting.","Topological क्रमबद्ध करें","Topological_sort","Topological_sorting","Topologically order","Topologically sorts","Topologicalsort","Topologiche ordinamento","Topologicke","Topologické triedenie","Topologické třídění","Topologikus sorrend","Topologinen lajittelu","Topologisch sorteren","Topologische Sortieren","Topologische Sortierung","Topologische Sortierung - Wikipedia","Topologische Sortierung in","Topologische Sortierung â€“ Wikipedia","Topologische Sortierung – Wikipedia","Topologische_Sortierung","Topologischen Sortierung","Topologisches Sortieren","Topologisches Sortieren - Wikipedia","Topologisk sortering","Topologisk sortering - Wikipedia","Topologiske Sorter","Topologiske sortering","Toposort","Tri topologique","Tri topologique - Wikip?dia","Tri topologique - Wikipédia","Urut topologi","What are algorithms of Topological Sort?","What are some examples of Topological Sort","What are some examples of Topological sort?","WikiPedia:Topological_sort","Wikipedia Article on Topographical Sort","Wikipedia article Ordenación topológica","Wikipedia article Ordenação topológica","Wikipedia article Topological sort","Wikipedia article Topological sorting","Wikipedia article on Topological sort","Wikipedia article on Topological sorting","Wikipedia article Топологічне сортування","Wikipedia entry for Topological sorting","Wikipedia entry for topological sort","Wikipedia page for Topological Sort","Wikipedia page on Topological Sort","Wikipedia-Artikel Topologische Sortierung","Wikipedia-Artikel Topologisches Sortieren","Wikipedia-Seite zu 'Topologische Sortierung'","Wikipedia: Topologische Sortierung","Wikipedia::Topological sorting","Wikipedia::Topological_sorting","Wikipedia:Ordinamento_topologico","a classificação topológica.","a topological sort","beaucoup plus facile","clasificación topológica","classificação topológica","computer science term","de clasificación topológica","de classificação topológica","de.wikipedia.org/wik...ologische_Sortierung","de.wikipedia.org/wik...sentation_im_Rechner","de.wikipedia.org/wiki/Topologische_Sortierung","de:Topologische Sortierung","di ordinamento topologico.","du tri topologique","eine topologische Sortierung","ejemplo muy ilustrativo","el:Τοπολογική ταξινόμηση","en topologisk sortering","en.wikipedia.org/...Topological_sorting","en.wikipedia.org/wiki/Topological_sorting","en.wikipedia.org/wiki/Topological_sorting#Algorithms","es:Ordenación topológica","espécie topológica,","fa:مرتبسازی توپولوژیکی","fa:مرتبسازی موضعی","fi:Topologinen lajittelu","fi:Topologinen_lajittelu","fr:Tri topologique","he:מיון טופולוגי","http://de.wikipedia.org/w...sche_Sortierung","http://de.wikipedia.org/wiki/Topolog...e_Sortierungen","http://de.wikipedia.org/wiki/Topolog...erbare_Graphen","http://de.wikipedia.org/wiki/Topolog...ren#Siehe_auch","http://de.wikipedia.org/wiki/Topologische_Sortierung","http://de.wikipedia.org/wiki/Topologische_Sortierung...","http://de.wikipedia.org/wiki/Topologisches_Sortieren","http://el.wikipedia.org/wiki/Τοπολογική_ταξινόμηση","http://en.wikipedia....logical_sorting","http://en.wikipedia....opological_sort","http://en.wikipedia.org/wiki/Topolog...ing#Algorithms","http://en.wikipedia.org/wiki/Topologica ... Algorithms","http://en.wikipedia.org/wiki/Topological sorting","http://en.wikipedia.org/wiki/Topological_","http://en.wikipedia.org/wiki/Topological_ordering","http://en.wikipedia.org/wiki/Topological_ordering.","http://en.wikipedia.org/wiki/Topological_sort","http://en.wikipedia.org/wiki/Topological_sort...","http://en.wikipedia.org/wiki/Topological_sorting","http://en.wikipedia.org/wiki/Topological_sorting#Algorithms","http://en.wikipedia.org/wiki/Topological_sorting#Examples","http://en.wikipedia.org/wiki/Topological_sorting)","http://en.wikipedia.org/wiki/Topological_sorting.","http://en.wikipedia.org/wiki/Topological_sorting>","http://en.wikipedia.​org/wiki/Topological​_sorting","http://es.wikipedia.org/wiki/Ordenaci%C3%B3n_topol","http://fi.wikipedia.org/wiki/Topologinen_lajittelu","http://fr.wikipedia.org/wiki/Tri_topologique","http://goo.gl/hjFw","http://hu.wikipedia.org/wiki/Topologikus_sorrend","http://it.wikipedia.org/wiki/Ordinamento_topologico","http://pl.wikipedia.org/wiki/Sortowanie_topologiczne","http://pt.wikipedia.org/wiki/Ordena","http://ru.wikipedia.org/wiki/Топологическая_сортировка","hu:Topologikus sorrend","it:Ordinamento topologico","ja:トポロジカルソート","jauh lebih mudah","jenis topologi","l'ordinamento topologico","la clasificación topológica","la clasificación topológica.","la classification topologique","la classificazione topologica","le tri topologique","le tri topologique.","lineare Erweiterung einer Halbordnung","menyortir topologi","molto più facile","muito mais fácil","một dễ dàng hơn rất nhiều","no:Topologisk sortering","on layers","orden topológico","ordenación topológica","ordenación topológica,","ordenado topologicamente","ordenamiento topológico","ordenação topológica","ordenação topológica.","ordinamento topologico","ordinamento topologico,","pemilahan topologi","penyortiran topologi","phân loại topo.","pl:Sortowanie topologiczne","posortować go topologicznie","pt:Ordenação topológica","ru:Топологическая сортировка","sorting topological","sortowania topologicznego","sortowanie topologiczne","sr:Тополошко сортирање","sắp xếp topo,","sắp xếp tô pô","sắp xếp tôpô","tipi topologiche","tipi topologici","tipo topologico","tipo topológico","top-sort","topo phân loại","topo phân loại.","topo sort","topoligically sort","topologi Urut","topologi memilah","topologi penyortiran.","topologi semacam,","topologica di ordinamento.","topological order, aka ancestral order","topological ordering","topological orderings","topological pag-aayos","topological short","topological sort","topological sort (Wikipedia)","topological sort algorithm","topological sort.","topological sorter","topological sorting","topological sorting algorith","topological sorts","topological छँटाई","topological प्रकार","topological सॉर्ट","topological การ เรียง ลำดับ","topological เรียง ลำดับ.","topological-uri-uriin,","topologically sort","topologically sorted","topologically sorts","topologically-sorted list","topologiche Ordina","topologické třídění","topologické uspořádání","topologikus rendezési","topologisch Sortieren","topologisch sorteren","topologisch sortieren","topologische Klassifizierung","topologische Sorteer","topologische Sorteren","topologische Sortierung","topologische Sortierung,","topologische soort","topologische soorten","topologische sorteren","topologische sortering","topologischen Arten","topologischen Sortieren","topologischen Sortierung","topologisk slags","topologisk sortere","topologisk sortering","topologiske slags","topologiske sortering","topológikus sorrendben","tri topologique","tri topologique,","tri topologique.","ttp://de.wikipedia.org/wiki/Topologische_Sortierung)","ttp://en.wikipedia.org/wiki/Topological_sort","two more algorithms for topological sort","tô pô phân loại","uk:Топологічне сортування","un montón más fácil","un ordinamento topologico","un tri topologique","una ordenación topológica","vi:Sắp xếp tô pô","viel einfacher","which appears to have a great page on","which keeps a list of all nodes with","wp:Topological sorting","zadanie 5","zh:拓撲排序","Τοπολογική ταξινόμηση","Τοπολογική ταξινόμηση - Βικιπαίδεια","τοπολογική ταξινόμηση","Топологическая","Топологическая сортировка","Топологическая сортировка,","Топологически сортирует","Топологічне сортування","Тополошко сортирање","алгоритм топологической сортировки графа","на слои","топологическая сортировка","топологически сортирует","топологические виды","топологический рода,","топологических сортировка","топологических сортировки","топологического рода","топологической классификации","топологической рода","топологической сортировке","топологической сортировки","топологической сортировки.","топологической сортировкой","топологическую сортировку","топологично сортиран","ויקיפדיה - 'מיון טופולוגי'","מיון טופולוגי","מיון טופולוגי – ויקיפדיה","مرتبسازی توپولوژیکی","مرتبسازی توپولوژیکی - ویکیپدیا","जैसे तुम","টপোলজিকাল সর্ট","การ เรียง ลำดับ topological.","การเรียงลำดับ topological","ง่ายมาก","จัด เรียง Topological","จัด เรียง topological","อ่านเพิ่มเติมใน Wikipedia","เรียง Topological","「トポロジカルソート」についてWikipediaで調査","「トポロジカルソート」をWikipediaで調べる","「トポロジカルソート」をWikiで調べる","に、）","トポロジカルソート","トポロジカルソート - Wikipedia","トポロジカルソート@","トポロジカルソートは、","トポロジカルソートを","トポロジカル整列","一个变异","一个容易得多","一個容易得多","位相の並べ替え","位相ソートは","位相並べ替え","位相分類","位相的な並べ替え","位相ｿｰﾄ-wikipedia","多くの簡単）","拓扑分类","拓扑排序","拓扑排序- 维基百科，自由的百科全书","拓排序- 维基百科，自由的百科全书","拓撲排序","有向グラフのトポロジカル順序の有無を求めるアルゴリズム","的拓扑排序","这里拓扑排序","순조로울","위상 정렬","위상 정렬,","위상 정렬됩니다.","위상 정렬을"],"name":"Topological sorting","categories":["Articles with example pseudocode","Directed graphs","Graph algorithms","Sorting algorithms"],"tag_line":"In the field of computer science, a topological sort (sometimes abbreviated toposort) or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bogosort","_score":0,"_source":{"description":"In computer science, bogosort (also stupid sort, slowsort, random sort, shotgun sort or monkey sort) is a particularly ineffective sorting algorithm based on the generate and test paradigm. It is not useful for sorting, but may be used for educational purposes, to contrast it with other more realistic algorithms; it has also been used as an example in logic programming. If bogosort were used to sort a deck of cards, it would consist of checking if the deck were in order, and if it were not, throwing the deck into the air, picking the cards up at random, and repeating the process until the deck is sorted. Its name comes from the word bogus.","alt_names":["*Bogosort","- Bogosort :","-> Read the article about 'Bogosort'","...Wikipedia Bogosort","...Wikipedia Stupid sort","...mehr auf Wikipedia über Bogosort","...more on Wikipedia about Bogosort","...more on Wikipedia about Bozo sort","2 Running time and termination","3 Related algorithms","3.1 Bozo sort","3.2 Quantum bogosort","A second idea is based on the joke","An in-joke among computer scientists is that","Bogo Sort","Bogo sort","Bogo 排序算法","Bogo-sort","BogoBusca","BogoSort","BogoSort, na Wikipédia","BogoSort.","Bogosort","Bogosort (engl.)","Bogosort (ou Estou com sort)","Bogosort - Wikipedia","Bogosort - Wikipedia, the free encyclopedia","Bogosort - Wikipédia, a enciclopédia livre","Bogosort - a legineffektívebb rendezési 'algoritmus'","Bogosort Wikip dia, a enciclop dia livre","Bogosort ·","Bogosort – Wikipedia","Bogosort – Wikipédia, a enciclopédia livre","Bogosort!","Bogosort,","Bogosort.","Bogosort; it is used under the","Bogosorter","Bogosortering","Bogosortは","Bogosort보세요!","Bogosort은","Bogo排序","Bogo排序 - 维基百科，自由的百科全书","Bogo排序- 维基百科，自由的百科全书","Bozo Sort","Bozo Sort na wikipedia","Bozo sort","Bozosort","Bozosortを","Definición de Stupid sort más completo","GCJ2011が元ネタ","It also assumes that destroying the universe is","Learn about Bogosort>>>","MonkeySort","Monkeysort","Not the worst.","Quanten bogosort","Quantum BogoSort","Quantum Bogosort","Quantum bogosort","Quantum bogosort: 'The list is then inspected, and","Randomized Exchange Sort","Randomized Exchange Sort; it is used under the","Rastgele değiştirmeli sıralama","Running time and termination","Saçma sıralama","Saçma sıralama - Vikipedi","Stupid Sort","Stupid sort","Stupid sort - Wikipedia, the free encyclopedia","Stupid sort - Wikipedie","Stupid sort!","Stupid sort,","Stupid-Sort","StupidSort","Stupidsort","TIL about Bogosort: the sorting algorithm with a","Totally the most awesome sorting algorithm","Tri stupide","Vishwajith: Bogosort - Wikipedia, the free encyclopedia","Whatever you do, do NOT use bogosort!","Wikipedia (Bogosort)","Wikipedia article Bogosort","Wikipedia article Bozo sort","Wikipedia article Randomized Exchange Sort","Wikipedia article Stupid sort","Wikipedia article about Bogosort","Wikipedia article on Bogosort","Wikipedia article on Stupid sort","Wikipedia artikel Bogosort","Wikipedia entry for Bogosort","Wikipedia-Artikel Bogosort","Wikipedia-Artikel Stupidsort","Wikipedia: Bogosort","algoritmo Bogosort","always do stupid things","an Bogosort angelehnt zu sein","article Bogosort","artigo da Wikipédia Bogosort","artículo de Wikipedia Bogosort","artículo de Wikipedia Stupid sort","beliebter Sortieralgorithmus","bogo sort","bogo-sort","bogoshuffle","bogosort","bogosort algorithm","bogosort cuántica","bogosort efficiently","bogosort kwantowej","bogosort!","bogosort,","bogosorting","bogosorttia","bogosortを","bogosort에","bogosort을","bozo sort","cs:Stupid sort","de.wikipedia.org/wiki/Bogosort","de:Bogosort","editar ligacoes extern","editar ligacoes externas entrada para bogo sort no","en.wikipedia.org/wiki/Bogosort","en.wikipedia.org/wiki/Bogosort#Quantum_Bogosort","en.wikipedia.org/wiki/Bogosort#Quantum_Bogosort)","en.wikipedia.org/wiki/Bogosort#Quantum_bogosort","en:Bogosort","es:Stupid sort","fa:مرتبسازی Bogo","fa:مرتبسازی بوگو","fr:Tri stupide","full wikipedia glory","http://bit.ly/a2ea8p","http://de.wikipedia.org/wiki/Bo gosort","http://de.wikipedia.org/wiki/Bogosort","http://de.wikipedia.org/wiki/Monkeysort","http://en....i/Bogosort","http://en.wikipedia.org/wiki/Bogosort","http://en.wikipedia.org/wiki/Bogosort#Bacon_sort","http://en.wikipedia.org/wiki/Bogosort#Bozo_sort","http://en.wikipedia.org/wiki/Bogosort#Perl_6","http://en.wikipedia.org/wiki/Bogosort#Quantum_Bogosort","http://en.wikipedia.org/wiki/Bogosort#Quantum_bogosort","http://en.wikipedia.org/wiki/Bogosort#Quantum_bogosort.","http://en.wikipedia.org/wiki/Bogosort.","http://en.wikipedia.org/wiki/Bozo_sort","http://en.wikipedia.org/wiki/Randomized_Exchange_Sort","http://en.wikipedia.org/wiki/Stupid_sort","http://es.wikipedia.org/wiki/Stupid_sort","http://fr.wikipedia.org/wiki/Tri_stupide","http://it.wikipedia.org/wiki/Stupid_sort","http://ja.wikipedia.org/wiki/ボゴソート","http://nl.wikipedia.org/wiki/Bogosort","http://pl.wikipedia.org/wiki/Bogosort","http://pt.wikipedia.org/wiki/Bogosort","http://ru.wikipedia.org/wiki/Bogosort","http://t.co/3fONbTn","http://zh.wikipedia.org/wiki/Bogo%E6%8E","implement bogosort","incredibly-poor","ja:ボゴソート","linear-time sorting algorithm","many-worlds bogosort","monkeysort","nl:Bogosort","no:Bogosortering","pl:Bogosort","popular sorting algorithm","pretty inefficient sort algorithms","pt:Bogosort","quantum bogosort","ru:Bogosort","sorting algorithm of evil","sr:Глупи сорт","stupidsort","tr:Saçma sıralama","tri stupide (Bogosort)","uk:Сортування Бого","uma hilária (BogoSort)","vyloženě špatný algoritmus","w:Bogosort#Implementations_in_different_programming_languages","zh:Bogo排序","¿voy bien así?","Глупи сорт","Глупи сорт Википедија","Сортування Бого","احمق","مرتبسازی بوگو","क्वांटम bogosort","「ボゴソート」をWikipediaで調べる","ボゴソート","ボゴソート - Wikipedia","ボゴソートを","ボゾソート","有些","有些完全无用)，每个算法都其优点缺点。程序员须要分析实际应用，去选择及实现算法。理想地，更可以实验多个算法，用实际数据去作出比较。 评论肖舸的实现","維基百科的文章“ Bogo排序”","维基百科的文章“ Bogo排序”","量子Bogo排序","量子bogosortの","ﾎﾞｺﾞｿｰﾄ-wikipedia"],"name":"Bogosort","categories":["Accuracy disputes from November 2015","All accuracy disputes","Articles to be expanded from November 2015","Comparison sorts","Computer humor","Sorting algorithms","Use dmy dates from June 2011"],"tag_line":"In computer science, bogosort (also stupid sort, slowsort, random sort, shotgun sort or monkey sort) is a particularly ineffective sorting algorithm based on the generate and test paradigm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"reverse-delete-algorithm","_score":0,"_source":{"description":"The reverse-delete algorithm is an algorithm in graph theory used to obtain a minimum spanning tree from a given connected, edge-weighted graph. It first appeared in Kruskal (1956), but it should not be confused with Kruskal's algorithm which appears in the same paper. If the graph is disconnected, this algorithm will find a minimum spanning tree for each disconnected part of the graph. The set of these minimum spanning trees is called a minimum spanning forest, which contains every vertex in the graph.\nThis algorithm is a greedy algorithm, choosing the best choice given any situation. It is the reverse of Kruskal's algorithm, which is another greedy algorithm to find a minimum spanning tree. Kruskal’s algorithm starts with an empty graph and adds edges while the Reverse-Delete algorithm starts with the original graph and deletes edges from it. The algorithm works as follows:\nStart with graph G, which contains a list of edges E.\nGo through E in decreasing order of edge weights.\nFor each edge, check if deleting the edge will further disconnect the graph.\nPerform any deletion that does not lead to additional disconnection.","alt_names":["Reverse delete algorithm","Reverse การ ลบ ขั้น ตอน วิธี","Reverse-Delete","Reverse-Delete Algorithm","Reverse-Delete Algorithm.","Reverse-Delete algorithm","Reverse-delete","Reverse-delete algorithm","Reverse-delete algorithm - Wikipedia :: The free encyclopedia","Reverse-delete algorithm - Wikipedia, the free encyclopedia","Reverse-delete algorithm - Wikipedia, the free encyclopedia ...","Reverse-delete algorithm by Wikipedia","Reverse-delete algorithm: Example","Reverse-delete algorithme","Reverse-delete algoritme","Reverse-delete algoritmo","Reverse-delete-Algorithmus","Reverse-menghapus algoritma","Reverse-slette algoritme","Reverse-tanggalin ang algorithm","Reverse-usuwanie algorytm","Reverse-xóa các thuật toán","Reverso-excluir algoritmo","Reverzní odstranění algoritmus","What is the example of Reverse-Delete algorithm","Wikipedia article Reverse-Delete algorithm","Wikipedia article Reverse-delete algorithm","Wikipedia entry for Reverse-delete algorithm","algoritmo inverso-delete","everse-delete algorithm","http://en.wikipedia.org/wiki/Reverse-Delete_algorithm","http://en.wikipedia.org/wiki/Reverse-Delete_algorithm#Running_time","http://en.wikipedia.org/wiki/Reverse-del","http://en.wikipedia.org/wiki/Reverse-delete_algorithm","inversa eliminar algoritmo","reverse-delete algorithm","yago-res:Reverse-delete algorithm","Обратные удалить алгоритма","Обратный алгоритм удаления","उल्टा - हटाना एल्गोरिथ्म","反向删除算法","反向刪除算法","逆のアルゴリズムを削除する","逆削除アルゴリズムでは、","역방향 알고리즘 삭제"],"name":"Reverse-delete algorithm","categories":["Graph algorithms","Spanning tree"],"tag_line":"The reverse-delete algorithm is an algorithm in graph theory used to obtain a minimum spanning tree from a given connected, edge-weighted graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lexicographic-breadth-first-search","_score":0,"_source":{"description":"In computer science, lexicographic breadth-first search or Lex-BFS is a linear time algorithm for ordering the vertices of a graph. The algorithm is different from breadth first search, but it produces an ordering that is consistent with breadth-first search.\nThe lexicographic breadth-first search algorithm is based on the idea of partition refinement and was first developed by Donald J. Rose, Robert E. Tarjan, and George S. Lueker (1976). A more detailed survey of the topic is presented by Corneil (2004). It has been used as a subroutine in other graph algorithms including the recognition of chordal graphs, and optimal coloring of distance-hereditary graphs.","alt_names":["- Lexicographic breadth-first search :","LexBFS","Lexicographic breadth-first","Lexicographic breadth-first search","Lexicographic breadth-first search - Wikipedia, the free ...","Lexicographic breadth-first search - Wikipedia, the free encyclopedia","Lexicographic breadth-first search by Wikipedia","Lexicographic breadthfirst search","What are other applications of Lexicographic breadth-first","Wikipedia article Lexicographic breadth-first search","Wikipedia article on Lex-BFS","Wikipedia entry for Lexicographic breadth-first search","en.wikipedia.org/...cographic_breadth-first_search","http://en.wikipedia.org/wiki/Lexicographic_breadth-first_search","lexicographic BFS","lexicographic breadth-first search","wiki:Lexicographic_breadth-first_search"],"name":"Lexicographic breadth-first search","categories":["Graph algorithms","Search algorithms"],"tag_line":"In computer science, lexicographic breadth-first search or Lex-BFS is a linear time algorithm for ordering the vertices of a graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"adaptive-sort","_score":0,"_source":{"description":"A sorting algorithm falls into the adaptive sort family if it takes advantage of existing order in its input. It benefits from the presortedness in the input sequence – or a limited amount of disorder for various definitions of measures of disorder – and sorts faster. Adaptive sorting is usually performed by modifying existing sorting algorithms.","alt_names":["- Adaptive sort :","Adaptive Sort","Adaptive sort","Adaptive sort - Wikipedia :: The free encyclopedia","Adaptive sort - Wikipedia, the free encyclopedia","Adaptive,","Adaptive_sort","Algoritmi di ordinamento adattivi","Algoritmi di ordinamento adattivi - Wikipedia","Ordinamento adattivo","Straight insertion","What are some examples of Adaptive sort","Wikipedia (Adaptive sort)","Wikipedia article Adaptive sort","Wikipedia article Algoritmi di ordinamento adattivi","Wikipedia article Ordenação adaptativa","Wikipedia article on Adaptive sort","Wikipedia entry for Adaptive sort","adaptive merge sort","adaptive mergesort","adaptive sort","adaptive sorting family","adaptive sorts","http://en.wikipedia.org/wiki/Adaptive_so","http://en.wikipedia.org/wiki/Adaptive_sort","http://it.wikipedia.org/wiki/Algoritmi_di_ordinamento_adattivi","i dati in ingresso sono già parzialmente ordinati","input is already sorted to some degree","it takes advantage of existing order in its","pt:Ordenação adaptativa"],"name":"Adaptive sort","categories":["Sorting algorithms"],"tag_line":"A sorting algorithm falls into the adaptive sort family if it takes advantage of existing order in its input."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cache-oblivious-distribution-sort","_score":0,"_source":{"description":"The cache-oblivious distribution sort is a comparison-based sorting algorithm. It was introduced in 1999 in the context of the cache oblivious model. In the external memory model, the number of memory transfers it needs to perform a sort of  items on a machine with cache of size  and cache lines of length  is , under the tall cache assumption that . This number of memory transfers has been shown to be asymptotically optimal for comparison sorts. This distribution sort also achieves the asymptotically optimal runtime complexity of .","alt_names":[],"name":"Cache-oblivious distribution sort","categories":["All articles lacking reliable references","All articles needing expert attention","All articles that are too technical","All orphaned articles","Analysis of algorithms","Articles lacking reliable references from May 2014","Articles needing expert attention from May 2014","Cache (computing)","Comparison sorts","External memory algorithms","Models of computation","Orphaned articles from May 2014","Sorting algorithms","Wikipedia articles that are too technical from May 2014"],"tag_line":"The cache-oblivious distribution sort is a comparison-based sorting algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"shortest-path-faster-algorithm","_score":0,"_source":{"description":"The Shortest Path Faster Algorithm (SPFA) is an improvement of the Bellman–Ford algorithm which computes single-source shortest paths in a weighted directed graph. The algorithm is believed to work well on random sparse graphs and is particularly suitable for graphs that contain negative-weight edges. However, the worst-case complexity of SPFA is the same as that of Bellman–Ford, so for graphs with nonnegative edge weights Dijkstra's algorithm is preferred. The SPFA algorithm was published in 1994 by Fanding Duan.","alt_names":[],"name":"Shortest Path Faster Algorithm","categories":["Graph algorithms"],"tag_line":"The Shortest Path Faster Algorithm (SPFA) is an improvement of the Bellman–Ford algorithm which computes single-source shortest paths in a weighted directed graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"spectral-layout","_score":0,"_source":{"description":"Spectral layout is a class of algorithm for drawing graphs. The layout uses the eigenvectors of a matrix, such as the Laplace matrix of the graph, as Cartesian coordinates of the graph's vertices.","alt_names":[": layout using as coordinates the","Spectral layout","Spectral layout - Wikipedia, the free encyclopedia","Spectral layout by Wikipedia","Wikipedia article Spectral layout","Wikipedia article on Spectral layout","Wikipedia entry for Spectral layout","http://en.wikipedia.org/wiki/Spectral_layout","spectral layout","yago-res:Spectral layout"],"name":"Spectral layout","categories":["All stub articles","Applied mathematics stubs","Graph algorithms","Graph drawing"],"tag_line":"Spectral layout is a class of algorithm for drawing graphs."}}
,{"_index":"throwtable","_type":"algorithm","_id":"yen's-algorithm","_score":0,"_source":{"description":"Yen's algorithm computes single-source K-shortest loopless paths for a graph with non-negative edge cost. The algorithm was published by Jin Y. Yen in 1971 and employs any shortest path algorithm to find the best path, then proceeds to find K − 1 deviations of the best path.","alt_names":[],"name":"Yen's algorithm","categories":["Articles with example pseudocode","Graph algorithms","Polynomial-time problems"],"tag_line":"Yen's algorithm computes single-source K-shortest loopless paths for a graph with non-negative edge cost."}}
,{"_index":"throwtable","_type":"algorithm","_id":"insertion-sort","_score":0,"_source":{"description":"Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However, insertion sort provides several advantages:\nSimple implementation: Bentley shows a three-line C version, and a five-line optimized version\nEfficient for (quite) small data sets, much like other quadratic sorting algorithms\nMore efficient in practice than most other simple quadratic (i.e., O(n2)) algorithms such as selection sort or bubble sort\nAdaptive, i.e., efficient for data sets that are already substantially sorted: the time complexity is O(nk) when each element in the input is no more than k places away from its sorted position\nStable; i.e., does not change the relative order of elements with equal keys\nIn-place; i.e., only requires a constant amount O(1) of additional memory space\nOnline; i.e., can sort a list as it receives it\nWhen people manually sort cards in a bridge hand, most use a method that is similar to insertion sort.\n\n","alt_names":["مرتبسازی درجی","Inserção","http://ko.wikipedia.org/wiki/%EC%82%BD","http://en.wikipedia.org/wiki/Insertion_s…","Сортировка вставками","Insertion sort","(Insertion Sort","(chèn sắp xếp","(http://en.wikipedia.org/wiki/Insertion_sort)","(per inserzione","(semacam penyisipan","(straight insertion sort)","(tipo de inserción","(tipo de inserção","(tri par insertion","(Сортировка вставкой","(จัด เรียง แทรก","(삽입 정렬이나","-> Read the article about 'Insertion sort'","...Wikipedia Insertion sort","...Wikipedia Ordenamiento por inserción","...Wikipedia Sortowanie przez wstawianie","...Wikipedia Tri par insertion","...ertion_sort_animation.gif","...mehr auf Wikipedia über Insertionsort","...more on Wikipedia about Insertion sort","1 Ejemplo de funcionamiento","1算法描述","2 Best, worst, and average cases","2 示例代码","2 소스 코드","2 소스코드","2.1 C example","2.1 JAVA","2.2 C","2.2 C++ example","2.3 C++","2.3 JAVA example","2.4 Objective Caml example","2.4 Objective Caml(OCaml)","2示例代码","3 Comparisons to other sorting algorithms","3 算法复杂度","3 복잡도","3算法复杂度",">ウィキペディアには記載がある >。まあ、誰でも考えそうなことだ。二分探索が logn だから、比較回数は nlogn","@ 삽입 정렬","A video showing how to sort with insertion","Algorisme per inserció","Algoritmo de Ordenamiento de Inserción (Insert Sort)","Araya sokmalı sıralama","Best worst and average cases","Best, worst, and ...","Beszuro rendezes","Beszúrásos rendezés","Beszúró rendezés","Chen Phân loại","Chen sắp xếp","Comparisons to other sorting algorithms","Cортировку вставками (Insertion sort)","Die 5 rutscht in der blauen sortierten Teilliste","Druh vložení","Eklemeli Sıralama","Eklemeli sıralama","INSERCION","INSERITION SORT","INSERTION SORT","Indsættelse sortere","Innsetningarröðun","Innsetningarröðun - Wikipedia, frjálsa alfræðiritið","Insection Sort","Insercción","Inserition sort","Insert Sort","Insert Sort (wiki)","Insert-sort","InsertSort","Insertion Sort","Insertion Sort (Wikipedia)","Insertion Sort - The best O(n 2 ) algorithm","Insertion Sort Algorithm and Pseudocode","Insertion Sort,","Insertion Sort.","Insertion Sort:","Insertion Sorting","Insertion Sorts","Insertion sort (a.k.a. Shell sort)","Insertion sort (wikipedia)","Insertion sort - Best, worst, and average cases","Insertion sort - Wikipedia","Insertion sort - Wikipedia)","Insertion sort - Wikipedia, the free encycl","Insertion sort - Wikipedia, the free encyclopedia","Insertion sort - Wikipedie","Insertion sort ? Wikip?dia, a enciclop?dia livre","Insertion sort @ Wikipedia","Insertion sort Wikipedia the free encyclopedia","Insertion sort article on Wikipedia","Insertion sort – Wikipédia, a enciclopédia livre","Insertion sort.","Insertion sort: Wikipedia article on insertion sort","Insertion sort; it is used under the","Insertion-","Insertion-Sort","Insertion-uri-uriin","InsertionSort","InsertionSort at Wikipedia (DE)","InsertionSort at Wikipedia (EN)","InsertionSort bei Wikipedia (DE)","InsertionSort bei Wikipedia (EN)","InsertionSorter","Insertion_sort","Insertion_sort_animation.gif","Insertions Sort","Insertionsort","Insertionsort ? Wikipedia","Insertionsort Wikipedia","Insertionsort – Wikipedia","Insertionsort-Algorithmus","Inserttion Sort","Instertion sort","Insättningssortering","Ir a Ordenamiento por inserción - Wikipedia, la enciclopedia","Le tri par insertion","Learn about Insertion sort>>>","Lesefni um innsetningarröðun á Wikipedia","Linear insertion sort","Lisäyslajittelu","More info on insertion sort","Método de Inserción","Navadna vstavljanja","Ordenamiento Insertion Sort","Ordenamiento por Inserción","Ordenamiento por inserci Wikipedia, la enciclopedia libre","Ordenamiento por inserción","Ordenamiento por inserción - Wikipedia, la enciclopedia libre","Ordenar la inserción","Pagsunud-sunurin ayon Insertion","Pengisian semacam","Pesquisar insertion na Wikipedia Portugal","Pseudocode auf wikipedia","Sortieren durch Einfügen","Sortowanie przez wstawianie","Sortowanie przez wstawianie – Wikipedia, wolna encyklopedia","Sortowanie_przez_wstawianie","Sắp xếp chèn","The Insertion Sort","Tri par insertion","Tri par insertion (C/Java)","Tri par insertion - Wikip","Tri par insertion - Wikipédia","Triedenie priamym vkladaním","Tư Tưởng","Urejanje z navadnim vstavljanjem","Urut penyisipan","Vahelepanemisega sortimine","Vahelepanemisega sortimine - Vikipeedia, vaba entsüklopeedia","WIKIPEDIA SIĘ KŁANIA","Wiki: Insertion Sort","WikiPedia Insertion Sort","WikiPedia: Insertion Sort","Wikipedia - Insertion Sort","Wikipedia - Insertion sort","Wikipedia Insertion sort page","Wikipedia article Indsættelsessortering","Wikipedia article Innsetningarröðun","Wikipedia article Insertion sort","Wikipedia article Linear insertion sort","Wikipedia article Urejanje z navadnim vstavljanjem","Wikipedia article on Insertion sort","Wikipedia article on Ordenamiento por inserción","Wikipedia article on insertion sort","Wikipedia article Įterpimo rikiavimo algoritmas","Wikipedia article Ներդրմամբ տեսակավորում","Wikipedia article ഇൻസർഷൻ സോർട്ട്","Wikipedia article การเรียงลำดับแบบแทรก","Wikipedia artikel Insertion sort","Wikipedia entry for Insertion sort","Wikipedia l'articolo Insertion-Sort","Wikipedia on Insertion sort","Wikipedia 挿入ソート","Wikipedia-Artikel Insertion sort","Wikipedia-Artikel Insertionsort","Wikipedia-Artikel Insertsort","Wikipedia-Ordenamiento por Insercion","Wikipedia-Ordenamiento por Inserción","Wikipedia-Seite zu 'Insertionsort'","Wikipedia: Insertion Sort","Wikipedia: Insertion sort","Wikipedia: Insertionsort","Wikipedia:Insertion Sort","Wikipediaで「基本挿入法」を調べる","Wikipediaで「挿入ソート」を調べる","Wikipediaの挿入ソート","Wikipédia artigo Insertion","Wikipédia artigo Insertion sort","algoritmo de inserción","also talk about","another and faster","ar:ترتيب بالإدراج","artigo da Wikipédia Insertion sort","artículo de Wikipedia Insertion sort","artículo de Wikipedia Ordenamiento por insercion","artículo de Wikipedia Ordenamiento por inserción","binary insertion sort","cs:Insertion sort","da:Indsættelsessortering","de.wikipedia.org/wiki/Insertionsort","de:Insertionsort","druh vložení","en sorteringsalgoritm","en.wikipedia.org/...Insertion_sort","en.wikipedia.org/wiki/Inser...","en.wikipedia.org/wiki/Insertion_sort","en:Insertion sort","en:insertion sort","ere http://en.wikipedia.org/wiki/Insertion_","es.wikipedia.org/wiki/Ordenamiento_por_inserci%C3%B3n","es:Ordenamiento por inserción","et:Vahelepanemisega sortimine","fa:مرتبسازی درجی","fi:Lisäyslajittelu","fr:Tri par insertion","graphical representation of insertion sort","he:מיון הכנסה","http://cs.wikipedia.org/wiki/Insertion_sort","http://de.wikipedia.org/wiki/Insertion_sort","http://de.wikipedia.org/wiki/Insertionso","http://de.wikipedia.org/wiki/Insertionsort","http://de.wikipedia.org/wiki/Insertionsort#Pseudocode","http://de.wikipedia.org/wiki/Insertsort","http://en.Liarpedia.org/wiki/Insertion_sort","http://en.wikipedia..../Insertion_sort","http://en.wikipedia.org/ wiki/ Insertion_sort","http://en.wikipedia.org/wiki/Binary_insertion_sort","http://en.wikipedia.org/wiki/I nsertion_sort","http://en.wikipedia.org/wiki/Insertio...","http://en.wikipedia.org/wiki/Insertion_sort","http://en.wikipedia.org/wiki/Insertion_sort Insertion sort","http://en.wikipedia.org/wiki/Insertion_sort#Algorithm","http://en.wikipedia.org/wiki/Insertion_sort#Comparisons_to_other_sorting_algorithms","http://en.wikipedia.org/wiki/Insertion_sort#Variants","http://en.wikipedia.org/wiki/Insertion_sort)","http://en.wikipedia.org/wiki/Insertion_sort.","http://es.wikipedia.org/wiki/Insertion_sort","http://es.wikipedia.org/wiki/Insertion_s…","http://es.wikipedia.org/wiki/Ordenamiento_por_inserci%C3%B3n","http://es.wikipedia.org/wiki/Ordenamiento_por_inserción","http://et.wikipedia.org/wiki/Vahelepanemisega_sortimine","http://fi.wikipedia.org/wiki/Lisäyslajittelu","http://fr.wikipedia.org/wiki/Tri_par_in … mentations","http://fr.wikipedia.org/wiki/Tri_par_insertion","http://fr.wikipedia.org/wiki/Tri_par_insertion#Complexité","http://fr.wikipedia.org/wiki/Tri_par_ins…","http://is.wikipedia.org/wiki/Innsetningarr%C3%B6","http://it.wikipedia.org/wiki/Insertion_sort","http://it.wikipedia.org/wiki/Insertion_sort#C","http://it.wikipedia.org/wiki/Insertion_sort#Descrizione_dell.27algoritmo","http://it.wikipedia.org/wiki/Insertion_s…","http://ja.wikipedia.org/wiki/挿入ソート","http://ko.wikipedia.org/wiki/삽입_정렬","http://nl.wikipedia.org/wiki/Insertion_sort","http://pl.wikipedia....rzez_wstawianie","http://pl.wikipedia.org/w...rzez_wstawianie","http://pl.wikipedia.org/wiki/Sortowa...zez_wstawianie","http://pl.wikipedia.org/wiki/Sortowanie ... _algorytmu","http://pl.wikipedia.org/wiki/Sortowanie ... wstawianie","http://pl.wikipedia.org/wiki/Sortowanie_przez_ws","http://pl.wikipedia.org/wiki/Sortowanie_przez_wstawianie","http://pl.wikipedia.org/wiki/Sortowanie_pżez_wstawianie","http://pt.wikipedia.org/wiki/Insertion_sort","http://pt.wikipedia.org/wiki/Insertion_s…","http://ru.wikipedia....ровка_вставками","http://ru.wikipedia.org/wiki/Сортировка_вставками","http://ru.wikipedia.org/wiki/Сортировка_методом_вставок","http://tr.wikipedia.org/wiki/Eklemeli_S%C4%B1ralama","http://zh.wikipedia.org/wiki/插入排序","http://zh.wikipedia.org/zh-tw/% E6% 8F","http://zh.wikipedia.org/zh-tw/插入排序","hu:Beszúrásos rendezés","hy:Ներդրմամբ տեսակավորում","indføring slags.","indsættelse sortere","indsættelsen slags","inserción","insert sort","insertaion sort","insertion short","insertion sort","insertion sort algorithm","insertion sort wikipedia the free encyclopedia","insertion sort!","insertion sort's","insertion sort,","insertion sort.","insertion sorting","insertion-sort","insertion-sort as known for arrays","insertion_sort","insertionsort","is:Innsetningarröðun","it:Insertion sort","ja:挿入ソート","jenis penyisipan.","ko:삽입 정렬","linear insertion sort","lt:Įterpimo rikiavimo algoritmas","ml:ഇന്സര്ഷന് സോര്ട്ട്","ml:ഇൻസർഷൻ സോർട്ട്","mã giả trên wikipedia","mètode d'inserció directa","nl:Insertion sort","nsertion sort","ordenació per inserció","ordenación por inserción","ordenamiento por insercion","ordenamiento por inserción","ordenar la inserción","ordenação por inserção","ordinamento per","ordinamento per inserimento","ordinamento per inserzione","ordinamento per inserzione.","ort http://en.wikipedia.org/wiki/Insertion_sort","pl.wikipedia.org/wiki/Sortowanie_przez_wstawianie","pl:Sortowanie przez wstawianie","przez wstawianie","pseudo di wikipedia","pseudo sur wikipedia","pseudocode ในวิกิพีเดีย","pseudocodice su Wikipedia","pseudocódigo en la wikipedia","pseudocódigo na wikipedia","pt:Insertion sort","rt http://de.wikipedia.org/wiki/Insertionsort","ru:Сортировка вставками","semacam penyisipan","sk:Triedenie priamym vkladaním","sl:Urejanje z navadnim vstavljanjem","sorgente pascal","sorta di inserimento","sorta di inserimento.","sortowania przez wstawianie","sortowania wstawiania.","sortowanie przez wstawianie","sortowaniu przez wstawianie","straight insertion sort","sv:Insättningssortering","sắp xếp chèn","sắp xếp chèn.","th:การเรียงลำดับแบบแทรก","tipo de inserción","tipo de inserción.","tipo de inserção","tipo de inserção.","tr:Eklemeli sıralama","tri par insertion","tri par insertion.","uk:Сортування включенням","uri insertion.","vahelepanemisega sorteerimist","vi:Sắp xếp chèn","vkládání druhu.","vkládání třídit","w:insertion sort","w:Сортировка вставками","weiterer Sortieralgorithmus wir","wp:Insertion sort","zh:插入排序","Įterpimo","Įterpimo rikiavimo algoritma...","Įterpimo rikiavimo algoritmas","įterpimo rūšiavimo algoritmas","Википедия(Сортировка вставками)","Вставками","Вставок","Сортировать вставки","Сортировка вставками на Википедии","Сортировка методом вставок","Сортировки вставкой","Сортування включенням","вид вставки","вставок.","к которой я привык","методом вставки","псевдокод в Википедии","сартаванне ўстаўкамі","сортиране","сортировка вставками","сортировке методом вставок","сортировки вставками","сортировки вставкой","сортировкой вставками","сортировку вставками","сортировку вставками.","сортування включенням","сортування вставкою","Ներդրմամբ ...","Ներդրմամբ տեսակավորում","מיון הכנסה","מיון הכנסה – ויקיפדיה","الگوریتم مرتبسازی درجی","ترتيب بالإدراج","درجی","مرتبسازی درجی - ویکیپدیا","कर सम्मिलन","निवेशन सॉर्ट","प्रविष्टि तरह.","से ही","ഇൻസർഷൻ സോർട്ട്","การ จัด เรียง แทรก","การเรียงลำดับแบบแทรก","จัด เรียง แทรก","จัด เรียง แทรก.","จัด เรียง ใส่","→ Статья «Сортировка вставками»","⌈ l o g 2 ( n ! ) ⌉","「基本挿入法」をWikipediaで調べる","「基本挿入法」をWikiで調べる","に擬似、","の挿入ソート","インサーション","インサーションソート","ウィキペディアの記事 基本挿入法","ウィキペディアの記事 挿入ソート","二分挿入ソート","偽維基百科上","基本挿入法","挿入ソート","挿入ソート - Wikipedia","挿入ソート – Wikipedia","挿入ソート(Wikipedia)","挿入ソート。","挿入ソートが","挿入ソートでは、","挿入ソートは、","挿入ソートを","挿入並べ替え","插入排序","插入排序- 維基百科，自由的百科全書","插入排序- 维基百科，自由的百科全书","插入排序法","插入排序法（insertion sort）","插入排序维基百科，自由的百科全书","插入排序（Insertion Sort）","插入排序，","插入排序：Insertion Sort","的插入","維基百科的文章“ 插入排序”","维基百科上的伪代码","维基百科的文章“ 插入排序”","計算時間","講操作方法","配合binary search的insertion sort","삽입 정렬","삽입 정렬을","삽입 정렬이나","위키 피 디아 문서 삽입 정렬","위키백과 의사 코드","위키백과-삽입 정렬"],"name":"Insertion sort","categories":["All articles with unsourced statements","Articles with example pseudocode","Articles with unsourced statements from September 2011","Articles with unsourced statements from September 2014","Commons category with local link same as on Wikidata","Comparison sorts","Online sorts","Pages with URL errors","Sorting algorithms","Stable sorts"],"tag_line":"Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time."}}
,{"_index":"throwtable","_type":"algorithm","_id":"selection-sort","_score":0,"_source":{"description":"In computer science, selection sort is a sorting algorithm, specifically an in-place comparison sort. It has O(n2) time complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort. Selection sort is noted for its simplicity, and it has performance advantages over more complicated algorithms in certain situations, particularly where auxiliary memory is limited.\nThe algorithm divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.","alt_names":["tego algorytmu","مرتبسازی انتخابی","Selection sort","'Selection Sort' algorithm","- Selection sort :","-> Read the article about 'Selection sort'","...Wikipedia Ordenamiento por selección","...Wikipedia Selection sort","...Wikipedia Sortowanie przez wybieranie","...Wikipedia Tri par sélection","...ection_sort_animation.gif","...mehr auf Wikipedia über Selectionsort","...more on Wikipedia about Selection sort","4 Comparison to other sorting algorithms","Algorisme per selecció","Algorithme de tri par sélection","Algoritmo de Ordenamiento por Selección (Selection Sort)","Art der Selektion","Auswahl Art","Auswahl sortieren","Beispiel, welches das Vorgehen des Algorithmus' visualisiert","Bingo sort","Comparison to other sorting ...","Comparison to other sorting algorithms","Die Komplexität von Selectionsort ist, in der Landau","Encyclopedia: Selection sort","Fuente del algoritmo","Funktionsweise von Selection-Sort","Hier für selectioSort","Išrinkimo","Išrinkimo rikiavimo algoritmas","Kiválasztásos rendezés","Learn about Selection sort>>>","Lūdzu","Minsort","Método de Selección","Ordenamiento SelectionSort","Ordenamiento por Selección","Ordenamiento por selecci?n - Wikipedia, la enciclopedia libre","Ordenamiento por selecciÃ³n - Wikipedia, la enciclopedia libre","Ordenamiento por selección","Ordenamiento por selección - Wikipedia, la enciclopedia libre","Ordenar por seleção - Wikipedia","Ordenar selección","Ordina per selezione - Wikipedia","Ordinamento per selezione","Read More selection sort wikipedia the free encyclopedia","Read the Wikipedia article on selection sort","SELECCION","SELECCION DIRECTA","SELECTION SORT","See more about Selection Sort...","Select Sort","Selecti sort","Selecti sort pdia a enciclopdia livre","Selectie Sorteren","Selectie sorteren","Selection Art","Selection Sort","Selection Sort (Wikipedia)","Selection Sort - A better O(n 2 ) algorithm","Selection Sort Explained","Selection Sort Info (wiki)","Selection Sort bei Wikipedia","Selection Sort,","Selection Sort.","Selection Sort:","Selection sort (wikipedia)","Selection sort -","Selection sort - Wikipedia","Selection sort - Wikipedia, the free encyclopedia","Selection sort - Wikipedie","Selection sort - Wikipédia, a enciclopédia livre","Selection sort Wikipedia the free encyclopedia","Selection sort Wikipedia, the free encyclopedia","Selection sort algorithms","Selection sort – Wikipédia, a enciclopédia livre","Selection sort(Wikipedia)","Selection sort: Wikipedia article on selection sort","Selection sort; it is used under the","Selection sortere","Selection-Sort","Selection-based sorting","SelectionSort","SelectionSort at Wikipedia (DE)","SelectionSort at Wikipedia (EN)","SelectionSort bei Wikipedia (DE)","SelectionSort bei Wikipedia (EN)","SelectionSorter","Selection_sort","Selectionsort","Selectionsort – Wikipedia","Selectionsort-Algorithmus","Selectionsort:","Seçim göre sırala - Vikipedi","Seçmeli Sıralama","Seçmeli sıralama","Seçmeli sıralama - Vikipedi","Sortieren durch Auswahl","Sortieren durch Auswahl: Algorithmus","Sortieren durch Auswählen","Sortieren nach Auswahl - Wikipedia","Sortieren-durch-Auswählen","Sortowanie przez wybieranie","Sortowanie przez wybieranie - Wikipedia, wolna encyklopedia","Sortowanie przez wybieranie – Wikipedia, wolna encyklopedia","Sortuj wyboru","Straight selection sort","Sắp xếp chọn","The Selection Sort","Tri par sélection","Tri par sélection (C)","Tri par sélection - Wikipédia","Udtagelsessortering - Wikipedia, den frie encyklopædi","Udvælgelse slags","Urejanje z izbiranjem","Urejanje z navadnim izbiranjem","Urvalssortering","Vaihtolajittelu","Valiksortimine","Valintalajittelu","Variante von SelectionSort","Want More ??","What is algorithm of Selection sort?","What is mathematical definition of Bingo sort?","What variants of Bingo sort are there?","Wiki: Selection Sort","Wiki: Сортировка выбором","Wikipedia - Selection Sort","Wikipedia - Selection sort","Wikipedia : selection sort","Wikipedia > Selection Sort","Wikipedia Ordenamiento por selección","Wikipedia article Bingo sort","Wikipedia article Selection sort","Wikipedia article Selectionsort","Wikipedia article Udtagelsessortering","Wikipedia article on Selection sort","Wikipedia article on selection sort","Wikipedia article ترتيب الاختيار","Wikipedia article സെലക്ഷൻ സോർട്ട്","Wikipedia artikel Selection sort","Wikipedia entry for Selection sort","Wikipedia l'articolo Ordinamento per selezione","Wikipedia on Selection sort","Wikipedia sur Tri par sélection","Wikipedia 選択ソート","Wikipedia's selection sort page","Wikipedia-Artikel Minsort","Wikipedia-Artikel Selection Sort","Wikipedia-Artikel SelectionSort","Wikipedia-Artikel Selectionsort","Wikipedia-Seite zu 'SelectionSort'","Wikipedia: Selection Sort","Wikipedia: Selection Sort.","Wikipedia: Selection sort","Wikipedia:Selection_sort","Wikipediaからpseudocdeの","Wikipédia artigo Ordenação por seleção","Wikipédia artigo Selection sort","[12] Selection sort","[[選択ソート]]","ang Pinili-uri-uriin,","artigo da Wikipédia Selection sort","artículo de Wikipedia Ordenamiento por seleccion","artículo de Wikipedia Ordenamiento por selección","artículo de Wikipedia Selection sort","baca disini aja","bg:Сортиране чрез пряка селекция","bingo sort","class sorting algorithm data structure array worst case","comparison section of the selection sort article","cs:Selection sort","có sẵn trong pseudocde từ Wikipedia,","da:Udtagelsessortering","de tri de sélection,","de.wikipedia.org/wiki/SelectionSort","de.wikipedia.org/wiki/Selection_Sort","de.wikipedia.org/wiki/Selectionsort","de.wikipedia.org/wiki/Selectionsort#C.23","de:Selectionsort","e selection so","election sort","en.wikipedia.org/...Selection_sort","en.wikipedia.org/wiki/Selection_sort","es:Ordenamiento por selección","especie de selección","est disponible dans pseudocde de Wikipedia,","está disponible en pseudocde de Wikipedia,","está disponível no pseudocde da Wikipedia,","et.wikipedia.org/wiki/Valiksortimine","et:Valiksortimine","et:Valikuga sortimine","explanation of selection sort","fa:مرتبسازی انتخابی","fi:Vaihtolajittelu","fr:Tri par sélection","he:מיון בחירה","http://cs.wikipedia.org/wiki/Selection_sort","http://cs.wikipedia.org/wiki/Selectsort","http://de.wikipedia.org/wiki/SelectionSort","http://de.wikipedia.org/wiki/Selection_Sort","http://de.wikipedia.org/wiki/Selectionso","http://de.wikipedia.org/wiki/Selectionsort","http://de.wikipedia.org/wiki/Selectionsort#Java","http://de.wikipedia.org/wiki/Selectionsort#Pascal","http://de.wikipedia.org/wiki/Selectionso…","http://en.wikipedia..../Selection_sort","http://en.wikipedia...._sort#Algorithm","http://en.wikipedia.org/wiki/Selection_Sort","http://en.wikipedia.org/wiki/Selection_Sort#Code","http://en.wikipedia.org/wiki/Selection_s","http://en.wikipedia.org/wiki/Selection_s...","http://en.wikipedia.org/wiki/Selection_sort","http://en.wikipedia.org/wiki/Selection_sort Selection sort","http://en.wikipedia.org/wiki/Selection_sort#Code","http://en.wikipedia.org/wiki/Selection_sort#Method","http://en.wikipedia.org/wiki/Selection_sort#Pseudo-code","http://en.wikipedia.org/wiki/Selection_s…","http://es.wikipedia.org/wiki/Ordenamiento_por_selecci%C3%B3n","http://es.wikipedia.org/wiki/Ordenamiento_por_selección","http://es.wikipedia.org/wiki/Selection_sort","http://et.wikipedia.org/wiki/Valiksortimine","http://fi.wikipedia.org/wiki/Vaihtolajittelu","http://fr.wikipedia....i_par_sélection","http://fr.wikipedia.org/wiki/Tri_par_s%C3%A9lection","http://fr.wikipedia.org/wiki/Tri_par_sélection","http://it.wikipedia.org/wiki/Selection_sort","http://ja.wikipedia.org/wiki/選択ソート","http://nl.wikipedia.org/wiki/Selection_sort","http://pl.wikipedia....rzez_wybieranie","http://pl.wikipedia.org/wiki/Sortowa...zez_wybieranie","http://pl.wikipedia.org/wiki/Sortowanie_...wybieranie","http://pl.wikipedia.org/wiki/Sortowanie_przez_wyb%C3%B3r","http://pl.wikipedia.org/wiki/Sortowanie_przez_wybieranie","http://pl.wikipedia.org/wiki/Sortowanie_pżez_wybieranie","http://pt.wikipedia.org/wiki/Selecti...C3.B3digo_em_C","http://pt.wikipedia.org/wiki/Selection_sort","http://pt.wikipedia.org/wiki/Selection_sort#C.C3","http://pt.wikipedia.org/wiki/Selection_s…","http://ru.wikipedia.org/wiki/Сортировка_выбором","http://sl.wikipedia.org/wiki/Urejanje_z_navadnim_izbiranjem","http://sv.wikipedia.org/wiki/Urvalssortering","http://zh.wikipedia.org/wiki/选择排序","http://zh.wikipedia.org/zh-tw/% E9% 80","http://zh.wikipedia.org/zh-tw/选择排序","hy:Selection sort","in pseudocde aus Wikipedia zur Verfügung,","is available in pseudocde from Wikipedia","it:Selection sort","išrinkimo rūšiavimo algoritmas","ja:選択ソート","ko:선택 정렬","l'ordinamento per selezione","le tri par sélection","loại lựa chọn","lt:Išrinkimo rikiavimo algoritmas","markering slags","ml:സെലക്ഷന് സോര്ട്ട്","ml:സെലക്ഷൻ സോർട്ട്","namespace1","nl:Selection sort","ordenació per selecció","ordenamiento por selección","ordenação por seleção","ordinamento per selezione","per selezione,","phân loại tuyển chọn,","pl:Sortowanie przez wybieranie","przez wybieranie","pt:Selection sort","r einfachsten Sortieralgorithmen fü","rodzaj selekcji","ru:Сортировка выбором","select sor","selection sor","selection sort","selection sort algorithm","selection sort in Wikipedia Nederland zoeken","selection sort(선택 정렬)","selection sort.","selection sorting algorithm","selection sorts","selection sortu","selection-sort","selectionSort","selection_sort","selectionsort","semacam seleksi","semacam seleksi,","sl:Urejanje z navadnim izbiranjem","soort van selectie","sorta di selezione","sortare prin selecţie","sorte de sélection","sorting by selection","sortowania przez proste wybieranie","sortowania przez wybieranie","sortowanie przez wybieranie","sortowanie wyboru","sortowanie wybór","specie di selezione,","sr:Сортирање селекцијом","sv:Urvalssortering","sắp xếp lựa chọn,","tersedia dalam pseudocde dari Wikipedia,","this link at wikipedia.","tipo de selección","tipo de selección,","tipo de selecção","tipo de selecção,","tipo de seleção","tipo de seleção,","tipo di selezione","tr:Seçmeli sıralama","tri par sélection","tri par sélection du maximum","triedenie výberom","type de sélection","udvælgelse slags","uk:Сортування вибором","valg Arranger","valikuga sorteerimine","vi:Sắp xếp chọn","výběr Seřadit","výběr druh","výběr druhu","w:Сортировка выбором","w:選択ソート","wybór rodzaju","zh:选择排序","Ð¡Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²ÐºÐ° Ð²Ñ‹Ð","è disponibile in pseudocde da Wikipedia,","Википедии статью Сортировка выбором","Выбор рода","Выбор сортировки","Выбором","Сортиране чрез пряка селекция","Сортирање селекцијом","Сортировать по выбору - Wikipedia","Сортировка выбором","Сортировка выбором на Википедии","Сортировка выбором — Википедия","Сортировка методом выбора","Сортировка_методом_выбора","Сортування вибором","выбор рода","выбора рода,","выборе рода,","выборочной сортировке","имеется в pseudocde из Википедии,","описание сортировки методом выбора","простого выбора","прочети във уикипедията","пряка селекция","рода выбор","сортировка выбором","сортировка выбором!","сортировки выбором","сортування вибором","сортуванні вибором","тип выбора","ויקיפדיה - 'מיון בחירה'","מיון בחירה","מיון בחירה – ויקיפדיה","מתואר בויקיפדיה","תאור נוסף","المرتبة حسب الاختيار -- ويكيبيديا","الگوریتم مرتبسازی انتخابی","انتخابی","ترتيب الاختيار","ترتيب الاختيار - ويكيبيديا، ...","مرتبسازی انتخابی - ویکیپدیا","مرتبسازی انتخابی/selection sort","चयन के आधार पर छाँटें - विकिपीडिया","സെലക്ഷൻ സോർട്ട്","จัด เรียง เลือก","มี อยู่ ใน pseudocde จาก วิ กิ พี","เรียง ลำดับ การ เลือก","“Selection sort - Wikipedia, the free encyclopedia”, en.wikipedia","→ Статья «Сортировка выбором»","「選択ソート」をWikiで調べる","セレクションソート","セレクションソート - Wikipedia","セレクションソートを","可以从维基pseudocde，","可在pseudocde從Wikipedia，","类型的选择","維基百科的文章“ 选择排序”","維基百科的文章“ 選擇排序”","选择排序","选择排序- 维基百科，自由的百科全书","選択の種類は、","選択ソート","選択ソート - Wikipedia","選択ソート(Wikipedia)","選択ソートの説明","選択ソートは安定しない","選択ｿｰﾄ-wikipedia","選擇排序","選擇排序 - 維基百科，自由的百科全書 http://zh.wikipedia.org/zh","選擇排序法","選擇排序法（selection sort）","選擇排序：Selection Sort","선택 정렬","선택 정렬,","선택을 일종의","선택정렬 자세히보기","영어 위키 선택정렬","위키 피 디아 문서 선택 정렬","위키 피 디아 문서 선택정렬","위키 피 디아에서 pseudocde에서,","위키백과-선택 정렬"],"name":"Selection sort","categories":["Comparison sorts","Sorting algorithms"],"tag_line":"In computer science, selection sort is a sorting algorithm, specifically an in-place comparison sort."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sorting-network","_score":0,"_source":{"description":"In computer science, comparator networks are abstract devices built up of a fixed number of \"wires\", carrying values, and comparator modules that connect pairs of wires, swapping the values on the wires if they are not in a desired order. Such networks are typically designed to perform sorting on fixed numbers of values, in which case they are called sorting networks.\nSorting networks differ from general comparison sorts in that they are not capable of handling arbitrarily large inputs, and in that their sequence of comparisons is set in advance, regardless of the outcome of previous comparisons. This independence of comparison sequences is useful for parallel execution and for implementation in hardware. Despite the simplicity of sorting nets, their theory is surprisingly deep and complex. Sorting networks were first studied circa 1954 by Armstrong, Nelson and O'Connor, who subsequently patented the idea.\nSorting networks can be implemented either in hardware or in software. Donald Knuth describes how the comparators for binary integers can be implemented as simple, three-state electronic devices. Batcher, in 1968, suggested using them to construct switching networks for computer hardware, replacing both buses and the faster, but more expensive, crossbar switches. Since the 2000s, sorting nets (especially bitonic mergesort) are used by the GPGPU community for constructing sorting algorithms to run on graphics processing units.","alt_names":["-> Read the article about 'Sorting network'","...d-sorting-network.svg.png","...e-sorting-network.svg.png","...leSortingNetwork2.svg.png","...n-sorting-network.svg.png","Clasificación de la red","Lajitteluverkotkin","Learn about Sorting network>>>","Optimal sorting","Orting Networks","Orting Netze","Orting Redes","Read More sorting network wikipedia the free encyclopedia","See the picture in the upper right hand","Sortering Networks","Sortier-Netze","Sortier-Netzwerk","Sortieren Netzwerk","Sortierung Netzwerk","Sorting <b>network b> - Wikipedia","Sorting Network","Sorting Networks","Sorting network","Sorting network - Wikipedia","Sorting network - Wikipedia, the free encyclopedia","Sorting network; it is used under the","Sorting networks","Sortowanie sieci","Source Wikipedia.org Arcticle - Sorting network","Třídění síť","Wiki: sorting network","Wikipedia - Sorting networks","Wikipedia article Sorting network","Wikipedia article about Sorting network","Wikipedia article on Sorting network","Wikipedia entry for Sorting network","Wikipedia: Sorting Network","en.wikipedia.org/wiki/Sorting network.","en.wikipedia.org/wiki/Sorting_network","en.wikipedia.org/wiki/Sorting_network#Optimal_sorting","en:Sorting network","http://en.wikipedia....Sorting_network","http://en.wikipedia.org/wiki/Sorting network","http://en.wikipedia.org/wiki/Sorting_net","http://en.wikipedia.org/wiki/Sorting_net...","http://en.wikipedia.org/wiki/Sorting_network","http://en.wikipedia.org/wiki/Sorting_network.","http://en.wikipedia.org/wiki/Sorting_networks","http://en.wikipedia.org/wiki/Sorting_net…","http://htn.to/xF5f89","http://pl.wikipedia.org/wiki/Sie%C4%87_sortuj","ja.wikipedia.org/...%88%E3%83%AF%E3","jaringan pemilahan","jaringan penyortiran","les réseaux de tri","mạng lưới phân loại","network ng paghihiwalay","network sorting","network sorts","orting Networks","orting sítě","paghihiwalay network","pl:Sieć sortująca","pl:Sieć_sortująca","principe 0-1","red de clasificación","rede de triagem","redes de clasificación","redes de triagem","rete di ordinamento","reti di ordinamento","réseau de tri","sieci sortowania","sorteren netwerk","sorteren netwerken","sortering netværk","sortering netwerk","sorting network","sorting networks","třídění síť","wires and then inserts the remaining value Based","zero-one principle","Ортинг сетей","Сеть сортировки","сортировка сети","сортировки сети","شبکه ای","شبکه های مرتب سازی","شبکههای مرتبسازی","شبکههای مرتبسازی - ویکیپدیا","เครือข่าย sorting","、クヌース（","ソーティングネットワーク","ソーティングネットワーク - Wikipedia","ソートのネットワーク","ソートネットワークを","ネットワークのアルゴリズム","ネットワークの並べ替え","ネットワークオーティング","奥廷网络","排序的网络","排序網絡","排序网络","維基百科的文章“ 0-1原理”","维基百科的文章“ 0-1原理”","정렬 네트워크","ｿｰﾃｨﾝｸﾞﾈｯﾄﾜｰｸ-wikipedia"],"name":"Sorting network","categories":["Computer engineering","Pages using duplicate arguments in template calls","Sorting algorithms"],"tag_line":"In computer science, comparator networks are abstract devices built up of a fixed number of \"wires\", carrying values, and comparator modules that connect pairs of wires, swapping the values on the wires if they are not in a desired order."}}
,{"_index":"throwtable","_type":"algorithm","_id":"library-sort","_score":0,"_source":{"description":"Library sort, or gapped insertion sort is a sorting algorithm that uses an insertion sort, but with gaps in the array to accelerate subsequent insertions. The name comes from an analogy:\n\nSuppose a librarian were to store his books alphabetically on a long shelf, starting with the A's at the left end, and continuing to the right along the shelf with no spaces between the books until the end of the Z's. If the librarian acquired a new book that belongs to the B section, once he finds the correct space in the B section, he will have to move every book over, from the middle of the B's all the way down to the Z's in order to make room for the new book. This is an insertion sort. However, if he were to leave a space after every letter, as long as there was still space after B, he would only have to move a few books to make room for the new one. This is the basic principle of the Library Sort.\n\nThe algorithm was proposed by Michael A. Bender, Martín Farach-Colton, and Miguel Mosteiro in 2004 and was published in 2006.\nLike the insertion sort it is based on, library sort is a stable comparison sort and can be run as an online algorithm; however, it was shown to have a high probability of running in O(n log n) time (comparable to quicksort), rather than an insertion sort's O(n2). The mechanism used for this improvement is very similar to that of a skip list. There is no full implementation given in the paper, nor the exact algorithms of important parts, such as insertion and rebalancing. Further information would be needed to discuss how the efficiency of library sort compares to that of other sorting methods in reality.\nCompared to basic insertion sort, the drawback of library sort is that it requires extra space for the gaps. The amount and distribution of that space would be implementation dependent. In the paper the size of the needed array is (1 + ε)n, but with no further recommendations on how to choose ε.\nOne weakness of insertion sort is that it may require a high number of swap operations and be costly if memory write is expensive. Library sort may improve that somewhat in the insertion step, as fewer elements need to move to make room, but is also adding an extra cost in the rebalancing step. In addition, locality of reference will be poor compared to mergesort as each insertion from a random data set may access memory that is no longer in cache, especially with large data sets.","alt_names":["- Library sort :","Kütüphane sıralaması","Library Sort","Library sort","Library sort - Wikipedia, the free encyclopedia","Library sort @ Wikipedia","Library sort Wikipedia the free encyclopedia - result","LibrarySort","Library_sort","Sortowanie biblioteczne","Wikipedia (Library sort)","Wikipedia article ''Library sort''","Wikipedia article Library sort","Wikipedia article on Library sort","Wikipedia article Գրադարանային տեսակավորում","Wikipedia entry for Library sort","en.wikipedia.org/wiki/Library_sort","http://en.wikipedia.org/wiki/Library_sor","http://en.wikipedia.org/wiki/Library_sort","http://en.wikipedia.org/wiki/Library_sor…","http://pl.wikipedia.org/wiki/Sortowanie_biblioteczne","kütüphane sıralaması","library sor","library sort","wikipedia:en:Library_sort","Գրադարանային ...","Գրադարանային տեսակավորում","کتابخانه ای"],"name":"Library sort","categories":["Comparison sorts","Online sorts","Sorting algorithms","Stable sorts"],"tag_line":"Library sort, or gapped insertion sort is a sorting algorithm that uses an insertion sort, but with gaps in the array to accelerate subsequent insertions."}}
,{"_index":"throwtable","_type":"algorithm","_id":"spreadsort","_score":0,"_source":{"description":"Spreadsort is a sorting algorithm invented by Steven J. Ross in 2002. It combines concepts from distribution-based sorts, such as radix sort and bucket sort, with partitioning concepts from comparison sorts such as quicksort and mergesort. In experimental results it was shown to be highly efficient, often outperforming traditional algorithms such as quicksort, particularly on distributions exhibiting structure.\nQuicksort identifies a pivot element in the list and then partitions the list into two sublists, those elements less than the pivot and those greater than the pivot. Spreadsort generalizes this idea by partitioning the list into n/c partitions at each step, where n is the total number of elements in the list and c is a small constant (in practice usually between 4 and 8 when comparisons are slow, or much larger in situations where they are fast). It uses distribution-based techniques to accomplish this, first locating the minimum and maximum value in the list, and then dividing the region between them into n/c equal-sized bins. Where caching is an issue, it can help to have a maximum number of bins in each recursive division step, causing this division process to take multiple steps. Though this causes more iterations, it reduces cache misses and can make the algorithm run faster overall.\nIn the case where the number of bins is at least the number of elements, spreadsort degenerates to bucket sort and the sort completes. Otherwise, each bin is sorted recursively. The algorithm uses heuristic tests to determine whether each bin would be more efficiently sorted by spreadsort or some other classical sort algorithm, then recursively sorts the bin.\nLike other distribution-based sorts, spreadsort has the weakness that the programmer is required to provide a means of converting each element into a numeric key, for the purpose of identifying which bin it falls in. Although it is possible to do this for arbitrary-length elements such as strings by considering each element to be followed by an infinite number of minimum values, and indeed for any datatype possessing a total order, this can be more difficult to implement correctly than a simple comparison function, especially on complex structures. Poor implementation of this value function can result in clustering that harms the algorithm's relative performance.\n^ Steven J. Ross. The Spreadsort High-performance General-case Sorting Algorithm. Parallel and Distributed Processing Techniques and Applications, Volume 3, pp.1100–1106. Las Vegas Nevada. 2002.","alt_names":["Spreadsort","Spreadsort - Wikipedia, the free encyclopedia","Two Levels are as Good as Any","Wikipedia article Spreadsort","Wikipedia article on Spreadsort","Wikipedia entry for Spreadsort","en.wikipedia.org/wiki/Spreadsort","http://en.wikipedia.org/wiki/Spreadsort","spreadsort","yago-res:Spreadsort","مرتب سازی گسترده"],"name":"Spreadsort","categories":["Sorting algorithms"],"tag_line":"Spreadsort is a sorting algorithm invented by Steven J. Ross in 2002."}}
,{"_index":"throwtable","_type":"algorithm","_id":"merge-algorithm","_score":0,"_source":{"description":"Merge algorithms are a family of algorithms that take multiple sorted lists as input and produce a single list as output, containing all the elements of the inputs lists in sorted order. These algorithms are used as subroutines in various sorting algorithms, most famously merge sort.","alt_names":["- Merge algorithm :","-> Read the article about 'Merge algorithm'","Merge Algorithm","Merge algorithm","Merge algorithm - Wikipedia, the free encyclopedia","Merge algorithm Wikipedia the free encyclopedia","Merge algorithm: Analysis","Merge algorithm: Language support","Merge algorithm: Pseudocode","Merge algorithm: Uses","Merge algorithm; it is used under the","Merge algorithms","Merge th","Merge-Algorithmus","Merge-Algorithmus.","Source Wikipedia.org Arcticle - Merge algorithm","Wikipedia (Merge algorithm)","Wikipedia - Merge algorithm","Wikipedia article Merge algorithm","Wikipedia article on Merge algorithm","Wikipedia entry for Merge algorithm","Wikipedia/Merge algorithm","Wikipedia: Algoritmo Merge","Wikipedia: Algoritmo de fusión","Wikipedia: Algorytm Merge","Wikipedia: Flet algoritme","Wikipedia: Merge Algorithm","Wikipedia: Merge algorithm","Wikipedia: Merge-Algorithmus","Wikipedia: Samenvoegen Algoritme","Wikipedia: Sloučit algoritmus","algoritma merge.","algoritmo de combinación de correspondencia.","algoritmo de junção.","algoritmo di unione.","algoritmu sloučit","algorytmu scalania","aquest article sobre l'algorisme de fusió","en.wikipedia.org/wiki/Merge_algorithm","en:Merge algorithm","erge a","fusie-algoritme","http://en.wikipedia.org/wiki/Merge_algorithm","l'algorithme de fusion.","list merging algorithm","merge algorithm","merge phase","merge the ordered sequences","merge_algorithm","standard merge algorithm","sumanib algorithm.","thuật toán hợp nhất.","Википедия: Merge Алгоритм","алгоритма слияния.","за линейное время слить 2 сортированных массива","विकिपीडिया: एल्गोरिथ्म मर्ज","विकिपीडिया: मर्ज एलगोरिदम","รวม กลไก.","「マージ」をWikipediaで調べる","「マージ」をWikiで調べる","ウィキペディア：マージアルゴリズム","マージ - Wikipedia","マージアルゴリズム","合併算法","合并算法","合并算法的","维基百科：合并算法","알고리즘을 병합의","ﾏｰｼﾞ-wikipedia"],"name":"Merge algorithm","categories":["Articles with example pseudocode","Sorting algorithms"],"tag_line":"Merge algorithms are a family of algorithms that take multiple sorted lists as input and produce a single list as output, containing all the elements of the inputs lists in sorted order."}}
,{"_index":"throwtable","_type":"algorithm","_id":"spaghetti-sort","_score":0,"_source":{"description":"Spaghetti sort is a linear-time, analog algorithm for sorting a sequence of items, by Alexander Dewdney in his column, Scientific American. This algorithm sorts a sequence of items requiring O(n) stack space in a stable manner. It requires a parallel processor.","alt_names":["- Spaghetti sort :","...more on Wikipedia about Spaghetti sort","Spaghetti (Poll) sort","Spaghetti Sort","Spaghetti soort","Spaghetti sort","Spaghetti sort - Wikipedia, the free encyclopedia","Spaghetti sort#Analysis","Spaghetti sorta","Spaghetti sortere","Spaghetti-","The Spaghetti sort","What is algorithm of Spaghetti sort","What is algorithm of Spaghetti sort ?","Wikipedia article Spaghetti sort","Wikipedia article on Spaghetti sort","Wikipedia entry for Spaghetti sort","a model of sorting numbers","a model ofsorting numbers","en.wikipedia.org/wiki/Spaghetti_sort","en:Spaghetti sort","http://bit.ly/cN8ZS9","http://en.wikipedia.org/wiki/Spaghetti_sort","ordenação spaghetti","paghetti sort","sorta di spaghetti","spaghetti sort","spaghetti sorting","tipo espagueti","tri par les spaghetti","Špagety řadit","Спагетти рода","スパゲッティソート","スパゲティソートは","意大利面条排序","意粉分类"],"name":"Spaghetti sort","categories":["Accuracy disputes from July 2013","All Wikipedia articles needing clarification","All accuracy disputes","All articles with unsourced statements","Articles with unsourced statements from April 2015","Sorting algorithms","Wikipedia articles needing clarification from July 2013"],"tag_line":"Spaghetti sort is a linear-time, analog algorithm for sorting a sequence of items, by Alexander Dewdney in his column, Scientific American."}}
,{"_index":"throwtable","_type":"algorithm","_id":"funnelsort","_score":0,"_source":{"description":"Funnelsort is a comparison-based sorting algorithm. It was introduced by Frigo, Leiserson, Prokop, and Ramachandran in 1999 in the context of the cache oblivious model. In the external memory model, the number of memory transfers it needs to perform a sort of  items on a machine with cache of size  and cache lines of length  is , under the tall cache assumption that . This number of memory transfers has been shown to be asymptotically optimal for comparison sorts. Funnelsort also achieves the asymptotically optimal runtime complexity of .","alt_names":[],"name":"Funnelsort","categories":["All articles lacking in-text citations","All articles lacking reliable references","All articles needing expert attention","All articles that are too technical","Analysis of algorithms","Articles lacking in-text citations from May 2014","Articles lacking reliable references from May 2014","Articles needing expert attention from May 2014","CS1 errors: chapter ignored","Cache (computing)","Comparison sorts","External memory algorithms","Models of computation","Sorting algorithms","Wikipedia articles that are too technical from May 2014"],"tag_line":"Funnelsort is a comparison-based sorting algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"polyphase-merge-sort","_score":0,"_source":{"description":"A polyphase merge sort is an algorithm which decreases the number of runs at every iteration of the main loop by merging runs into larger runs. It is used for external sorting.","alt_names":["Polyphase merge sort","Polyphase merge sort - Wikipedia, the free encyclopedia","Polyphase merge sort - Wikipedia, the free encyclopedia ...","Sortowanie polifazowe","Sortowanie wielofazowe","Wikipedia article Polyphase merge sort","Wikipedia article on Polyphase merge sort","Wikipedia entry for Polyphase merge sort","a fancier version of mergesort","http://en.wikipedia.org/wiki/Polyphase_merge_sort","http://pl.wikipedia.org/wiki/Sortowanie_wielofazowe","polyphase merge sort","polyphase mergesort"],"name":"Polyphase merge sort","categories":["Comparison sorts","Online sorts","Sorting algorithms"],"tag_line":"A polyphase merge sort is an algorithm which decreases the number of runs at every iteration of the main loop by merging runs into larger runs."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bzip2","_score":0,"_source":{"description":"bzip2 is a free and open-source file compression program that uses the Burrows–Wheeler algorithm. It only compresses single files and is not a file archiver. It is developed and maintained by Julian Seward. Seward made the first public release of bzip2, version 0.15, in July 1996. The compressor's stability and popularity grew over the next several years, and Seward released version 1.0 in late 2000.","alt_names":["Bzip","http://ja.wikipedia.org/wiki/Bzip2","bzip2","BZ2","Bzip2","*.BZ2","- Bzip2 :","-> Read the article about 'Bzip2'","... archivio.tar.bz2 lista dei file tar xjf","...Wikipedia BZIP2","...Wikipedia Bzip2","...mehr auf Wikipedia über Bzip2","...more on Wikipedia about Bzip2",".BZ2",".bz2",".bzip2",".tar.bz2/.tbz2)","/ media","1 Compression efficiency","2 Compression stack","A .bz2 stream consists of a 4-byte","AnswerQuestions article on Bzip2","BZ/BZ2","BZ2,","BZ2.","BZIP2","BZIP2 - Wikipedia","BZIP2 algorithm","BZip","BZip2","BZip2 compressed files","BZip2 format","BZip2 on Wikipedia","Bzip2 (wikipedia)","Bzip2 - Vikipedi","Bzip2 - Wikipedia","Bzip2 - Wikipedia, the free encyclopedia","Bzip2 - w polskiej Wikipedii","Bzip2 Related Content:","Bzip2 Wikipedia The Free Encyclopedia","Bzip2 bei der wikipedia","Bzip2 |","Bzip2-wikipedia","Bzip2.","Bzip2:sta kertovassa artikkelissa","Bzip2↗","Bzip2とは？ (Wikipediaへのリンク)","Bzip2에서)","Compression algorithm/file extension","Compression stack","Compression tool","Enciclopedia Bzip2","Mar 22 2011, 02:24 PM","Read More About bzip2 - wikipedia the free encyclopedia","Read More bzip2 wikipedia the free encyclopedia","Tar-BZip2","Türkçe Vikipedi bzip2","View Bzip2 on Wikipedia","Vikipedi'deki Bzip2","WikiPedia on bzip2","Wikipedia (Bzip2)","Wikipedia article ''Bzip2''","Wikipedia article BZIP2","Wikipedia article Bzip2","Wikipedia article about BZIP2","Wikipedia article about Bzip2","Wikipedia article bzip2","Wikipedia article on BZ2","Wikipedia article on BZip2","Wikipedia article on Bzip2","Wikipedia article on bzip2","Wikipedia artikel Bz2","Wikipedia artikel Bzip2","Wikipedia entry for Bzip2","Wikipedia has more details on bzip2","Wikipedia l'articolo Bzip2","Wikipedia-Artikel BZ2","Wikipedia-Artikel BZip2","Wikipedia-Artikel Bzip2","Wikipedia-Artikel zu Bzip2","Wikipedia-Seite zu 'BZ2'","Wikipedia-Seite zu 'Bzip2'","Wikipedia:Bunzip2","Wikipedia:Bzip2","Wikipediaで「BZIP2」を調べる","Wikipediaで「Bzip2」を調べる","Wikipédia artigo Bzip2","[D] BZ2","`bzip2","ar:بزيب2","article Bzip2","artigo da Wikipédia Bzip2","artículo de Wikipedia BZ2","artículo de Wikipedia BZip2","artículo de Wikipedia Bzip2","bZip2","bunzip2","bz2","bz2 file header/magic numbers","bz2)","bz2,","bz2, Bzip 2.","bz2-Datei","bz2. Tipo MIME. application/x-bzip. Sviluppato da","bzip","bzip2 (外鏈，英文)","bzip2 (外链，英文)","bzip2 - Wikipedia","bzip2 - Wikipedia, la enciclopedia libre","bzip2 - Wikipedia, the free encyclopedia","bzip2 - Wikipedia, the free encyclopedia - Wikipedia","bzip2 - Wikipédia","bzip2 - w polskiej Wikipedii","bzip2 - 维基百科，自由的百科全书","bzip2 From Wikipedia the free encyclopedia","bzip2 Wikipedia the free encyclopedia","bzip2 Wikipedia, the free encyclopedia","bzip2 algorithm.","bzip2 compaction algorithm","bzip2 compression","bzip2 compression algorithm","bzip2 file format","bzip2 from Wikipedia","bzip2 is a free and open source lossless","bzip2 shrinking algorithm","bzip2 usa la trasformata di Burrows-Wheeler per","bzip2 – Wikipedia","bzip2 – Wikipédia, a enciclopédia livre","bzip2 — Википедия","bzip2 — Вікіпедія","bzip2).","bzip2-compressed","bzip2-ed","bzip2-wikipedia","bzip2.","bzip2/bunzip2","bzip2の","bzip2のページ","bzip2压缩","bzip2壓縮","bzip2的","bzipem2","bzipped","bzipом2","ca:Bzip2","chunks data in 100K – 900k blocks","compress better, although slower","compression format","compression stack","cs:Bzip2","de catre bzip","de.wikipedia.org/wiki/Bzip2","de:Bzip2","en.wikipedia.org/Bzip2","en.wikipedia.org/wiki/Bzip2","en.wikipedia.org/wiki/Bzi…","es:Bzip2","fa:بیزیپ۲","fr:Bzip2","gemäss der deutschsprachigen Wikipedia","http://ca.wikipedia.org/wiki/Bzip2","http://cs.wikipedia.org/wiki/Bzip2","http://de.wikipedia.org/wiki/BZ2","http://de.wikipedia.org/wiki/BZip","http://de.wikipedia.org/wiki/BZip2","http://de.wikipedia.org/wiki/Bzip2","http://en.wikipedia.org/wiki/BZIP2","http://en.wikipedia.org/wiki/Bzip2","http://en.wikipedia.org/wiki/Bzip2#Compression_efficiency","http://en.wikipedia.org/wiki/Bzip2#Compression_stack","http://en.wikipedia.org/wiki/Bzip2#External_links","http://en.wikipedia.org/wiki/Bzip2#File_forma...","http://en.wikipedia.org/wiki/Bzip2#File_format","http://en.wikipedia.org/wiki/Bzip2#File_format,","http://en.wikipedia.org/wiki/Bzip2#Implementations","http://en.wikipedia.org/wiki/Bzip2.","http://en.wikipedia.org/wiki/Bzip2>bzip2</a","http://es.wikipedia.org/wiki/BZ2","http://es.wikipedia.org/wiki/Bzip2","http://fr.wikipedia.org/wiki/Bz2","http://fr.wikipedia.org/wiki/Bzip2","http://it.wikipedia.org/wiki/Bunzip2","http://it.wikipedia.org/wiki/Bzip2","http://ja.wikipedia.org/wiki/BZIP2","http://ja.wikipedia.org/wiki/Bzip2>bzip2</a","http://ja.wikipedia.org/wiki/Bzip2のthumbnail","http://ko.wikipedia.org/wiki/Bzip2","http://nl.wikipedia.org/wiki/Bz2","http://nl.wikipedia.org/wiki/Bzip2","http://pl.wikipedia.org/wiki/BZIP2","http://pl.wikipedia.org/wiki/Bzip2","http://ru.wikipedia.org/wiki/Bz2","http://ru.wikipedia.org/wiki/Bzip2","http://tr.wikipedia.org/wiki/Bzip2","http://www.wikipedia.org/wiki/Bzip2","http://www.wikipedia.org/wiki/Bzip2>bzip2</a","http://zh.wikipedia.org/wiki/Bzip2","http://zh.wikipedia.org/zh-cn/Bzip2","it:Bzip2","ja:Bzip2","ko:Bzip2","l'article de Wikipédia Bz2","l'article de Wikipédia Bzip","l'article de Wikipédia Bzip2","libbz2","n10:Bzip2","nl:Bzip2","pl:Bzip2","pt:Bzip2","ru.wikip...ki/Bzip","ru.wikip...ki/Bzip2","ru.wikipedia.org/wiki/Bzip2","ru:Bzip2","sv:Bzip2","t http://en.wikipedia.org/wiki/Bzip","tar.bz2 file","tbz2","the Wikipedia article on bzip2","tr:Bzip2","uk:Bzip2","zh:Bzip2","Википедии статью BZIP2","Википедии статью Bz2","Википедии статью Bzip","Википедии статью Bzip2","Поиск по словам распаковать tar.bz2 в интернете","информация не новая","сжатом формате","بیزیپ۲ - ویکیپدیا","∙ Bzip2 - Vikipedi","∙ bzip2 - Wikipédia","はbzip2","ウィキペディアの記事 BZIP2","ウィキペディアの記事 Bzip2","的bzip2","維基百科的文章“ BZ2 ”","維基百科的文章“ Bzip2 ”","维基百科的文章“ BZ2 ”","维基百科的文章“ Bzip2 ”","레스 햇의 bzip2를","위키 피 디아 문서 Bzip2"],"name":"Bzip2","categories":["1996 software","All articles containing potentially dated statements","All articles with specifically marked weasel-worded phrases","All articles with unsourced statements","Archive formats","Articles containing potentially dated statements from May 2010","Articles with specifically marked weasel-worded phrases from February 2014","Articles with unsourced statements from February 2014","Cross-platform software","Free data compression software","Lossless compression algorithms","Unix archivers and compression-related utilities","Use dmy dates from August 2012"],"tag_line":"bzip2 is a free and open-source file compression program that uses the Burrows–Wheeler algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"embedded-zerotrees-of-wavelet-transforms","_score":0,"_source":{"description":"Embedded Zerotrees of Wavelet transforms (EZW) is a lossy image compression algorithm. At low bit rates, i.e. high compression ratios, most of the coefficients produced by a subband transform (such as the wavelet transform) will be zero, or very close to zero. This occurs because \"real world\" images tend to contain mostly low frequency information (highly correlated). However where high frequency information does occur (such as edges in the image) this is particularly important in terms of human perception of the image quality, and thus must be represented accurately in any high quality coding scheme.\nBy considering the transformed coefficients as a tree (or trees) with the lowest frequency coefficients at the root node and with the children of each tree node being the spatially related coefficients in the next higher frequency subband, there is a high probability that one or more subtrees will consist entirely of coefficients which are zero or nearly zero, such subtrees are called zerotrees. Due to this, we use the terms node and coefficient interchangeably, and when we refer to the children of a coefficient, we mean the child coefficients of the node in the tree where that coefficient is located. We use children to refer to directly connected nodes lower in the tree and descendants to refer to all nodes which are below a particular node in the tree, even if not directly connected.\nIn zerotree based image compression scheme such as EZW and SPIHT, the intent is to use the statistical properties of the trees in order to efficiently code the locations of the significant coefficients. Since most of the coefficients will be zero or close to zero, the spatial locations of the significant coefficients make up a large portion of the total size of a typical compressed image. A coefficient (likewise a tree) is considered significant if its magnitude (or magnitudes of a node and all its descendants in the case of a tree) is above a particular threshold. By starting with a threshold which is close to the maximum coefficient magnitudes and iteratively decreasing the threshold, it is possible to create a compressed representation of an image which progressively adds finer detail. Due to the structure of the trees, it is very likely that if a coefficient in a particular frequency band is insignificant, then all its descendants (the spatially related higher frequency band coefficients) will also be insignificant.\nEZW uses four symbols to represent (a) a zerotree root, (b) an isolated zero (a coefficient which is insignificant, but which has significant descendants), (c) a significant positive coefficient and (d) a significant negative coefficient. The symbols may be thus represented by two binary bits. The compression algorithm consists of a number of iterations through a dominant pass and a subordinate pass, the threshold is updated (reduced by a factor of two) after each iteration. The dominant pass encodes the significance of the coefficients which have not yet been found significant in earlier iterations, by scanning the trees and emitting one of the four symbols. The children of a coefficient are only scanned if the coefficient was found to be significant, or if the coefficient was an isolated zero. The subordinate pass emits one bit (the most significant bit of each coefficient not so far emitted) for each coefficient which has been found significant in the previous significance passes. The subordinate pass is therefore similar to bit-plane coding.\nThere are several important features to note. Firstly, it is possible to stop the compression algorithm at any time and obtain an approximation of the original image, the greater the number of bits received, the better the image. Secondly, due to the way in which the compression algorithm is structured as a series of decisions, the same algorithm can be run at the decoder to reconstruct the coefficients, but with the decisions being taken according to the incoming bit stream. In practical implementations, it would be usual to use an entropy code such as arithmetic code to further improve the performance of the dominant pass. Bits from the subordinate pass are usually random enough that entropy coding provides no further coding gain.\nThe coding performance of EZW has since been exceeded by SPIHT and its many derivatives.","alt_names":["EZW","- Embedded Zerotrees of Wavelet transforms :","EZW (Embedded Zerotree Wavelet)","EZW; it is used under the","Embedded Zerotree Wavelet","Embedded Zerotrees Of Wavelet Transforms","Embedded Zerotrees of Wavelet transforms","Embedded Zerotrees of Wavelet transforms - Wikipedia, the ...","Embedded Zerotrees of Wavelet transforms - Wikipedia, the free","Embedded Zerotrees of Wavelet transforms / EZW","Embedded Zerotrees of Wavelet transforms by Wikipedia","Embedded_Zerotrees_of_Wavelet_transforms","Ezw","Ezw - Wikipedia","Learn about Embedded Zerotrees of Wavelet transforms>>>","Wikipedia article EZW","Wikipedia article Embedded Zerotree Wavelet","Wikipedia article Embedded Zerotrees of Wavelet transforms","Wikipedia article Ezw","Wikipedia article on EZW","Wikipedia artikel Ezw","Wikipedia entry for Embedded Zerotrees of Wavelet transforms","en.wikipedia.org/wiki/Embedded_Zerotrees_of_Wavelet_transfor...","http://en.Liarpedia.org/wiki/Embedded_Zerotrees_of_Wavelet_transforms","http://en.wikipedia.org/wiki/EZW","http://en.wikipedia.org/wiki/EZW#","http://en.wikipedia.org/wiki/Embedded_Zerotrees_of_Wavelet_transforms","http://nl.wikipedia.org/wiki/Ezw","zero-trees"],"name":"Embedded Zerotrees of Wavelet transforms","categories":["Commons category with local link same as on Wikidata","Image compression","Lossless compression algorithms","Trees (data structures)","Wavelets"],"tag_line":"Embedded Zerotrees of Wavelet transforms (EZW) is a lossy image compression algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"microsoft-point-to-point-compression","_score":0,"_source":{"description":"Microsoft Point-to-Point Compression (MPPC; described in RFC 2118) is a streaming data compression algorithm based on an implementation of Lempel–Ziv using a sliding window buffer. According to Hifn's IP statement, MPPC is patent-encumbered.\nWhere V.44 or V.42bis operate at layer 1 on the OSI model, MPPC operates on layer 2, giving it a significant advantage in terms of computing resources available to it. The dialup modem's in-built compression (V.44 or V.42bis) can only occur after the data has been serially transmitted to the modem, typically at a maximum rate of 115,200 bit/s. MPPC, as it is controlled by the operating system, can receive as much data as it wishes to compress, before forwarding it on to the modem.\nThe modem's hardware must not delay data too much, while waiting for more to compress in one packet, otherwise an unacceptable latency level will result. It also cannot afford to, as this would require both sizable computing resources (on the scale of a modem) as well as significant buffer RAM. Software compression such as MPPC is free to use the host computer's resources which will typically include a CPU of several hundred Megahertz and several hundred Megabytes of RAM - greater computing power than that of the modem by several orders of magnitude. This allows it to keep a much larger buffer to work on at any one time, and it processes through a given amount of data much faster.\nThe end result is that where V.44 may achieve a maximum of 4:1 compression (230 kbit/s) but is usually limited to 115.2 kbit/s, MPPC is capable of a maximum of 8:1 compression (460 kbit/s). MPPC also, given the far greater computing power at its disposal, is more effective on data than V.44 and achieves higher compression ratios when 8:1 isn't achievable.\n^ http://www.ietf.org/ietf/IPR/hifn-ipr-draft-friend-tls-lzs-compression.txt","alt_names":["Microsoft Point to Point Compression","Microsoft Point-to-Point Compression","Microsoft Point-to-Point Compression - Wikipedia, the free","Microsoft_Point-to-Point_Compression","Wikipedia article Microsoft Point-to-Point Compression","article Microsoft Point-to-Point Compression","en.wikipedia.org/wiki/Mi...oint_Compression","http://en.wikipedia.org/wiki/Microsoft Point-to","http://en.wikipedia.org/wiki/Microsoft_Point-to-Point_Compression","mppc","Википедии статью MPPC"],"name":"Microsoft Point-to-Point Compression","categories":["All articles lacking sources","All articles needing expert attention","Articles lacking sources from August 2009","Articles needing expert attention from February 2009","Articles needing expert attention with no reason or talk parameter","Computing articles needing expert attention","Lossless compression algorithms","Microsoft initiatives","Modems"],"tag_line":"Microsoft Point-to-Point Compression (MPPC; described in RFC 2118) is a streaming data compression algorithm based on an implementation of Lempel–Ziv using a sliding window buffer."}}
,{"_index":"throwtable","_type":"algorithm","_id":"stooge-sort","_score":0,"_source":{"description":"Stooge sort is a recursive sorting algorithm with a time complexity of O(nlog 3 / log 1.5 ) = O(n2.7095...). The running time of the algorithm is thus slower compared to efficient sorting algorithms, such as Merge sort, and is even slower than Bubble sort, a canonical example of a fairly inefficient and simple sort.\nThe algorithm is defined as follows:\nIf the value at the end is smaller than the value at the start, swap them.\nIf there are 3 or more elements in the list, then:\nStooge sort the initial 2/3 of the list\nStooge sort the final 2/3 of the list\nStooge sort the initial 2/3 of the list again\n\nelse: exit the procedure\nIt is important to get the integer sort size used in the recursive calls by rounding the 2/3 upwards, e.g. rounding 2/3 of 5 should give 4 rather than 3, as otherwise the sort can fail on certain data. However, if the code is written to end on a base case of size 1, rather than terminating on either size 1 or size 2, rounding the 2/3 of 2 upwards gives an infinite number of calls.\nThe algorithm gets its name from slapstick routines of The Three Stooges, in which each stooge hits the other two.","alt_names":["- Stooge sort :","...mehr auf Wikipedia über Stoogesort","...more on Wikipedia about Stooge sort","Stooge Sort","Stooge sort","Stooge sort - Wikipedia","Stooge sort - Wikipedia, the free encyclopedia","Stooge sort Wikipedia the free encyclopedia - result","Stooge sort →","Stooge_sort","Stoogesort","Stoogesort – Wikipedia","Trippel sort","Trippelsort","What is implementation of Stooge sort","Wikipedia article Stooge sort","Wikipedia article about Stooge sort","Wikipedia article on Stooge sort","Wikipedia entry for Stooge sort","Wikipedia l'articolo Trippel sort","Wikipedia-Artikel Stooge sort","Wikipedia-Artikel Stoogesort","Wikipedia-Artikel Trippelsort","de:Stoogesort","http://de.wikipedia.org/wiki/Stooge_sort","http://de.wikipedia.org/wiki/Stoogesort","http://en.wikipedia.org/wiki/Stooge_sort","http://it.wikipedia.org/wiki/Stooge_sort","http://it.wikipedia.org/wiki/Trippel_sort","http://ru.wikipedia.org/wiki/Stooge_sort","it:Trippel sort","ru:Stooge sort","stooge sort","yago-res:Stooge sort"],"name":"Stooge sort","categories":["All articles with unsourced statements","All stub articles","Articles with example pseudocode","Articles with unsourced statements from March 2010","Comparison sorts","Computer science stubs","Sorting algorithms","Use dmy dates from October 2010"],"tag_line":"Stooge sort is a recursive sorting algorithm with a time complexity of O(nlog 3 / log 1.5 ) = O(n2.7095...)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lossless-compression","_score":0,"_source":{"description":"Lossless compression is a class of data compression algorithms that allows the original data to be perfectly reconstructed from the compressed data. By contrast, lossy compression permits reconstruction only of an approximation of the original data, though this usually improves compression rates (and therefore reduces file sizes).\nLossless data compression is used in many applications. For example, it is used in the ZIP file format and in the GNU tool gzip. It is also often used as a component within lossy data compression technologies (e.g. lossless mid/side joint stereo preprocessing by the LAME MP3 encoder and other lossy audio encoders).\nLossless compression is used in cases where it is important that the original and the decompressed data be identical, or where deviations from the original data could be deleterious. Typical examples are executable programs, text documents, and source code. Some image file formats, like PNG or GIF, use only lossless compression, while others like TIFF and MNG may use either lossless or lossy methods. Lossless audio formats are most often used for archiving or production purposes, while smaller lossy audio files are typically used on portable players and in other cases where storage space is limited or exact replication of the audio is unnecessary.","alt_names":["Lossless compression benchmarks"],"name":"Lossless compression","categories":["All articles with unsourced statements","Articles with unsourced statements from August 2011","Articles with unsourced statements from December 2007","Articles with unsourced statements from November 2012","Articles with unsourced statements from November 2015","Data compression","Lossless compression algorithms"],"tag_line":"Lossless compression is a class of data compression algorithms that allows the original data to be perfectly reconstructed from the compressed data."}}
,{"_index":"throwtable","_type":"algorithm","_id":"x-+-y-sorting","_score":0,"_source":{"description":"In computer science, X + Y sorting is the problem of sorting pairs of numbers by their sum. Given two finite sets X and Y, the problem is to order all pairs (x, y) in the Cartesian product X × Y by the key x + y. The problem is attributed to Elwyn Berlekamp.\nThis problem can be solved using a straightforward comparison sort on the Cartesian product, taking time O(nm log(nm)) for sets of sizes n and m. When it is assumed that m = n, the complexity is O(n2 log n2) = O(n2 log n), which is also the best known bound on the problem, but whether X + Y sorting can be done strictly faster than sorting n⋅m arbitrary numbers is an open problem. The number of required comparisons is certainly lower than for ordinary comparison sorting: Fredman showed, in 1976, that X + Y sorting can be done using only O(n2) comparisons, though he did not show an algorithm. The first actual algorithm that achieves this number of comparisons and O(n2 log n) total complexity was only published sixteen years later.\nOn a RAM machine with word size w and integer inputs 0 ≤ {x, y} < n = 2w, the problem can be solved in O(n log n) operations by means of the fast Fourier transform.\nSkiena recounts a practical application in transit fare minimisation, an instance of the shortest path problem: given fares x and y for trips from departure A to some intermediate destination B and from B to final destination C, determine the least expensive combined trip from A to C.","alt_names":[],"name":"X + Y sorting","categories":["Sorting algorithms","Unsolved problems in computer science"],"tag_line":"In computer science, X + Y sorting is the problem of sorting pairs of numbers by their sum."}}
,{"_index":"throwtable","_type":"algorithm","_id":"power-quality-compression-algorithm","_score":0,"_source":{"description":"A power quality compression algorithm is an algorithm used in power quality analysis. To provide high quality electric power service, it is essential to monitor the quality of the electric signals also termed as power quality (PQ) at different locations along an electrical power network. Electrical utilities carefully monitor waveforms and currents at various network locations constantly, to understand what lead up to any unforeseen events such as a power outage and blackouts. This is particularly critical at sites where the environment and public safety are at risk (institutions such as hospitals, sewage treatment plants, mines, etc.).","alt_names":["Power Quality Compression Algorithm - Responsible Electricity","Power quality compression algorithm","Power quality compression algorithm - Wikipedia, the free ...","Power quality compression algorithm; it is used under","http://en.wikipedia.org/wiki/Power_quality_compression_algorithm"],"name":"Power quality compression algorithm","categories":["All articles needing cleanup","All articles to be merged","All articles with topics of unclear notability","Articles needing cleanup from November 2010","Articles to be merged from March 2013","Articles with topics of unclear notability from December 2012","Cleanup tagged articles without a reason field from November 2010","Compression algorithms","Power engineering","Wikipedia pages needing cleanup from November 2010"],"tag_line":"A power quality compression algorithm is an algorithm used in power quality analysis."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lempel–ziv–welch","_score":0,"_source":{"description":"Lempel–Ziv–Welch (LZW) is a universal lossless data compression algorithm created by Abraham Lempel, Jacob Ziv, and Terry Welch. It was published by Welch in 1984 as an improved implementation of the LZ78 algorithm published by Lempel and Ziv in 1978. The algorithm is simple to implement, and has the potential for very high throughput in hardware implementations. It is the algorithm of the widely used Unix file compression utility compress, and is used in the GIF image format.","alt_names":[],"name":"Lempel–Ziv–Welch","categories":["All articles to be merged","Articles to be merged from December 2015","Articles with example pseudocode","Lossless compression algorithms","Wikipedia articles needing clarification from October 2012"],"tag_line":"Lempel–Ziv–Welch (LZW) is a universal lossless data compression algorithm created by Abraham Lempel, Jacob Ziv, and Terry Welch."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lempel–ziv–stac","_score":0,"_source":{"description":"Lempel–Ziv–Stac (LZS, or Stac compression) is a lossless data compression algorithm that uses a combination of the LZ77 sliding-window compression algorithm and fixed Huffman coding. It was originally developed by Stac Electronics for tape compression, and subsequently adapted for hard disk compression and sold as the Stacker disk compression software. It was later specified as a compression algorithm for various network protocols. LZS is specified in the Cisco IOS stack.","alt_names":[],"name":"Lempel–Ziv–Stac","categories":["Lossless compression algorithms"],"tag_line":"Lempel–Ziv–Stac (LZS, or Stac compression) is a lossless data compression algorithm that uses a combination of the LZ77 sliding-window compression algorithm and fixed Huffman coding."}}
,{"_index":"throwtable","_type":"algorithm","_id":"multiplication-algorithm","_score":0,"_source":{"description":"A multiplication algorithm is an algorithm (or method) to multiply two numbers. Depending on the size of the numbers, different algorithms are in use. Efficient multiplication algorithms have existed since the advent of the decimal system.","alt_names":["3 × 11","multiplication algorithm","Multiplication algorithm","multiplication of large integers","- Lattice method :","- Lattice multiplication :","- Multiplication algorithm :","- Shabakh :","...Wikipedia Technique de la multiplication par jalousies","...Wikipedia Technique de multiplication","...more on Wikipedia about Multiplication algorithm","...more on Wikipedia about Shabakh","1 Long multiplication","1 Multiplicación de dos enteros","1.2 Space complexity","1.3 Electronic usage","2 Sunzi multiplication algorithm","2 Álgebra: Multiplicación de Monomios","215px-Hindu_lattice.svg.png","220px Hindu lattice 2 svg png","3 Lattice multiplication","3 Multiplicación de un polinomio entre un monomio","4 Multiplicación de dos polinomios","4 Peasant or binary multiplication","5 Shift and add","6 Fast multiplication algorithms for large inputs","6.1 Gauss's complex multiplication algorithm","6.2 Karatsuba multiplication","6.3 Toom–Cook","6.4 Fourier transform methods","6.5 Linear time multiplication","6.6 Quarter square multiplier","6.7 Polynomial multiplication","7 Lower bounds","Algorisme de multiplicació","Algorisme de multiplicació - Viquipèdia","Algorithme de multiplication","Algorithme de multiplication - Wikipédia","Algoritmi di moltiplicazione","Algoritmi di moltiplicazione - Wikipedia","Algoritmo de Gauss de la multiplicación compleja","Algoritmo de multiplicación","Algoritmo de multiplicación - Wikipedia, la enciclopedia libre","Algoritmo de multiplikado - Vikipedio","Algoritmo_de_multiplicación","Artykuł o algorytmach mnożenia na wiki","Binary Fast Fourier Transform","Binary multiplication","FFT multiplication","Hindu lattice","Information About Lattice","La multiplication","La multiplication par jalousies","Lattice Multiplication","Lattice Multiplication at Wikipedia","Lattice method","Lattice method on Wikipedia","Lattice multiplication","Lattice multiplication (“Inmultirea cu tabel”)","Lattice multiplication - Wikipedia, the free encyclopedia","Lattice multiplication Wikipedia the free encyclopedia","Lattice multiplication Wikipedia, the ...","Lattice multiplication; it is used under the","Lattice multiplication?","Lattice, or sieve, multiplication","Lattice_multiplication","Leonardo Fibonacci-Wikipedia","Lien_ext6","Long multiplication","Multiplicación de dos polinomios","Multiplicación de un polinomio y un monomio","Multiplication Algorithm","Multiplication Algorithms","Multiplication algorithm - Wikipedia :: The free encyclopedia","Multiplication algorithm - Wikipedia, the free ...","Multiplication algorithm - Wikipedia, the free encyclopedia","Multiplication algorithm Wikipedia the free encyclopedia","Multiplication algorithm bei Wikipedia, Englisch","Multiplication algorithm on Wikipedia","Multiplication algorithm on Wikipedia, English","Multiplication algorithm: Example","Multiplication algorithms","Multiplication algorithms for computer algebra","Multiplication algorithms; it is used under the","Multiplication par Jalousies","Multiplication_algorithm","Multiplikationsalgorithmen)","Peasant or binary multiplication","Perkalian algoritma).","Principe de Jalousie","Schoolbook long multiplication","Shabakh","Shabakh - Wikipedia, the free encyclopedia","Shift and Add","Source Wikipedia.org Arcticle - Shabakh","Strassen's method for integer multiplication","Sunzi multiplication ...","Technique de la multiplication par jalousies","Technique de la multiplication par jalousies - Wikipédia","Technique de la multiplication « par jalousies »","Technique de multiplication","Technique de multiplication - Wikipédia","The Lattice Method","The lattice method.","What is Lattice method's example?","What is the description of Shabakh","Wikipedia - Multiplication algorithm","Wikipedia - multiplication algorithms","Wikipedia --Lattice Multiplication","Wikipedia Artikel über binäre Multiplikation mit Computern","Wikipedia article Algorithme de multiplication","Wikipedia article Algoritmo de multiplicación","Wikipedia article Algoritmo de multiplikado","Wikipedia article Lattice method","Wikipedia article Lattice multiplication","Wikipedia article Long multiplication","Wikipedia article Multiplication algorithm","Wikipedia article Shabakh","Wikipedia article on Algoritmo de multiplicación","Wikipedia article on Long multiplication","Wikipedia article on Multiplication algorithm","Wikipedia entry for Multiplication algorithm","Wikipedia entry for Shabakh","Wikipedia page on multiplication algorithms","Wikipedia's article on binary multiplication with computers","Wikipedia: Multiplication algorithm","Wikipedia的文章乘法与计算机的二进制","Wikipedii článek o binární násobení s počítači","algorisme de multiplicació","algorithm for multiplication","algorithmes de multiplication).","algoritma perkalian","algoritmi di moltiplicazione).","algoritmo de multiplicación","algoritmos de multiplicação).","algoritmust.","articolo di Wikipedia sulla moltiplicazione binaria con i","artículo de Wikipedia Algoritmo de multiplicacion","artículo de Wikipedia Algoritmo de multiplicación","ca:Algorisme de multiplicació","các thuật toán Phép nhân).","denne Wikipedia-artiklen","deze Wikipedia-artikel","effectuer la multiplication","el artículo de Wikipedia sobre la multiplicación binaria","en.wikipedia.org/Shabakh","en.wikipedia.org/wik...iplication_algorithm","en.wikipedia.org/wiki/Multiplication_...","en.wikipedia.org/wiki/Multiplication_algorithm","en.wikipedia.org/wiki/Multiplication_algorithm#Lattice_mu...","en.wikipedia.org/wiki/Multiplication_algorithm#Shift_and_add","en.wikipedia.org/wiki/Multiplication_algorithms","en.wikipedia.org/wiki/Shabakh","eo:Algoritmo de multiplikado","es:Algoritmo de multiplicación","fast arithmetic","faster algorithms are also known","fr.wikipedia.org/wiki/Algorithme_de_multiplication","fr:Algorithme de multiplication","fr:Technique de la multiplication par jalousies","fr:Technique de multiplication","gelosia or lattice multiplication","grade-school algorithm","grade-school method","grade-school multiplication","http://ca.wikipedia.org/wiki/Algorisme_de_multiplicaci%C3%B3","http://en.wikipedia.o...attice_multiplication","http://en.wikipedia.org/w(...)er_transform_methods","http://en.wikipedia.org/wiki/Lattice_met…","http://en.wikipedia.org/wiki/Lattice_multiplication","http://en.wikipedia.org/wiki/Lattice_multiplication#Lattice_multiplication","http://en.wikipedia.org/wiki/Lattice_mul…","http://en.wikipedia.org/wiki/Long_multip…","http://en.wikipedia.org/wiki/M...ithm#Fourier_transform_methods","http://en.wikipedia.org/wiki/Multipl...#Shift_and_add","http://en.wikipedia.org/wiki/Multipl...multiplication","http://en.wikipedia.org/wiki/Multipl...nsform_methods","http://en.wikipedia.org/wiki/Multiplica ... #Toom-Cook","http://en.wikipedia.org/wiki/Multiplica ... rm_methods","http://en.wikipedia.org/wiki/Multiplication algorithm","http://en.wikipedia.org/wiki/Multiplication_a...","http://en.wikipedia.org/wiki/Multiplication_a...lgorithm","http://en.wikipedia.org/wiki/Multiplication_algorithm","http://en.wikipedia.org/wiki/Multiplication_algorithm#Fast_multiplication_algorithms_for_large_inputs","http://en.wikipedia.org/wiki/Multiplication_algorithm#Fourier_transform_methods","http://en.wikipedia.org/wiki/Multiplication_algorithm#Karatsuba_multiplication","http://en.wikipedia.org/wiki/Multiplication_algorithm#Lattic","http://en.wikipedia.org/wiki/Multiplication_algorithm#Lattice_multiplication","http://en.wikipedia.org/wiki/Multiplication_algorithm#Long_multiplication","http://en.wikipedia.org/wiki/Multiplication_algorithm#Multiplication_algorithms_for_computer_algebra","http://en.wikipedia.org/wiki/Multiplication_algorithm#Peasant_or_binary_multiplication","http://en.wikipedia.org/wiki/Multiplication_algorithm#Peasant_or_binary_multiplication - Multiplication","http://en.wikipedia.org/wiki/Multiplication_algorithm#Peasant_or_binary_multiplication.","http://en.wikipedia.org/wiki/Multiplication_algorithm#Quarter_square_multiplier","http://en.wikipedia.org/wiki/Multiplication_algorithm#Shift_and_add","http://en.wikipedia.org/wiki/Multiplication_algorithms","http://en.wikipedia.org/wiki/M​ultiplication_algorithm#Lattic","http://en.wikipedia.org/wiki/Shabakh","http://eo.wikipedia.org/wiki/Algoritmoj_de_multiplikado","http://eo.wikipedia.org/wiki/Longa_multipliko","http://eo.wikipedia.org/wiki/Multiplika_algoritmo","http://es.wikipedia.org/wiki/Algoritmo_de_multiplicaci%C3%B3n","http://es.wikipedia.org/wiki/Algoritmo_de_multiplicación","http://fr.wikipedia.org/wiki/Algori..._multiplication","http://fr.wikipedia.org/wiki/Algorit...multiplication","http://fr.wikipedia.org/wiki/Algorithme … iplication","http://fr.wikipedia.org/wiki/Algorithme_de_multiplication","http://fr.wikipedia.org/wiki/Techn [...] _jalousies","http://fr.wikipedia.org/wiki/Technique_ … _jalousies","http://fr.wikipedia.org/wiki/Technique_de_la_multiplication_par_jalousies","http://fr.wikipedia.org/wiki/Technique_de_multiplication","http://tr.wikipedia.org/wiki/%C3%87arpma_algoritmalar%C4","http://tr.wikipedia.org/wiki/Çarpma_algoritmaları","integer multiplication algorithm","it:Algoritmi di moltiplicazione","la technique de multiplication par jalousies","lattice method","lattice multiplication","lattice multiplication.","long multiplication","long multiplications","los algoritmos de multiplicación).","mention the shift and add","more efficient methods","most computers do this","multiplicaciones largas","multiplicar números grandes","multiplication algorithm#Shift and add","multiplication algorithms","multiplication by doubling","multiplication lattices","multiplication methods based on the Fast Fourier transform","multiplication par jalousies","multiplicações longas","multiply numbers","multiplying large integers","multiplying large numbers","méthode de multiplication par jalousies","método para multiplicar","par Jalousie","peasant's algorithm","people have already done this","procedure for multiplying large numbers","quick approaches","series of shifts and adds or subtracts","shifting then adding","sistema occidental","technique de la multiplication par jalousies","textbook multiplication","the lattice method","tout plein d'autres","tr:Çarpma Algoritmaları","tr:Çarpma algoritmaları","traditional algorithm for solving multi-digit multiplication","w artykule Wikipedii na mnożenie binarne z komputerami","Álgebra : multiplicación de monomios","Ã‡arpma algoritmalarÄ± - Vikipedi","Çarpma Algoritması 1. Yol","Çarpma algoritmaları","Çarpma algoritmaları - Vikipedi","алгоритма умножения).","алгоритъма за бързо умножение","быстрое умножение","в статье Википедии о бинарных умножения с компьютерами","อั ลก อริ คูณ).","の乗算アルゴリズム","を使用し","乘法算法","곱셈 알고리즘을","사용하는"],"name":"Multiplication algorithm","categories":["All articles needing additional references","All articles to be expanded","Articles needing additional references from January 2013","Articles needing additional references from May 2013","Articles needing additional references from September 2012","Articles to be expanded from October 2008","Computer arithmetic algorithms","Multiplication","Pages with citations having bare URLs","Pages with citations lacking titles","Unsolved problems in computer science"],"tag_line":"A multiplication algorithm is an algorithm (or method) to multiply two numbers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"prefix-code","_score":0,"_source":{"description":"A prefix code is a type of code system (typically a variable-length code) distinguished by its possession of the \"prefix property\", which requires that there is no code word in the system that is a prefix (initial segment) of any other code word in the system. For example, a code with code words {9, 55} has the prefix property; a code consisting of {9, 5, 59, 55} does not, because \"5\" is a prefix of \"59\" and also of \"55\". A prefix code is a uniquely decodable code: a receiver can identify each word without requiring a special marker between words.\nPrefix codes are also known as prefix-free codes, prefix condition codes and instantaneous codes. Although Huffman coding is just one of many algorithms for deriving prefix codes, prefix codes are also widely referred to as \"Huffman codes\", even when the code was not produced by a Huffman algorithm. The term comma-free code is sometimes also applied as a synonym for prefix-free codes but in most mathematical books and articles (e.g.) a comma-free code is used to mean a self-synchronizing code, a subclass of prefix codes.\nUsing prefix codes, a message can be transmitted as a sequence of concatenated code words, without any out-of-band markers or (alternatively) special markers between words to frame the words in the message. The recipient can decode the message unambiguously, by repeatedly finding and removing sequences that form valid code words. This is not generally possible with codes that lack the prefix property, for example {0, 1, 10, 11}: a receiver reading a \"1\" at the start of a code word would not know whether that was the complete code word \"1\", or merely the prefix of the code word \"10\" or \"11\"; so the string \"10\" could be interpreted either as a single codeword or as the concatenation of the words \"1\" then \"0\".\nThe variable-length Huffman codes, country calling codes, the country and publisher parts of ISBNs, the Secondary Synchronization Codes used in the UMTS W-CDMA 3G Wireless Standard, and the instruction sets (machine language) of most computer microarchitectures are prefix codes.\nPrefix codes are not error-correcting codes. In practice, a message might first be compressed with a prefix code, and then encoded again with channel coding (including error correction) before transmission.\nKraft's inequality characterizes the sets of code word lengths that are possible in a uniquely decodable code.\n^ US Federal Standard 1037C\n^ ATIS Telecom Glossary 2007, retrieved December 4, 2010 \n^ Berstel, Jean; Perrin, Dominique (1985), Theory of Codes, Academic Press \n^ Golomb, S. W.; Gordon, Basil; Welch, L. R. (1958), \"Comma-Free Codes\", Canadian Journal of Mathematics 10 (2): 202–209, doi:10.4153/CJM-1958-023-9 \n^ Berstel et al (2010) p.75","alt_names":["Префиксный код","Prefix code","- Prefix code :","-> Read the article about 'Prefix code'","...Wikipedia Kod prefiksowy","...more on Wikipedia about Prefix code","2 Prefix codes in use today","Codice prefisso (da wikipedia)","Código prefijo","Código prefijo - Wikipedia, la enciclopedia libre","Kod prefiksowy – Wikipedia, wolna encyklopedia","Kod_prefiksowy","Pr%C3%A4fix-Code bei der wikipedia","Pr%C3%A4fixcode bei der wikipedia","Prefix Code","Prefix code - Wikipedia, the free encyclopedia","Prefix code - Wikipedia, the free encyclopediaA prefix","Prefix code Wikipedia the free encyclopedia","Prefix code Wikipedia, the free ...","Prefix code; it is used under the","Prefix codes","Prefix codes in use today","Prefix coding","Prefix-Codes","Prefix-free code","Prefix_code","Prefixový kód","Prefixový kód - Wikipedie","Präfix-code","Präfixcode","Präfixcode in","Präfixcode – Wikipedia","Vorwahlen","Wikipedia : 接頭符号","Wikipedia article ''Prefix code''","Wikipedia article Código prefijo","Wikipedia article Kod prefiksowy","Wikipedia article Prefix code","Wikipedia article Prefix codes","Wikipedia article Prefix_code","Wikipedia article on Códigos prefijo","Wikipedia article on Prefix code","Wikipedia entry for Prefix code","Wikipedia-Artikel Präfix-Code","Wikipedia-Artikel Präfixcode","Wikipedia-Seite zu 'Präfixcode'","Wikipedia:Prefix_code","Wikipediaで「接頭符号」を調べる","Wikipediaで「語頭符号」を調べる","artículo de Wikipedia Código prefijo","artículo de Wikipedia Códigos prefijo","codes préfixe","codice prefisso","codici di prefisso","cs:Prefixový kód","código prefijo","códigos de prefixo","códigos prefijo","de:Präfixcode","en.wikipedia.org/wiki/Prefix_code","es:Código prefijo","http://de.wikipedia.org/wiki/Pr%C3%A4fixcode","http://en.Liarpedia.org/wiki/Prefix_code","http://en.wikipedia.org/wiki/Prefix-free_code","http://en.wikipedia.org/wiki/Prefix_code","http://en.wikipedia.org/wiki/Prefix_codes","http://en.wikipedia.org/wiki/prefix_code","http://es.wikipedia.org/wiki/C%C3%B3digo_prefijo","http://fr.wikipedia.org/wiki/Code_pr%C3%A9fixe","http://pl.wikipedia.org/wiki/Kod_pr","http://pl.wikipedia.org/wiki/Kod_prefiksowy","http://ru.wikipedia.org/wiki/Префиксный_...","http://ru.wikipedia.org/wiki/Префиксный_код","ja:接頭符号","kode awalan","kodem prefiksowym","kody prefiksowe","mã số tiền tố","optimal prefix codes","pl.wikipedia.org/wiki/Kod_prefiksowy","pl:Kod prefiksowy","prefix code","prefix coded","prefix codes","prefix compression","prefix property","prefix-free","prefix-free binary code","prefix-free code","prefixový kód","präfixcode","präfixfreier Code","ru:Префиксный код","uk:Префіксний код","wikipedia:Prefix code","Википедии статью Префиксный код","Префиксный код — Википедия","Префіксний код","префикса кодов","префиксного","префиксный","префиксный код","префиксным","префиксным кодом","префиксными бинарными кодами переменной длины","รหัส คำนำ หน้า","“Prefix coding”","のプリフィックスコード","ウィキペディアの記事 接頭符号","ウィキペディアの記事 語頭符号","前綴代碼","前缀代码","前缀码","接頭<b>符号</b> - Wikipedia","接頭符号","接頭符号 - Wikipedia","接頭符号-wikipedia","語頭符号","語頭符号-wikipedia","접두사를 코드"],"name":"Prefix code","categories":["Coding theory","Data compression","Lossless compression algorithms","Prefixes","Wikipedia articles incorporating text from the Federal Standard 1037C"],"tag_line":"A prefix code is a type of code system (typically a variable-length code) distinguished by its possession of the \"prefix property\", which requires that there is no code word in the system that is a prefix (initial segment) of any other code word in the system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"computational-complexity-of-mathematical-operations","_score":0,"_source":{"description":"The following tables list the running time of various algorithms for common mathematical operations.\nHere, complexity refers to the time complexity of performing computations on a multitape Turing machine. See big O notation for an explanation of the notation used.\nNote: Due to the variety of multiplication algorithms, M(n) below stands in for the complexity of the chosen multiplication algorithm.\n\n","alt_names":["- Computational complexity of mathematical operations :","Arithmetic and algebraic functions","Complexity of matrix algebra(Wikipedia)","Computational Complexity of Mathematical Operations.","Computational Komplexität der mathematischen Operationen","Computational complexity of mathematic...","Computational complexity of mathematical operations","Computational complexity of mathematical operations - Wikipedia","Computational complexity of mathematical operations - Wikipedia ...","Computational complexity of mathematical operations - Wikipedia :: The free","Computational complexity of mathematical operations - Wikipedia, the free","Computational complexity of mathematical operations - Wikipedia, the...","Computational complexity of mathematical operations - Wikipedia.","Computational complexity of mathematical operations ...","Computational complexity of mathematical operations Wikipedia","Computational complexity of mathematical operations#Matrix algebra","Computational kompleksitet matematiske operationer","Computational_complexity_of_mathematical_operations","Matrix_algebra # http://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations","N-LogN complexity.","O(n^3)","O(n^{2.376})","Source Wikipedia.org Arcticle - Computational complexity of mathematical","Wikipedia article Computational complexity of mathematical operations","Wikipedia entry for Computational complexity of mathematical operations","Wikipedia on the Computational Complexity of Mathematical Operations","Wikipedia: Computational Complexity of Mathematical Operations","Wikipedia: Computational complexity of mathematical operations","Złożoność obliczeniowa operacji matematycznych","complejidad cúbica","complessità computazionale di operazioni matematiche","complexity of mathematical operations,","complexity of multiplication","computational complexity of mathematical operations","computationele complexiteit van de wiskundige bewerkingen","en.wikipedia.org/wiki/Computational_complexity_of_mathema...","fastest algorithm for multiplication","http://en.wikipedia.org/wiki/Computa...cal_operations","http://en.wikipedia.org/wiki/Computatio ... operations","http://en.wikipedia.org/wiki/Computational...ical_operations","http://en.wikipedia.org/wiki/Computational_complexity_of_mat...","http://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations","http://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations#Matrix_algebra","important - or at least common - algorithms","la complejidad computacional de operaciones matemáticas","nu: n`et geen O(n log n","the computational complexity of mathematical operations","výpočetní složitost matematických operací","which is O(n 2 )","wp:Computational_complexity_of_mathematical_operations","yago-res:Computational complexity of mathematical operations","Вычислительная сложность математических операций","गणितीय आपरेशन के कम्प्यूटेशनल जटिलता","数学运算的计算复杂性","算術演算の計算の複雑さ"],"name":"Computational complexity of mathematical operations","categories":["All articles needing additional references","Articles needing additional references from April 2015","Computational complexity theory","Computer arithmetic algorithms","Mathematics-related lists","Number theoretic algorithms","Unsolved problems in computer science"],"tag_line":"The following tables list the running time of various algorithms for common mathematical operations."}}
,{"_index":"throwtable","_type":"algorithm","_id":"toom–cook-multiplication","_score":0,"_source":{"description":"Toom–Cook, sometimes known as Toom-3, named after Andrei Toom, who introduced the new algorithm with its low complexity, and Stephen Cook, who cleaned the description of it, is a multiplication algorithm, a method of multiplying two large integers.\nGiven two large integers, a and b, Toom–Cook splits up a and b into k smaller parts each of length l, and performs operations on the parts. As k grows, one may combine many of the multiplication sub-operations, thus reducing the overall complexity of the algorithm. The multiplication sub-operations can then be computed recursively using Toom–Cook multiplication again, and so on. Although the terms \"Toom-3\" and \"Toom–Cook\" are sometimes incorrectly used interchangeably, Toom-3 is only a single instance of the Toom–Cook algorithm, where k = 3.\nToom-3 reduces 9 multiplications to 5, and runs in Θ(nlog(5)/log(3)), about Θ(n1.465). In general, Toom-k runs in Θ(c(k) ne), where e = log(2k − 1) / log(k), ne is the time spent on sub-multiplications, and c is the time spent on additions and multiplication by small constants. The Karatsuba algorithm is a special case of Toom–Cook, where the number is split into two smaller ones. It reduces 4 multiplications to 3 and so operates at Θ(nlog(3)/log(2)), which is about Θ(n1.585). Ordinary long multiplication is equivalent to Toom-1, with complexity Θ(n2).\nAlthough the exponent e can be set arbitrarily close to 1 by increasing k, the function c unfortunately grows very rapidly. The growth rate for mixed-level Toom-Cook schemes was still an open research problem in 2005. An implementation described by Donald Knuth achieves the time complexity Θ(n 2√(2 log n) log n).\nDue to its overhead, Toom–Cook is slower than long multiplication with small numbers, and it is therefore typically used for intermediate-size multiplications, before the asymptotically faster Schönhage–Strassen algorithm (with complexity Θ(n log n log log n)) becomes practical.\nToom first described this algorithm in 1963, and Cook published an improved (asymptotically equivalent) algorithm in his PhD thesis in 1966.\n\n","alt_names":[],"name":"Toom–Cook multiplication","categories":["Computer arithmetic algorithms","Multiplication"],"tag_line":"Toom–Cook, sometimes known as Toom-3, named after Andrei Toom, who introduced the new algorithm with its low complexity, and Stephen Cook, who cleaned the description of it, is a multiplication algorithm, a method of multiplying two large integers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"color-cell-compression","_score":0,"_source":{"description":"Color Cell Compression is an early lossy image compression algorithm first described by Campbell et al. in 1986. It is a variant of Block Truncation Coding. The encoding process works on small blocks of pixels. For each block, it first partitions the pixels in that block into two sets based on their luminance values, then generates representative colour values for each of these sets, and a bitmap that specifies which pixels belong to which set. The two colour values and the bitmap for each block are then output directly without any further quantization or entropy coding.\nThe decoding process is simple; each pixel of an output block is generated by choosing one of the two representative colours for that block, based on that block's bitmap.\nIn spite of its very simple mechanism, the algorithm yields surprisingly good results on photographic images, and it has the advantage of being very fast to decode with limited hardware. Although far surpassed in compression ratio by later block-transform coding methods such as JPEG, it had the advantage of very simple decompression and fast random access into the compressed image, and it can be regarded as a forerunner of modern texture compression algorithms.","alt_names":[],"name":"Color Cell Compression","categories":["All stub articles","Computer graphics stubs","Lossy compression algorithms"],"tag_line":"Color Cell Compression is an early lossy image compression algorithm first described by Campbell et al."}}
,{"_index":"throwtable","_type":"algorithm","_id":"gauss–legendre-algorithm","_score":0,"_source":{"description":"The Gauss–Legendre algorithm is an algorithm to compute the digits of π. It is notable for being rapidly convergent, with only 25 iterations producing 45 million correct digits of π. However, the drawback is that it is memory intensive and it is therefore sometimes not used over Machin-like formulas.\nThe method is based on the individual work of Carl Friedrich Gauss (1777–1855) and Adrien-Marie Legendre (1752–1833) combined with modern algorithms for multiplication and square roots. It repeatedly replaces two numbers by their arithmetic and geometric mean, in order to approximate their arithmetic-geometric mean.\nThe version presented below is also known as the Gauss–Euler, Brent–Salamin (or Salamin–Brent) algorithm; it was independently discovered in 1975 by Richard Brent and Eugene Salamin. It was used to compute the first 206,158,430,000 decimal digits of π on September 18 to 20, 1999, and the results were checked with Borwein's algorithm.","alt_names":[],"name":"Gauss–Legendre algorithm","categories":["Pi algorithms"],"tag_line":"The Gauss–Legendre algorithm is an algorithm to compute the digits of π."}}
,{"_index":"throwtable","_type":"algorithm","_id":"gwic","_score":0,"_source":{"description":"GWIC (GNU Wavelet Image Codec) is a lossy image compression algorithm.","alt_names":["GWIC","GWIC; it is used under the","Gwic","Wikipedia article GWIC","Wikipedia entry for GWIC","http://en.wikipedia.org/wiki/GWIC"],"name":"GWIC","categories":["All articles lacking sources","All articles with dead external links","All articles with topics of unclear notability","All orphaned articles","All stub articles","Articles lacking sources from February 2014","Articles with dead external links from February 2014","Articles with topics of unclear notability from November 2015","Graphics software stubs","Lossy compression algorithms","Orphaned articles from February 2009"],"tag_line":"GWIC (GNU Wavelet Image Codec) is a lossy image compression algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lamport-timestamps","_score":0,"_source":{"description":"The algorithm of Lamport timestamps is a simple algorithm used to determine the order of events in a distributed computer system. As different nodes or processes will typically not be perfectly synchronized, this algorithm is used to provide a partial ordering of events with minimal overhead, and conceptually provide a starting point for the more advanced vector clock method. They are named after their creator, Leslie Lamport.\nDistributed algorithms such as resource synchronization often depend on some method of ordering events to function. For example, consider a system with two processes and a disk. The processes send messages to each other, and also send messages to the disk requesting access. The disk grants access in the order the messages were sent. Now, imagine process 1 sends a message to the disk asking for access to write, and then sends a message to process 2 asking it to read. Process 2 receives the message, and as a result sends its own message to the disk. Now, due to some timing delay, the disk receives both messages at the same time: how does it determine which message happened-before the other? ( happens-before  if one can get from  to  by a sequence of moves of two types: moving forward while remaining in the same process, and following a message from its sending to its reception.) A logical clock algorithm provides a mechanism to determine facts about the order of such events.\nLamport invented a simple mechanism by which the happened-before ordering can be captured numerically. A Lamport logical clock is an incrementing software counter maintained in each process.\nIt follows some simple rules:\nA process increments its counter before each event in that process;\nWhen a process sends a message, it includes its counter value with the message;\nOn receiving a message, the receiver process sets its counter to be the maximum of the message counter and its own counter (already incremented due to rule 1), before it considers the message received.\nConceptually, this logical clock can be thought of as a clock that only has meaning in relation to messages moving between processes. When a process receives a message, it resynchronizes its logical clock with that sender.","alt_names":["Lamport-Uhr","Lamport timestamps","...mehr auf Wikipedia über Lamport-Uhr","...more on Wikipedia about Lamport timestamps","Horloge de Lamport - Wikipédia","Horloge logique - Wikip?dia","Horloge logique - Wikipédia","Lamport Clock","Lamport Clocks","Lamport Timestamps","Lamport clock","Lamport clocks","Lamport logical clock","Lamport timestamp","Lamport timestamps - Wikipedia, the free encyclopedia","Lamport timestamps: Lamport's logical clock in distributed systems","Lamport timestamps; it is used under the","Lamport घड़ियों","Lamport's Timestamps","Lamport's logical clock","Lamport's timestamp algorithm","Lamport-Uhr bei der wikipedia","Lamport-Uhr – Wikipedia","Lamport-Uhren","Lamportのクロックを","Learn about Lamport timestamps>>>","Wikipedia article Lamport clock","Wikipedia article Lamport logical clock","Wikipedia article Lamport timestamps","Wikipedia article on Lamport clock","Wikipedia article on Lamport logical clock","Wikipedia article on Lamport timestamps","Wikipedia entry for Lamport timestamps","Wikipedia sur Horloge logique","Wikipedia-Artikel Lamport-Uhr","Wikipedia-Seite zu 'Lamport-Uhr'","[2] Lamport timestamps","a Lamport Clock","clock logico","de:Lamport-Uhr","en:Lamport timestamps","horloge logique","http://de.wikipedia.org/wiki/Lamport-Uhr","http://en.wikipedia.org/wiki/Lamport_clock","http://en.wikipedia.org/wiki/Lamport_logical_clock","http://en.wikipedia.org/wiki/Lamport_tim","http://en.wikipedia.org/wiki/Lamport_timestamps","http://fr.wikipedia.org/wiki/Horloge_de_Lamport","http://fr.wikipedia.org/wiki/Horloge_logique","lamport clocks","lamport logical clock","lamport timestamps","orologi Lamport","partial ordering would be preserved","relojes Lamport","yago-res:Lamport timestamps","Временные метки Лампорта","Лампорт часы","алгоритма временных меток Лампорта","हैं Lamport","兰波特时钟","람포트 클락"],"name":"Lamport timestamps","categories":["Distributed algorithms"],"tag_line":"The algorithm of Lamport timestamps is a simple algorithm used to determine the order of events in a distributed computer system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"parallel-tebd","_score":0,"_source":{"description":"The parallel-TEBD is a version of the TEBD algorithm adapted to run on multiple hosts. The task of parallelizing TEBD could be achieved in various ways.\nAs a first option, one could use the OpenMP API (this would probably be the simplest way to do it), using preprocessor directives to decide which portion of the code should be parallelized. The drawback of this is that one is confined to Symmetric multiprocessing (SMP) architectures and the user has no control on how the code is parallelized. An Intel extension of OpenMP, called Cluster OpenMP [2], is a socket-based implementation of OpenMP which can make use of a whole cluster of SMP machines; this spares the user of explicitly writing messaging code while giving access to multiple hosts via a distributed shared-memory system. The OpenMP paradigm (hence its extension Cluster OpenMP as well) allows the user a straightforward parallelization of serial code by embedding a set of directives in it.\nThe second option is using the Message Passing Interface (MPI) API. MPI can treat each core of the multi-core machines as separate execution host, so a cluster of, let's say, 10 compute nodes with dual-core processors will appear as 20 compute nodes, on which the MPI application can be distributed. MPI offers the user more control over the way the program is parallelized. The drawback of MPI is that is not very easy to implement and the programmer has to have a certain understanding of parallel simulation systems.\nFor the determined programmer the third option would probably be the most appropriate: to write ones own routines, using a combination of threads and TCP/IP sockets to complete the task. The threads are necessary in order to make the socket-based communication between the programs non-blocking (the communication between programs has to take place in threads, so that the main thread doesn't have to wait for the communication to end and can execute other parts of the code). This option offers the programmer complete control over the code and eliminates any overhead which might come from the use of the Cluster OpenMP or MPI libraries.\nThis article introduces the conceptual basis of the implementation, using MPI-based pseudo-code for exemplification, while not restricting itself to MPI - the same basic schema could be implemented with the use of home-grown messaging routines.","alt_names":["Parallel TEBD Wikipedia the free encyclopedia","Parallel-TEBD","Parallel-TEBD - Wikipedia, the free encyclopedia","What is implementation of Parallel-TEBD","Wikipedia entry for Parallel-TEBD","http://en.wikipedia.org/wiki/Parallel-TEBD","parallel-TEBD","yago-res:Parallel-TEBD"],"name":"Parallel-TEBD","categories":["Computational physics","Distributed algorithms"],"tag_line":"The parallel-TEBD is a version of the TEBD algorithm adapted to run on multiple hosts."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ostrich-algorithm","_score":0,"_source":{"description":"In computer science, the ostrich algorithm is a strategy of ignoring potential problems on the basis that they may be exceedingly rare. It is named for the ostrich effect which is defined as \"to stick one's head in the sand and pretend there is no problem.\" It is used when it is more cost-effective to allow the problem to occur than to attempt its prevention.","alt_names":["...mehr auf Wikipedia über Vogel-Strauß-Algorithmus","Algoritma Ostrich :: Wikipedia Bahasa Indonesia","Algoritmo do avestruz - Wikipédia, a enciclopédia livre","Algoritmo do avestruz – Wikipédia, a enciclopédia livre","Ostrich Algoritham","Ostrich Algorithm","Ostrich algorithm","Ostrich algorithm - Wikipedia :: The free encyclopedia","Ostrich algorithm - Wikipedia, the free encyclopedia","Ostrich algorithm Wikipedia the free encyclopedia","Ostrich algorithm from Wikipedia","Ostrich_algorithm","Ostrich_algorithm en inglés","Ostrichova algoritmu","Proč by ne?","Pštrosí algoritmus","The Ostrich Algorithm","Vogel-Strau%C3%9F-Algorithmus bei der wikipedia","Vogel-Strauß-Algorithmus","Wikipedia article Algoritma Ostrich","Wikipedia article Algoritmo do avestruz","Wikipedia article Ostrich algorithm","Wikipedia entry for Ostrich algorithm","Wikipedia-Artikel Vogel-Strauß-Algorithmus","Wikipedia-Seite zu 'Vogel-Strauß-Algorithmus'","Yeah, that one jumped out at me.","[11] Ostrich algorithm","[dav] Vogel-Strauß-Algorithmus (from Bookmarks Everywhere RSS","algoritmo da avestruz","algoritmo dello struzzo","http://bit.ly/3LqxmY","http://bit.ly/TqmvP","http://bit.ly/jiLnJr","http://de.wikipedia.org/wiki/Vogel-Strau","http://de.wikipedia.org/wiki/Vogel-Strau%C3","http://en.wikipedia.org/wiki/Ostrich_alg","http://en.wikipedia.org/wiki/Ostrich_algorith...","http://en.wikipedia.org/wiki/Ostrich_algorithm","http://pt.wikipedia.org/wiki/Algoritmo_do_Avestruz","http://pt.wikipedia.org/wiki/Algoritmo_do_avestruz","ostrich algorithm","ostrich algorithm wikipedia the free encyclopedia","pštrosí algoritmus","pštrosím algoritmem","yago-res:Ostrich algorithm","Řeším","Αλγόριθμος της Στρουθοκαμήλου","Алгоритм страуса","এটার নামে একটা অ্যালগোরিদমও আছে।","ダチョウ・アルゴリズム - Wikipedia","ダチョウ・アルゴリズム -wikipedia","鸵鸟算法","ﾀﾞﾁｮｳ・ｱﾙｺﾞﾘｽﾞﾑ-wikipedia"],"name":"Ostrich algorithm","categories":["Concurrent algorithms"],"tag_line":"In computer science, the ostrich algorithm is a strategy of ignoring potential problems on the basis that they may be exceedingly rare."}}
,{"_index":"throwtable","_type":"algorithm","_id":"timestamp-based-concurrency-control","_score":0,"_source":{"description":"In computer science, a timestamp-based concurrency control algorithm is a non-lock concurrency control method. It is used in some databases to safely handle transactions, using timestamps.\n\n","alt_names":["-> Read more about Timestamp-based concurrency control","...more on Wikipedia about Timestamp-based concurrency control","How does Timestamp-based concurrency control work","How does Timestamp-based concurrency control work?","Timestamp Based Concurrency Control","Timestamp based concurrency control","Timestamp ordering","Timestamp-based concurrency control","Timestamp-based concurrency control - Wikipedia, the free ...","Timestamp-based concurrency control - Wikipedia, the free encyclopedia","Timestamp-based concurrency control.","Timestamp-based_concurrency_control","Timestampbased concurrency control Wikipedia the free encyclopedia","Wikipedia article Timestamp-based concurrency control","Wikipedia entry for Timestamp-based concurrency control","Wikipedia-Artikel Zeitstempelverfahren","Wikipedia-Seite zu 'Zeitstempelverfahren'","Wikipediaで「時刻印ロック」を調べる","Zeitstempelverfahren","en.wikipedia.org/wiki/Timestamp-based_concurrency_control","http://de.wikipedia.org/wiki/Zeitstempelverfahren","http://en.wikipedia.org/wiki/Timestamp-b","http://en.wikipedia.org/wiki/Timestamp-based_concurrency_control","http://en.wikipedia.org/wiki/Timestamp-based_concurrency_control)","http://en.wikipedia.org/wiki/Timestamp-b…","l. http://en.wikipedia.","optimistic concurrency based on internal timestamps","timestamp-based concurrency control","wen:Timestamp-based concurrency control","wen:Timestamp-based concurrency control#Informal","ウィキペディアの記事 時刻印ロック","時刻印ロック","時刻印ロック - Wikipedia","時刻印ﾛｯｸ-wikipedia"],"name":"Timestamp-based concurrency control","categories":["Accuracy disputes from April 2012","All accuracy disputes","All articles lacking sources","All articles needing cleanup","Articles lacking sources from June 2007","Articles needing cleanup from April 2012","Cleanup tagged articles without a reason field from April 2012","Concurrency control","Concurrency control algorithms","Transaction processing","Wikipedia pages needing cleanup from April 2012"],"tag_line":"In computer science, a timestamp-based concurrency control algorithm is a non-lock concurrency control method."}}
,{"_index":"throwtable","_type":"algorithm","_id":"concurrent-algorithm","_score":0,"_source":{"description":"In computer science, a concurrent algorithm is one that can be executed concurrently. Most standard computer algorithms are sequential algorithms, and assume that the algorithm is run from start to finish without any other processes executing. These often do not behave correctly when run concurrently, as demonstrated at right, and are often nondeterministic, as the actual sequence of computations is determined by the external scheduler. Concurrency often adds significant complexity to an algorithm, requiring concurrency control such as mutual exclusion to avoid problems such as race conditions.\nMany parallel algorithms are run concurrently, particularly distributed algorithms, though these are distinct concepts in general.","alt_names":[],"name":"Concurrent algorithm","categories":["Algorithms and data structures stubs","All articles lacking sources","All stub articles","Articles lacking sources from February 2014","Computer science stubs","Concurrent algorithms"],"tag_line":"In computer science, a concurrent algorithm is one that can be executed concurrently."}}
,{"_index":"throwtable","_type":"algorithm","_id":"berkeley-algorithm","_score":0,"_source":{"description":"The Berkeley algorithm is a method of clock synchronisation in distributed computing which assumes no machine has an accurate time source. It was developed by Gusella and Zatti at the University of California, Berkeley in 1989  and like Cristian's algorithm is intended for use within intranets.","alt_names":["Berkeley algorithm","Berkeley Algorithm","Berkeley Algorithm Wikipedia The Free Encyclopedia","Berkeley Algorithm; it is used under the","Berkeley Algorithmus","Berkeley algorithm - Wikipedia :: The free encyclopedia","Berkeley algorithm - Wikipedia, the free encyclopedia","Berkeley-Algorithmus","Berkeley-Algorithmus ? Wikipedia","Berkeley-Algorithmus – Wikipedia","Berkeley_Algorithmus","Berkley Algorithm","Wikipedia article Berkeley algorithm","Wikipedia entry for Berkeley algorithm","Wikipedia-Artikel Berkeley-Algorithmus","[8] Berkeley algorithm","de:Berkeley-Algorithmus","http://de.wikipedia.org/wiki/Berkeley-Al","http://de.wikipedia.org/wiki/Berkeley-Algorithmus","http://en.wikipedia.org/wiki/Berkeley_Algorithm","http://en.wikipedia.org/wiki/Berkeley_algorithm","yago-res:Berkeley algorithm"],"name":"Berkeley algorithm","categories":["Distributed algorithms"],"tag_line":"The Berkeley algorithm is a method of clock synchronisation in distributed computing which assumes no machine has an accurate time source."}}
,{"_index":"throwtable","_type":"algorithm","_id":"maekawa's-algorithm","_score":0,"_source":{"description":"Maekawa's algorithm is an algorithm for mutual exclusion on a distributed system. The basis of this algorithm is a quorum like approach where any one site needs only to seek permissions from a subset of other sites.","alt_names":["Maekawa's algorithm","9595b965452332672143c24e2ec576 ...","Algorithme de Maekawa","Algorithme de Maekawa - Wikipédia","Maekawa's Algorithm","Maekawa's algorithm - Wikipedia, the free encyclopedia","Maekawa-Algorithmus","Maekawa-Algorithmus – Wikipedia","What is algorithm of Maekawa's Algorithm","Wikipedia article Maekawa's Algorithm","de:Maekawa-Algorithmus","http://de.wikipedia.org/wiki/Maekawa-Algorithmus","http://en.wikipedia.org/wiki/Maekawa%27s_algorithm"],"name":"Maekawa's algorithm","categories":["All articles lacking sources","Articles lacking sources from December 2009","Concurrency control algorithms"],"tag_line":"Maekawa's algorithm is an algorithm for mutual exclusion on a distributed system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"chang-and-roberts-algorithm","_score":0,"_source":{"description":"The Chang and Roberts algorithm is a ring-based coordinator election algorithm, employed in distributed computing.","alt_names":["Chang & Roberts algorithm","Chang and Roberts algorithm","Chang and Roberts algorithm - Wikipedia, the free encyclopedia","Nachrichtenausl%C3%B6schung_nach_Chang_und_Roberts bei der wikipedia","Nachrichtenauslöschung nach Chang und Roberts","Nachrichtenauslöschung_nach_Chang_und_Roberts","Wikipedia article Chang and Roberts algorithm","Wikipedia article on Chang and Roberts algorithm","Wikipedia entry for Chang and Roberts algorithm","Wikipedia-Artikel Nachrichtenauslöschung nach Chang und Roberts","[3] Chang & Roberts algorithm","http://de.wikipedia.org/wiki/Nachrichtenausl%C3%B6schung_nach_Chang_und_Roberts","http://en.wikipedia.org/wiki/Chang_and_Roberts_algorithm"],"name":"Chang and Roberts algorithm","categories":["Distributed algorithms"],"tag_line":"The Chang and Roberts algorithm is a ring-based coordinator election algorithm, employed in distributed computing."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ricart–agrawala-algorithm","_score":0,"_source":{"description":"The Ricart-Agrawala Algorithm is an algorithm for mutual exclusion on a distributed system. This algorithm is an extension and optimization of Lamport's Distributed Mutual Exclusion Algorithm, by removing the need for  messages. It was developed by Glenn Ricart and Ashok Agrawala.\n\n","alt_names":[],"name":"Ricart–Agrawala algorithm","categories":["All articles lacking sources","Articles lacking sources from December 2009","Distributed algorithms"],"tag_line":"The Ricart-Agrawala Algorithm is an algorithm for mutual exclusion on a distributed system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"montgomery-modular-multiplication","_score":0,"_source":{"description":"In modular arithmetic computation, Montgomery modular multiplication, more commonly referred to as Montgomery multiplication, is a method for performing fast modular multiplication, introduced in 1985 by the American mathematician Peter L. Montgomery.  \nGiven two integers a and b, the classical modular multiplication algorithm computes ab mod N. Montgomery multiplication works by transforming a and b into a special representation known as Montgomery form. For a modulus N, the Montgomery form of a is defined to be aR mod N for some constant R depending only on N and the underlying computer architecture. If aR mod N and bR mod N are the Montgomery forms of a and b, then their Montgomery product is abR mod N. Montgomery multiplication is a fast algorithm to compute the Montgomery product. Transforming the result out of Montgomery form yields the classical modular product ab mod N.\nBecause of the overhead involved in converting a and b into Montgomery form, computing a single product by Montgomery multiplication is slower than computing the product in the integers and performing a modular reduction by division or Barrett reduction. However, when many products are required, as in modular exponentiation, the conversion to Montgomery form becomes a negligible fraction of the time of the computation, and performing the computation by Montgomery multiplication is faster than the available alternatives. Many important cryptosystems such as RSA and Diffie–Hellman key exchange are based on arithmetic operations modulo a large number, and for these cryptosystems, the increased speed afforded by Montgomery multiplication can be important in practice.","alt_names":[],"name":"Montgomery modular multiplication","categories":["Computer arithmetic","Cryptographic algorithms","Modular arithmetic"],"tag_line":"In modular arithmetic computation, Montgomery modular multiplication, more commonly referred to as Montgomery multiplication, is a method for performing fast modular multiplication, introduced in 1985 by the American mathematician Peter L. Montgomery."}}
,{"_index":"throwtable","_type":"algorithm","_id":"verification-based-message-passing-algorithms-in-compressed-sensing","_score":0,"_source":{"description":"Verification-based message-passing algorithms (VB-MPAs) in compressed sensing (CS), a branch of digital signal processing that deals with measuring sparse signals, are some methods to efficiently solve the recovery problem in compressed sensing. One of the main goal in compressed sensing is the recovery process. Generally speaking, recovery process in compressed sensing is a method by which the original signal is estimated using the knowledge of the compressed signal and the measurement matrix. Mathematically, the recovery process in Compressed Sensing is finding the sparsest possible solution of an under-determined system of linear equations. Based on the nature of the measurement matrix one can employ different reconstruction methods. If the measurement matrix is also sparse, one efficient way is to use Message Passing Algorithms for signal recovery. Although there are message passing approaches that deals with dense matrices, the nature of those algorithms are to some extent different from the algorithms working on sparse matrices.","alt_names":[],"name":"Verification-based message-passing algorithms in compressed sensing","categories":["All articles covered by WikiProject Wikify","All articles lacking in-text citations","All articles needing references cleanup","All orphaned articles","Articles covered by WikiProject Wikify from February 2015","Articles lacking in-text citations from February 2015","Digital signal processing","Distributed algorithms","Inter-process communication","Orphaned articles from January 2015","Pages using web citations with no URL","Wikipedia references cleanup from February 2015"],"tag_line":"Verification-based message-passing algorithms (VB-MPAs) in compressed sensing (CS), a branch of digital signal processing that deals with measuring sparse signals, are some methods to efficiently solve the recovery problem in compressed sensing."}}
,{"_index":"throwtable","_type":"algorithm","_id":"key-wrap","_score":0,"_source":{"description":"Key Wrap constructions are a class of symmetric encryption algorithms designed to encapsulate (encrypt) cryptographic key material. The Key Wrap algorithms are intended for applications such as (a) protecting keys while in untrusted storage, or (b) transmitting keys over untrusted communications networks. The constructions are typically built from standard primitives such as block ciphers and cryptographic hash functions.\nKey Wrap may be considered as a form of key encapsulation algorithm, although it should not be confused with the more commonly known asymmetric (public-key) key encapsulation algorithms (e.g., PSEC-KEM). Key Wrap algorithms can be used in a similar application: to securely transport a session key by encrypting it under a long-term encryption key.","alt_names":["- Key Wrap :","Key Wrap","Key Wrap - Wikipedia, the free encyclopedia","Key Wrap from Wikipedia","Schlüssel wickeln","Synthetic Initialization Vector","Wikipedia article Key Wrap","Wikipedia article Nist key wrap","Wikipedia article on Key Wrap","Wikipedia entry for Key Wrap","abrigo clave","chiave avvolgere","http://en.wikipedia.org/wiki/Key_Wrap","key wrap","key wrapping","klucza owinąć","nøgle wrap","sleutel wikkel","yago-res:Key Wrap"],"name":"Key Wrap","categories":["Cryptographic algorithms"],"tag_line":"Key Wrap constructions are a class of symmetric encryption algorithms designed to encapsulate (encrypt) cryptographic key material."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rc-algorithm","_score":0,"_source":{"description":"The RC algorithms are a set of symmetric-key encryption algorithms invented by Ron Rivest. The \"RC\" may stand for either Rivest's cipher or, more informally, Ron's code. Despite the similarity in their names, the algorithms are for the most part unrelated. There have been six RC algorithms so far:\nRC1 was never published.\nRC2 was a 64-bit block cipher developed in 1987.\nRC3 was broken before ever being used.\nRC4 is the world's most widely used stream cipher.\nRC5 is a 32/64/128-bit block cipher developed in 1994.\nRC6, a 128-bit block cipher based heavily on RC5, was an AES finalist developed in 1997.","alt_names":["Rivest's Cipher","RC algorithm","RC algorithm - Wikipedia, the free encyclopedia","RCアルゴリズム","RCアルゴリズム - Wikipedia","RCシリーズ","RCシリーズ - Wikipedia","RC暗号","RC暗号 - Wikipedia","RCｼﾘｰｽﾞ-wikipedia","Wikipedia : RCシリーズ","Wikipedia article RC algorithm","Wikipedia article Rivest's Cipher","Wikipedia entry for RC algorithm","Wikipediaで「RCアルゴリズム」を調べる","Wikipediaで「RCシリーズ」を調べる","Wikipediaで「RC暗号」を調べる","http://en.wikipedia.org/wiki/RC algorithm","http://en.wikipedia.org/wiki/RC_algorith","http://en.wikipedia.org/wiki/RC_algorithm","http://en.wikipedia.org/wiki/Rivest%27s_Cipher","ja:RCシリーズ","the Rivest Cipher","「RCシリーズ」をWikiで調べる","ウィキペディアの記事 RCアルゴリズム","ウィキペディアの記事 RCシリーズ"],"name":"RC algorithm","categories":["Cryptographic algorithms"],"tag_line":"The RC algorithms are a set of symmetric-key encryption algorithms invented by Ron Rivest."}}
,{"_index":"throwtable","_type":"algorithm","_id":"coppersmith-method","_score":0,"_source":{"description":"The Coppersmith method, proposed by Don Coppersmith, is a method to find small integer zeroes of univariate or bivariate polynomials modulo a given integer.\nThe method uses the Lenstra–Lenstra–Lovász lattice basis reduction algorithm (LLL) to find a polynomial that has the same zeroes as the target polynomial but smaller coefficients.\nIn cryptography, the Coppersmith method is mainly used in attacks on RSA when parts of the secret key are known and forms a base for Coppersmith's Attack.\n^ \"Lattice Basis Reduction Algorithms\".","alt_names":["Coppersmith method","Coppersmith method - Wikipedia, the free encyclopedia","Coppersmith-methode","Wikipedia article on Coppersmith method","http://en.wikipedia.org/wiki/Coppersmith_method","http://nl.wikipedia.org/wiki/Coppersmith-methode","nl.wikipedia.org/wiki/Coppersmith-methode"],"name":"Coppersmith method","categories":["All articles needing additional references","All articles needing cleanup","All articles needing expert attention","Articles needing additional references from January 2010","Articles needing cleanup from January 2010","Articles needing expert attention from January 2010","Articles needing expert attention with no reason or talk parameter","Asymmetric-key algorithms","Cleanup tagged articles without a reason field from January 2010","Mathematics articles needing expert attention","Wikipedia pages needing cleanup from January 2010"],"tag_line":"The Coppersmith method, proposed by Don Coppersmith, is a method to find small integer zeroes of univariate or bivariate polynomials modulo a given integer."}}
,{"_index":"throwtable","_type":"algorithm","_id":"master-password","_score":0,"_source":{"description":"Master Password is an algorithm designed by Maarten Billemont for creating unique passwords in a reproducible manner. It differs from traditional password managers in that the passwords are not stored on disk or in the cloud, but are recreated every time by using information entered by the user; most importantly, their full name, a master password, and a unique name for the service the password is intended for.\nBy not storing the passwords anywhere, this approach tries to make it harder for attackers to steal or intercept them. It also removes the need for synchronization between devices, and backups of potential password databases.\n^","alt_names":[],"name":"Master Password","categories":["Cryptographic algorithms","Free security software","Official website not in Wikidata"],"tag_line":"Master Password is an algorithm designed by Maarten Billemont for creating unique passwords in a reproducible manner."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hmac-based-one-time-password-algorithm","_score":0,"_source":{"description":"HOTP is an HMAC-based one-time password (OTP) algorithm. It is a cornerstone of Initiative For Open Authentication (OATH).\nHOTP was published as an informational IETF RFC 4226 in December 2005, documenting the algorithm along with a Java implementation. Since then, the algorithm has been adopted by many companies worldwide (see below). The HOTP algorithm is a freely available open standard.\n\n","alt_names":[],"name":"HMAC-based One-time Password Algorithm","categories":["All accuracy disputes","All articles with unsourced statements","Articles with disputed statements from August 2015","Articles with unsourced statements from August 2015","Computer access control protocols","Cryptographic algorithms","Internet protocols"],"tag_line":"HOTP is an HMAC-based one-time password (OTP) algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"barrett-reduction","_score":0,"_source":{"description":"In modular arithmetic, Barrett reduction is a reduction algorithm introduced in 1986 by P.D. Barrett. A naive way of computing\n\nwould be to use a fast division algorithm. Barrett reduction is an algorithm designed to optimize this operation assuming  is constant, and , replacing divisions by multiplications.","alt_names":["Barrett reduction","Barrett reduction - Wikipedia, the free encyclopedia","Wikipedia article Barrett reduction","http://en.wikipedia.org/wiki/Barrett_reduction"],"name":"Barrett reduction","categories":["Computer arithmetic","Cryptographic algorithms","Modular arithmetic"],"tag_line":"In modular arithmetic, Barrett reduction is a reduction algorithm introduced in 1986 by P.D."}}
,{"_index":"throwtable","_type":"algorithm","_id":"primality-test","_score":0,"_source":{"description":"A primality test is an algorithm for determining whether an input number is prime. Amongst other fields of mathematics, it is used for cryptography. Unlike integer factorization, primality tests do not generally give prime factors, only stating whether the input number is prime or not. Factorization is thought to be a computationally difficult problem, whereas primality testing is comparatively easy (its running time is polynomial in the size of the input). Some primality tests prove that a number is prime, while others like Miller–Rabin prove that a number is composite. Therefore, the latter might be called compositeness tests instead of primality tests.\n\n","alt_names":["primalité","test de primalidad","test de primalité","primality test","確率的素数判定法","test di primalità","Test de primalidad","primality testing","- Primality test :","- Primality testing :","- Primality tests :","-> Read more about Primality test","...Wikipedia Test de primalidad","...Wikipedia Test de primalité","...Wikipedia Test pierwszości","...mehr auf Wikipedia über Primzahltest","...more on Wikipedia about Primality test","1 素数","2 素数判定的历史","3 怎样判别一个自然数是素数","4 公式用途","4.1 证明素数无穷多","4.2 哥德巴赫猜想的合理框架","4.3 诠释台尔曼公式","6k+1/6k-1","8c5bdadaa5565373016c67d56c06f ...",":http://de.wikipedia.org/wiki/Primzahltest","A página da Wikipédia","Adleman's test","Certifying the primality","Các trang wikipedia","Der Sieb der Eratosthenes","Fast deterministic tests","Further exploration of this topic","Http://en.wikipedia.org/wiki/Primality_test","Ki?m tra t?nh nguy?n t? ? Wikipedia","Ki?m tra tính nguyên t? – Wikipedia ti","Kiểm Tra Tính Nguyên Tố_Wikipedia VN","Kiểm tra tính nguyên tố","Kiểm tra tính nguyên tố – Wikipedia tiếng Việt","La página de Wikipedia","La página de la wikipedia","Learn about Primality test>>>","Méthode naïve","Méthodes basées...","Naïve methods","Number-theoretic methods","O(log(n) 6","PRIMES","PRIMES - Wikipedia","Priemgetaltest","Priemgetaltest - Wikipedia","Priemgetaltests op Wikipedia","Priemtest testen algoritmen uit Wikipedia","Primalidad algoritmos de las pruebas de la Wikipedia","Primality Test","Primality Test (Wikipedia)","Primality Test - Wikipedia, The Free Encyclopedia","Primality Test.","Primality Testing","Primality test","Primality test - Simple English Wikipedia, the free encyclopedia","Primality test - Wikipedia :: The free encyclopedia","Primality test - Wikipedia, the free encyclopedia","Primality test - Wikipedia, the free encyclopedia A primality","Primality test Wikipedia, the free ...","Primality test algoritmer fra Wikipedia","Primality testing","Primality testing (Wikipedia)","Primality testing algorithms from Wikipedia","Primality tests","Primality से विकिपीडिया एल्गोरिदम परीक्षण","Primality_test","Primality_test#Complexity","Prime testing","Primeca provo","Primeca provo - Vikipedio","Primtallstest","Primtalstest","Primzahlentest","Primzahltest","Primzahltest - Wikipedia","Primzahltest ? Wikipedia","Primzahltest â€“ Wikipedia","Primzahltest – Wikipedia","Primzahltest.","Primzahltests","Primzahltests aus Wikipedia","Probabilistic tests","Prímszámolóra.","Prímteszt","Prímteszt - Wikipédia","Read More primality test wikipedia the free encyclopedia","See Wikipedia for more efficient algorithms","Test de Primalidad","Test de primalidad - Wikipedia, la enciclopedia libre","Test de primalitat","Test de primalitat - Viquipèdia","Test de primalité","Test de primalité - Wikipédia","Test di primalit? - Wikipedia","Test di primalità","Test di primalità - Wikipedia","Test for primality","Test pierwszosci – Wikipedia, wolna encyklopedia","Test pierwszości","Test pierwszości – Wikipedia, wolna encyklopedia","Test_de_primalidad","Teste de primalidade","Teste_de_primalidade","Tests de Primalidad","Tests...","The wikipedia halaman","WIKI: Test de Primalidad","Wikipedia : 素数判定","Wikipedia Test de primalidad","Wikipedia article Primality test","Wikipedia article Primality testing","Wikipedia article Primality tests","Wikipedia article Prime testing","Wikipedia article Primeca provo","Wikipedia article Primtallstest","Wikipedia article Primtalstest","Wikipedia article Prímteszt","Wikipedia article Test de primalidad","Wikipedia article Test pierwszości","Wikipedia article Teste de primalidade","Wikipedia article on Primality test","Wikipedia article on Prime testing","Wikipedia article on Test de primalidad","Wikipedia article Тест простоти","Wikipedia article Тест простоты","Wikipedia artikel Priemgetaltest","Wikipedia page on primality tests","Wikipedia-Artikel PRIMES","Wikipedia-Artikel Primzahlentest","Wikipedia-Artikel Primzahltest","Wikipedia-Seite zu 'Primzahltest'","Wikipedia:Primzahltest","Wikipedia:「素数判定」","Wikipediaeintrag zu Primzahltest","Wikipediaで「擬似素数判定」を調べる","Wikipediaで「素数判定」を調べる","Wikipediaの素数判定の項","algoritmi di analisi primalità da Wikipedia","artículo de Wikipedia Test de primalidad","artículo sobre los llamados test de primalidad","bài kiểm tra tính nguyên tố xác suất","bài kiểm tra tính nguyên tố.","ca.wikipedia.org/wiki/Test_de_primalitat","ca:Test de primalitat","check for primality","check if it's a prime","checking primality","ci vollero 27 anni","comprobar la primalidad","controleer priemtest","các xét nghiệm","d'un test probabiliste","de.wikipedia.org/wiki/Primzahltest","de:Primzahltest","der gerngelesenen Wikipedia","deterministic primality test","deterministic test","deterministický primality test","deterministisch priemtest","deterministischen Primzahltest","deterministyczny test pierwszości","effzientere Verfahren","en.wikipedia.org/...Primality_test","en.wikipedia.org/wiki/Primality_test","en.wikipedia.org/wiki/Primality_test#Fast_deterministic_tests","eo:Primeca provo","es.wikipedia.org/wiki/Test_de_primalidad","es:Test de primalidad","f72eaa241f8de63f6a59861c45239e ...","fast deterministic test","fast primality testing","fr:Test de primalité","http://bit.ly/f6kFPw","http://ca.wikipedia.org/wiki/Test_de_primalitat","http://de.wikipedia.org/wiki/Pr imzahltest","http://de.wikipedia.org/wiki/Primzah...s_Eratosthenes","http://de.wikipedia.org/wiki/Primzahlentest#Bekannte_Primzahltest-Verfahren","http://de.wikipedia.org/wiki/Primzahlent¡","http://de.wikipedia.org/wiki/Primzahlent…","http://de.wikipedia.org/wiki/Primzahltes","http://de.wikipedia.org/wiki/Primzahltest","http://de.wikipedia.org/wiki/Primzahltest#...es_Eratosthenes","http://de.wikipedia.org/wiki/Primzahltest#Einfaches_Durchtesten_.28Brute","http://de.wikipedia.org/wiki/Primzahltes…","http://en.wikipedia..../Primality_test","http://en.wikipedia....rministic_tests","http://en.wikipedia.org/wiki/Primal...C3.AFve_methods","http://en.wikipedia.org/wiki/Primali...ministic_tests","http://en.wikipedia.org/wiki/Primality_ ... stic_tests","http://en.wikipedia.org/wiki/Primality_t","http://en.wikipedia.org/wiki/Primality_test","http://en.wikipedia.org/wiki/Primality_test#Comple ...","http://en.wikipedia.org/wiki/Primality_test#Complexity","http://en.wikipedia.org/wiki/Primality_test#Fast_deterministic_tests","http://en.wikipedia.org/wiki/Primality_test#Na.C3","http://en.wikipedia.org/wiki/Primality_test#Probabilistic_tests","http://en.wikipedia.org/wiki/Primality_test.","http://en.wikipedia.org/wiki/Primality_testing","http://en.wikipedia.org/wiki/Primality_tests","http://en.wikipedia.org/wiki/Primality_tests#Na.C3","http://en.wikipedia.org/wiki/Primality_t…","http://en.wikipedia.org/wiki/Prime_testing","http://es.wikipedia.org/wiki/Test de primalidad","http://es.wikipedia.org/wiki/Test_d","http://es.wikipedia.org/wiki/Test_de_primalidad","http://es.wikipedia.org/wiki/Test_de_pri…","http://fr.wikipedia.org/wiki/Test_ [...] na.C3","http://fr.wikipedia.org/wiki/Test_de_primalit%C3%A9","http://fr.wikipedia.org/wiki/Test_de_primalité","http://hu.wikipedia.org/wiki/Pr%C3%ADmteszt","http://it.wikipedia.org/wiki/Test_di_primalit%C3%A0","http://it.wikipedia.org/wiki/Test_di_primalità","http://it.wikipedia.org/wiki/Test_di_pri…","http://ja.wikipedia.org/wiki/素数判定","http://nl.wikipedia.org/wiki/Priemgetaltest","http://pl.wikipedia.org/wiki/Test_pierwszo%C5%9Bci","http://pl.wikipedia.org/wiki/Test_pierwszości","http://ru.wikipedia.org/wiki/Тест_просто...","http://ru.wikipedia.org/wiki/Тест_простоты","hu:Prímteszt","imality tests","ir pirmskaitlis","is the number given prime?","isprime","it's relationship to finding primes","it:Test di primalità","ja:素数判定","l'approche naïve","l'article de Wikipédia Primalité","l'article de Wikipédia Test de primalité","las pruebas de primalidad","le test de primalité","líkindapróf.","many optimizations that one could make","mathematical tricks","mathematische Methoden","more advanced tests","much faster algorithms","nichtdeterministische Primzahltests","nl:Priemgetaltest","no:Primtallstest","ohne Rest teilbar","ojear este enlace de la Wikipedia","pl.wikipedia.org/wiki/Test_pierwszo%C5%9Bci","pl:Test pierwszości","priemgetaltest","priemtest tests","primalidad","primality test algorithm","primality test on Wikipedia","primality testin","primality tests","primality tests.","primality 테스트를","primality-proving","primality-test","primarility testing","primarility tests","prime Tests auf wikipedia aufgeführt.","prime testing","prime tests listed on wikipedia","primeca provo","primtallstesting","probabalistic methods for determining primality","probabilistic ones","probabilistic primality test","probabilistic primality testing","probabilistic prime test","probabilistic test","probabilistically tested","probabilistisch","probabilistischen Primzahltest.","probabilistyczny","probabilística,","problema de saber si un número es primo","prove Primo elencati su Wikipedia.","prueba de primalidad determinista","pruebas de primer listados en Wikipedia.","pt:Teste de primalidade","quickly verify that this factor is prime","rimality tests","ru:Тест простоты","see if they're prime","simple:Primality test","sprawdzić pierwszości","sv:Primtalstest","tes de primalidad","tes perdana yang terdaftar di wikipedia.","tes primality probabilistik.","tes primality.","test de primalidad probabilísticos.","test de primalidad.","test de primalitat","test de primalité déterministe","test de primalité probabilistes.","test de primalité.","test di primalità deterministico","test di primalità.","test di primalità:","test probabilistico di primalità.","testar primalidade","teste de primalidade determinístico","teste de primalidade probabilística.","teste de primalidade.","testem pierwszości","testes de primalidade","testes primalidade","testes prime listadas na Wikipédia.","testing whether a number n is prime","testowanie algorytmów pierwszości z Wikipedii","tests de primalidad","tests de primalitat","tests de primalité","tests de prime cotée sur wikipedia.","testu pierwszości","testy pierwszości","testy pierwszości liczb","testy prvočíselnosti","uk:Тест простоти","vi:Kiểm tra tính nguyên tố","wikipedia article: Primality test","zh:素性测试","à jour sur ce point","ç´ æ•°åˆ¤å®š - Wikipedia","Весь перечень википедии по тестам на простоту","Википедии статью Тест простоты","Тест простоти","Тест простоты","Тест простоты (Вики)","Тест простоты — Википедия","Тесты на простоту числа","берёте","вероятностного теста простоты.","вероятностные алгоритмы","детерминированный тест простоты","премьер испытаниям, указанным в Википедии.","проверить число на простоту","проверки простоты чисел","простоты испытания","простоты теста.","распознавания простоты","тест на простоту","тест простоты","теста простоты","тестов простоты","тестом простоты","тесты на простоту","тесты простоты на википедии","является ли данное число простым","การ ทดสอบ primality น่า จะ เป็น.","การ ทดสอบ ที่ สำคัญ","ทดสอบ primality.","⇒ 素数判定 -- Wikipedia","「素数判定」についてWikipediaで調査","ウィキペディアの記事 素数判定","判定テストを","在维基百科中列出的","擬似素数判定","概率素性检验","概率素性檢驗","決定素数テストを","決定論的素数判定テスト","确定性素性测试","确定的素性测试","確率的な素数判定テスト","確率的素数判定","素性判定法则- 维基百科，自由的百科全书","素性检验","素性檢驗","素性测试","素性測試","素数かどうかを高速に判定する方法","素数のテストウィキペディアに記載され","素数の判定方法","素数判定","素数判定 - Wikipedia","素数判定(Wikipedia)","素数判定- Wikipedia »","素数判定-wikipedia","素数判定アルゴリズム","素数判定問題","素数判定法","素数判定法则","素数判定法则- 维基百科，自由的百科全书","維基百科的文章“ 素性检验”","維基百科的文章“ 素性测试”","選び出し","黃金測試百科上市","소수 테스트를 위키 피 디아에 나와있습니다.","위키 피 디아의 페이지에","확률 primality 테스트를","：http://en.wikipedia.org/wiki/Primality_test"],"name":"Primality test","categories":["All articles needing additional references","All articles with specifically marked weasel-worded phrases","Articles needing additional references from August 2013","Articles with specifically marked weasel-worded phrases from April 2010","Asymmetric-key algorithms","Pages containing cite templates with deprecated parameters","Primality tests"],"tag_line":"A primality test is an algorithm for determining whether an input number is prime."}}
,{"_index":"throwtable","_type":"algorithm","_id":"three-pass-protocol","_score":0,"_source":{"description":"In cryptography, the three-pass protocol for sending messages is a framework which allows one party to securely send a message to a second party without the need to exchange or distribute encryption keys. This message protocol should not be confused with various other algorithms which use 3 passes for authentication.\nIt is called the three-pass protocol because the sender and the receiver exchange three encrypted messages. The first three-pass protocol was developed by Adi Shamir circa 1980, and is described in more detail in a later section. The basic concept of the Three-Pass Protocol is that each party has a private encryption key and a private decryption key. The two parties use their keys independently, first to encrypt the message, and then to decrypt the message.\nThe protocol uses an encryption function E and a decryption function D. The encryption function uses an encryption key e to change a plaintext message m into an encrypted message, or ciphertext, E(e,m). Corresponding to each encryption key e there is a decryption key d which allows the message to be recovered using the decryption function, D(d,E(e,m))=m. Sometimes the encryption function and decryption function are the same.\nIn order for the encryption function and decryption function to be suitable for the Three-Pass Protocol they must have the property that for any message m, any encryption key e with corresponding decryption key d and any independent encryption key k,  D(d,E(k,E(e,m))) = E(k,m). In other words, it must be possible to remove the first encryption with the key e even though a second encryption with the key k has been performed. This will always be possible with a commutative encryption. A commutative encryption is an encryption that is order-independent, i.e. it satisfies E(a,E(b,m))=E(b,E(a,m)) for all encryption keys a and b and all messages m. Commutative encryptions satisfy D(d,E(k,E(e,m))) = D(d,E(e,E(k,m))) = E(k,m).\nThe Three-Pass Protocol works as follows:\nThe sender chooses a private encryption key s and a corresponding decryption key t. The sender encrypts the message m with the key s and sends the encrypted message E(s,m) to the receiver.\nThe receiver chooses a private encryption key r and a corresponding decryption key q and super-encrypts the first message E(s,m) with the key r and sends the doubly encrypted message E(r,E(s,m)) back to the sender.\nThe sender decrypts the second message with the key t. Because of the commutativity property described above D(t,E(r,E(s,m)))=E(r,m) which is the message encrypted with only the receiver's private key. The sender sends this to the receiver.\nThe receiver can now decrypt the message using the key q, namely D(q,E(r,m))=m the original message.\nNotice that all of the operations involving the sender's private keys s and t are performed by the sender, and all of the operations involving the receiver's private keys r and q are performed by the receiver, so that neither party needs to know the other party's keys.","alt_names":["- Massey-Omura cryptosystem :","...mehr auf Wikipedia über Massey-Omura-Schema","...more on Wikipedia about Massey-Omura cryptosystem","/wiki/Massey-Omura-Schema“","3 통과 절차를","3つのパスのプロトコル","Aus allen ausgetauschten Nachrichten kann ohne Wissen um","Ba qua giao thức","Drei Pass Protokoll","Drei Pass-Protokoll","Drie pass protocol","How is security of Three-pass protocol","Massey-Omura Cryptosystem","Massey-Omura cryptosystem","Massey-Omura cryptosystem; it is used under the","Massey-Omura-Schema","Massey-Omura-Schema – Wikipedia","Shamir three pass","Shamir three-pass protocol","Shamir's three-pass protocol","Sistema de encriptado de Massey-Omura","Three Pass Protocol","Three pass protocol","Three-Pass Protocol","Three-pass protocol","Three-pass protocol - Wikipedia, the free encyclopedia","Three-pass protocol - Wikipedia, the free encyclopedia ...","Three-pass protocol; it is used under the","Threepass protocol","Tiga lewat protokol","Tre pass-protokollen","Tre protocollare","Tres Tarjeta de protocolo","Trois Carte protocolaire","Trzy legitymacja wydana przez Protokół","Três protocolo passar","Tříprůchodovém protokol","Wikipedia (Three-pass protocol)","Wikipedia article Shamir three-pass protocol","Wikipedia article Three-pass protocol","Wikipedia article on Massey-Omura cryptosystem","Wikipedia article on Massey-omura cryptosystem","Wikipedia article on Shamir three-pass protocol","Wikipedia article on Three-pass protocol","Wikipedia entry for Three-pass protocol","Wikipedia-Artikel Massey-Omura-Schema","Wikipedia-Seite zu 'Massey-Omura-Schema'","Wikipedia: Three-pass protocol","en.wikipedia.org/wiki/Massey-Omura_cryptosystem","en.wikipedia.org/wiki/Three-pass_protocol","http://de.wikipedia.org/wiki/Massey-Omur","http://de.wikipedia.org/wiki/Massey-Omura-Schema","http://en.wikipedia.org/wiki/Massey-Omur…","http://en.wikipedia.org/wiki/Three-pass_","http://en.wikipedia.org/wiki/Three-pass_protocol","http://en.wikipedia.org/wiki/Three-pass_protocol#Massey","http://en.wikipedia.org/wiki/Three-pass_protocol.","http://www.de.wikipedia.org/wiki/Massey-Omura","no-key","three pass protocol","three-pass protocol","Три прохода протокол","โปรโตคอล ผ่าน สาม","三通过协议","三通過協議"],"name":"Three-pass protocol","categories":["Asymmetric-key algorithms","Cryptographic protocols"],"tag_line":"In cryptography, the three-pass protocol for sending messages is a framework which allows one party to securely send a message to a second party without the need to exchange or distribute encryption keys."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ms-chap","_score":0,"_source":{"description":"MS-CHAP is the Microsoft version of the Challenge-Handshake Authentication Protocol, CHAP. The protocol exists in two versions, MS-CHAPv1 (defined in RFC 2433) and MS-CHAPv2 (defined in RFC 2759). MS-CHAPv2 was introduced with Windows NT 4.0 SP4 and was added to Windows 98 in the \"Windows 98 Dial-Up Networking Security Upgrade Release\" and Windows 95 in the \"Dial Up Networking 1.3 Performance & Security Update for MS Windows 95\" upgrade. Windows Vista dropped support for MS-CHAPv1.\nMS-CHAP is used as one authentication option in Microsoft's implementation of the PPTP protocol for virtual private networks. It is also used as an authentication option with RADIUS servers which are used for WiFi security using the WPA-Enterprise protocol. It is further used as the main authentication option of the Protected Extensible Authentication Protocol (PEAP).\nCompared with CHAP, MS-CHAP:\nis enabled by negotiating CHAP Algorithm 0x80 (0x81 for MS-CHAPv2) in LCP option 3, Authentication Protocol\nprovides an authenticator-controlled password change mechanism\nprovides an authenticator-controlled authentication retry mechanism\ndefines failure codes returned in the Failure packet message field\nMS-CHAPv2 provides mutual authentication between peers by piggybacking a peer challenge on the Response packet and an authenticator response on the Success packet.","alt_names":["- MS-CHAP :","- MS-CHAPv2 :","-MS-CHAPv2","...more on Wikipedia about MS-CHAP","Chap protoco","Chap protocol","MS CHAP","MS CHAP Wikipedia the free encyclopedia","MS-CHAP","MS-CHAP (Microsoft Handshake Authentication Protocol)","MS-CHAP - Wikip","MS-CHAP - Wikip?dia","MS-CHAP - Wikipedia","MS-CHAP - Wikipedia :: The free encyclopedia","MS-CHAP - Wikipedia, the free encyclopedia","MS-CHAP - Wikipédia","MS-CHAP / MS-CHAPv2","MS-CHAP v1","MS-CHAP v2","MS-CHAP-v2","MS-CHAP: É","MS-CHAPV2","MSCHAP","MSCHAP Wikipedia the free encyclopedia","MSCHAPv2","Microsoft CHAP V1/V2","Ms Chap","Read More about mschap wikipedia the free encyclopedia","Read More mschap wikipedia the free encyclopedia","Source Wikipedia.org Arcticle - MS-CHAP","Wikipedia article MS-CHAP","Wikipedia article MS-CHAPv2","Wikipedia article about MS-CHAP","Wikipedia article on MS-CHAP","Wikipedia article on MS-CHAPv2","Wikipedia entry for MS-CHAP","Wikipedia:MS-CHAP","en.wikipedia.org/wiki/MS-CHAP","en:MS-CHAP","http://en.wikipedia.org/wiki/MS-CHAP","http://en.wikipedia.org/wiki/MS-CHAP,","http://en.wikipedia.org/wiki/MS-CHAPv2","http://fr.wikipedia.org/wiki/MS-CHAP","http://it.wikipedia.org/wiki/MS-CHAP","http://pl.wikipedia.org/wiki/MS-CHAP","http://ru.wikipedia.org/wiki/MS-CHAP","it:MS-CHAP","l'article de Wikipédia MS-CHAP","ms-CHAPv2","oft: MS-CHAP","pl:MS-CHAP","ru:MS-CHAP","yago-res:MS-CHAP","Википедии статью MS-CHAP"],"name":"MS-CHAP","categories":["All articles lacking in-text citations","Articles lacking in-text citations from July 2013","Broken cryptography algorithms","Computer access control protocols","Internet protocols","Microsoft Windows security technology"],"tag_line":"MS-CHAP is the Microsoft version of the Challenge-Handshake Authentication Protocol, CHAP."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lattice-sieving","_score":0,"_source":{"description":"Lattice sieving is a technique for finding smooth values of a bivariate polynomial  over a large region. It is almost exclusively used in conjunction with the number field sieve. The original idea of the lattice sieve came from John Pollard.\nThe algorithm implicitly involves the ideal structure of the number field of the polynomial; it takes advantage of the theorem that any prime ideal above some rational prime p can be written as . One then picks many prime numbers q of an appropriate size, usually just above the factor base limit, and proceeds by\n\nFor each q, list the prime ideals above q by factorising the polynomial f(a,b) over For each of these prime ideals, which are called 'special 's, construct a reduced basis  for the lattice L generated by ; set a two-dimensional array called the sieve region to zero.\nFor each prime ideal  in the factor base, construct a reduced basis  for the sublattice of L generated byFor each element of that sublattice lying within a sufficiently large sieve region, add  to that entry.\n\nRead out all the entries in the sieve region with a large enough value\n\nFor the number field sieve application, it is necessary for two polynomials both to have smooth values; this is handled by running the inner loop over both polynomials, whilst the special-q can be taken from either side.","alt_names":["&qfr;","3efeda71081426693778a9a1fc ...","Lattice Sieve","Lattice Sieving","Lattice sieving","Lattice sieving - Wikipedia, the free encyclopedia","Wikipedia (Lattice sieving)","Wikipedia article Lattice sieving","Wikipedia entry for Lattice sieving","http://en.wikipedia.org/wiki/Lattice_sie","http://en.wikipedia.org/wiki/Lattice_sieving","lattice sieving","yago-res:Lattice sieving"],"name":"Lattice sieving","categories":["Integer factorization algorithms"],"tag_line":"Lattice sieving is a technique for finding smooth values of a bivariate polynomial  over a large region."}}
,{"_index":"throwtable","_type":"algorithm","_id":"schoof's-algorithm","_score":0,"_source":{"description":"Schoof's algorithm is an efficient algorithm to count points on elliptic curves over finite fields. The algorithm has applications in elliptic curve cryptography where it is important to know the number of points to judge the difficulty of solving the discrete logarithm problem in the group of points on an elliptic curve.\nThe algorithm was published by René Schoof in 1985 and it was a theoretical breakthrough, as it was the first deterministic polynomial time algorithm for counting points on elliptic curves. Before Schoof's algorithm, approaches to counting points on elliptic curves such as the naive and baby-step giant-step algorithms were, for the most part, tedious and had an exponential running time.\nThis article explains Schoof's approach, laying emphasis on the mathematical ideas underlying the structure of the algorithm.","alt_names":["Schoof's algorithm","...more on Wikipedia about Schoof's algorithm","06499cd8609251da23d9affd91ff39 ...","2c1234cf7e919c74484302ed2b0864 ...","Algorithme de Schoof","Algorithme de Schoof - Wikipédia","Schoof%27s_algorithm","Schoof's","Schoof's algorithm - Wikipedia, the free ...","Schoof's algorithm - Wikipedia, the free encyclopedia","Schoof's algorithm by Wikipedia","Schoofs Algorithmus","What are implementations of Schoof algorithm","Wikipedia article Algorytm Schoofa","Wikipedia article Schoof's algorithm","Wikipedia article Schoof's_algorithm","http://en.wikipedia.org/wiki/Schoof %27s_algorithm","http://en.wikipedia.org/wiki/Schoof%27s_algorithm","http://en.wikipedia.org/wiki/Schoof's_algorithm","http://pl.wikipedia.org/wiki/Algorytm_Schoofa","http://pl.wikipedia.org/wiki/Algorytm_Shoofa","l'algorythme de Schoof","pl:Algorytm Schoofa","schoof's algorithm","sjoOof's algorithm","| # E ( &Fopf; q ) - ( q + 1 ) | ≤ 2 q ,"],"name":"Schoof's algorithm","categories":["Asymmetric-key algorithms","Elliptic curve cryptography","Elliptic curves","Finite fields","Group theory","Number theory"],"tag_line":"Schoof's algorithm is an efficient algorithm to count points on elliptic curves over finite fields."}}
,{"_index":"throwtable","_type":"algorithm","_id":"the-art-of-computer-programming","_score":0,"_source":{"description":"The Art of Computer Programming (sometimes known by its initials TAOCP) is a comprehensive monograph written by Donald Knuth that covers many kinds of programming algorithms and their analysis.\nKnuth began the project, originally conceived as a single book with twelve chapters, in 1962. The first three of what was then expected to be a seven-volume set were published in 1968, 1969, and 1973. The first installment of Volume 4 (a paperback fascicle) was published in 2005. The hardback volume 4A was published in 2011. Additional fascicle installments are planned for release approximately biannually.\n\n","alt_names":["Chapter outline","http://ja.wikipedia.org/wiki/The_Art_of_Computer_Programming","The_Art_of_Computer_Programming","'El arte de programar ordenadores'","'The Art Of Programming'","'The Art of Computer Programming'","**____http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming____**","-> Read the article about 'The Art of Computer","...Wikipedia The Art of Computer Programming","...mehr auf Wikipedia über The Art of Computer","2 Assembly language in the book","3 livros do Knuth","3 томика","3 第4A卷,列舉與回溯（Enumeration and Backtracking","4 Chapter outline of published and unpublished volumes","4 第4B卷,圖形與網路演算法（Graph and Network","4.6.2 Factorization of polynomials","42, 41, and 37 years ago","5 Detailed outline of unpublished Volume 4","5 第4C及4D(可能)卷, 最佳化與遞歸","5.1 Subvolume 4A Enumeration and Backtracking","5.2 Subvolume 4B Graph and Network Algorithms","5.3 Subvolumes 4C and 4D Optimization and Recursion","6 English editions","6 發佈","6.1 Current editions","6.2 Previous editions","7 英文版本","7.1 當前版本","7.2 以前版本","8 中譯本","A Arte da Programação","A Arte da Programação de Computadores","A Arte do Programação de Computadores","A arte da programação","A arte da programação.","A arte de desenvolver software é inexplicável","A számítógép programozás művészete","AOCP v3","Ang Art ng Computer Programming.","Art ng Computer Programming.","Art of Computer Programming","Art of Computer Programming.","Art of Computer programming","Art of computer programming","Art_of_Computer_Programming","Arta Programării Calculatoarelor","Arta programarii calculatoarelor(vol.2, Algoritmi seminumerici)","Arta programării calculatoarelor","Arta programării calculatoarelor - Wikipedia","Arte da Programação de Computadores.","Arte de la Programación","Arts of Programming, Volume 2: Seminumerical Algorithms.","Assembly language in the book","Book Series: Donald Knuth - The Art of Programming","De Kunst van het Programmeren","De kunst van de programmering","De kunst van het programmeren","Die Art of Computer Programming","Die Kunst des Programmierens","Don Knuth's Art of Computer Programming","Donald Knuth - The Art Of Computer Programming","Donald Knuth's The Art of Computer Programming","Donald Knuth's argument","Donald Knuth's seminal texts","El ARTE de la programación de computadores","El Arte de Programación","El Arte de Programación de Ordenador","El Arte de Programar Computadores","El Arte de la Programación","El Arte de la Programación de Computadores.","El arte de la programación","El arte de la programación.","El arte de programar computadoras","Grundlagenwerk über Programmierung","Informatyki Sztuki programowania","Just goes","Knuth 2","Knuth Vol. 2 CHAP 3 auf Zufallszahlen","Knuth Vol. 2 CHAP 3 op Random Numbers","Knuth Vol. 2 Chap 3 on Random Numbers","Knuth Vol. 2 Kapitel 3 om tilfældige tal","Knuth Vol. 2 Rozdział 3 na Random Numbers","Knuth Vol.. 2 kap 3 na náhodných čísel","Knuth Volume One","Knuth books","Knuth collection","Knuth's Art of Computer Programming.","Knuth's Art of Programming","Knuth's Semi-numerical Algorithms","Knuth's Seminumerical Algorithms","Knuth's TAOCP","Knuth's book","Knuth's kunst van het programmeren","Knuth's masterpiece","Knuth's set","Knuth's third edition","Knuth's “The Art of Computer Programming”","Knuth, Donald - The Art of Computer Programming","Knuth, section 3.5","Knuth.","Knuth. There's is only one to start with","Knuth: The Art Of Computer Programming, Seminumerical Algorithms","Knuth: The Art of Computer Programming","Knuths Art of Programming","Knuthの","Kunsten af programmeringen","Kuth-Book-1-4.jpg","L'Art de la programmation","L'Art of Computer Programming","L'art de la programmation.","L'arte della programmazione","L'arte della programmazione.","Microsoft bewerben","Mr Knuth","Nghệ thuật của Lập trình","Nghệ thuật lập trình.","Outline of Volume 4A Enumeration and Backtracking","Programming ศิลปะ","Read More the art of computer programming wikipedia","Seni pemrograman.","Si è naturalmente conquistato anche una corposa voce","Sorting and Searching","Sztuce programowania","Sztuka programowania","Sztuka programowania – Wikipedia, wolna encyklopedia","Sztuka_programowania","TAOC","TAOCP","TAOCP on Wikipedia","TAOCP vol.4","TAoCP","TAoCP do Knuth","THE ALGORITHM BIBLE","THE ART OF COMPUTER PROGRAMMING","THE ART OF PROGRAMING :cool:","The Art Of Computer Programming","The Art Of Computer Programming (TAOCP)","The Art Of Computer Programming (http://en.wikipedia","The Art Of Computer Programming - Donald Knuth","The Art Of Computer Programming ? Wikipedia","The Art Of Computer Programming Vol. 1","The Art Of Computer Programming Wikipedia The Free","The Art Of Computer Programming – Donald E Knuth","The Art of Computer","The Art of Computer Progamming","The Art of Computer Programing","The Art of Computer Programmin","The Art of Computer Programming","The Art of Computer Programming (Wikipedia)","The Art of Computer Programming (wikipedia)","The Art of Computer Programming - Donald Knuth","The Art of Computer Programming - Vikipedi","The Art of Computer Programming - Viquipèdia","The Art of Computer Programming - Wikipedia","The Art of Computer Programming - Wikipedia bahasa Indonesia","The Art of Computer Programming - Wikipedia, the ...","The Art of Computer Programming - Wikipedia, the f&hellip","The Art of Computer Programming - Wikipedia, the free","The Art of Computer Programming - Wikipedie, otevřená encyklopedie","The Art of Computer Programming - Wikipedija","The Art of Computer Programming - Wikipédia","The Art of Computer Programming - Wikipédia, a enciclopédia","The Art of Computer Programming ...","The Art of Computer Programming : wikipedia","The Art of Computer Programming @ Wikipedia","The Art of Computer Programming Vol.2","The Art of Computer Programming Volume 3, Sorting","The Art of Computer Programming Wikip dia","The Art of Computer Programming Wikipedia","The Art of Computer Programming Wikipedia the free","The Art of Computer Programming de","The Art of Computer Programming from Wikipedia","The Art of Computer Programming on Wikipedia","The Art of Computer Programming vol. 1-3","The Art of Computer Programming w","The Art of Computer Programming – Wikipedia","The Art of Computer Programming – Wikipedia tiếng Việt","The Art of Computer Programming – Wikipedia, the free","The Art of Computer Programming – Wikipédia","The Art of Computer Programming – Wikipédia, a enciclopédia","The Art of Computer Programming(A Arte da","The Art of Computer Programming,","The Art of Computer Programming, Vol. 1, Fundamental","The Art of Computer Programming, Vol.2, Abschnitt","The Art of Computer Programming, Volume 2: Seminumerical","The Art of Computer Programming.","The Art of Computer Programming...","The Art of Computer Programming; it is used","The Art of Computer Programmingとは？ (Wikipediaへのリンク","The Art of Computer programování","The Art of Computer...","The Art of Programming","The Art of computer programming","The Holy Scripture","The art of Computer Programming","The art of computer programming","The art of computing programing","The art of programming","The_Art_of_Computer_Programming bei der wikipedia","The_Art_of_Computer_Programming-wikipedia","The_Art_of_Computer_Programming?title=Spezial:Booksources&isbn=0321335708","Umění programování","Umění programování - Wikipedie","Umění programování počítače","Vol Knuth. 2 Cap. 3 da numeri casuali","Vol. Knuth. 2 Capítulo 3 sobre números aleatorios","Volumes 1-3 of Donald Knuth's The Art","WP: Art of Computer Programming","What is the history of Art of Computer","Wiki on Donald Knuth","Wikipedia article Art of Computer Programming","Wikipedia article TAOCP","Wikipedia article The Art of Computer Programming","Wikipedia article The_Art_of_Computer_Programming","Wikipedia article Umění programování","Wikipedia article on The Art of Computer Programming","Wikipedia article on the books in The Art","Wikipedia article فن برمجة الحاسوب","Wikipedia article দ্য আর্ট অফ কম্পিউটার প্রোগ্রামিং","Wikipedia article 计算机程序设计艺术","Wikipedia entry for The Art of Computer Programming","Wikipedia-Artikel TAOCP","Wikipedia-Artikel The Art of Computer Programming","Wikipedia-Seite zu 'The Art of Computer Programming","Wikipedia-Seite zu The Art of Computer Programming","Wikipedia: The Art of Computer Programming","Wikipediaで「The Art of Computer Programming」を調べる","Wikipédia artigo The Art of Computer Programming","Wikipédia artigo The art of computer programming","[en:wiki] Art of Computer Programming","acronym — TAOCP","ar:فن برمجة الحاسوب","argue that programming is an art","art de la programmation","artigo da Wikipédia The Art of Computer Programming","artista della programmazione","bn:দ্য আর্ট অফ কম্পিউটার প্রোগ্রামিং","ca:The Art of Computer Programming","cs:The Art of Computer Programming","cs:Umění programování","da arte da programação","de Arte Knuth de Programación","de kunst van het programmeren","de:The Art of Computer Programming","die Art der Programmierung","die Kunst des Programmierens","die Kunst des Programmierens.","do Art of Programming","dsc00758b","duh Art of Computeâh Programming","e “The Art of Computer","el Art of Computer Programming","el Arte de la Programación","el arte de Programación,","en.wikipedia.org/...he_Art_of_Computer_Programming","en.wikipedia.org/wiki/Th...uter_Programming","en.wikipedia.org/wiki/The_Art_of_Comp...","en.wikipedia.org/wiki/The_Art_of_Computer_Programming","en.wikipedia.org/wiki/The_Art_of···gramming","en:The Art of Computer Programming","epickej ságe","erudite volumes","fr:The Art of Computer Programming","his seminal work The Art of Computer Programming","hr:The Art of Computer Programming","http://bn.wikipedia.org/wiki/The_Art_of_Computer_Programming","http://cs.wikipedia.org/wiki/The_Art_of_Computer_... ...","http://de.wikipedia.org/wiki/TAOCP","http://de.wikipedia.org/wiki/The_Art...er_Buchrei he","http://de.wikipedia.org/wiki/The_Art...er_Programming","http://de.wikipedia.org/wiki/The_Art_of_Computer_P[...]","http://de.wikipedia.org/wiki/The_Art_of_Computer_Programming","http://de.wikipedia.org/wiki/The_Art_of_Computer_Programming#Aufbau_der_Buchreihe","http://en.Liarpedia.org/wiki/The_Art_of_Computer_Programming","http://en.wikipedia....ter_Programming","http://en.wikipedia...Computer_Programming","http://en.wikipedia.org/wiki/Art_of_Comp...","http://en.wikipedia.org/wiki/Art_of_Computer_...","http://en.wikipedia.org/wiki/Art_of_Computer_Programming","http://en.wikipedia.org/wiki/T.....rogramming","http://en.wikipedia.org/wiki/T....rogramming","http://en.wikipedia.org/wiki/The_...rogramming","http://en.wikipedia.org/wiki/The_A [...] rogramming","http://en.wikipedia.org/wiki/The_Ar...ter_Programming","http://en.wikipedia.org/wiki/The_Art...er_Programming","http://en.wikipedia.org/wiki/The_Art_of ... l_response","http://en.wikipedia.org/wiki/The_Art_of ... rogramming","http://en.wikipedia.org/wiki/The_Art_of … rogramming","http://en.wikipedia.org/wiki/The_Art_of_Compu...","http://en.wikipedia.org/wiki/The_Art_of_Computer_... ...","http://en.wikipedia.org/wiki/The_Art_of_Computer_P rogramming","http://en.wikipedia.org/wiki/The_Art_of_Computer_P...","http://en.wikipedia.org/wiki/The_Art_of_Computer_Pro...","http://en.wikipedia.org/wiki/The_Art_of_Computer_Progra...","http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming","http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming#Assembly_language_in_the_book","http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming#Chapter_outline_of_published_and_unpublished_volumes","http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming#Critical_response","http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming.","http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming~~ROOT~~V","http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming~~V","http://en.wikipedia.org/wiki/The_Art_of_…age_in_the_book","http://en.wikipedia.org/wiki/The_art_of_computer_programming","http://en.wikipedia.org/wiki/the_art_of_...","http://fr.wikipedia.org/wiki/The_Art...er_Programming","http://fr.wikipedia.org/wiki/The_Art_o [...] r_Programming","http://fr.wikipedia.org/wiki/The_Art_of_Computer_Programming","http://goo.gl/ZbFOh","http://id.wikipedia.org/wiki/The_Art_of_Computer_Programming","http://ja.wikipedia.org/wiki/en:The_Art_of_Computer_Programming","http://pl.wikipedia.org/wiki/Sztuka_programowania","http://pl.wikipedia.org/wiki/The_Art_of_Computer_Programming","http://ro.wikipedia.org/wiki/The_Art_of_Computer_Programming","http://ru.wikipedia.org/wiki/Искусство_программирования","http://vi.wikipedia.org/wiki/The_Art_of_Computer_Programming","id:The Art of Computer Programming","it's an art","ja:The Art of Computer Programming","ko:컴퓨터 프로그래밍의 예술","l'Art de la programmation","l'Art de la programmation informatique.","l'Art of Computer Programming Il","l'art de la programmation","l'art de la programmation informatique","l'arte della programmazione","l'article de Wikipédia TAOCP","l'article de Wikipédia The Art of Computer","l'article de Wikipédia The art of computer","le Knuth","multi-volume set of books by the same","nghệ thuật của các máy tính lập trình","pl.wikipedia.org/wiki/Sztuka_programowania","pl:Sztuka programowania","programação também é uma arte","programmering är en konstform","pt:The Art of Computer Programming","que quiero tener","ro:Arta programării calculatoarelor","ru.wikipedia.org​/wiki​/%D0%98%D1%81","ru:Искусство программирования","sausāku literatūru","seven volume monograph","sk:The Art of Computer Programming","subvolume 4A","sv:The Art of Computer Programming","sztuki programowania","taocp","the Art of Computer Programming","the Knuth","the art of computer programming","thuật Lập trình Máy tính.","tr:The Art of Computer Programming","uk:Мистецтво програмування","ultimate reference","umění programování","vi:The Art of Computer Programming","volume 2, chapter 3 of this seminal work","w:en:The Art of Computer Programming","wikipedia:The_Art_of_Computer_Programming","wrote the book on computer programming","zh:计算机程序设计艺术","« The Art of Computer Programming »","«Искусство программирования»","«Исскуство программирования»","«Мистецтво програмування»","Ð˜Ñ ÐºÑƒÑ Ñ Ñ‚Ð²Ð¾ Ð¿Ñ","Τhe Art of Computer Programming.","Википедии статью Искусство программирования","Дональд Кнут, Искусство программирования","Дональд Кнут. Искусство программирования, в 3х томах","Искусства программирования","Искусстве программирования","Искусство программирования","Искусство программирования — Википедия","Искусство программирования,","Искусство программирования.","Искусство_программирования","Искусством программирования","Исскуство программирования","Кнута Vol. 2 гл 3 на случайных чисел","Кнута.","Мистецтво програмування","СЕЙ","википедии ссылка","искусство программирования","искусство программирования.","классическом труде","основных алгоритмов","оставшихся томов","трехтомник Кнута «Искусство программирования»","նյութին","ופועלו","فن برمجة الحاسوب","कम्प्यूटर प्रोग्रामिंग की कला","की प्रोग्रामिंग कला","नुथ","नुथ Vol. पर नंबर रैंडम 3 2 तड़कना","म्हणणे","विकिपीडिया रेफरी","আর্ট অফ প্রোগ্রামিং","งาน ศิลปะ ของ การ โปรแกรม คอมพิวเตอร์","ศิลปะ ของ การ เขียน โปรแกรม.","ศิลปะ ของ การ โปรแกรม คอมพิวเตอร์","ศิลปะ ของ โปรแกรม คอมพิวเตอร์","ศิลปะ ของ โปรแกรม คอมพิวเตอร์.","ở dưới","“Art of computer programming”","“Arta programarii computerelor”","“Nghệ thuật lập trình máy tính”","“The Art of Computer Programming”","“The Art of Computing” series of books","“The art of computer programming”","“Физика”","“计算机程序设计艺术的”","„The Art of Computer Programming“","„Искусство программирования“","《计算机程序设计艺术(The Art of Computer Programming)》","《计算机程序设计艺术(The Art of Computer Programming)》而设计的系统，对于数学公式的排版支援十分强大","《计算机程序设计艺术》","のプログラミングアート","のプログラミングアートが","のプログラミング技術","アートコンピュータプログラミングの概要","ウィキペディアの記事 Art of Computer Programming","ウィキペディアの記事 The Art of Computer Programming","クヌースを","コンピュータプログラミングのアート","コンピュータプログラミングのアートを","プログラミングの","プログラミングのアート","プログラミングのアートを","プログラミングアート","プログラミングコンピュータアートの","・The Art of Computer Programming","可能是计算机程序","和计算机程序设计","在艺术节目","在藝術節目","在计算机程序设计艺术","把這套書念完你就是高手了","的编程艺术","的藝術計算機程序","的計算機程序設計藝術","的计算机程序设计","的计算机程序设计艺术","維基百科的文章“ 計算機程序設計藝術”","維基百科的文章“ 计算机程序设计艺术”","編程的藝術","维基号","维基百科的文章“ 计算机程序设计艺术”","编程的艺术","编程艺术","艺术计算机程序","节目的艺术","藝術計算機程序","計算機程序設計藝術","計算機程式設計藝術","计算机的程序设计艺术","计算机程序的艺术","计算机程序设计艺术","计算机程序设计艺术- 维基百科，自由的百科全书","计算机程序设计艺术的","這套書","電腦程式設計藝術","라고 말했다.","서평","예술 컴퓨터 프로그래밍을","위키 피 디아 문서 The Art of Computer","컴퓨터 프로그래밍 the의 예술이다.","컴퓨터 프로그래밍의 예술","컴퓨터 프로그래밍의 예술 - 위키백과, 우리 ...","컴퓨터 프로그래밍의 예술 - 위키백과, 우리 모두의 백과사전","컴퓨터 프로그래밍의 예술.","컴퓨터 프로그래밍의 예술로","컴퓨터 프로그래밍의 예술을","컴퓨터 프로그래밍의 예술의","크누스","프로그래밍의 예술"],"name":"The Art of Computer Programming","categories":["1968 books","1969 books","1973 books","1981 books","2011 books","Addison-Wesley books","Algorithms","All articles containing potentially dated statements","All articles with unsourced statements","Analysis of algorithms","Articles containing potentially dated statements from 2011","Articles with inconsistent citation formats","Articles with unsourced statements from June 2012","Books by Donald Knuth","Computer programming books","Computer science books","Monographs"],"tag_line":"The Art of Computer Programming (sometimes known by its initials TAOCP) is a comprehensive monograph written by Donald Knuth that covers many kinds of programming algorithms and their analysis."}}
,{"_index":"throwtable","_type":"algorithm","_id":"list-of-algorithms","_score":0,"_source":{"description":"The following is a list of algorithms along with one-line descriptions for each.","alt_names":["graph algorithms","graph algorithm","Graph algorithms","3.4 Linguistics","список алгоритмов","http://en.wikipedia.org/wiki/List_of_alg…","lista di algoritmi","Liste von Algorithmen","- Algortimusok listája","- Graph algorithm :","- List of algorithms :","-> Read the article about 'List of algorithms'","...mehr auf Wikipedia über Liste von Algorithmen","...more on Wikipedia about List of algorithms","/wiki/Список_алгоритмов","1 Abstract Algebra","1 Combinatorial algorithm","1 Combinatorial algorithms","1 Комбинаторные алгоритмы","1.1 General combinatorial algorithms","1.2 Graph algorithm","1.2 Graph algorithms","1.2.1 Graph drawing","1.2.2 Network theory","1.2.3 Routing","1.2.4 Search","1.2.5 Subgraphs","1.3 Search algorithm","1.3 Search algorithms","1.3 Sequence algorithms","1.3.1 Approximate matching","1.3.1 Sequence alignment","1.3.2 Approximate matching","1.3.2 Item search","1.3.3 Item search","1.3.3 Merging","1.3.4 Merging","1.3.4 Permutations","1.3.5 Permutations","1.3.5 Sequence alignment","1.3.6 Sorting","1.3.7 Subsequences","1.3.8 Substrings","1.4 String algorithm","1.4 String algorithms","1.4.1 Searching","1.4.2 Approximate matching","1.5 Sort algorithm","1.5 Sort algorithms","1.5 Sorting algorithms","1.6 Merge algorithms","10 Digital signal processing","10 Machine learning algorithms","10 Neural networks","10 Number theoretic algorithms","10 Parsing","10 Медицинские алгоритмы","10.1 Image Processing","11 Electronics and hardware algorithms","11 Genetic Algorithms","11 Medical algorithms","11 Numerical algorithms","11 Software engineering","11 Нейронные сети","12 Machine Learning and Statistical Classification","12 Neural networks","12 Numerical algebra","12 Operating systems algorithms","12 Quantum algorithms","12 Вычислительная алгебра","13 Genetic algorithms","13 Medical algorithms","13 Number theoretic algorithms","13 Optimization algorithms","13 Теоретико-числовые алгоритмы","14 Numerical algebra","14 Numerical algorithms","14 Parsing","14 Численные алгоритмы","14.1 Elementary and Special Functions","14.2 Geometric","14.3 Interpolation and Extrapolation","14.4 Numerical Integration","14.5 Linear Algebra","14.6 Monte Carlo","14.7 Root Finding","15 Number theoretic algorithms","15 Optimization algorithms","15 Quantum algorithms","15 Алгоритмы оптимизации","16 Numerical algorithms","16 Parsing","16 Programming Language Theory","16 Software engineering","16 Грамматический разбор","16.1 Parsing","17 Neural networks","17 Optimization algorithms","17 Quantum algorithms","17 Квантовые алгоритмы","18 Genetic Algorithms","18 Parsing","18 Science and Medicine","18 Theory of computation and automata","18 Теория вычислений и автоматов","18.1 Astronomy","18.2 Physics","18.3 Linguistics","18.4 Medicine","19 Quantum algorithms","19 Software engineering","19 Theory of computation and automaton","19 Другие","19.1 Database algorithms","19.2 Distributed systems algorithms","19.3 Memory Allocation and deallocation algorithms","19.4 Operating systems algorithms","19.4.1 Disk scheduling algorithms:","19.4.2 Networking algorithms","19.4.3 Process synchronization algorithms:","19.4.4 Scheduling algorithms","2 Coding Theory","2 Compression algorithms","2 Computational mathematics","2 Алгоритмы сжатия данных","2. List of algorithms - Wikipedia, the free encyclopedia","2.1 Abstract algebra","2.1 Lossless compression algorithms","2.2 Computer algebra","2.2 Lossy compression algorithms","2.4 Number theoretic algorithms","2.5 Numerical algorithms","2.5.1 Elementary and special functions","2.5.2 Geometric","2.5.3 Interpolation and extrapolation","2.5.4 Linear algebra","2.5.4 Numerical integration","2.5.5 Linear algebra","2.5.5 Monte Carlo","2.5.6 Monte Carlo","2.5.6 Numerical integration","2.5.7 Root finding","2.6 Optimization algorithms","20 Other","20 Statistical Algorithms","20 Theory of computation and automata","21 Theory of computation and automata","3 Combinatorial algorithms","3 Computational geometry","3 Computational science","3 Вычислительная геометрия","3.1 General combinatorial algorithms","3.2 Bioinformatics","3.2 Graph algorithms","3.3 Geoscience","3.3 Search algorithms","3.4 String algorithms","3.4.1 Searching","3.4.2 Approximate matching","3.5 Medicine","3.5 Sorting algorithms","3.6 Merge algorithms","4 Compression algorithms","4 Computer graphics","4 Компьютерная графика","4.1 Computer architecture","4.1 Lossless compression algorithms","4.2 Computer graphics","4.2 Lossy compression algorithms","4.4 Digital logic","4.5 Machine learning and statistical classification","4.6 Programming language theory","4.6.1 Parsing","4.7 Quantum algorithms","4.8 Theory of computation and automata","5 Computational geometry","5 Computer vision","5 Cryptographic algorithms","5 Information theory and signal processing","5 Компьютерное зрение","5.1 Coding theory","5.1.1 Error detection and correction","5.1.2 Lossless compression algorithms","5.1.3 Lossy compression algorithms","5.2 Digital signal processing","5.2.1 Image processing","6 Computer algebra","6 Cryptographic algorithms","6 Digital signal processing","6 Distributed systems algorithms","6 Software engineering","6 Криптографические алгоритмы","6.1 Database algorithms","6.2 Distributed systems algorithms","6.3 Memory allocation and deallocation algorithms","6.4 Operating systems algorithms","6.4.1 Disk scheduling","6.4.2 Networking","6.4.3 Process synchronization","6.4.4 Scheduling","7 Computer graphics","7 Digital signal processing","7 Distributed systems algorithms","7 Medical algorithms","7 Numerical algorithms","7 Цифровая обработка сигналов","7.1 Optimization algorithms","7.2 Digital signal processing","8 Computer vision","8 Medical algorithms","8 Number theoretic algorithms","8 Software engineering","8 Разработка программного обеспечения","8.1 Distributed systems algorithms","8.2 Memory Allocation and deallocation algorithms","8.3 Operating systems algorithms","8.3.1 Disk scheduling algorithms:","8.3.2 Process synchronisation algorithms:","8.3.3 Scheduling algorithms","8.3.4 Electronics and hardware algorithms","9 Cryptographic algorithms","9 Electronics and hardware algorithms","9 Medical algorithms","9 Numerical algebra","9 Генетические алгоритмы","A long list of algorithms to do different","A visiter de toute urgence ici","Additional Lists","Algorithm List on Wikipedia.org","Algorithms list","Algorithms of Interest","Algoritma Listesi","Algoritma listesi","Algoritma listesi - Vikipedi","Algoritmalar listesi","Algoritmide loend","Algortimusok listája","All algorithm definitions on Wikipedia","CLICK HER 2 GIT WIZE","Danh sách wikipedia của alorithms","Der er en pæn liste her","Div. algo","Graph algorithm","Graph algorithms:","Har du glemt algoritmen?","Http://en.wikipedia.org/wiki/List_of_algorithms","Huge List Of Merchandising And Demo Companies: Find","Information theory and Signal Processing","Information theory and signal processing","LIST OF ALGORITHMS","Li t of algorithm Wikipedia the free encyclopedia","Link 28802 thumbnail","List Of Algorithms","List Of Algorithms - Wikipedia, The Free Encyclopedia","List Of Algorithms From Wikipedia","List Of Algorithms Wikipedia The Free Encyclopedia","List of Algorithms","List of Algorithms - Wikipedia","List of Algorithms - Wikipedia, the free encyclopedia","List of algorithm","List of algorithms","List of algorithms (wikipedia)","List of algorithms - Wikipedia","List of algorithms - Wikipedia :: The free encyclopedia","List of algorithms - Wikipedia(en)","List of algorithms - Wikipedia, the ...","List of algorithms - Wikipedia, the free en","List of algorithms - Wikipedia, the free ency...","List of algorithms - Wikipedia, the free encycl...","List of algorithms - Wikipedia, the free encyclope...","List of algorithms - Wikipedia, the free encyclopedia","List of algorithms - Wikipedia, the free encyclopedia (via","List of algorithms - Wikipedia, the free encyclopedia ...","List of algorithms - Wikipedia, the free encyclopedia Metaphone","List of algorithms - Wikipedia, the free encyclopedia The","List of algorithms - Wikipedia, the free encyclopedia »","List of algorithms - Wikipedia, the free encyclopediaGeneral","List of algorithms - Wikipedia, the free encyclopediaThe","List of algorithms - Wikipedia...","List of algorithms @ Wikipedia","List of algorithms @ wikipedia","List of algorithms Wikipedia the free encyclopedia","List of algorithms Wikipedia the free encyclopedia - result","List of algorithms for error detection and correction","List of algorithms from Wikipedia","List of algorithms from wikipedia","List of algorithms on Wikipedia","List of algorithms su Wikipedia","List of algorithms – Wikipedia","List of algorithms – Wikipedia, the free encyclopedia","List of algorithms.","List of algorithms.url","List of algorithms: Disk scheduling algorithms:","List of algorithms: Distributed systems","List of algorithms: Neural networks","List of algorithms: Parsing","List of algorithms: Sorting algorithms","List of algorithms算法清单","List of famous algorithms on Wikipedia","List_of_algorith","List_of_algorithms","Lista Wikipedia algorytmów","Lista algoritama","Lista algorytmów","Lista algorytmów - wiki","Lista di algoritmi su Wikipedia","Lista wikipedia di alorithms","Liste des algorithmes","Liste des algorithmes - Wikipédia","Liste von Algorithmen - Wikipedia","Liste von Algorithmen ? Wikipedia","Liste von Algorithmen Wikipedia","Liste von Algorithmen – Wikipedia","Liste_von_Algorithmen","Mazen A Melibari: List of algorithms - Wikipedia, the","Parsing Algorithms","Problems on wikipedia","Programming Algorithms","Read More list of algorithms wikipedia the free","Recueil d'algorithmes Wikipedia","Repository of Algorithms","Seznam Wikipedia algoritmů","Sortieralgorthmen auf Wikipedia","Tarjan's off-line least common ancestors algorithm: compute","Une liste imposante d'algo, sorting , searching...","Unstructured list of Algorithms","Vikipedi'deki Algoritma Listesi","WIKIPEDIA: Liste von Algorithmen","WP list of algorithms","Wiki Algorithms Directory","Wiki- list of algorithms","Wiki: Cписок алгоритмов","Wiki: List of Algorithms","WikiPedia: List of Algorithms","Wikipedia - List of Algorithms ( ordered by category)","Wikipedia - list of algorithms","Wikipedia Algorithms","Wikipedia Algorytmy","Wikipedia Categorized List of algorithms","Wikipedia List of Algorithms","Wikipedia Lista de alorithms","Wikipedia Liste der Algorithmen","Wikipedia Liste over Algoritmer","Wikipedia Liste von Algorithmen","Wikipedia article Рӯихати алгоритмҳо","Wikipedia entry for List of algorithms","Wikipedia list of algorithms","Wikipedia's List of Algorithms","Wikipedia's List of algorithms","Wikipedia's list of algorithms","Wikipedia's list of sorting algorithms","Wikipedia-Liste von alorithms","Wikipedia-Seite zu 'Liste von Algorithmen'","Wikipedia: Список алгоритмов","Wikipedia:List of algorithms","Wikipedia:List_of_algorithms","Wiki中的算法列表","Wikpedia's List of Algorithms","a huge list of algorithms","algorithm that you want done.","algoritma çeşitleri","alorithmsのウィキペディアの一覧","alorithms의 위키 피 디아의 목록","bookmarked List of algorithms - Wikipedia, the free encyclopedia","c'è una buona lista qui","daftar Wikipedia algoritma","daftar wikipedia algoritma?","danh sách Wikipedia giải thuật","en ligne,","en línea,","en.wikipedia.org/...List_of_algorithms","en.wikipedia.org/wiki/Graph_algorithm","en.wikipedia.org/wiki/List_of_algorithms","en.wikipedia.org/wiki/List_of_algorithms#Graph_algorithms","en.wikipedia.org/wiki/list_of_algorithms","en:List of algorithms","en:List_of_algorithms","er is een aardige lijst hier","er is een goede lijst hier","er is een goede lijst hier een","es gibt eine gute Liste hier","exact specifications of such algorithms","fr.wikipedia.org/wiki/Liste_des_algorithmes","graph-routing","hay una buena lista aquí","http://bit.ly/gTgnRU","http://de.wikipedia.org/wiki/Liste_v..._und_Grafik://","http://de.wikipedia.org/wiki/Liste_v...ieralgorithmen","http://de.wikipedia.org/wiki/Liste_von_Algorithmen","http://de.wikipedia.org/wiki/Liste_von_Algorithmen#Sortieralgorithmen","http://de.wikipedia.org/wiki/Liste_von_Algorithmen...","http://de.wikipedia.org/wiki/Liste_von_A…tieralgorithmen","http://de.wikipedia.org/wiki/ListevonAlgorithmen","http://en.wikipedia....t_of_algorithms","http://en.wikipedia.org/wiki/Graph_algorithm#Graph_algorithms","http://en.wikipedia.org/wiki/Graph_algorithms","http://en.wikipedia.org/wiki/Graph_algorithms#Graph_algorithms","http://en.wikipedia.org/wiki/List_of...aph_algorithms","http://en.wikipedia.org/wiki/List_of...hic_algorithms","http://en.wikipedia.org/wiki/List_of...ion_algorithms","http://en.wikipedia.org/wiki/List_of...ms#Item_search","http://en.wikipedia.org/wiki/List_of_algor...phic_algorithms","http://en.wikipedia.org/wiki/List_of_algor...raph_algorithms","http://en.wikipedia.org/wiki/List_of_algorithms","http://en.wikipedia.org/wiki/List_of_algorithms # Criptografía","http://en.wikipedia.org/wiki/List_of_algorithms # Cryptography","http://en.wikipedia.org/wiki/List_of_algorithms # Kryptographie","http://en.wikipedia.org/wiki/List_of_algorithms # kryptografie","http://en.wikipedia.org/wiki/List_of_algorithms # криптографии","http://en.wikipedia.org/wiki/List_of_algorithms#Combinatorial_algorithms","http://en.wikipedia.org/wiki/List_of_algorithms#Cryptographic_algorithms","http://en.wikipedia.org/wiki/List_of_algorithms#Cryptography","http://en.wikipedia.org/wiki/List_of_algorithms#Distributed_systems_algorithms","http://en.wikipedia.org/wiki/List_of_algorithms#Graph_algorithms","http://en.wikipedia.org/wiki/List_of_algorithms#Network_theory","http://en.wikipedia.org/wiki/List_of_algorithms#Parsing","http://en.wikipedia.org/wiki/List_of_algorithms#Routing","http://en.wikipedia.org/wiki/List_of_algorithms#Sorting","http://en.wikipedia.org/wiki/List_of_algorithms#Sorting_algorithms","http://en.wikipedia.org/wiki/List_of_algorithms#Substrings","http://en.wikipedia.org/wiki/List_of_algorithms?utm_source=twitterfeed&utm_medium","http://en.wikipedia.org/wiki/List_of_algorithms을","http://en.wikipedia.org/wiki/list_of_algorithms","http://en.wikipedia.org/wi​ki/List_of_algorithms","http://et.wikipedia.org/wiki/Algoritmide_loend","http://fr.wikipedia.org/wiki/Liste_des_algorithmes","http://fr.wikipedia.org/wiki/Liste_des_algorithmes#Algorithmes_de_hachage","http://ru.wikipedia.org/wiki/Список_алго...","http://ru.wikipedia.org/wiki/Список_алгоритмов","http://tr.wikipedia.org/wiki/Algoritma_listesi","há uma boa lista aqui","il ya une bonne liste ici","la lista de Wikipedia de alorithms","la liste de Wikipedia de alorithms","list of algorithms - wikipedia, the free encyclopedia","list of algorithms wikipedia the free encyclopedia","list of the algorithms","list of well-known algorithms","lista algorytmów","lista de Wikipedia de los algoritmos","lista de algoritmos","lista de algoritmos Wikipédia","lista di algoritmi di Wikipedia","liste af algoritmer","liste complète d'algorithmes","liste des algorithmes","liste des algorithmes de Wikipédia","nesta lista da Wikipedia","não há uma boa lista aqui","of widespread algorithms","parsing algorithm","pequeña lista","réunis en un endroit unique","secara online,","there is a nice list here","trực tuyến,","ttp://en.wikipedia.org/wiki/List_of_algorithms>","w:Liste von Algorithmen","wikipedia của danh sách các thuật toán?","wikipedia list of algorithms","wikipedia's Daftar alorithms","wikipedia's List of alorithms","wikipedia's list of algorithms","wp:List_of_algorithms","Ð¡Ð¿Ð¸Ñ Ð¾Ðº Ð°Ð»Ð³Ð¾Ñ","Εδώ θα βρείτε","Алгоритмы вычислительной геометрии","Алгоритмы на строках","Алгоритмы поиска строки Алгоритм Кнута — Морриса — Пратта Алгоритм","Алгоритмы сжатия без потерь","Википедии список алгоритмов?","И вообще литературы более, чем достаточно","Посмотри список алгоритмов тут,может поможет...","Рӯихати алгоритмҳо","Список Википедии алгоритмов","Список алгоримтов","Список алгоритмов","Список алгоритмов - Википедия","Список алгоритмов в Википедии.","Список алгоритмов — Википедия","Список_алгоритмов","Списък с алгоритми","алгоритма сжатия","алгоритмы поиска","есть хороший список здесь","нахождение простых чисел","онлайн,","основные алгоритмы","распространенных алгоритмов","сети. Вдруг его каждый второй пишет наизусть. Но","списка Википедия алгоритмов","список алгоритмов en.eikipedia","список алгоритмов ru.wikipedia","список из Википедии alorithms","три неща","صفحة لسرد الخوارزميات","قائمة خوارزميات","لیست کاملی از الگریتم ها","इस एल्गोरिदम के","एल्गोरिदम के विकिपीडिया सूची","ราย ชื่อ วิ กิ พี เดีย","ราย ชื่อ วิ กิ พี เดีย ของ alorithms","รายชื่อวิกิของขั้นตอนวิธี","แบบ ออนไลน์","アルゴリズムのウィキペディアのリストは","アルゴリズムの一覧はウィキペディア。","リストはこちらある良い","列表算法","名单的算法百科","有一个很好的列表在这里","百科列表算法","百科名單alorithms","算法的百科名单","維基百科名單算法","维基百科的alorithms名单","良いリストがここにあります","알고리즘에","온라인으로","의 알고리즘이 목록을 위키 피 디아"],"name":"List of algorithms","categories":["Algorithms","All articles needing additional references","Articles contradicting other articles","Articles needing additional references from April 2014","Mathematics-related lists"],"tag_line":"The following is a list of algorithms along with one-line descriptions for each."}}
,{"_index":"throwtable","_type":"algorithm","_id":"in-place-algorithm","_score":0,"_source":{"description":"In computer science, an in-place algorithm is an algorithm which transforms input using a data structure with a small amount of extra storage space. The input is usually overwritten by the output as the algorithm executes. An algorithm which is not in-place is sometimes called not-in-place or out-of-place.\nIn-place can have slightly different meanings. In its strictest form, the algorithm can only have a constant amount of extra space, counting everything including function calls and pointers. However, this form is very limited as simply having an index to a length n array requires O(log n) bits. More broadly, in-place means that the algorithm does not use extra space for manipulating the input but may require a small though nonconstant extra space for its operation. Usually, this space is O(log n), though sometimes anything in o(n) is allowed. Note that space complexity also has varied choices in whether or not to count the index lengths as part of the space used. Often, the space complexity is given in terms of the number of indices or pointers needed, ignoring their length. In this article, we refer to total space complexity (DSPACE), counting pointer lengths. Therefore, the space requirements here have an extra log n factor compared to an analysis that ignores the length of indices and pointers.\nAn algorithm may or may not count the output as part of its space usage. Since in-place algorithms usually overwrite their input with output, no additional space is needed. When writing the output to write-only memory or a stream, it may make be more appropriate to only consider the working space of the algorithm. In theory applications such as log-space reductions, it is more typical to always ignore output space (in these cases it is more essential that the output is write-only).\n\n","alt_names":["out-of-place","in-place","- In-place algorithm :","-> Read more about In-place algorithm","-> Read the article about 'In-place algorithm'","...Wikipedia Algorytm in situ","...mehr auf Wikipedia über In-place","...more on Wikipedia about In-place algorithm","Algoritmo in loco","INPLACE","In Place Algorithm","In computational complexity","In functional programming","In functional...","In place algorithm","In place – Wikipedia","In-Place","In-place","In-place algorithm","In-place algorithm - Wikipedia :: The free encyclopedia","In-place algorithm - Wikipedia, the free encyclopedia","In-place algorithm - Wikipedia, the free encyclopedia ...","In-place algoritmus","In-place sort algorithm","In-place – Wikipedia","In-place,","In-place_algorithm","In-placein","In-placeアルゴリズム","In-placeアルゴリズム - Wikipedia","In-placeアルゴリズムとは？ (Wikipediaへのリンク)","In-situ algorithm (in place-done)","Inplace algorithm","Learn more about in-place algorithms","Out Of Place","Out-of-place","Role of randomness","What are some examples of In-place algorithm","What are some examples of In-place sorting","Wikipedia article In-place","Wikipedia article In-place algorithm","Wikipedia article In-place sort algorithm","Wikipedia article on In-place algorithm","Wikipedia entry for In-place algorithm","Wikipedia lists (and links) the following options:","Wikipedia-Artikel In-Place","Wikipedia-Artikel In-place","Wikipedia-Seite zu 'In-place'","Wikipedia/In-place algorithm","Wikipedia:Algoritmo_in_loco","Wikipediaで「In-placeアルゴリズム」を調べる","Work in place","algoritmo in place","an Ort und Stelle","de.wikipedia.org/wiki/In-place","destructively","działającym w miejscu","en el lugar","en.wikipedia.org/wiki/In-place algorithm","en.wikipedia.org/wiki/In-place_algorithm","http://cs.wikipedia.org/wiki/In-place_algoritmus","http://de.wikipedia.org/wiki/In-Place","http://de.wikipedia.org/wiki/In-place","http://en.wikipedia.org/wiki/In-place","http://en.wikipedia.org/wiki/In-place_","http://en.wikipedia.org/wiki/In-place_al","http://en.wikipedia.org/wiki/In-place_algorithm","http://en.wikipedia.org/wiki/In−place_algorithm","http://it.wikipedia.org/wiki/Algoritmo_in_loco","http://ja.wikipedia.org/wiki/In-place%E3","http://pl.wikipedia.org/wiki/Algorytm_in_situ","in place algorithm","in situ algorithm, or in-place algorithm","in-place algorithm","in-place algorithm t","in-place algorithm,","in-place data structure","in-place sort algorithm","in-place sorting algorithm","in-placeアルゴリズム","in-sted","n-place αλγόριθμος","not in place","out-of-plac","sort in place","sul posto","v-místo","w miejscu","“In-place algorithm - Wikipedia, the free encyclopedia”, en","その場で","ウィキペディアの記事 In-placeアルゴリズム","代わりに-","原地","原地算法","原地算法（in-place algorithm）","就地","的就地"],"name":"In-place algorithm","categories":["Algorithms","All articles needing additional references","Articles needing additional references from January 2015"],"tag_line":"In computer science, an in-place algorithm is an algorithm which transforms input using a data structure with a small amount of extra storage space."}}
,{"_index":"throwtable","_type":"algorithm","_id":"divide-and-conquer-algorithms","_score":0,"_source":{"description":"In computer science, divide and conquer (D&C) is an algorithm design paradigm based on multi-branched recursion. A divide and conquer algorithm works by recursively breaking down a problem into two or more sub-problems of the same (or related) type (divide), until these become simple enough to be solved directly (conquer). The solutions to the sub-problems are then combined to give a solution to the original problem.\nThis divide and conquer technique is the basis of efficient algorithms for all kinds of problems, such as sorting (e.g., quicksort, merge sort), multiplying large numbers (e.g. Karatsuba), syntactic analysis (e.g., top-down parsers), and computing the discrete Fourier transform (FFTs).\nUnderstanding and designing D&C algorithms is a complex skill that requires a good understanding of the nature of the underlying problem to be solved. As when proving a theorem by induction, it is often necessary to replace the original problem with a more general or complicated problem in order to initialize the recursion, and there is no systematic method for finding the proper generalization. These D&C complications are seen when optimizing the calculation of a Fibonacci number with efficient double recursion.\nThe correctness of a divide and conquer algorithm is usually proved by mathematical induction, and its computational cost is often determined by solving recurrence relations.","alt_names":[],"name":"Divide and conquer algorithms","categories":["Algorithms","Operations research","Optimization algorithms and methods","Pages with citations lacking titles"],"tag_line":"In computer science, divide and conquer (D&C) is an algorithm design paradigm based on multi-branched recursion."}}
,{"_index":"throwtable","_type":"algorithm","_id":"list-of-algorithm-general-topics","_score":0,"_source":{"description":"This is a list of algorithm general topics.\nAnalysis of algorithms\nAnt colony algorithm\nApproximation algorithm\nBest and worst cases\nBig O notation\nCombinatorial search\nCompetitive analysis\nComputability theory\nComputational complexity theory\nEmbarrassingly parallel problem\nEmergent algorithm\nEvolutionary algorithm\nFast Fourier transform\nGenetic algorithm\nGraph exploration algorithm\nHeuristic\nHill climbing\nImplementation\nLas Vegas algorithm\nLock-free and wait-free algorithms\nMonte Carlo algorithm\nNumerical analysis\nOnline algorithm\nPolynomial time approximation scheme\nProblem size\nPseudorandom number generator\nQuantum algorithm\nRandom-restart hill climbing\nRandomized algorithm\nRunning time\nSorting algorithm\nSearch algorithm\nStable algorithm (disambiguation)\nSuper-recursive algorithm\nTree search algorithm","alt_names":["there's a bunch","- List of algorithm general topics :","...more on Wikipedia about List of algorithm general","List of algorithm general topics","List of algorithm general topics - Wikipedia, the free","List of algorithm general topics Wikipedia the free","List_of_algorithm_general_topics","Source Wikipedia.org Arcticle - List of algorithm general","Wikipedia - Algorithm Topics","Wikipedia Algorithm topics","Wikipedia article ''List of algorithm general topics''","Wikipedia article List of algorithm general topics","Wikipedia article about List of algorithm general topics","Wikipedia entry for List of algorithm general topics","http://en.wikipedia.org/wiki/List_of_al ... ral_topics","http://en.wikipedia.org/wiki/List_of_algorithm_general_topics","list of algorithm general topics","Википедии статью Список основных разделов теории алгоритмов","Список основных разделов теории алгоритмов"],"name":"List of algorithm general topics","categories":["Algorithms","Mathematics-related lists"],"tag_line":"This is a list of algorithm general topics."}}
,{"_index":"throwtable","_type":"algorithm","_id":"algorithmic-logic","_score":0,"_source":{"description":"Algorithmic logic is a calculus of programs which allows the expression of semantical properties of programs by appropriate logical formulas. It provides a framework that enables proving the formulas from the axioms of program constructs such as assignment, iteration and composition instructions and from the axioms of the data structures in question see Mirkowska & Salwicki (1987), Banachowski et al. (1977).\nThe following diagram helps to locate algorithmic logic among other logics. \nThe formalized language of algorithmic logic (and of algorithmic theories of various data structures) contains three types of well formed expressions: terms - i.e. expressions denoting operations on elements of data structures, formulas - i.e. expressions denoting the relations among elements of data structures, programs - i.e. algorithms - these expressions describe the computations. For semantics of terms and formulas consult pages on first order logic and Tarski's semantic. The meaning of a program  is the set of possible computations of the program.\n\nAlgorithmic logic is one of many logics of programs. Another logic of programs is dynamic logic, see dynamic logic, Harel, Kozen & Tiuryn (2000).","alt_names":[],"name":"Algorithmic logic","categories":["Algorithms","All articles covered by WikiProject Wikify","All articles with too few wikilinks","All orphaned articles","All stub articles","Articles covered by WikiProject Wikify from June 2015","Articles with too few wikilinks from June 2015","Mathematical logic stubs","Orphaned articles from June 2015","Theoretical computer science"],"tag_line":"Algorithmic logic is a calculus of programs which allows the expression of semantical properties of programs by appropriate logical formulas."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dakota","_score":0,"_source":{"description":"The Design Analysis Kit for Optimization and Terascale Applications (DAKOTA) is a software toolkit developed by engineers at Sandia National Laboratories to provide a flexible, extensible interface between analysis codes and iterative systems analysis methods. DAKOTA contains optimization algorithms using gradient and nongradient-based methods, parameter estimation with nonlinear least squares methods, uncertainty quantification with sampling, reliability, and stochastic finite element methods, and sensitivity/variance analysis with design of experiments and parameter study capabilities.","alt_names":["DAKOTA in Wikipedia","Wikipedia article DAKOTA","Wikipedia entry for DAKOTA","Wikipedia英語版 - DAKOTA","article DAKOTA","http://en.wikipedia.org/wiki/DAKOTA"],"name":"DAKOTA","categories":["Algorithms","All articles lacking sources","All articles with topics of unclear notability","All orphaned articles","All stub articles","Articles lacking sources from February 2015","Articles with topics of unclear notability from February 2015","Computer programming tool stubs","Orphaned articles from February 2009","Software","United States government stubs"],"tag_line":"The Design Analysis Kit for Optimization and Terascale Applications (DAKOTA) is a software toolkit developed by engineers at Sandia National Laboratories to provide a flexible, extensible interface between analysis codes and iterative systems analysis methods."}}
,{"_index":"throwtable","_type":"algorithm","_id":"avt-statistical-filtering-algorithm","_score":0,"_source":{"description":"AVT Statistical filtering algorithm is an approach to improving quality of raw data collected from various sources. One way to improve signal/noise ratio is to implement filtering to separate useful signal from noise. In ideal situation the useful signal has different frequency then noise and noise is separated/filtered out by frequency discrimination using various filters. Frequency discrimination filtering is done using Low Pass, High Pass and Band Pass filtering which refers to relative frequency filtering criteria target for such configuration. Filters are created using passive and active components and sometimes are implemented using software algorithms based on FFT.\nSometimes signal frequency coincides with noise frequency in real life. In this situations frequency discrimination filtering does not work since the noise and useful signal are indistinguishable. To achieve filtering in such conditions there are several algorithms available which is described below in more detail.","alt_names":[],"name":"AVT Statistical filtering algorithm","categories":["Algorithms"],"tag_line":"AVT Statistical filtering algorithm is an approach to improving quality of raw data collected from various sources."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hcs-clustering-algorithm","_score":0,"_source":{"description":"The HCS (Highly Connected Subgraphs) clustering algorithm (also known as the HCS algorithm , and other names such as Highly Connected Clusters/Components/Kernels) is an algorithm based on graph connectivity for Cluster analysis, by first representing the similarity data in a similarity graph, and afterwards finding all the highly connected subgraphs as clusters. The algorithm does not make any prior assumptions on the number of the clusters. This algorithm was published by Erez Hartuv (erez dot hartuv at gmail dot com) and Ron Shamir in 1998.\nThe HCS algorithm gives clustering solution, which is inherently meaningful in the application domain, since each solution cluster must have diameter 2 while a union of two solution clusters will have diameter 3.","alt_names":[],"name":"HCS clustering algorithm","categories":["Algorithms"],"tag_line":"The HCS (Highly Connected Subgraphs) clustering algorithm (also known as the HCS algorithm , and other names such as Highly Connected Clusters/Components/Kernels) is an algorithm based on graph connectivity for Cluster analysis, by first representing the similarity data in a similarity graph, and afterwards finding all the highly connected subgraphs as clusters."}}
,{"_index":"throwtable","_type":"algorithm","_id":"devex-algorithm","_score":0,"_source":{"description":"In applied mathematics, the devex algorithm is a pivot rule for the simplex method developed by Harris. It identifies the steepest-edge approximately in its search for the optimal solution.","alt_names":[],"name":"Devex algorithm","categories":["Algorithms","Algorithms and data structures stubs","All articles needing additional references","All stub articles","Articles needing additional references from August 2013","Computer science stubs"],"tag_line":"In applied mathematics, the devex algorithm is a pivot rule for the simplex method developed by Harris."}}
,{"_index":"throwtable","_type":"algorithm","_id":"super-recursive-algorithm","_score":0,"_source":{"description":"In computability theory, super-recursive algorithms are a generalization of ordinary algorithms that are more powerful, that is, compute more than Turing machines. The term was introduced by Mark Burgin, whose book \"Super-recursive algorithms\" develops their theory and presents several mathematical models. Turing machines and other mathematical models of conventional algorithms allow researchers to find properties of recursive algorithms and their computations. In a similar way, mathematical models of super-recursive algorithms, such as inductive Turing machines, allow researchers to find properties of super-recursive algorithms and their computations.\nBurgin, as well as other researchers (including Selim Akl, Eugene Eberbach, Peter Kugel, Jan van Leeuwen, Hava Siegelmann, Peter Wegner, and Jiří Wiedermann) who studied different kinds of super-recursive algorithms and contributed to the theory of super-recursive algorithms, have argued that super-recursive algorithms can be used to disprove the Church-Turing thesis, but this point of view has been criticized within the mathematical community and is not widely accepted.","alt_names":["Inductive Turing machines","Learn about Super-recursive algorithm>>>","Relation to the Church–Turing thesis","Schmidhuber's ...","Schmidhuber's generalized Turing machines","Super recursive algorithm","Super-recursive algorithm","Super-recursive algorithm - Wikipedia, the free encyclopedia","Super-recursive algorithm - Wikipedia, the free encyclopedia ...","Super-recursive algorithms","Super-recursive_algorithm","What are some examples of Inductive turing machine","What are some examples of Super-recursive algorithm","What is Super recursive algorithm","What is Super recursive algorithm?","Wikipedia (Super-recursive algorithm)","Wikipedia article Super recursive algorithm","Wikipedia article Super-recursive algorithm","Wikipedia entry for Super-recursive algorithm","http://en.wikipedia.org/wiki/Super-","http://en.wikipedia.org/wiki/Super-recu ... g_machines","http://en.wikipedia.org/wiki/Super-recursive_algorithm","is it worth while to analyze computations where","super-recursive algorithm","super-recursive algorithms","super-recursive-algorithms","super-recursively","yago-res:Super-recursive algorithm","Супер–рекурсивные алгоритмы"],"name":"Super-recursive algorithm","categories":["Algorithms","Hypercomputation","Pages using duplicate arguments in template calls","Theory of computation"],"tag_line":"In computability theory, super-recursive algorithms are a generalization of ordinary algorithms that are more powerful, that is, compute more than Turing machines."}}
,{"_index":"throwtable","_type":"algorithm","_id":"streaming-algorithm","_score":0,"_source":{"description":"In computer science, streaming algorithms are algorithms for processing data streams in which the input is presented as a sequence of items and can be examined in only a few passes (typically just one). These algorithms have limited memory available to them (much less than the input size) and also limited processing time per item.\nThese constraints may mean that an algorithm produces an approximate answer based on a summary or \"sketch\" of the data stream in memory.","alt_names":["- Streaming algorithm :","Algorithme de fouille de flots de données","Algorithme de fouille de flots de données - Wikipédia","Data Streams","Streaming Algorithm","Streaming Algorithmen","Streaming Algorithms","Streaming Algoritmer","Streaming Algoritmi","Streaming algorithm","Streaming algorithm (at Wikipedia)","Streaming algorithm - Wikipedia :: The free encyclopedia","Streaming algorithm - Wikipedia, the free encyclopedia","Streaming algorithm; it is used under the","Streaming algorithms","Streaming algoritmy","Streaming アルゴリズム","Streaming-Algorithmen","Streaming_algorithm","Wikipedia article Streaming algorithm","Wikipedia article on Streaming algorithm","Wikipedia article on Streaming algorithms","Wikipedia entry for Streaming algorithm","Wikipedia sur Algorithme de fouille de flots de","algoritmi in streaming","algoritmos de streaming","algorytmów streaming","data stream model","en.wikipedia.org/...Streaming_algorithm","en.wikipedia.org/wiki/Streaming_algorithm","http://en.wikipedia.org/wiki/Streaming_algorithm","http://en.wikipedia.org/wiki/Streaming_algorithm#Heavy_hitters","http://en.wikipedia.org/wiki/Streaming_algorithms","stream algorithms","streaming algorithm","streaming algorithms","streaming algoritmer","streaming algoritmes","streaming algoritmy","strumieniowych Algorytmy","yago-res:Streaming algorithm","Потоковое алгоритмов","потоковых алгоритмов","स्ट्रीमिंग एल्गोरिदम","ストリーミングアルゴリズム","流算法"],"name":"Streaming algorithm","categories":["Algorithms","All articles with unsourced statements","Articles with unsourced statements from March 2013","Pages using duplicate arguments in template calls","Pages with syntax highlighting errors"],"tag_line":"In computer science, streaming algorithms are algorithms for processing data streams in which the input is presented as a sequence of items and can be examined in only a few passes (typically just one)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hindley–milner-type-system","_score":0,"_source":{"description":"In type theory and functional programming, Hindley–Milner (HM) (also known as Damas–Milner or Damas–Hindley–Milner) is a classical type system for the lambda calculus with parametric polymorphism, first described by J. Roger Hindley and later rediscovered by Robin Milner. Luis Damas contributed a close formal analysis and proof of the method in his PhD thesis.\nAmong HM's more notable properties is completeness and its ability to deduce the most general type of a given program without the need of any type annotations or other hints supplied by the programmer. Algorithm W is a fast algorithm, performing type inference in almost linear time with respect to the size of the source, making it practically usable to type large programs. HM is preferably used for functional languages. It was first implemented as part of the type system of the programming language ML. Since then, HM has been extended in various ways, most notably by constrained types as used in Haskell.","alt_names":[],"name":"Hindley–Milner type system","categories":["1969 in computer science","1978 in computer science","1985 in computer science","Algorithms","All accuracy disputes","Articles with disputed statements from October 2013","Formal methods","Lambda calculus","Theoretical computer science","Type inference","Type systems","Type theory"],"tag_line":"In type theory and functional programming, Hindley–Milner (HM) (also known as Damas–Milner or Damas–Hindley–Milner) is a classical type system for the lambda calculus with parametric polymorphism, first described by J. Roger Hindley and later rediscovered by Robin Milner."}}
,{"_index":"throwtable","_type":"algorithm","_id":"timeline-of-algorithms","_score":0,"_source":{"description":"The following timeline outlines the development of algorithms (mainly \"mathematical recipes\") since their inception.","alt_names":["-> Read the article about 'Timeline of algorithms'","...more on Wikipedia about Timeline of algorithms","Algorithm timeline","Algorithms overview","Algoritmalar?n tarihsel s?ralamas? - Vikipedi","Algoritmalarin tarihsel siralamasi - Vikipedi","Algoritmaların Tarihsel Sıralaması","Algoritmaların tarihsel sıralaması","Algoritmaların tarihsel sıralaması - Vikipedi","Before Modern Era","Famous Algorithms","The timeline of algorithms","Timeline Of Algorithms - Wikipedia, The Free Encyclopedia","Timeline Of Algorithms Wikipedia The Free Encyclopedia","Timeline of Algorithms","Timeline of algorihtms","Timeline of algorithms","Timeline of algorithms - Wikipedia :: The free encyclopedia","Timeline of algorithms - Wikipedia, the free encyclopedia","Timeline of algorithms - Wikipedia, the free encyclopedia ...","Timeline of algorithms Wikipedia the free encyclopedia","Timeline of algorithms: 1950s","Timeline of algorithms: 1960s","Timeline of algorithms: Before 1940","Timelines of Algorithms","What was Timeline of algorithms in 1960s?","Wikipedia entry for Timeline of algorithms","Wikipedia: Historical algorithms","Wikipedia: Timeline of algorithms","algoritmos mais antigos","en.wikipedia.org/wiki/Timeline_of_algorithms","en:Timeline of algorithms","first algorithms","http://en.wikipedia....e_of_algorithms","http://en.wikipedia.org/wiki/Timeline_of_algorithms","http://en.wikipedia.org/wiki/Timeline_of_algorithms#1990s","http://tr.wikipedia.org/wiki/Algoritmalar%C4%B1n_tarihsel_s","yago-res:Timeline of algorithms"],"name":"Timeline of algorithms","categories":["Algorithms","Computing timelines","Mathematics timelines"],"tag_line":"The following timeline outlines the development of algorithms (mainly \"mathematical recipes\") since their inception."}}
,{"_index":"throwtable","_type":"algorithm","_id":"berlekamp–zassenhaus-algorithm","_score":0,"_source":{"description":"In mathematics, in particular in computational algebra, the Berlekamp–Zassenhaus algorithm is an algorithm for factoring polynomials over the integers, named after Elwyn Berlekamp and Hans Zassenhaus. As a consequence of Gauss's lemma, this amounts to solving the problem also over the rationals.\nThe algorithm starts by finding factorizations over suitable finite fields using Hensel's lemma to lift the solution from modulo a prime p to a convenient power of p. After this the right factors are found as a subset of these. The worst case of this algorithm is exponential in the number of factors.\nVan Hoeij (2002) improved this algorithm by using the LLL algorithm, substantially reducing the time needed to choose the right subsets of mod p factors.","alt_names":[],"name":"Berlekamp–Zassenhaus algorithm","categories":["Algebra stubs","Algorithms and data structures stubs","All stub articles","Computer algebra","Computer science stubs"],"tag_line":"In mathematics, in particular in computational algebra, the Berlekamp–Zassenhaus algorithm is an algorithm for factoring polynomials over the integers, named after Elwyn Berlekamp and Hans Zassenhaus."}}
,{"_index":"throwtable","_type":"algorithm","_id":"simulation-algorithms-for-atomic-devs","_score":0,"_source":{"description":"Given an atomic DEVS model, simulation algorithms are methods to generate the model's legal behaviors which are trajectories not to reach to illegal states. (see Behavior of DEVS). [Zeigler84] originally introduced the algorithms that handle time variables related to lifespan  and elapsed time  by introducing two other time variables, last event time, , and next event time  with the following relations:\n\nand\n\nwhere  denotes the current time. And the remaining time,\n\nis equivalently computed as\n\n, apparently .\n\nSince the behavior of a given atomic DEVS model can be defined in two different views depending on the total state and the external transition function (refer to Behavior of DEVS), the simulation algorithms are also introduced in two different views as below.","alt_names":[],"name":"Simulation algorithms for atomic DEVS","categories":["Algorithms"],"tag_line":"Given an atomic DEVS model, simulation algorithms are methods to generate the model's legal behaviors which are trajectories not to reach to illegal states."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sardinas–patterson-algorithm","_score":0,"_source":{"description":"In coding theory, the Sardinas–Patterson algorithm is a classical algorithm for determining in polynomial time whether a given variable-length code is uniquely decodable, named after August Albert Sardinas and George W. Patterson, who published it in 1953. The algorithm carries out a systematic search for a string which admits two different decompositions into codewords. As Knuth reports, the algorithm was rediscovered about ten years later in 1963 by Floyd, despite the fact that it was at the time already well known in coding theory.\n^ Sardinas & Patterson (1953).\n^ Knuth (2003), p. 2","alt_names":[],"name":"Sardinas–Patterson algorithm","categories":["Algorithms","Coding theory","Data compression"],"tag_line":"In coding theory, the Sardinas–Patterson algorithm is a classical algorithm for determining in polynomial time whether a given variable-length code is uniquely decodable, named after August Albert Sardinas and George W. Patterson, who published it in 1953."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rendezvous-hashing","_score":0,"_source":{"description":"Rendezvous or Highest Random Weight (HRW) hashing is an algorithm that allows clients to achieve distributed agreement on a set of k options out of a possible set of n options. A typical application is when clients need to agree on which sites (or proxies) objects are to assigned to. When k is 1, it accomplishes goals similar to consistent hashing, using an entirely different method.","alt_names":[],"name":"Rendezvous hashing","categories":["Algorithms","Hashing"],"tag_line":"Rendezvous or Highest Random Weight (HRW) hashing is an algorithm that allows clients to achieve distributed agreement on a set of k options out of a possible set of n options."}}
,{"_index":"throwtable","_type":"algorithm","_id":"kisao","_score":0,"_source":{"description":"The Kinetic Simulation Algorithm Ontology (KiSAO) supplies information about existing algorithms available for the simulation of systems biology models, their characterization and interrelationships. KiSAO is part of the BioModels.net project and of the COMBINE initiative.","alt_names":[],"name":"KiSAO","categories":["Algorithms","Bioinformatics","Biological databases","Free science software","Systems biology"],"tag_line":"The Kinetic Simulation Algorithm Ontology (KiSAO) supplies information about existing algorithms available for the simulation of systems biology models, their characterization and interrelationships."}}
,{"_index":"throwtable","_type":"algorithm","_id":"approximation-algorithm","_score":0,"_source":{"description":"In computer science and operations research, approximation algorithms are algorithms used to find approximate solutions to optimization problems. Approximation algorithms are often associated with NP-hard problems; since it is unlikely that there can ever be efficient polynomial-time exact algorithms solving NP-hard problems, one settles for polynomial-time sub-optimal solutions. Unlike heuristics, which usually only find reasonably good solutions reasonably fast, one wants provable solution quality and provable run-time bounds. Ideally, the approximation is optimal up to a small constant factor (for instance within 5% of the optimal solution). Approximation algorithms are increasingly being used for problems where exact polynomial-time algorithms are known but are too expensive due to the input size. A typical example for an approximation algorithm is the one for vertex cover in graphs: find an uncovered edge and add both endpoints to the vertex cover, until none remain. It is clear that the resulting cover is at most twice as large as the optimal one. This is a constant factor approximation algorithm with a factor of 2.\nNP-hard problems vary greatly in their approximability; some, such as the bin packing problem, can be approximated within any factor greater than 1 (such a family of approximation algorithms is often called a polynomial time approximation scheme or PTAS). Others are impossible to approximate within any constant, or even polynomial factor unless P = NP, such as the maximum clique problem.\nNP-hard problems can often be expressed as integer programs (IP) and solved exactly in exponential time. Many approximation algorithms emerge from the linear programming relaxation of the integer program.\nNot all approximation algorithms are suitable for all practical applications. They often use IP/LP/Semidefinite solvers, complex data structures or sophisticated algorithmic techniques which lead to difficult implementation problems. Also, some approximation algorithms have impractical running times even though they are polynomial time, for example O(n2156) . Yet the study of even very expensive algorithms is not a completely theoretical pursuit as they can yield valuable insights. A classic example is the initial PTAS for Euclidean TSP due to Sanjeev Arora which had prohibitive running time, yet within a year, Arora refined the ideas into a linear time algorithm. Such algorithms are also worthwhile in some applications where the running times and cost can be justified e.g. computational biology, financial engineering, transportation planning, and inventory management. In such scenarios, they must compete with the corresponding direct IP formulations.\nAnother limitation of the approach is that it applies only to optimization problems and not to \"pure\" decision problems like satisfiability, although it is often possible to conceive optimization versions of such problems, such as the maximum satisfiability problem (Max SAT).\nInapproximability has been a fruitful area of research in computational complexity theory since the 1990 result of Feige, Goldwasser, Lovász, Safra and Szegedy on the inapproximability of Independent Set. After Arora et al. proved the PCP theorem a year later, it has now been shown that Johnson's 1974 approximation algorithms for Max SAT, Set Cover, Independent Set and Coloring all achieve the optimal approximation ratio, assuming P != NP.","alt_names":["Approximation Algorithms","approximation algorithm","Approximationsalgorithmus","approximation algorithms","- Approximation algorithm :","- Approximation algorithms :","-> Read more about Approximation algorithm","...Wikipedia Algorithme d'approximation","...Wikipedia Algorytm aproksymacyjny","...mehr auf Wikipedia über Approximationsalgorithmus","...more on Wikipedia about Approximation algorithm","1 Performance guarantees","2 Epsilon terms","Algorithme d'approximation","Algorithme d'approximation - Wikipédia","Algorithmes d'approximation","Algorithmic and Approximation","Algoritmo de aproximacion","Algoritmo de aproximación","Algoritmo de aproximación - Wikipedia, la enciclopedia libre","Algorytm aproksymacyjny Wikipedia, wolna encyklopedia","Algorytm aproksymacyjny – Wikipedia, wolna encyklopedia","Algorytmy aproksymacyjne","Approx-Algorithmen","Approximate Algorithms","Approximation Algorithm","Approximation Algorithm Wikipedia The Free Encyclopedia","Approximation Algorithms.","Approximation algorithm","Approximation algorithm - Wikipedia :: The free encyclopedia","Approximation algorithm - Wikipedia, the free encyclopedia","Approximation algorithm Wikipedia the free encyclopedia","Approximation algorithm Wikipedia the free encyclopedia - result","Approximation algorithm from Wikipedia","Approximation algorithms","Approximation algorithms:","Approximation ratio","Approximation_algorithm","Approximation_algorithms","Approximationsalgorithmen","Approximationsalgorithmus bei der wikipedia","Approximationsalgorithmus in","Approximationsalgorithmus – ...","Approximationsalgorithmus – Wikipedia","Approximationsg%C3%BCte bei der wikipedia","Approximationsschema","Approximationsschema bei der wikipedia","Approximationsschranken","Approximierbarkeit","Approximierbarkeit bei der wikipedia","Aproksimasi Algoritma","Aproximační algoritmy","Aproximační algoritmy - Wikipedie","Epsilon terms","ISBN 3540653678","Learn about Approximation algorithm>>>","Near-optimization","Performance guarantees","R A ∞","Sbližování algoritmus","Suggested: approximation algorithm","Wikipedia article Algorithme d'approximation","Wikipedia article Approximation algorithm","Wikipedia article Approximation algorithms","Wikipedia article Approximationsalgorithmus","Wikipedia article on Algoritmo de aproximación","Wikipedia article on Approximation algorithm","Wikipedia article אלגוריתם קירוב","Wikipedia article ขั้นตอนวิธีการประมาณ","Wikipedia entry for Approximation algorithm","Wikipedia-Artikel Approximationsalgorithmus","Wikipedia-Artikel Approximationsgüte","Wikipedia-Artikel Approximationsschema","Wikipedia-Artikel Approximierbarkeit","Wikipedia-Seite zu 'Approximationsalgorithmus'","Wikipedia: Approximation algorithm","Wikipedia: approximation algorithms","Wikipediaで「近似アルゴリズム」を調べる","Wikipediaで「近似度」を調べる","Zbliżanie algorytmu","aanpassing algoritme","absolute performance guarantee","algorithmes d'approximation","algoritmes d'aproximació","algoritmo de aproximación","algoritmo de aproximação","algoritmo di approssimazione","algoritmos aproximados","algoritmos de aproximación","approksimoinnille","approksimointialgoritmeja","approximability","approximate algorithms","approximate solution","approximation algorithms and the approximation ratio","approximation algorithms,","approximation complexity","approximation problems","approximation ratio","approximation ratios","approximations algorithms","article on approximation algorithms","artículo de Wikipedia Algoritmo de aproximacion","artículo de Wikipedia Algoritmo de aproximación","constant factor approximation","cs:Aproximační algoritmy","de:Approximationsalgorithmus","es:Algoritmo de aproximación","fa:الگوریتمهای تقریبی","garantie de performance","giải pháp gần đúng","he:אלגוריתם קירוב","http://de.wikipedia.org/wiki/Ap proximierbarkeit","http://de.wikipedia.org/wiki/Approximationsalgorithmus","http://de.wikipedia.org/wiki/Approximationsschema","http://en.wikipedia.org/wiki/Approxima-","http://en.wikipedia.org/wiki/ApproximationAlgorithm","http://en.wikipedia.org/wiki/Approximation_al...","http://en.wikipedia.org/wiki/Approximation_algorithm","http://en.wikipedia.org/wiki/Approximation_algorithms","http://en.wikipedia.org/wiki/Approximation_ratio","http://es.wikipedia.org/wiki/Algoritmo_de_aproximaci%C3%B3n","http://fr.wikipedia.org/wiki/Algorithme_d%27approximation","http://ja.wikipedia.org/wiki/近似アルゴリズム","http://pl.wikipedia.org/wiki/Algorytm_aproksymacyjny","ja:近似アルゴリズム","ja:近似度","ko:근사 알고리즘","non approximal","näherungsweise Lösung","perkiraan solusi","pl:Algorytm aproksymacyjny","rapprochement algorithme","ravvicinamento Algoritmo","relative performance guarantee","s ≤ a ≤ ρ s , if ρ > 1 ; ρ","solución aproximada","solution approchée","soluzione approssimata","solução aproximada","th:ขั้นตอนวิธีการประมาณ","tilnærmelse algoritme","vi:Thuật toán xấp xỉ","wen:Approximation algorithm","within a small approximation factor of optimal","xấp xỉ thuật toán","zh:近似算法","δ-approximation algorithm","ε-approximation algorithm","алгоритм приближения","приближенное решение","приближенный алгоритм","אלגוריתם קירוב","אלגוריתם קירוב – ויקיפדיה","אלגוריתמי קירוב","ויקיפדיה - 'אלגוריתם קירוב'","الگوریتم های تقریبی","الگوریتم های تقریبی ، ویکی پدیای انگلیسی","الگوریتم های تقریبی ، ویکیپدیای انگلیسی","الگوریتم های تقریبی، ویکیپدیای انگلیسی","الگوریتمهای تقریبی - ویکیپدیا","ขั้นตอนวิธีการประมาณ","ประมาณ Algorithm","สารละลายตัวอย่าง","“Approximation algorithm - Wikipedia, the free encyclopedia”, en.wikipedia","問題に","近似アルゴリズム","近似アルゴリズム - Wikipedia","近似アルゴリズム-Wikipedia","近似度","近似度 - Wikipedia","近似度-wikipedia","近似演算法","近似算法","近似解","近似ｱﾙｺﾞﾘｽﾞﾑ-wikipedia","근사 알고리즘","근사 알고리즘 - 위키백과, 우리 모두의 백과사전","대략적인 해결책은","위키 피 디아 문서 근사 알고리즘"],"name":"Approximation algorithm","categories":["All articles lacking in-text citations","Approximation algorithms","Articles lacking in-text citations from April 2009","Computational complexity theory","Wikipedia articles with GND identifiers"],"tag_line":"In computer science and operations research, approximation algorithms are algorithms used to find approximate solutions to optimization problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"domination-analysis","_score":0,"_source":{"description":"Domination analysis of an approximation algorithm is a way to estimate its performance, introduced by Glover and Punnen in 1997. Unlike the classical approximation ratio analysis, which compares the numerical quality of a calculated solution with that of an optimal solution, domination analysis involves examining the rank of the calculated solution in the sorted order of all possible solutions. In this style of analysis, an algorithm is said to have dominance number or domination number K, if there exists a subset of K different solutions to the problem among which the algorithm's output is the best. Domination analysis can also be expressed using a domination ratio, which is the fraction of the solution space that is no better than the given solution; this number always lies within the interval [0,1], with larger numbers indicating better solutions. Domination analysis is most commonly applied to problems for which the total number of possible solutions is known and for which exact solution is difficult.\nFor instance, in the Traveling salesman problem, there are (n-1)! possible solutions for a problem instance with n cities. If an algorithm can be shown to have dominance number close to (n-1)!, or equivalently to have domination ratio close to 1, then it can be taken as preferable to an algorithm with lower dominance number.\nIf it is possible to efficiently find random samples of a problem's solution space, as it is in the Traveling salesman problem, then it is straightforward for a randomized algorithm to find a solution that with high probability has high domination ratio: simply construct a set of samples and select the best solution from among them. (See, e.g., Orlin and Sharma.)\nThe dominance number described here should not be confused with the domination number of a graph, which refers to the number of vertices in the smallest dominating set of the graph.\nRecently, a growing number of articles in which domination analysis has been applied to assess the performance of heuristics has appeared. This kind of analysis may be seen as competing with the classical approximation ratio analysis tradition. The two measures may also be viewed as complementary.","alt_names":["Dominance number","Domination Analysis","Domination analysis","Domination analysis - Wikipedia, the free encyclopedia","Wikipedia article Dominance number","Wikipedia article Domination analysis","Wikipedia entry for Domination analysis","http://en.wikipedia.org/wiki/Domination_analysis","yago-res:Domination analysis"],"name":"Domination analysis","categories":["Approximation algorithms"],"tag_line":"Domination analysis of an approximation algorithm is a way to estimate its performance, introduced by Glover and Punnen in 1997."}}
,{"_index":"throwtable","_type":"algorithm","_id":"method-of-conditional-probabilities","_score":0,"_source":{"description":"In mathematics and computer science, the probabilistic method is used to prove the existence of mathematical objects with desired combinatorial properties. The proofs are probabilistic — they work by showing that a random object, chosen from some probability distribution, has the desired properties with positive probability. Consequently, they are nonconstructive — they don't explicitly describe an efficient method for computing the desired objects.\nThe method of conditional probabilities (Erdős & Selfridge 1973), (Spencer 1987), (Raghavan 1988) converts such a proof, in a \"very precise sense\", into an efficient deterministic algorithm, one that is guaranteed to compute an object with the desired properties. That is, the method derandomizes the proof. The basic idea is to replace each random choice in a random experiment by a deterministic choice, so as to keep the conditional probability of failure, given the choices so far, below 1.\nThe method is particularly relevant in the context of randomized rounding (which uses the probabilistic method to design approximation algorithms).\nWhen applying the method of conditional probabilities, the technical term pessimistic estimator refers to a quantity used in place of the true conditional probability (or conditional expectation) underlying the proof.","alt_names":["450px-Method_of_conditional_ ...","A probabilistic proof of Turán's theorem","Example using conditional expectations","Example using pessimistic estimators","Method of conditional probabilities","Method of conditional probabilities - Wikipedia, the free ...","Method of conditional probabilities - Wikipedia, the free encyclopedia","Pessimistic Estimators, Wikipedia","Pessimistic estimator","Wikipedia article Method of conditional probabilities","http://en.wikipedia.org/wiki/Method_of_conditional_probabilities","method of conditional expectations","method of conditional probabilities","pessimistic estimator","pessimistic estimators","the method of conditional expectations","this for a probabilistic proof of Turán's theorem"],"name":"Method of conditional probabilities","categories":["All articles lacking in-text citations","Approximation algorithms","Articles lacking in-text citations from June 2012","Probabilistic arguments"],"tag_line":"In mathematics and computer science, the probabilistic method is used to prove the existence of mathematical objects with desired combinatorial properties."}}
,{"_index":"throwtable","_type":"algorithm","_id":"faugère's-f4-and-f5-algorithms","_score":0,"_source":{"description":"In computer algebra, the Faugère F4 algorithm, by Jean-Charles Faugère, computes the Gröbner basis of an ideal of a multivariate polynomial ring. The algorithm uses the same mathematical principles as the Buchberger algorithm, but computes many normal forms in one go by forming a generally sparse matrix and using fast linear algebra to do the reductions in parallel.\nThe Faugère F5 algorithm first calculates the Gröbner basis of a pair of generator polynomials of the ideal. Then it uses this basis to reduce the size of the initial matrices of generators for the next larger basis:\n\nIf Gprev is an already computed Gröbner basis (f2, …, fm) and we want to compute a Gröbner basis of (f1) + Gprev then we will construct matrices whose rows are m f1 such that m is a monomial not divisible by the leading term of an element of Gprev.\n\nThis strategy allows the algorithm to apply two new criteria based on what Faugère calls signatures of polynomials. Thanks to these criteria, the algorithm can compute Gröbner bases for a large class of interesting polynomial systems, called regular sequences, without ever simplifying a single polynomial to zero—the most time-consuming operation in algorithms that compute Gröbner bases. It is also very effective for a large number of non-regular sequences.","alt_names":[],"name":"Faugère's F4 and F5 algorithms","categories":["Algorithms and data structures stubs","All articles with unsourced statements","All stub articles","Articles with unsourced statements from February 2013","Computer algebra","Computer science stubs"],"tag_line":"In computer algebra, the Faugère F4 algorithm, by Jean-Charles Faugère, computes the Gröbner basis of an ideal of a multivariate polynomial ring."}}
,{"_index":"throwtable","_type":"algorithm","_id":"polynomial-time-algorithm-for-approximating-the-volume-of-convex-bodies","_score":0,"_source":{"description":"The paper is a joint work by Martin Dyer, Alan M. Frieze and Ravindran Kannan.\nThe main result of the paper is a randomized algorithm for finding an  approximation to the volume of a convex body  in -dimensional Euclidean space by assuming the existence of a membership oracle. The algorithm takes time bounded by a polynomial in , the dimension of  and .\nThe algorithm is a sophisticated usage of the so-called Markov chain Monte Carlo (MCMC) method. The basic scheme of the algorithm is a nearly uniform sampling from within  by placing a grid consisting -dimensional cubes and doing a random walk over these cubes. By using the theory of\nrapidly mixing Markov chains, they show that it takes a polynomial time for the random walk to settle down to being a nearly uniform distribution.\n^ M.Dyer, A.Frieze and R.Kannan (1991). \"A random polynomial-time algorithm for approximating the volume of convex bodies\". Journal of the ACM 38 (1): 1–17. doi:10.1145/102782.102783.","alt_names":[],"name":"Polynomial-time algorithm for approximating the volume of convex bodies","categories":["Approximation algorithms","Computational geometry"],"tag_line":"The paper is a joint work by Martin Dyer, Alan M. Frieze and Ravindran Kannan."}}
,{"_index":"throwtable","_type":"algorithm","_id":"k-approximation-of-k-hitting-set","_score":0,"_source":{"description":"In computer science, k-approximation of k-hitting set is an approximation algorithm for weighted hitting set. The input is a collection S of subsets of some universe T and a mapping W from T to non-negative numbers called the weights of the elements of T. In k-hitting set the size of the sets in S cannot be larger than k. That is, . The problem is now to pick some subset T' of T such that every set in S contains some element of T', and such that the total weight of all elements in T' is as small as possible.","alt_names":["261e1cd1415954068386f5629ef ...","In computer science, k-approximation of k-hitting","K approximation of k hitting set","K-approximation of k-hitting set","K-approximation of k-hitting set - Wikipedia :: The","K-approximation of k-hitting set - Wikipedia, the","Relation to linear programming","Wikipedia article K-approximation of k-hitting set","Wikipedia entry for K-approximation of k-hitting","d-approximation","d-近似","http://en.Liarpedia.org/wiki/K-approximation_of_k-hitting_set","http://en.wikipedia.org/wiki/K-approxima","http://en.wikipedia.org/wiki/K-approximation_of_k-hitting_set","k-approximation","k-approximation of k-hitting set","yago-res:K-approximation of k-hitting set","Σ a &Element; H W ( a ) ≤ k · Σ"],"name":"K-approximation of k-hitting set","categories":["Approximation algorithms"],"tag_line":"In computer science, k-approximation of k-hitting set is an approximation algorithm for weighted hitting set."}}
,{"_index":"throwtable","_type":"algorithm","_id":"flower-pollination-algorithm","_score":0,"_source":{"description":"Flower pollination algorithm (FPA) is a metaheuristic algorithm that was developed by Xin-She Yang, based on the pollination process of flowering plants. FPA has been applied to solve practical problems in engineering, solar PV parameter estimation, and fuzzy selection for dynamic economic dispatch.\n\n","alt_names":[],"name":"Flower pollination algorithm","categories":["All articles needing expert attention","Articles needing expert attention from July 2015","Bioinformatics algorithms","Computer science articles needing expert attention","Pollination"],"tag_line":"Flower pollination algorithm (FPA) is a metaheuristic algorithm that was developed by Xin-She Yang, based on the pollination process of flowering plants."}}
,{"_index":"throwtable","_type":"algorithm","_id":"selection-(genetic-algorithm)","_score":0,"_source":{"description":"Selection is the stage of a genetic algorithm in which individual genomes are chosen from a population for later breeding (using the crossover operator).\nA generic selection procedure may be implemented as follows:\nThe fitness function is evaluated for each individual, providing fitness values, which are then normalized. Normalization means dividing the fitness value of each individual by the sum of all fitness values, so that the sum of all resulting fitness values equals 1.\nThe population is sorted by descending fitness values.\nAccumulated normalized fitness values are computed (the accumulated fitness value of an individual is the sum of its own fitness value plus the fitness values of all the previous individuals). The accumulated fitness of the last individual should be 1 (otherwise something went wrong in the normalization step).\nA random number R between 0 and 1 is chosen.\nThe selected individual is the first one whose accumulated normalized value is greater than R.\nIf this procedure is repeated until there are enough selected individuals, this selection method is called fitness proportionate selection or roulette-wheel selection. If instead of a single pointer spun multiple times, there are multiple, equally spaced pointers on a wheel that is spun once, it is called stochastic universal sampling. Repeatedly selecting the best individual of a randomly chosen subset is tournament selection. Taking the best half, third or another proportion of the individuals is truncation selection.\nThere are other selection algorithms that do not consider all individuals for selection, but only those with a fitness value that is higher than a given (arbitrary) constant. Other algorithms select from a restricted pool where only a certain percentage of the individuals are allowed, based on fitness value.\nRetaining the best individuals in a generation unchanged in the next generation, is called elitism or elitist selection. It is a successful (slight) variant of the general process of constructing a new population.","alt_names":["...mehr auf Wikipedia über Selektion (genetischer Algorithmus)","Selecció (algorisme genètic)","Selección (computación evolutiva)","Selección (computación evolutiva) - Wikipedia, la ...","Selección (computación evolutiva) - Wikipedia, la enciclopedia libre","Selection (Genetic Algorithm)","Selection (genetic algorithm)","Selection (genetic algorithm) - Wikipedia :: The free encyclopedia","Selection (genetic algorithm) - Wikipedia, the free encyclopedia","Selection (genetic algorithm) from Wikipedia","Selection (naravna izbira)","Selection genetic algorithm","Selection genetic algorithm Wikipedia the free encyclopedia","Selection_(genetic_algorithm)","Selektion (genetischer Algorithmus)","Selektion (genetischer Algorithmus) – Wikipedia","Selektion für genetische Algorithmen","Selektion_(genetischer_Algorithmus)","Source Wikipedia.org Arcticle - Selection (genetic algorithm)","Wikipedia article Selección (computación evolutiva)","Wikipedia article Selection (genetic algorithm)","Wikipedia article Selection_(genetic_algorithm)","Wikipedia entry for Selection (genetic algorithm)","Wikipedia-Artikel Selektion (genetischer Algorithmus)","Wikipedia-Seite zu 'Selektion (genetischer Algorithmus)'","artículo de Wikipedia Seleccion (computacion evolutiva)","artículo de Wikipedia Selección (computación evolutiva)","ca:Selecció (algorisme genètic)","de:Selektion (genetischer Algorithmus)","es.wikipedia.org/...n_(computaci%C3%B3n_evolutiva)","es:Selección (computación evolutiva)","http://de.wikipedia.org/wiki/Selektion_(genetischer_Algorithmus)","http://en.wikipedia.org/wiki/Selection (genetic algorithm","http://en.wikipedia.org/wiki/Selection_%28genetic_algorithm%29","http://en.wikipedia.org/wiki/Selection_(genetic_algorithm","http://en.wikipedia.org/wiki/Selection_(genetic_algorithm)","http://es.wikipedia.org/wiki/Selecci%C3%B3n_","parent selection","screening/selection","selection (genetic algorithm)","survivor selection"],"name":"Selection (genetic algorithm)","categories":["Genetic algorithms"],"tag_line":"Selection is the stage of a genetic algorithm in which individual genomes are chosen from a population for later breeding (using the crossover operator)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"tournament-selection","_score":0,"_source":{"description":"Tournament selection is a method of selecting an individual from a population of individuals in a genetic algorithm. Tournament selection involves running several \"tournaments\" among a few individuals (or 'chromosomes') chosen at random from the population. The winner of each tournament (the one with the best fitness) is selected for crossover. Selection pressure is easily adjusted by changing the tournament size. If the tournament size is larger, weak individuals have a smaller chance to be selected.\nThe tournament selection method may be described in pseudo code:\n\nchoose k (the tournament size) individuals from the population at random\nchoose the best individual from pool/tournament with probability p\nchoose the second best individual with probability p*(1-p)\nchoose the third best individual with probability p*((1-p)^2)\nand so on...\n\nDeterministic tournament selection selects the best individual (when p = 1) in any tournament. A 1-way tournament (k = 1) selection is equivalent to random selection. The chosen individual can be removed from the population that the selection is made from if desired, otherwise individuals can be selected more than once for the next generation. In comparison with the (stochastic) fitness proportionate selection method, tournament selection is often implemented in practice due to its lack of stochastic noise.\nTournament selection has several benefits over alternative selection methods for genetic algorithms (for example, fitness proportionate selection and reward-based selection): it is efficient to code, works on parallel architectures and allows the selection pressure to be easily adjusted. Tournament selection has also been shown to be independent of the scaling of the genetic algorithm fitness function (or 'objective function') in some classifier systems.","alt_names":["- Tournament selection :","...more on Wikipedia about Tournament selection","Jillis ter Hove: Tournament selection - Wikipedia, the free","Seleção por Torneios","Tournament Selection","Tournament selection","Tournament selection - Wikipedia, the free encyclopedia","Wikipedia article Tournament selection","Wikipedia article Tournament_selection","Wikipedia article on tournament selection","Wikipedia entry for Tournament selection","en.wikipedia.org/wiki/Tournament_selection","en:tournament selection","http://en.wikipedia.org/wiki/Tournament_selectio","http://en.wikipedia.org/wiki/Tournament_selection","http://en.wikipedia.org/wiki/Tournament_selection.","s tournament selectio","tournament based selection","tournament scheme","tournament selection","turnuva seçimi","yago-res:Tournament selection"],"name":"Tournament selection","categories":["Genetic algorithms","Pages using citations with accessdate and no URL"],"tag_line":"Tournament selection is a method of selecting an individual from a population of individuals in a genetic algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"genetic-operator","_score":0,"_source":{"description":"A genetic operator is an operator used in genetic algorithms to guide the algorithm towards a solution to a given problem. There are three main types of operators (mutation, crossover and selection), which must work in conjunction with one another in order for the algorithm to be successful. Genetic operators are used to create and maintain genetic diversity (mutation operator), combine existing solutions (also known as chromosomes) into new solutions (crossover) and select between solutions (selection). In his book discussing the use of genetic programming for the optimization of complex problems, computer scientist John Koza has also identified an 'inversion' or 'permutation' operator; however, the effectiveness of this operator has never been conclusively demonstrated and this operator is rarely discussed.\nMutation (or mutation-like) operators are said to be unary operators, as they only operate on one chromosome at a time. In contrast, crossover operators are said to be binary operators, as they operate on two chromosomes at a time, combining two existing chromosomes into one new chromosome.","alt_names":["genetic operators","- Genetic operators :","-> Read more about Genetic operator","...more on Wikipedia about Genetic operator","Ein genetischer Operator bei einem genetischen Algorithmus ist","Genetic operations","Genetic operator","Genetic operator - Wikipedia, the free encyclopedia","Genetic operator Wikipedia the free encyclopedia","Genetic operator on wikipedia.org","Genetic_operator","Genetischer Operator","Genetischer Operator ? Wikipedia","Genetischer_Operator","Operador genètic (algorisme genètic)","Operador genético","Source Wikipedia.org Arcticle - Genetic operator","Wikipedia (Genetic operator)","Wikipedia article ''Genetic operator''","Wikipedia article Genetic operator","Wikipedia article Genetic operators","Wikipedia article Genetic_operator","Wikipedia article Operador genético","Wikipedia article about Genetic operator","Wikipedia article on Genetic operator","Wikipedia article مؤثر جيني","Wikipedia entry for Genetic operator","Wikipedia-Artikel Genetischer Operator","Wikipedia-Seite zu 'Genetischer Operator'","en:Genetic operator","enetic operators:","genetic operator","genetic operators:","http://de.wikipedia.org/wiki/Genetischer_Operator","http://en.wikipedia.org/wiki/Genetic operator","http://en.wikipedia.org/wiki/Genetic_ope","http://en.wikipedia.org/wiki/Genetic_operator","http://es.wikipedia.org/wiki/Operador_gen%C3%A9tico","operadores genéticos","zh:遺傳運算元","مؤثر جيني"],"name":"Genetic operator","categories":["Genetic algorithms"],"tag_line":"A genetic operator is an operator used in genetic algorithms to guide the algorithm towards a solution to a given problem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"uclust","_score":0,"_source":{"description":"UCLUST is an algorithm designed to cluster nucleotide or amino-acid sequences into clusters based on sequence similarity. The algorithm was published in 2010 and implemented in a program also named UCLUST. The algorithm is described by the author as following two simple clustering criteria, in regard to the requested similarity threshold T. The first criterion states that any given cluster's centroid sequence will have a similarity smaller than T to any other clusters' centroid sequence. The second criterion states that each member sequence in a given cluster will have similarity to the cluster's centroid sequence that is equal or greater than T.\nUCLUST algorithm is a greedy one. As a result, the order of the sequences in the input file will have an impact on the resulting clusters and their quality. For this reason, it's advised that the sequences will be sorted before entering clustering stage. The program UCLUST is equipped with some options to sort the input sequences prior to clustering them.\nUCLUST program is widely utilized among the bioinformatic research community, where it used for multiple applications including OTU assignment (e.g. 16s), creating non-redundant gene catalogs, taxonomic assignment\nand phylogenetic analysis.\n^ Edgar, R. C. (2010). \"Search and clustering orders of magnitude faster than BLAST\". Bioinformatics 26 (19): 2460–2461. doi:10.1093/bioinformatics/btq461. ISSN 1367-4803.","alt_names":[],"name":"UCLUST","categories":["2010 software","All articles covered by WikiProject Wikify","All articles with too few wikilinks","Articles covered by WikiProject Wikify from March 2015","Articles with too few wikilinks from March 2015","Bioinformatics algorithms","Metagenomics"],"tag_line":"UCLUST is an algorithm designed to cluster nucleotide or amino-acid sequences into clusters based on sequence similarity."}}
,{"_index":"throwtable","_type":"algorithm","_id":"gene-expression-programming","_score":0,"_source":{"description":"In computer programming, gene expression programming (GEP) is an evolutionary algorithm that creates computer programs or models. These computer programs are complex tree structures that learn and adapt by changing their sizes, shapes, and composition, much like a living organism. And like living organisms, the computer programs of GEP are also encoded in simple linear chromosomes of fixed length. Thus, GEP is a genotype-phenotype system, benefiting from a simple genome to keep and transmit the genetic information and a complex phenotype to explore the environment and adapt to it.","alt_names":["(no) http://en.wikipedia.org/wiki/Gene_expression_programming","...more on Wikipedia about Gene expression programming","Gene Expression Programming","Gene expression programming","Gene expression programming - Wikipedia, the free ...","Gene expression programming - Wikipedia, the free encyclopedia","Gene expression programming - Wikipedia, the free encyclopedia ...","Gene-Expression Programming","Geneexpressionprogramming - Wikipedia, the free encyclopedia","Wikipedia article ''Gene expression programming''","Wikipedia article Gene expression programming","Wikipedia article Gene_expression_programming","Wikipedia article about Gene expression programming","Wikipedia article on Gene expression programming","Wikipedia entry for Gene expression programming","gene expression programming","http://en.wikipedia.org/wiki/Gene_expression_programming","yago-res:Gene expression programming"],"name":"Gene expression programming","categories":["Evolutionary algorithms","Evolutionary computation","Gene expression programming","Genetic algorithms","Genetic programming","Wikipedia articles with possible conflicts of interest from November 2012"],"tag_line":"In computer programming, gene expression programming (GEP) is an evolutionary algorithm that creates computer programs or models."}}
,{"_index":"throwtable","_type":"algorithm","_id":"schema-(genetic-algorithms)","_score":0,"_source":{"description":"A schema is a template in computer science used in the field of genetic algorithms that identifies a subset of strings with similarities at certain string positions. Schemata are a special case of cylinder sets; and so form a topological space.","alt_names":["- Schema (genetic algorithms) :","Disruption (of schema)","Disruption of schema","Length schema","Schema (genetic algorithms)","Schema (genetic algorithms) - Wikipedia :: The free encyclopedia","Schema (genetic algorithms) - Wikipedia, the free encyclopedia","Schema genetic algorithms","Schema(genetic algorithms)","Schema_(genetic_algorithms)","Source Wikipedia.org Arcticle - Schema (genetic algorithms)","Wikipedia (Length schema)","Wikipedia article Disruption (of schema)","Wikipedia article Length schema","Wikipedia article Schema (genetic algorithms)","Wikipedia article on Schema (genetic algorithms)","Wikipedia entry for Disruption (of schema)","Wikipedia entry for Length schema","Wikipedia entry for Schema (genetic algorithms)","http://em.wikipedia.org/wiki/Schema_(genetic_algorithms)","http://en.wikipedia.org/wiki/Length_sche","http://en.wikipedia.org/wiki/Schema_(genetic_algorithms)"],"name":"Schema (genetic algorithms)","categories":["All articles to be merged","All stub articles","Articles to be merged from December 2011","Artificial intelligence stubs","Bioinformatics stubs","Computer science stubs","Genetic algorithms","Genetic programming"],"tag_line":"A schema is a template in computer science used in the field of genetic algorithms that identifies a subset of strings with similarities at certain string positions."}}
,{"_index":"throwtable","_type":"algorithm","_id":"santa-fe-trail-problem","_score":0,"_source":{"description":"The Santa Fe Trail problem is a Genetic programming exercise in which Artificial ants search for food pellets according to a programmed set of instructions. The layout of food pellets in the Santa Fe Trail problem has become a standard for comparing different genetic programming algorithms and solutions.\nOne method for programming and testing algorithms on the Santa Fe Trail problem is by using the NetLogo application. There is at least one case of a student creating a Lego robotic ant to solve the problem.","alt_names":["Santa Fe Trail problem","http://en.wikipedia.org/wiki/Santa_Fe_Trail_problem"],"name":"Santa Fe Trail problem","categories":["Genetic algorithms","Genetic programming"],"tag_line":"The Santa Fe Trail problem is a Genetic programming exercise in which Artificial ants search for food pellets according to a programmed set of instructions."}}
,{"_index":"throwtable","_type":"algorithm","_id":"determination-of-the-day-of-the-week","_score":0,"_source":{"description":"There are various methods to calculate the day of the week for any particular date in the past or future. These methods ultimately rely on algorithms to determine the day of the week for any given date, including those based solely on tables as found in perpetual calendars that require no calculations to be performed by the user. A typical application is to calculate the day of the week on which someone was born or any other specific event occurred.","alt_names":[],"name":"Determination of the day of the week","categories":["CS1 German-language sources (de)","Calendar algorithms","Days of the week","Gregorian calendar","Julian calendar"],"tag_line":"There are various methods to calculate the day of the week for any particular date in the past or future."}}
,{"_index":"throwtable","_type":"algorithm","_id":"md5","_score":0,"_source":{"description":"The MD5 message-digest algorithm is a widely used cryptographic hash function producing a 128-bit (16-byte) hash value, typically expressed in text format as a 32 digit hexadecimal number. MD5 has been utilized in a wide variety of cryptographic applications, and is also commonly used to verify data integrity.\nMD5 was designed by Ronald Rivest in 1991 to replace an earlier hash function, MD4. The source code in RFC 1321 contains a \"by attribution\" RSA license.\nIn 1996 a flaw was found in the design of MD5. While it was not deemed a fatal weakness at the time, cryptographers began recommending the use of other algorithms, such as SHA-1—which has since been found to be vulnerable as well. In 2004 it was shown that MD5 is not collision resistant. As such, MD5 is not suitable for applications like SSL certificates or digital signatures that rely on this property for digital security. Also in 2004 more serious flaws were discovered in MD5, making further use of the algorithm for security purposes questionable; specifically, a group of researchers described how to create a pair of files that share the same MD5 checksum. Further advances were made in breaking MD5 in 2005, 2006, and 2007. In December 2008, a group of researchers used this technique to fake SSL certificate validity. As of 2010, the CMU Software Engineering Institute considers MD5 \"cryptographically broken and unsuitable for further use\", and most U.S. government applications now require the SHA-2 family of hash functions. In 2012, the Flame malware exploited the weaknesses in MD5 to fake a Microsoft digital signature.","alt_names":["MD5 wiki","MD5s","5 Pseudocode","Don't waste your time.","MD5チェックサム","MD5 check sum","hash MD5","Message_Digest_Algorithm_5","материал в Википедии","MD5 collisions","trivial to break","4 Algorithm","المعلومات.","MD5 hash","MD5 checksum","MD5-Hash","reportez-vous ici","known vulnerabilities","file hash","MD5の","MD5 Checksum","d5","Why is md5 still widely used, despite the","的MD5","http://ja.wikipedia.org/wiki/MD5","MD5 hashes","md5","MD5 Hash","w wiki","md5 hash","MD5 - Wikipedia, the free encyclopedia","''checksum'' MD5","'MD5 hash'","( 클릭 )","(Collision Vulnerabilities)","(MD5","(MD5)","(MD5-хеши)","(Message-Digest algorithm)","(Wikipedia - MD5)","(http://de.wikipedia.org/wiki/MD5","(older) MD5 encryption","(열쇠를","**MD5**","*http://it is.*wikipedia.*org/*wiki/MD5","+ info acerca de MD5",", MD",", http://en.wikipedia.org/wiki/MD5",",의 MD5,","- MD5 :","- Md5 :","---> More ( Wikipedia)","-> Leggi l'articolo completo su MD5","->weitere Info zu MD5 auf wikipedia","... of MD5 After a Recent Attack (pdf), RSA","...Wikipedia MD5","...mehr auf Wikipedia über Message Digest Algorithm 5","...more on Wikipedia about MD5",".MD5 checksum file",".md5","1 History and cryptanalysis","1 Przykład","1 Sejarah dan kriptoanalisis","1) itt nézelődj!","128-bit number","2 Efek nyata dari kriptoanalisis","2 Vulnerability","2 pakelta 116,9 laipsniu","2.1 Collision vulnerabilities","2.2 Preimage vulnerability","2.3 Other vulnerabilities","2008, MD5 was denounced by government, banks and","2008年就已被大量破解， 并被政府，各大公司，银行及安全标准单位正式弃用","2^39th operations to generate a collision","3 Algorytm","3 Cryptanalyse","3 Pengujian Integritas","4 Algorithme","4 Algortima","4 Kod źródłowy","4.1 Pseudocode","4.2 Préparation du message","4.3 Boucle principale","5 MD5 hashes","6 Hash-hash MD5","7.1 Implémentations","7.1 Test Vectors","7.2 Cryptanalyse","7f138a09169b250e9dcb378140907378","8.1 Informasi MD5","8.2 Implementasi","8.3 Kerusakan","9.1 Test Vectors","9.1 Test vectors","90′s era technology",": MD",": http://en.wikipedia.org/wiki/MD5","<< click here >>","<MD5 - Wikipedia>","<a href=http://ru.wikipedia.org/wiki/MD5","<http://de.wikipedia.org/wiki/Md5>","@9:'","A resposta aqui","A resposta aquí","A válasz itt","ACAAAAA","About MD5","About MD5 Hashes","Algoritem MD5","Algorithm 5","Algoritma MD5","Algoritmo MD5","Algoritmo MD5 Wikipedia","Algoritmo MD5 en Wikipedia","Algoritmo de encriptación MD5","An MD5 hash is typically expressed as a","An freagra anseo","Analyse-Methode","Ang sagot dito","Article MD5 sur Wikipedia","Article on MD5's","Article sur MD5 sur Wikipédia","Article: MD5, about md5 @ wikipedia.org","Artykuł o MD5","Atbildi šeit","Atsakymas čia","Az MD5 titkosításról itt olvashatsz.","Bővebben az MD5 titkosításról Wikipedián.","C6:C4:ED:86:CB:7B:3B:22","CALG_MD5","CMN versions on Wikipedia","Ce este codul MD5?","Checksum Algorithm","Checksum MD5","Click here if you would like to have","Co to jest md5","Criptografía MD5","Câu trả lời ở đây","DESCARGAR PIAIP V1.19","Das is md5","De wikipedia :","DeWikiPedia:Message-Digest_Algorithm_5","Definición de MD5 más completo","Der Wikipedia-Artikel über MD5","Descripción del algoritmo md5. Empezamos suponiendo que tenemos","Description of MD5","Die Analyse-Methode Im August 2004 fand ein","Die antwoord is hier","Digest Algorithm 5","Digest Algorithm, Message","Digest-MD5","Définition du md5","Efek nyata dari kriptoanalisis","El MD5 en wiki","El artículo de Wikipedia sobre MD5","Erklärung zu MD5","Everything you ever wanted to know but were","Explicacion (un tanto desnutrida) de MD5 en la","F ( X , Y , Z ) = ( X &wedge; Y ) &vee","Failed its digital signature.","Faille dans le MD5","FreeBSD MD5","HASH MD5","HASHVERFAHREN (MD5)","HIER INFO MD5 !","HMAC MD5","HVA MD5","Hash Functions MD5","Hash MD5","Hash-Werte vergessen","Hash-hash MD5","Hashfunktionen MD5","Hashing MD5","Here's more info on it","Herr Gott was ist eigentlich MD5...","Het Wikipedia artikel over MD5","Het antwoord hier","Hier ist es erklÃ¤rt","Hier stehts auch.","Historia de MD5","History and Cryptanalysis, and Vulnerability, in Wikipedia Article","History and cryptanalysis","Hmm ganz sicher?","How its algorithm and pseudo code works ?","How to apply for MD5 - A Message Digest","Ich weiß was MD5 ist ;D","Image:MD5.svg","Implementasi","In 2007 a group of researchers including Arjen","In cryptography, MD5 (Message-Digest algorithm 5) is","Informasi MD5","Infos zu MD5 / Was ist MD5?","Is MD5 secure?","It-tweġiba hawn","Jawaban di sini","Jawabannya di sini","Jawapan di sini","Kerusakan","Klicken Sie hier wenn Sie detailiertere Informationen über","Klik disini gan","Kontrolinė suma MD5","L'acronimo MD5 (Message Digest algorithm 5) indica","L'algoritmo MD5","L'articolo di Wikipedia su MD5","La resposta aquí","La respuesta aquí","La somme md5","Le Premier lien","Le hachage M","Le hash Md5 c'est quoi ?","Learn about MD5>>>","Lees meer over MD5 Hier","Leia mais sobre MD5 aqui","Lektüre für Interessierte","Lesen dieser","Link to documentation on MD5","Linkt: Wickipedia","Läs mer om MD5 på denna sida","MD 5 - Wikipedia","MD algorithm series","MD-5 and their collisions","MD-5-Checksumme","MD4-5","MD5","MD5 (Einweg Verschlüsselung)","MD5 (Message Digest 5","MD5 (Message Digest 5)","MD5 (Message Digest Algorithm 5)","MD5 (Message Digest Algorithm)","MD5 (Message Digest algorithm 5)","MD5 (Message-Digest algorithm 5)","MD5 (Message-Digest algorithm 5) checksums","MD5 (Message-Digest algorithm 5) cryptographics hash","MD5 (Message-Digest thuật toán 5)","MD5 (Wikipedia)","MD5 (eng.)","MD5 (external link)","MD5 (http://en.wikipedia.org/wiki/Md5)","MD5 (pl.)","MD5 (weblink)","MD5 (wiki)","MD5 (wikipedia)","MD5 ) @ Wikipedia","MD5 -","MD5 - ????,???????","MD5 - Prüfsumme","MD5 - Prüfsummen","MD5 - Vikipedi","MD5 - Viquipèdia","MD5 - Wikip?dia","MD5 - Wikipedia","MD5 - Wikipedia :: The free encyclopedia","MD5 - Wikipedia bahasa Indonesia, ensiklopedia bebas","MD5 - Wikipedia, The Free Encyclopedia","MD5 - Wikipedia, den frie encyklopædi","MD5 - Wikipedia, la enciclopedia libre","MD5 - Wikipedia, the free","MD5 - Wikipedia, the free e...","MD5 - Wikipedia, the free encyclopedia - Wikipedia","MD5 - Wikipedia, the free encyclopedia - Wikipedia wikipedia.org","MD5 - Wikipedia, the free encyclopedia | MD5 Hash Dcrypter","MD5 - Wikipedia, the free encyclopediaThe MD5 Message","MD5 - Wikipedia@","MD5 - Wikipedie, otevřená encyklopedie","MD5 - Wikipédia","MD5 - Wikipédia, a enciclopédia livre","MD5 - Примеры использования","MD5 - วิกิพีเดีย","MD5 - 維基百科，自由的百科全書","MD5 - 维基百科，自由的百科全书","MD5 - 위키백과","MD5 - 위키백과, 우리 모두의 백과사전","MD5 128 bit hash","MD5 ? Wikipedia","MD5 ? Wikipedia, wolna encyklopedia","MD5 @ Wikipedia","MD5 @ wiki","MD5 @ wikipedia","MD5 Algorithm","MD5 Algorithm on Wikipedia:","MD5 Algorithmus","MD5 Article","MD5 CRC checksumok","MD5 Checksummen","MD5 Cryptographic Hash","MD5 Cryptographic Hash Function","MD5 Digest","MD5 Encrypted Key","MD5 Encryption","MD5 HASHES","MD5 Hash Algorithm","MD5 Hash Algorithms","MD5 Hash Algorythm","MD5 Hash Code","MD5 Hash Database","MD5 Hash Werte","MD5 Hash-Algorithmus","MD5 Hash?","MD5 Here","MD5 In Wikipedia","MD5 Information (Wikipedia)","MD5 Message","MD5 Message Digest","MD5 Message Digest Algorithm","MD5 Message Digest Algorithm 5","MD5 Message Digest algorithm","MD5 Message-Digest Algorithm (RFC 1321)","MD5 Message-Digest Algorithmus","MD5 Prüfsumme","MD5 Prüfsumme:","MD5 Pseudocode","MD5 Related Content:","MD5 SRSLY","MD5 Schlüssel","MD5 Schlüßel","MD5 Schwachstellen","MD5 Sjekksumalgoritme","MD5 Standard","MD5 Summe","MD5 Summen","MD5 Utility","MD5 Verletzlichkeit","MD5 Verschlüsselung","MD5 Vulnerabilities","MD5 Wiki","MD5 Wiki Entry","MD5 Wikipedia","MD5 Wikipedia Definition","MD5 Wikipedia The Free Encyclopedia","MD5 Wikipedia page","MD5 Wikipedia the free encyclopedia","MD5 Wikipedia the free encyclopedia - result","MD5 Wikipedia the free encyclopedia Wikipedia","MD5 Wikipedia 정의","MD5 Wikipedia, the free encyclopedia","MD5 [BG]","MD5 [EN]","MD5 [KLIK]","MD5 [Wikipedia]","MD5 [Регистрация не отнимет много времени]","MD5 a 128 bit","MD5 a la Wikipedia","MD5 algorithm","MD5 algoritması için pseudocode - Wikipedia","MD5 algoritme","MD5 algoritmi","MD5 algoritmom","MD5 algoritmą","MD5 and SHA-1 not recommended for security","MD5 and it's vulnerabilities","MD5 article on Wikipedia","MD5 at Wikipedia","MD5 attack of last year","MD5 bei Wikipedia","MD5 beveiliging","MD5 botsingen","MD5 can you found in Wikipedia","MD5 check","MD5 check sums","MD5 checksu","MD5 checksumját","MD5 checksumming","MD5 cheksum","MD5 code","MD5 codes","MD5 codierung","MD5 collision","MD5 collision attack","MD5 collision vulnerability (wikipedia)","MD5 cracker","MD5 cryptographic algorithms","MD5 cryptographic hash","MD5 cryptographic hash function","MD5 cryptographic hashing","MD5 cryptography","MD5 de 128 bits","MD5 digest","MD5 digest algorithm","MD5 digest function","MD5 digest hash","MD5 digests","MD5 en Wihkipedia","MD5 en la Wikipedia","MD5 en la wikipedia","MD5 encription","MD5 encrypted","MD5 encryptie","MD5 encryption","MD5 encryption algorithm","MD5 et Wikipédia","MD5 files","MD5 format","MD5 from Wikipedia","MD5 har också säkerhetsproblem","MD5 has been employed in a wide variety","MD5 has well known weaknesses","MD5 hash algorithm","MD5 hash algorithms","MD5 hash code","MD5 hash format","MD5 hash format.","MD5 hash function","MD5 hash function.","MD5 hash lenyomatát","MD5 hash marks","MD5 hash protection","MD5 hash string","MD5 hash value","MD5 hash-code","MD5 hash.","MD5 hash?","MD5 hashe","MD5 hashed","MD5 hashed passwords","MD5 hashes are always 128 bits long","MD5 hashing","MD5 hashing algorithm","MD5 hashing function","MD5 hashkódját","MD5 hashs","MD5 haš","MD5 hašů","MD5 here","MD5 heše","MD5 in Wikipedia","MD5 in particular","MD5 in wiki","MD5 info, if you're curious","MD5 is a cryptologial hash algorithm","MD5 is a message digest","MD5 is a one way encryption hash","MD5 is insecure","MD5 is no more secure","MD5 is not long-term secure","MD5 is not secure anymore","MD5 is one way hash","MD5 is really badly broken. Good to know","MD5 is unusable","MD5 is vulnerable to collisions","MD5 isn't very secure","MD5 ist ein Hashwert","MD5 kollisioner","MD5 kwetsbaarheden","MD5 kwetsbaarheid","MD5 lukę","MD5 message-digest algorithm","MD5 n'est plus très sûr","MD5 na české Wikipedii","MD5 on Wikipedia","MD5 on Wikipedia.org","MD5 on the Wikipedia website","MD5 on wikipedia","MD5 on wikipedia.org","MD5 otisk","MD5 otisku","MD5 overview","MD5 p","MD5 patikros raktas","MD5 picadillo","MD5 pseudocode","MD5 readme","MD5 rekenmethode","MD5 reprezentacija","MD5 santraukos algoritmu","MD5 security","MD5 sequence","MD5 signature","MD5 standard","MD5 sårbarhed","MD5 sårbarheder","MD5 technology","MD5 text vector","MD5 tiivistettä","MD5 topic on Wikipedia","MD5 transformation algorithm","MD5 translator","MD5 values in Wikipedia","MD5 vulnerabilidad","MD5 vulnerabilities","MD5 vulnerability","MD5 vulnerabilità","MD5 was ist das?","MD5 wikipedia","MD5 zranitelnost","MD5 zranitelnosti","MD5 |","MD5 Примеры использования","MD5 вЂ” Р'РёРєРёРїРµРґРёСЏ","MD5 описание","MD5 столкновений","MD5 уязвимостей","MD5 уязвимости","MD5 хеш","MD5 من","MD5 یعنی چه؟","MD5 भेद्यता","MD5 – Wikipedia","MD5 – Wikipedia ti?ng Vi?t","MD5 – Wikipedia tiếng Việt","MD5 – Wikipedia, the free encyclopedia","MD5 – Wikipedia, wolna encyklopedia","MD5 – Wikipedia.org","MD5 – Wikipédia, a enciclopédia livre","MD5 – ויקיפדיה","MD5 — ?????????","MD5 — Википедия","MD5 “should be considered cryptographically broken","MD5 チェックサム","MD5 出典: フリー百科事典『ウィキペディア（Wikipedia）』","MD5 可以产生碰撞","MD5 安全性","MD5 安全性- Wikipedia","MD5 维基百科","MD5 방식","MD5 체크섬","MD5 해시","MD5 해시를","MD5!?","MD5(Message Digest Algorithm 5)","MD5(Message-Digest Algorithm 5)","MD5(Message-Digest algorithm 5)","MD5(un de los algoritmos de reducción criptográficos","MD5(ハッシュ)","MD5)","MD5,","MD5, a","MD5-","MD5- Prüfsummen","MD5-Algorithmus","MD5-Algorithmus als Pseudo-Code","MD5-Algorithmusses","MD5-Challenge","MD5-CheckSum","MD5-Checksumme","MD5-Checksummen","MD5-Checksummern","MD5-Filter","MD5-Filters","MD5-Fingerabdruck","MD5-Format","MD5-Hash bei Wikipedia)","MD5-Hash-Code","MD5-Hash-Funktion","MD5-Hash-Wert","MD5-Hashes","MD5-Hashs","MD5-Hashsumme","MD5-Hashwert","MD5-Hashwerte","MD5-Hashwertes","MD5-Kodierung","MD5-Prüfschlüssel","MD5-Prüfsumme","MD5-Prüfsummen","MD5-Summe","MD5-Summen","MD5-Verfahren","MD5-Verschlüsselung","MD5-Wert","MD5-Wikipedia","MD5-algoritme","MD5-algoritme als pseudo-code","MD5-algoritmen","MD5-algoritmilla","MD5-checksum","MD5-checksums","MD5-encrypted","MD5-filter","MD5-hash","MD5-kodiert","MD5-kryptaus","MD5-kryptering","MD5-method","MD5-salausta","MD5-sum","MD5-summaa","MD5-summen","MD5-und","MD5-verschlüsselt","MD5-verschlüsselte","MD5-ös hashben","MD5-подписи","MD5-хеш","MD5-хеша","MD5-хэш","MD5-хэша","MD5-хэши","MD5-ի","MD5.","MD5: MD5 hashes","MD5: Коллизии","MD5=FAIL","MD5?","MD5Hash:","MD5MD5","MD5codering","MD5dir","MD5とは","MD5とは?","MD5とは→","MD5とは？ (Wikipediaへのリンク)","MD5とは＠wikipedia","MD5について","MD5について（Wikipedia）","MD5について：Wikipedia","MD5のWikiのページ","MD5のコリジョン","MD5の脆弱性","MD5の脆弱性を","MD5の衝突","MD5は","MD5を","MD5を使用する","MD5アルゴリズム","MD5コード","MD5ハッシュを","MD5ハッシュ値","MD5ハッシュ値が同じ二つのファイルを作成することなどは可能だが、あるファイルと同じMD5ハッシュ値を持つファイルを作るのはまだ難しいらしい","MD5哈希","MD5哈希值","MD5消息摘要算法","MD5的","MD5的安全漏洞","MD5的漏洞","MD5的碰撞","MD5碼","MD5碼 Codice MD5","MD5碼 MD5 code","MD5碼 MD5 código","MD5碼 MD5 kod","MD5碼 MD5 kodu","MD5碼 MD5 kód","MD5碼 MD5 yards","MD5碼 MD5 κωδικός","MD5碼 MD5 код","MD5碼 MD5 कोड","MD5碼 MD5-Code","MD5碼 MD5-code","MD5碼 MD5のヤード","MD5碼 MD5码","MD5碼 code MD5","MD5碼 código MD5","MD5碼 رمز MD5","MD5碼 의 MD5 코드","MD5算法","MD5編碼","MD5维基百科，自由的百科全书","MD5编码","MD5에 대한 자세한 정보","MD5：http://en.wikipedia.org/wiki/Md5","MD5ｺｰﾄﾞ","MD5ﾁｪｯｸｻﾑ","MD５","MESSAGE DIGEST","Mas informacion sobre MD5","Md5","Md5 - Collision_vulnerabilities","Md5 - Wikipedia","Md5 - Wikipedia, The Free Encyclopedia","Md5 article","Md5 bei Wikipedia","Md5 bei der wikipedia","Md5 hash","Md5#Practical_effect_of_cryptanalysis","Md5- hashia","Meer info over MD5","Meer informatie over MD5.","Mehr über MD5 lernen...","Message Digest 5","Message Digest 5 (MD5)","Message Digest 5 (MD5) algorithm","Message Digest Algorithm","Message Digest Algorithm 5","Message Digest Algorithm 5 (MD5)","Message Digest Algorithm 5 - Wikipedia","Message Digest Algorithm 5 bei Wikipedia","Message Digest Algorithm 5 – Wikipedia","Message Digest Algorithm 5 › Sicherheitsüberlegungen – Wikipedia","Message Digest Version 5","Message Digest algorithm 5","Message Digest algorithms","Message Digest v. 5","Message digest algorithms","Message-Digest 5 (MD5)","Message-Digest Algorithm 5","Message-Digest Algorithm 5 (MD5)","Message-Digest Algorithm 5 (MD5) [Wikipedia, die freie","Message-Digest Algorithm 5 (deutsche Wikipedia)","Message-Digest Algorithm 5 - Sicherheitsüberlegungen","Message-Digest Algorithm 5 - Wikipedia","Message-Digest Algorithm 5 ? Wikipedia","Message-Digest Algorithm 5 Wikipedia","Message-Digest Algorithm 5 bei Wikipedia","Message-Digest Algorithm 5 â€“ Wikipedia","Message-Digest Algorithm 5 – Wikipedia","Message-Digest Algorithm 5? Wikipedia","Message-Digest Algorithm-5","Message-Digest algorithm","Message-Digest algorithm 5","Message-Digest algorithm 5 (MD5)","Message-Digest algorithm 5? Wikipedia","Message-Digest-Algorithm 5","Message-Digest_Algorithm_5","More Information On MD5","More MD5 info","More about MD5","More about MD5...","More about MD5…","More info on MD5","More on how to check an MD5 hash","Más info sobre el MD5 en la Wikipedia","Na pewno nie ma zabezpieczenia nie do złamania","O md5 po angielsku w Wikipedii","O md5 po polsku w Wikipedii","O que é MD5?","O que é MD5???","Odgovor ovdje","Odgovor tukaj","Odpoveď tu","Odpověď na tuto otázku","Oh, here's a Wiki on it, read the","Om MD5 på Wikipedia","Om Md5 på Wikipedia","One-way hached version.","Opis MD5 na Wikipedii","Pengujian Integritas","Please read up on MD5, you seem to","Plus d'info sur Wikipédia.","Poczytaj wikipedie","Podatność na ataki MD-5","Pop on over to Wikipedia","Pour en savoir plus sur le système MD5","Preimage Vulnerabilities","Pseudo-Kollisionen","Página Wiki del MD5","Përgjigja këtu","Qué es MD5","RL http://en.wikipedia.org/wiki/MD5.","RSA-MD5","Read More md5 wikipedia the free encyclopedia","Read more about MD5 >>>","Read this you insignificant padawan .","Refer For More","Referência para algoritmo MD5.","Răspunsul aici","SHA-1/MD5","Saiba mais!!!","Seguridad y Aplicaciones","Sehr ausführliche Erklärung.","Sejarah dan kriptoanalisis","Si, è possibile","Sicherheitsüberlegungen","Skrót Wiadomości wersja 5 - MD5","Somma MD5","Somme MD5","Source Wikipedia.org Arcticle - MD5","Specified in RFC 1321, MD5 has been employed","Suma md5","Sumy MD5","Svaret her","Svaret här","Svarið hér","Teoria sobre la encriptacion MD5-(LINK)","The MD5 Message-Digest Algorithm is a widely","The MD5 hash is a 32 character string","The MD5 message digest algorithm","The Wikipedia article on MD5","The Wikipeida","The security of the MD5 hash function is","To learn more about MD5, visit Wikipedia.org","Tutaj odpowiedź","US-CERT of the U. S. Department of Homeland","Und zwar für gewöhnlich diese Variante: MD5","VER MAS SOBRE MD5","Vastaus tässä","Vastus siin","View MD5 on Wikipedia","Vikipedi'deki MD5","Vikipedia MD5","Visit MD5 page on the wikipedia.org.","Voce enciclopedica di MD5","Voir MD5 sur Wikipedia","Vulnérabilité de MD5 aux collisions sur Wikipedia en","WIKI - MD5","WIKI.de/MD5&sicherheitsüberlegungen","WIKIPEDIAEINTRAG","Was ist MD5","Was ist MD5?","Was ist MD5? - Wikipedia","Was ist ein MD5 Check","Was ist ein MD5-Hash?","Was ist md5","Weitere Informationen zu MD5 bei Wikipedia","Weitere Informationen zu MD5 »","What an MD5 is","What does it means? Br/portuguese","What does/means MD5?Eng","What is MD5 ?","What is MD5 CheckSum?","What is MD5?","What is MD5? (Wikipedia)","What is algorithm of MD5?","What's an MD5 Sum?","Whats MD5?","Why you shouldn't really use md5","Wi-ki по MD5","Wiikipedia.org/wiki/MD5","Wiki - MD5","Wiki > MD5","Wiki MD5","Wiki MD5 Page","Wiki Mandriva : Pour en savoir plus...","Wiki- > MD5","Wiki.MD5","Wiki:MD5 Hashfunktion","WikiPedia entry on MD5","WikiPedia fr","WikiPedia.ja:MD5","WikiPedia: MD5","WikiPedia:MD5","Wikipedai said","Wikipedia (MD5)","Wikipedia - MD5","Wikipedia - Md5 kryptering","Wikipedia - Message Digest Algorithm 5","Wikipedia - Message Digest Algorithm 5 MD5","Wikipedia : MD5","Wikipedia Article on MD5","Wikipedia English - md5","Wikipedia MD5","Wikipedia MD5 Hash","Wikipedia MD5 def","Wikipedia MD5 entry","Wikipedia MD5.","Wikipedia Message Digest Algorithm 5","Wikipedia about MD5","Wikipedia article ''MD5''","Wikipedia article MD5","Wikipedia article MD5 hash","Wikipedia article Md5","Wikipedia article Message-Digest algorithm","Wikipedia article about MD5","Wikipedia article on MD5","Wikipedia artikel MD5","Wikipedia entry for MD5","Wikipedia entry on MD5","Wikipedia has some psuedocode for it","Wikipedia information on MD5 hash","Wikipedia l'articolo MD5","Wikipedia l'articolo Md5","Wikipedia o MD5","Wikipedia om MD5.","Wikipedia on MD5","Wikipedia on MD5 Security","Wikipedia on the MD5 hash function","Wikipedia on the Message-Digest algorithm 5","Wikipedia page for MD5","Wikipedia page on MD5","Wikipedia pseudo-code for MD5","Wikipedia section [MD5] Security","Wikipedia zu md5","Wikipedia zu: MD5 - Sicherheitsüberlegungen","Wikipedia Ã¼ber MD5","Wikipedia Ãžber MD5","Wikipedia über MD5","Wikipedia أ¼ber MD5","Wikipedia – MD5","Wikipedia 眉ber MD5","Wikipedia's MD5 article","Wikipedia's MD5 page.","Wikipedia's article on MD5","Wikipedia's artikkel om MD5","Wikipedia's md5 page.","Wikipedia, Message Digest Algorithm 5, 23. März 2006","Wikipedia-Artikel MD5","Wikipedia-Artikel Md5","Wikipedia-Artikel Message Digest Algorithm 5","Wikipedia-Artikel Message-Digest Algorithm 5","Wikipedia-Eintrag zu MD5","Wikipedia-MD5","Wikipedia-Pseudoquellcode","Wikipedia-Seite zu 'MD5'","Wikipedia-Seite zu 'Message Digest Algorithm 5'","Wikipedia-Seite zu 'Message-Digest Algorithm 5'","Wikipedia-artiklen om MD5","Wikipedia/MD5","Wikipedia: MD5","Wikipedia: MD5 - Nachteile","Wikipedia: Message Digest Algorithm 5","Wikipedia: What is MD5","Wikipedia: md5","Wikipedia:MD5","Wikipedia:Message-Digest Algorithm 5","Wikipedia:md5()","Wikipediaで「MD5」を調べる","Wikipediaで「Md5sum」を調べる","WikipediaのMD5に関するページ","WikipediaのMD5のページ","Wikipediaの記事では、","Wikipediaドイツ版 - md5","Wikipediaフランス語版 - md5","Wikipedia中国語版 - md5","Wikipedia英語版 - md5","Wikipédia - MD5","Wikipédia - MD5 (angol)","Wikipédia - MD5 (magyar)","Wikipédia artigo MD5","Wikipédia artigo Md5","Wikipédia em Inglês, com código fonte","Wikipédia: MD5","You read the entire original article about MD5","ZQ5 une bpxfå fäxreurgfceboyrz","Zde je výpis","Zu MD5 auf Wikipedia","[for the uneducated]","[modifier] MD5. MD5 (Message Digest 5) est une","]md5 hash","^ Message-Digest Algorithm 5","a MD5.","a836c0108b2847f82928d5fc9bfdb79b","about MD5","about MD5 algorithm","about md5","algorithm that already conveniently produces 16-byte hashes","algorithme MD5","algoritmen MD5","algoritmo MD5","algoritmo MD5 come pseudo codice","algoritmo MD5 como pseudo-código","algoritmo de encriptacion","algoritmo de encriptacion MD5","algoritmo md5","algoritmo no próprio wikipedia","algoritmo univoco","algoritmului MD5","algorytm MD5","algorytmem MD5","alphanumeric string","ambito informatico","an MD5 message digest","an explanation of MD5","analytisch vorgegangen","and have, in the case of the MD5","ao melhor estilo MD5","aplicaciones MD5","aqui tem uma explicação da wikipedia","ar.wikipedia.org/wik...%AF%D9%8A5","ar:إم دي5","article MD5","article on MD5","articolul corespunzator","articolul despre MD5","artigo da Wikipédia MD5","artículo de Wikipedia Algoritmo MD5","artículo de Wikipedia MD5","as an MD5 hash","at least with MD5","attaques cryptographiques réussies contre MD5","avoid MD5","banale per rompere","banalne do złamania","bei Wikipedia nachlesen (beispielhaft für MD5)","bg:MD5","bij de kleinste bit die ontbreekt/anders is","bit.ly/ifY2ca","broken MD5 hash function","broken for a while","broken secure hash function","ca:MD5","ce inseamna?","check integrity","check somme MD5","check the md5 sum to make sure it","checksum MD5","chequeo de md5","chiffrement MD5","cifrado md5","clave MD5","co je MD5","co to jest md5 (wikipedia)","codifica MD5","codificação MD5","coliziuni în algoritm","collision vulnerabilities","collision weaknesses have been found in MD5","collisions MD5","collisions in MD5","comprobacion md5","compute a checksum for your data archive","considered broken","continue reading http://en.wikipedia.org/wiki/MD5","criptografia MD5","cryptage de données md5","cryptage md5","cryptographic hash function.","cs:Message-Digest algorithm","các giá trị băm mật khẩu","código MD5","código md5. ...","d5 y","da:MD5","data encryption doodad","de.wikipedia.org/...Message-Digest_Algorithm_5","de.wikipedia.org/wik...e-Digest_Algorithm_5","de.wikipedia.org/wiki/M...rheits.C3.BCberlegungen","de.wikipedia.org/wiki/MD5","de.wikipedia.org/wiki/Md5","de.wikipedia.org/wiki/Message-Digest_Algorithm_5","de.wikipedia.org/wiki/Message_Diges...","de.wikipedia.org/wiki/Message_Digest_Algorithm_5","de:Message-Digest Algorithm 5","definición de MD5 en Wikipedia","depreciated algorithm.","der MD5 Checksumme","des hachages MD5,","des valeurs de hachage de mot de passe","diese Erklärung in www.wikipedia.de","digest MD5","documented vulnerabilities","dostatečně silné","double MD5 hashing","décrit sur Wikipédia","effectively broken","el algoritmo MD5","el hachís MD5","el hash MD5 de la misma","el md5","empreinte MD5","empreinte md5","empreintes MD5","en.wikipedia.org/ wiki/MD5","en.wikipedia.org/MD5","en.wikipedia.org/wiki/MD5","en.wikipedia.org/wiki/MD5 :","en.wikipedia.org/wiki/MD5#Collision_vulnerability","en.wikipedia.org/wiki/MD5#History_and_cryptanalysis","en.wikipedia.org/wiki/MD5#Security","en.wikipedia.org/wiki/MD5#Vulnerability","en.wikipedia.org/wiki/Md5","en.wikipedia.org/wiki/Md5#Vulnerability","en.wikipedia.org/wiki/Md5.","en:MD5","encriptación MD5","encryptage MD5","eo:MD5","es MD","es.wikipedia.org/wiki/MD5","es:MD5","eu:MD5","exactly it is","extremely broken","fa:امدی۵","fantastic info","fi:MD5","filtre-MD5","filtro-MD5","firme MD5","flawed MD5 algorithm","for more Information about MD5 Hash´s....","format md5","fr.wikipedia.org/wiki/MD5","fr.wikipedia.org/wiki/Md5","fr:MD5","fringe cases.","fuenteeee","funkcijo MD5","generalmente 32 caratteri","generate collisions","generating an MD5 collision","gewoonlijk 32 tekens lang zijn","grâce à un code spécifique","hachage MD5","hachange MD5","had it's day","has to do with finding two prefixes that","hash MD-5","hash MD5.","hash function (MD5)","hash function is not secure","hash md5","hash password values","hash valores de contraseña","hash ค่ารหัสผ่าน","hash-MD5","hash-exploit","hash/MD5","hashage MD5","hashe MD5","hashes MD5","hashes md5 reversibles","hashfile (hash MD5) WIKI","hashfunktionen MD5","hashing MD5","hashs MD5","hashu md5","hashujacego","hasz sum","he:MD5","here: Wiki","het lezen van deze","hier anschauen...","hier findest du weitere infos","hier klicken für mehr infos","hmac_md5","hoeveel werk*","hr:MD5","http :// en . wikipedia. org /wiki/MD5","http://ar.wikipedia.org/wiki/MD5","http://ca.wikipedia.org/wiki/MD5","http://ca.wikipedia.org/wiki/Md5","http://cs.wikipedia.org/wiki/MD4","http://cs.wikipedia.org/wiki/MD5","http://cs.wikipedia.org/wiki/MD5...","http://cs.wikipedia.org/wiki/Message-Digest_algorithm","http://da.wikipedia.org/wiki/MD5","http://de.wikiped...Pseudocode","http://de.wikipedia....g_der_MD5-Summe","http://de.wikipedia.or...essage-Digest_Algorithm_5","http://de.wikipedia.org/.../Message-Digest_Algorithm_5","http://de.wikipedia.org/wiki/M...gorithm_5#","http://de.wikipedia.org/wiki/M...lgorithm_5","http://de.wikipedia.org/wiki/MD 5","http://de.wikipedia.org/wiki/MD5","http://de.wikipedia.org/wiki/MD5#Algorithmus","http://de.wikipedia.org/wiki/MD5#Die_Analyse-Methode","http://de.wikipedia.org/wiki/MD5#Die_Analyse−Methode","http://de.wikipedia.org/wiki/MD5#MD5-Hashes","http://de.wikipedia.org/wiki/MD5#MD5−Hashes","http://de.wikipedia.org/wiki/MD5#Rainbow-Tables","http://de.wikipedia.org/wiki/MD5#Sic....BCberlegungen","http://de.wikipedia.org/wiki/MD5#Sicher ... erlegungen","http://de.wikipedia.org/wiki/MD5#Sicherheits.C3","http://de.wikipedia.org/wiki/MD5#Verwend…f","http://de.wikipedia.org/wiki/Md5","http://de.wikipedia.org/wiki/Md5#.C3.9C","http://de.wikipedia.org/wiki/Md5#Algorithmus","http://de.wikipedia.org/wiki/Md5#Die_Analyse-Methode","http://de.wikipedia.org/wiki/Md5#Die_Br ... ce","http://de.wikipedia.org/wiki/Md5#MD5-Hashes","http://de.wikipedia.org/wiki/Md5#Rainbow-Tables","http://de.wikipedia.org/wiki/Md5#Regenbogentabellen","http://de.wikipedia.org/wiki/Md5#Sic....BCberlegungen","http://de.wikipedia.org/wiki/Md5#Sicher ... erlegungen","http://de.wikipedia.org/wiki/Md5#Sicherhei...3","http://de.wikipedia.org/wiki/Md5#Sicherheits.C3","http://de.wikipedia.org/wiki/Md5#Ver....C3","http://de.wikipedia.org/wiki/Md5#Verwen ... BCgbarkeit","http://de.wikipedia.org/wiki/Md5,","http://de.wikipedia.org/wiki/Me ssage-Digest_Algorithm_5","http://de.wikipedia.org/wiki/Mess age-Digest_Algorithm_5","http://de.wikipedia.org/wiki/Messag","http://de.wikipedia.org/wiki/Message-Dige ...","http://de.wikipedia.org/wiki/Message-DigestAlgorithm5","http://de.wikipedia.org/wiki/Message-Digest_Algori...","http://de.wikipedia.org/wiki/Message-Digest_Algorith...","http://de.wikipedia.org/wiki/Message-Digest_Algorithm_5","http://de.wikipedia.org/wiki/Message-Digest_Algorithm_5#Algorithmus","http://de.wikipedia.org/wiki/Message-Digest_Algorithm_5#Die_Analysemethode","http://de.wikipedia.org/wiki/Message-Digest_Algorithm_5#Pseudocode","http://de.wikipedia.org/wiki/Message-Digest_Algorithm_5#Sicherheits","http://de.wikipedia.org/wiki/Message-Digest_Algorithm_5.","http://de.wikipedia.org/wiki/Message-Digest_Algorithm_5]Message","http://de.wikipedia.org/wiki/Message-Dig…3","http://de.wikipedia.org/wiki/Message-Dig…hm_5","http://de.wikipedia.org/wiki/Message....BCberlegungen","http://de.wikipedia.org/wiki/Message...Rainbow-Tables","http://de.wikipedia.org/wiki/Message..._5#Algorithmus","http://de.wikipedia.org/wiki/Message..._der_MD5-Summe","http://de.wikipedia.org/wiki/Message...m_5#MD5","http://de.wikipedia.org/wiki/Message...m_5#Pseudocode","http://de.wikipedia.org/wiki/MessageDigest_Algorithm_5","http://de.wikipedia.org/wiki/Message_Di ... bow-Tables","http://de.wikipedia.org/wiki/Message_Diges...#Rainbow-Tables","http://de.wikipedia.org/wiki/Message_Digest_Algorithm_5","http://de.wikipedia.org/wiki/Message−Digest_Algorithm_5","http://de.wikipedia.org/wiki/md5.","http://en.wikiped...g/wiki/MD5","http://en.wikipedia..../MD5#Pseudocode","http://en.wikipedia....5#Vulnerability","http://en.wikipedia....i/MD5#Algorithm","http://en.wikipedia....i/Md5#Algorithm","http://en.wikipedia...ki/MD5#Vulnerability","http://en.wikipedia.org/w iki/MD5","http://en.wikipedia.org/w iki/MD5#Algorithm","http://en.wikipedia.org/w iki/MD5#External_links","http://en.wikipedia.org/w iki/MD5#References","http://en.wikipedia.org/w iki/MD5#Vulnerability","http://en.wikipedia.org/w iki/MD5#cite_note","http://en.wikipedia.org/w iki/MD5_hash","http://en.wikipedia.org/w iki/Md5","http://en.wikipedia.org/wiki/...nerability","http://en.wikipedia.org/wiki/M D5","http://en.wikipedia.org/wiki/MD5","http://en.wikipedia.org/wiki/MD5 # Col .. _vulnerability","http://en.wikipedia.org/wiki/MD5 # Col. .. _vulnerability","http://en.wikipedia.org/wiki/MD5 # Pseudocode","http://en.wikipedia.org/wiki/MD5 # Pseudocódigo","http://en.wikipedia.org/wiki/MD5 # Pseudokód","http://en.wikipedia.org/wiki/MD5 # colonel .. _vulnerability","http://en.wikipedia.org/wiki/MD5 # kol. .. _vulnerability","http://en.wikipedia.org/wiki/MD5 # pseudocode","http://en.wikipedia.org/wiki/MD5 # pseudokode","http://en.wikipedia.org/wiki/MD5 # Đại tá","http://en.wikipedia.org/wiki/MD5 # συνταγματάρχης .. _vulnerability","http://en.wikipedia.org/wiki/MD5 # Псевдокод","http://en.wikipedia.org/wiki/MD5 # полк. .. _vulnerability","http://en.wikipedia.org/wiki/MD5 # полковник .. _vulnerability","http://en.wikipedia.org/wiki/MD5 # سرهنگ.. _vulnerability","http://en.wikipedia.org/wiki/MD5 f","http://en.wikipedia.org/wiki/MD5#Algorithm","http://en.wikipedia.org/wiki/MD5#Algorit…","http://en.wikipedia.org/wiki/MD5#Applications","http://en.wikipedia.org/wiki/MD5#Applica…","http://en.wikipedia.org/wiki/MD5#Co...vulnerabilities","http://en.wikipedia.org/wiki/MD5#Col..._vulnerability","http://en.wikipedia.org/wiki/MD5#Col...ulnerabilities","http://en.wikipedia.org/wiki/MD5#Collis ... rabilities","http://en.wikipedia.org/wiki/MD5#Collisi...rabilities","http://en.wikipedia.org/wiki/MD5#Collision_vulnerabilities","http://en.wikipedia.org/wiki/MD5#Collision_vulnerability","http://en.wikipedia.org/wiki/MD5#Collisions","http://en.wikipedia.org/wiki/MD5#External_links","http://en.wikipedia.org/wiki/MD5#His..._crypt","http://en.wikipedia.org/wiki/MD5#His..._cryptanalysis","http://en.wikipedia.org/wiki/MD5#History_and_cryptanalysis","http://en.wikipedia.org/wiki/MD5#MD5_hashes","http://en.wikipedia.org/wiki/MD5#Other_vulnerabilities","http://en.wikipedia.org/wiki/MD5#Preimage_vulnerability","http://en.wikipedia.org/wiki/MD5#Pseudocode","http://en.wikipedia.org/wiki/MD5#Pseudocode>http","http://en.wikipedia.org/wiki/MD5#Security","http://en.wikipedia.org/wiki/MD5#Security)*","http://en.wikipedia.org/wiki/MD5#Security>","http://en.wikipedia.org/wiki/MD5#Security],","http://en.wikipedia.org/wiki/MD5#Security}","http://en.wikipedia.org/wiki/MD5#Vulnerability","http://en.wikipedia.org/wiki/MD5#Web_based_MD5_Crackers","http://en.wikipedia.org/wiki/MD5#Web_based_tools","http://en.wikipedia.org/wiki/MD5#_note-5","http://en.wikipedia.org/wiki/MD5#cite_note-1","http://en.wikipedia.org/wiki/MD5#cite_note-4","http://en.wikipedia.org/wiki/MD5#cite_note-7","http://en.wikipedia.org/wiki/MD5#cite_note-8","http://en.wikipedia.org/wiki/MD5#cite_note-autogenerated1","http://en.wikipedia.org/wiki/MD5#cite_note-autogenerated2","http://en.wikipedia.org/wiki/MD5#cite_note-browserflaw","http://en.wikipedia.org/wiki/MD5#cite_note-sslHarmful","http://en.wikipedia.org/wiki/MD5#hashes","http://en.wikipedia.org/wiki/MD5)","http://en.wikipedia.org/wiki/MD5.","http://en.wikipedia.org/wiki/MD5MD5","http://en.wikipedia.org/wiki/MD5_hash","http://en.wikipedia.org/wiki/MD5＃上校.. _vulnerability","http://en.wikipedia.org/wiki/MD5＃伪代码","http://en.wikipedia.org/wiki/MD5＃大佐.. _vulnerability","http://en.wikipedia.org/wiki/Md5","http://en.wikipedia.org/wiki/Md5 # Vulnerability","http://en.wikipedia.org/wiki/Md5 # saugumo","http://en.wikipedia.org/wiki/Md5 # безпеки","http://en.wikipedia.org/wiki/Md5#Algorith m","http://en.wikipedia.org/wiki/Md5#Algorithm","http://en.wikipedia.org/wiki/Md5#Applications","http://en.wikipedia.org/wiki/Md5#Applica…","http://en.wikipedia.org/wiki/Md5#Col...ulnerabilities","http://en.wikipedia.org/wiki/Md5#Collision_vulnerabilities","http://en.wikipedia.org/wiki/Md5#Collisions","http://en.wikipedia.org/wiki/Md5#Collisi…","http://en.wikipedia.org/wiki/Md5#His..._cryptanalysis","http://en.wikipedia.org/wiki/Md5#History_and_cryptanalysis","http://en.wikipedia.org/wiki/Md5#Integrity_checking","http://en.wikipedia.org/wiki/Md5#MD5_collision_databases","http://en.wikipedia.org/wiki/Md5#MD5_hashes","http://en.wikipedia.org/wiki/Md5#Preimage_vulnerability","http://en.wikipedia.org/wiki/Md5#Pseudocode","http://en.wikipedia.org/wiki/Md5#Security","http://en.wikipedia.org/wiki/Md5#Vulnerabilit...","http://en.wikipedia.org/wiki/Md5#Vulnerability","http://en.wikipedia.org/wiki/Md5#Vulnerability[[BR","http://en.wikipedia.org/wiki/Md5#Vulnera…","http://en.wikipedia.org/wiki/Md5#_note-0","http://en.wikipedia.org/wiki/Md5#_note-1","http://en.wikipedia.org/wiki/Md5#_note−1","http://en.wikipedia.org/wiki/Md5#cite_note-8","http://en.wikipedia.org/wiki/Md5.","http://en.wikipedia.org/wiki/Md5...","http://en.wikipedia.org/wiki/M​D5","http://eo.wikipedia.org/wiki/MD5","http://es.wikipedia.org/wiki/Algoritmo_MD5","http://es.wikipedia.org/wiki/Algoritmo_MD5#Paso_1._A","http://es.wikipedia.org/wiki/MD5","http://es.wikipedia.org/wiki/MD5#Algorit…","http://es.wikipedia.org/wiki/MD5#Aplicaciones","http://es.wikipedia.org/wiki/MD5#Codificaci.C3","http://es.wikipedia.org/wiki/MD5#Seguridad","http://es.wikipedia.org/wiki/Md5","http://fi.wikipedia.org/wiki/MD5","http://fr.wikipedia.org/wiki/MD5","http://fr.wikipedia.org/wiki/MD5#Attaques","http://fr.wikipedia.org/wiki/MD5#Attaques(...)","http://fr.wikipedia.org/wiki/MD5#Cryptanalyse","http://fr.wikipedia.org/wiki/MD5#Exemple","http://fr.wikipedia.org/wiki/MD5#Faiblesse_de_MD5","http://fr.wikipedia.org/wiki/MD5#Pseudocode","http://fr.wikipedia.org/wiki/MD5(...)","http://fr.wikipedia.org/wiki/Md5","http://fr.wikipedia.org/wiki/Md5#Algorithme","http://fr.wikipedia.org/wiki/Md5#Cryptanalyse","http://fr.wikipedia.org/wiki/md5","http://he.wikipedia.org/wiki/MD5","http://hr.wikipedia.org/wiki/MD-5","http://hr.wikipedia.org/wiki/MD5","http://hu.wikipedia.org/wiki/MD5","http://hu.wikipedia.org/wiki/Md5","http://id.wikipedia.org/wiki/MD5","http://it.wikipedia.org/wiki/MD5","http://it.wikipedia.org/wiki/MD5#Sospetti_e_polemiche","http://it.wikipedia.org/wiki/Md5","http://ja.wikipedia.org/wiki/%4D%44%35","http://ja.wikipedia.org/wiki/MD5#.E3.83.8","http://ja.wikipedia.org/wiki/MD5#.E5.AE","http://ja.wikipedia.org/wiki/MD5?==MD5とは","http://ja.wikipedia.org/wiki/MD5のthumbnail","http://ko.wikipedia.org/wiki/MD5","http://ko.wikipedia.org/wiki/Md5","http://lt.wikipedia.org/wiki/MD5","http://ms.wikipedia.org/wiki/MD5","http://nl.wikipedia.org/wiki/MD5","http://nl.wikipedia.org/wiki/Md5","http://no.wikipedia.org/wiki/MD5","http://pl.wikiped...g/wiki/MD5","http://pl.wikipedia....ki/MD5#Algorytm","http://pl.wikipedia.org/wiki/MD5","http://pl.wikipedia.org/wiki/MD5#Historia","http://pl.wikipedia.org/wiki/Md5","http://pt.wikipedia.org/wiki/MD","http://pt.wikipedia.org/wiki/MD5","http://pt.wikipedia.org/wiki/MD5#Hashes_MD5","http://pt.wikipedia.org/wiki/MD5#Pseudoc.C3","http://pt.wikipedia.org/wiki/Md5","http://ro.wikipedia.org/wiki/MD5","http://ru.wikipedia.org/wiki.....BC_MD5","http://ru.wikipedia.org/wiki/MD5","http://ru.wikipedia.org/wiki/MD5#.D 0.9","http://ru.wikipedia.org/wiki/MD5#.D0...BD","http://ru.wikipedia.org/wiki/MD5#.D0.9A","http://ru.wikipedia.org/wiki/MD5#.D0.9C","http://ru.wikipedia.org/wiki/MD5#.D0.A1","http://ru.wikipedia.org/wiki/MD5#.D0.A3","http://ru.wikipedia.org/wiki/MD5#Примеры_использования","http://ru.wikipedia.org/wiki/Md5","http://ru.wikipedia.org/wiki/Md5#.D0.90","http://ru.wikipedia.org/wiki/Md5#.D0.9A","http://ru.wikipedia.org/wiki/md5","http://se.wikipedia.org/wiki/MD5","http://sk.wikipedia.org/w iki/MD5","http://sk.wikipedia.org/w iki/Message-Digest_algori","http://sk.wikipedia.org/wiki/MD5","http://sk.wikipedia.org/wiki/Message-Digest_algorithm","http://sr.wikipedia.org/sr/MD5","http://sr.wikipedia.org/wiki/MD5","http://sv.wikipedia.org/wiki/MD5","http://tg.wikipedia.org/wiki/MD5","http://th.wikipedia.org/wiki/MD5","http://tr.wikipedia.org/wiki/MD5","http://vi.wikiped...g/wiki/MD5","http://vi.wikipedia.org/wiki/MD5","http://vi.wikipedia.org/wiki/MD5#Kh.....A5n_c","http://wikipedia.org/wiki/MD5","http://www.csie.ntu.edu.tw/~piaip/games","http://zh.wikipedia.org/w iki/MD5","http://zh.wikipedia.org/wiki/MD5","http://zh.wikipedia.org/wiki/MD5#cite_note-2","http://zh.wikipedia.org/zh-cn/MD5","http://zh.wikipedia.org/zh-hk/MD5","http://zh.wikipedia.org/zh-tw/MD5","http://é.wikipedia.org/wiki/MD5","hu.wikipedia.org/wiki/MD5","hu:MD5","hy:MD5","iJuanaSearch: MD5 - Wikipédia","ici t'aideras à comprendre","id.wikipedia.org/wiki/MD5","id:MD5","il a été prouvé qu'il était faillible","il check del md5","in a mode","ind M","info on MD5","informations sur le principe de hachage de md5","is not recommended because it is cryptographically weak","isn't any easy way","it.wikipedia.org/MD5","it:MD5","ja:MD5","jibu hapa","karma bir MD5","keine gute Wahl","klein deel van de boodschap in het geheugen","kleiner Teil der Nachricht in den Speicher","kleinigheidjes","known attacks","known collision vulnerabilities","known cryptographic weaknesses with MD5","ko:MD5","kryptoanalityczne słabości","l'MD5","l'MD5 è un algoritmo senza ritorno","l'algorithme MD5","l'algorithme de hachage MD5","l'algorithme de hachage cryptographique MD5","l'article de Wikipédia MD5","l'article de Wikipédia Md5","l'empreinte md5","la MD","la lectura de este","la lettura di questo","la somme MD5","las vulnerabilidades MD5","le MD5 est une fonction de hachage cryptographique","le vulnerabilità MD5","learn2wiki","leer que significa en wikipedia","leia mais sobre md5 aqui","les faiblesses","let's google ;)","like MD5","lille del af beskeden til hukommelsen","link selengkapnya...","lo suficientemente fuertes","logo_md5","loock here for more information about MD5 Hashs","looked up the Internet","lt:MD5","luk MD5","malou část zprávy do paměti","md5 (Message-Digest algorithm 5)","md5 + соль","md5 - wikipedia","md5 = no longer secure","md5 @wikipedia","md5 Algorithmus","md5 Hash Algorithm","md5 Info","md5 Prüfsumme","md5 Summe","md5 algorithm","md5 algorithm as pseudo code","md5 authentication","md5 checksum","md5 collision","md5 collisions","md5 cryptographic hash","md5 encrypted","md5 encryption","md5 format","md5 function","md5 hack.","md5 has a complexity of (2^24.1)/2","md5 hash-key.","md5 hashattuja","md5 hashek","md5 hashes","md5 hashes shouldn't be trusted","md5 hashing","md5 im Wikipedia","md5 is broken and deprecated","md5 is not exactly secure","md5 kódolással","md5 on Wikipedia","md5 prüfsumme","md5 questo sconosciuto","md5 sum","md5 sum/hash","md5 utan salt är inte till så mycket","md5 wiki","md5 wikipedia","md5 wikipedia the free encyclopedia","md5 или специальный алгоритм шифрования","md5 на вики","md5 хеш","md5 хешами","md5 хеше","md5 хэш","md5 는 암호화 모듈","md5 암호화","md5()","md5)","md5). To authenticate you just need to hash","md5-","md5- Datenbank","md5-Algorithmus","md5-Checksummen","md5-Datei","md5-Funktion","md5-Hashalgorithmus","md5-Prüfsummen","md5-Verschlüsselung","md5-Verschlüsselungsmethode","md5-algorithm","md5-encrypted","md5-gehashten","md5-hash","md5-hashed","md5-hashing","md5-хешей","md5-хэш","md5.","md5su","md5és","md5란?","mehr dazu findest du bei Wikipedia.de","menggunakan MD5","message digest (MD5)","message digest 5","message digest hash","metodou MD5","mindenki által hozzáférhető eszközökkel","ml:MD5","more on MD5)","more on md5","ms:MD5","méthode de vérification en informatique","newly exposed vulnerabilities","ngay tại đây","nicht stark genug","nie wystarczająco silna","niet meer als veilig wordt beschouwd","niet sterk genoeg","niewielka część wiadomości do pamięci","nilai hash password","nl.wikipedia.org/wiki/MD","nl.wikipedia.org/wiki/Md5","nl.wikipedia.org/wiki/Md5...","nl:MD5","no sirve para encriptar información","no:MD5","non abbastanza forte","not considered a secure hashing scheme","not strong enough","not technically perfect","not that secure","nutzen MD5","operates on 512 bit chunks","pequeña parte del mensaje en la memoria","piccola parte del messaggio alla memoria","piccola parte del messaggio nella memoria","pl.wikipedia.org/wiki/MD5","pl:MD5","praktisk aftalt spil problem","pratical collusion problem","pratical मिलीभगत समस्या","pretty broken","principe md5()","przeczytaniu tego","pseudocode from wikipedia","pt:MD5","qualche astruso calcolo","random hatch back number","read more about md5 here","recomendo que veja esta página","resumen MD5","resumen criptográfico MD5","ro:MD5","ru.wikipedia.org/wiki/MD5","ru.wikipedia.org/wiki/MD5#.D0.9A.D0","ru.wikipedia.org/wiki/Md5","ru:MD5","s (MD","s MD5","salt the hash","security research","seqüência de caracteres que gere o mesmo hash","several vulnerabilities","severely compromised","sha-1 is generally better regarding protection,so","should no longer be used","sicher verschlüsselt","sicurezza è in MD5","signatura MD5","signature MD5","simplificando","sk:Message-Digest algorithm","skrótu MD5","sl:Algoritem MD5","small part of the message to memory","so beaten up","somewhat secure now","somme MD5","somme de contrôle MD5","somme de contrôle Md5","sr:MD5","suma kontrolna MD5","suma/algoritmo md5","sume de control MD5","sumę MD5","sv:MD5","sử dụng MD5","t http://en.wikipedia.org/wiki/MD5","tajné dohody Praktické problémy","target=_blank>MD5","technically broken","techniek niet meer zo veilig","tem deficiências conhecidas","tg:MD5","th:MD5","the MD5 article on Wikipedia","the MD5 hash algorithm","the breakdown of the MD5 algorithm","the current status of MD5","the pseudo-code for the MD5 algorithm","the pseudocode on wikipedia","the wiki md5","this code","this security vulnerability","toh due righe di codice","totally cracked","tp://en.wikipedia.org/wiki/MD5>","tp://en.wikipedia.org/wiki/Md5","tr:MD5","trivial para romper","trivial zu brechen","trivielt at bryde","ttp://en.wikipedia.org/wiki/MD5)","ttp://en.wikipedia.org/wiki/Md5","ttp://en.wikipedia.org/wiki/Md5#_note−0","ttp://ja.wikipedia.org/wiki/MD5","ttp://zh.wikipedia.org/wiki/MD5","typically 32 characters long","typicky 32 znaků","typischerweise 32 Zeichen lang sein","typisk 32 tegn lange","típicamente 32 caracteres de longitud","uk:MD5","una vulnerabilidad en el algoritmo MD5","und vor allem nicht ungesalzen","une description de MD5","une fonction de hachage unidirectionnelle (MD5)","unique MD5 hash","usar MD5","use MD5","uso MD5","utilisation MD5","utilizan MD5","vad är MD5?","valores de hash de senha","valori hash password","verificar la codificación MD5","verouderde vorm van encryptie","vi:MD5","visad ja galit rast wikipedijoje","vlastnosti MD5 včetně informace o hledání kolizí","vulnerabilidad de MD5","vulnerabilities in MD5","vulnerable to collision","w:MD5","was ist MD5?","websidor","weitverbreitete kryptographische Hash-Funktion","well documented vulnerabilities","what is MD5","what md5 is","what wikipedia has to say on the topic","when it became possible to have 2 SSL","wiki - MD5","wiki MD5","wiki puslapis","wiki/MD5","wiki/md5 -> Verwendung und Verfügbarkeit","wikipedia : md5","wikipedia > md5","wikipedia MD5","wikipedia about MD5","wikipedia's MD5 page","wikipedia: MD5","wikipedia: md5","wikipedia:MD5","zazwyczaj 32 znaków","zh:MD5","zogenaamde collision aanvallen","| MD5 hash","¿Qué es eso de MD5?","¿Qué es eso del MD5?","Översikt MD5","å bruke MD5","æŸ¥çœ‹è¿™é‡Œ","összegző kód","čtení tohoto","Η απάντηση εδώ","ισχυρή κωδικοποίηση","Адказ тут","Алгоритм MD5","Вики может","Википедии статью MD5","Википедии статью Md5","Википедия: MD5","Вонъ тамъ","Відповідь тут","Информация по md5","Источнике","Коллизии MD5","МД5","МД5 сумму","МъДъ 5","Одговор овде","Одговорот тука","Отговорът тук","Почитай теорию, занимательно","Псевдокод MD5","Статья Википедии о MD5","Статья о MD5 хэшах в Wikipedia","Узнать больше из материала Википедии","Читаем, что такое MD5","Читайте в Вики","Что такое контрольнуя сумма md5?","Что это? (IMG:","алгоритм MD5","алгоритм хеширования","алгоритм хеширования MD5","алгоритма MD5, как псевдо-код","алгоритмом MD5","алгоритмом md5","вики для справки","википедия - MD5 (Message Digest 5) — 128-битный алгоритм","здесь (раздел Примеры использования)","значения хеш-значение пароля","использовать MD5","коллизий в хеш-функции MD5","мд5","метод md5(md5(pass)+word)","не в моде","не рекомендуется, поскольку он является криптографически слабым","небольшую часть сообщение для памяти","небольшую часть сообщений в памяти","о коллизиях MD5","обычный лэптоп справится с задачей за несколько часов","почему MD5 не годится","почитайте про MD5","статью по MD5","статья о MD5","хеша MD5","хитро смешивая","хэша md5","читают эту","אלגוריתם פסאודוקוד","דער ענטפֿערן דאָ","וגיבוב","חלש","חתימה כלשהי","חתימת MD5","לקריאה מה זה MD5, לחץ כאן","פונקציית הגיבוב MD5","קישור לאלגוריתם","إم دي فايف","إم دي5","إم دي5 - ويكيبيديا، الموسوعة الحرة","اطلاعاتی در مورد ام.دی.5","امدی۵","امدی۵ - ویکیپدیا","ایم ڈی پانچ ھیشنگ الگورتھم","تابع هش MD5 (ویکی پدیا)","ترامز MD5","دایجست","درباره MD-5","ملخص الرسالة 5 (MD5) الخوارزمية","نقاط ضعف MD5","همين الگوريتم MD5","پاسخ در اینجا","एमडी 5","एमडी 5 भेद्यता","के लिए याद करने के लिए संदेश का","यहाँ जवाब","लिए स्मृति संदेश का हिस्सा छोटा","हैं कि","होगा pratical मिलीभगत","এই পেজটা দেখতে পারেন","คำตอบที่นี่","ใช้ MD5","—> More ( Wikipedia)","“MD5 - Wikipedia, the free encyclopedia”, en.wikipedia.org","„MD5”","…should be considered cryptographically broken and unsuitable for","→MD5とは","、MD5の","、MD5を","《MD5 - 維基百科》","「MD5」の「ハッシュの衝突耐性について」の項","「MD5」をWikipediaで調べる","「md5」をWikipediaで調べる","ここに答え","のMD5","はMD5","はMD5。","ウィキペディア MD5","ウィキペディア「MD5」","ウィキペディアの記事 MD5","ウィキペディアの記事 Md5sum","ウィキペディア：MD5","ウィキペディア：MD5の","コリジョンの報告がある","ハッシュの衝突耐性について","ハッシュはずトリック","ハッシュをストリーム","ハッシュ値をパスワード","ハッシュ関数（MD5)","パソコンで１分以内に衝突を発見できるレベル","メッセージ ダイジェスト アルゴリズム 5 (MD5)","メッセージ-アルゴリズム5ダイジェスト？ウィキペディア","メッセージダイジェストアルゴリズム5？ウィキペディア","メッセージ・ダイジェストの説明:wikipedia.org","メモリへのメッセージの一部を","不够强大","伪代码md5算法","使用MD5","关于MD5 Wikipedia文章","典型的32个字符","到内存中的一小部分信息","加载到内存中的消息的一","同じハッシュ値が出現する可能性もあるっぽい","哈希密码值","哈希密碼值","哈希演算法","弱衝突耐性","弱衝突耐性の突破","弱衝突耐性は破られていない","打破的","擬似コードとしてMD5アルゴリズム","消息摘要5 (MD5)","消息摘要5（MD5）算法","消息摘要算法5？维基百科","発見した。","的MD5。","的MD5哈希","的MD5，","看这","破ることは簡単","答案点这里","答案點這裡","維基百科對MD5 的解釋。","維基百科的文章“ MD5 ”","維基百科：MD5","維基百科～MD5","维基百科的文章“ MD5 ”","维基百科：MD5","维基百科：MD5的","要深入了解,按我吧,快點","그것의 MD5","당신의 MD5","또는의 MD5","또한의 MD5를","바로 여기","사용하고의 MD5","여기에 대답","예를의 MD5","위키 피 디아 문서 MD5","위키 피 디아 문서 Md5","의 MD5","의 MD5는","의 MD5를","의 MD5를 사용","있는 md5","있는 md5를","취약하다고","함수의 MD5","해시 값을 암호","후의 MD5","（key","：http://en.wikipedia.org/wiki/MD5","：http://en.wikipedia.org/wiki/MD5）","：http://en.wikipedia.org/wiki/Md5","ＭＤ５"],"name":"MD5","categories":["All articles with unsourced statements","Articles with example pseudocode","Articles with unsourced statements from August 2014","Broken hash functions","Checksum algorithms","Cryptographic hash functions","Use dmy dates from April 2014"],"tag_line":"The MD5 message-digest algorithm is a widely used cryptographic hash function producing a 128-bit (16-byte) hash value, typically expressed in text format as a 32 digit hexadecimal number."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dijkstra's-algorithm","_score":0,"_source":{"description":"Dijkstra's algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.\nThe algorithm exists in many variants; Dijkstra's original variant found the shortest path between two nodes, but a more common variant fixes a single node as the \"source\" node and finds shortest paths from the source to all other nodes in the graph, producing a shortest-path tree.\nFor a given source node in the graph, the algorithm finds the shortest path between that node and every other. It can also be used for finding the shortest paths from a single node to a single destination node by stopping the algorithm once the shortest path to the destination node has been determined. For example, if the nodes of the graph represent cities and edge path costs represent driving distances between pairs of cities connected by a direct road, Dijkstra's algorithm can be used to find the shortest route between one city and all other cities. As a result, the shortest path algorithm is widely used in network routing protocols, most notably IS-IS and Open Shortest Path First (OSPF). It is also employed as a subroutine in other algorithms such as Johnson's.\nDijkstra's original algorithm does not use a min-priority queue and runs in time  (where  is the number of nodes). The idea of this algorithm is also given in (Leyzorek et al. 1957). The implementation based on a min-priority queue implemented by a Fibonacci heap and running in  (where  is the number of edges) is due to (Fredman & Tarjan 1984). This is asymptotically the fastest known single-source shortest-path algorithm for arbitrary directed graphs with unbounded non-negative weights. However, specialized cases (such as bounded/integer weights, directed acyclic graphs etc) can indeed be improved further as detailed in § Specialized variants.\nIn some fields, artificial intelligence in particular, Dijkstra's algorithm or a variant of it is known as uniform-cost search and formulated as an instance of the more general idea of best-first search.\n\n","alt_names":["article on WikiPedia","Dijkstry","Pseudocode in Wikipedia","Dijkstra's shortest path problem","алгоритма Дейкстры","http://vi.wikipedia.org/wiki/Thu%E1%...3","dijkstra","алгоритм Дейкстры","Algorithmus_von_Dijkstra","Dijkstra's Algorith","http://en.wikipedia....a%27s_algorithm","Dijkstra's shortest path algorithm","http://en.wikipedia.org/wiki/Dijkstra's_algorithm","Dijkstra Algorithm","Dijkstra's Algorithm","Dijkstra's algorithm - Wikipedia, the free encyclopedia","Dijkstra's algorithm","% 27s_algorithm http://en.wikipedia.org/wiki/Dijkstra","'algorithme de Dijkstra","(Dijkstra","(no) http://en.wikipedia.org/wiki/Dijkstra_algorithm","(no) http://it.wikipedia.org/wiki/Algoritmo_di_Dijkstra","*Algoritmo de *Dijkstra",", http://en.wikipedia.org/wiki/Dijkstra's_algorithm","- Dijkstra's algorithm :","-> Leggi tutto l'articolo su 'Algoritmo di Dijkstra","-> Read the article about 'Dijkstra's algorithm'","...Wikipedia Algorithme de Dijkstra","...Wikipedia Algoritmo de Dijkstra","...Wikipedia Algoritmo di Dijkstra","...Wikipedia Algorytm Dijkstry","...Wikipedia Dijkstras algoritm","...mehr auf Wikipedia über Algorithmus von Dijkstra","...more on Wikipedia about Dijkstra's algorithm","//__http://es.wikipedia.org/wiki/Algoritmo_de_Dijkstra__//","/wiki/Алгоритм_Дейкстры","1 알고리즘의 개요","1959 algorithm","2 伪代码","2 수도코드","27s_algorithm http://en.wikipedia.org/wiki/Dijkstra%","27s_algorithm% http://en.wikipedia.org/wiki/Dijkstra","3 C++ CODE (인접행렬 이용)","3 Running time","3 실행 시간","4 Related problems and algorithms","4 相关问题及算法","4 관련된 문제와 알고리즘","4 실행 시간","4. אלגוריתם ישן -דיאקסטרה (מתוך ויקיפדיה)","5 관련된 문제와 알고리즘","6.1 Dijkstra`s algorithm",": http://fr.wikipedia.org/wiki/","<http://en.wikipedia.org/wiki/Dijkstra%27s_","Ablauf grafisch","About Dijkstra's algorithm","Algo de Dijkstra","Algorimto di Dijkstra","Algorisme de Dijkstra","Algorisme de Dijkstra - ViquipÃ¨dia","Algorisme_de_Dijkstra","Algorithme de Dijkstra","Algorithme de Dijkstra - Wikip?dia","Algorithme de Dijkstra - Wikipdia","Algorithme de Dijkstra - WikipÃ©dia","Algorithme de Dijkstra - Wikipédia","Algorithme_de_Dijkstra","Algorithmus von Dijkstra","Algorithmus von Dijkstra.","Algorithmus zum Finden des kürzesten Pfades in einem","Algoritma Dijkstra","Algoritma Dijkstra - Wikipedia bahasa Indonesia,","Algoritma Dijkstra - Wikipedia bahasa Indonesia, ensiklopedia ...","Algoritma Dijkstra - Wikipedia bahasa Indonesia, ensiklopedia bebas","Algoritma Dijkstra :: Wikipedia Bahasa Indonesia","Algoritma jalan terpendek","Algoritmo Dijkstra","Algoritmo Disjtra","Algoritmo Djikstra de","Algoritmo de Dijkstr","Algoritmo de Dijkstra","Algoritmo de Dijkstra (na Wikipedia)","Algoritmo de Dijkstra - Wikipedia","Algoritmo de Dijkstra - Wikipedia, la enciclopedia libre","Algoritmo de Dijkstra - Wikipédia, a enciclopédia livre","Algoritmo de Dijkstra ? Wikip?dia, a enciclop?dia","Algoritmo de Dijkstra en la Wiki","Algoritmo de Dijkstra na Wikipedia","Algoritmo de Dijkstra para caminho mais curto","Algoritmo de Dijkstra – Wikipédia, a enciclopédia livre","Algoritmo de Dijkstra(Wikipedia):","Algoritmo de Dijskstra","Algoritmo de Djstra","Algoritmo de Menor Caminho","Algoritmo de caminos mínimos","Algoritmo dei cammini minimi","Algoritmo di Dijkstra","Algoritmo di Dijkstra (Dijkstra's Algorithm)","Algoritmo di Dijkstra - Wikipedia","Algoritmo_de_Dijkstra","Algoritmo_di_Dijkstra","Algoritmu' lu' Dijkstra","Algoritmus zur Bestimmung des kurzesten Pfades","Algorytm Dijkstra","Algorytm Dijkstry","Algorytm Dijkstry - Wikipedia","Algorytm Dijkstry - Wikipedia, wolna encyklopedia","Algorytm Dijkstry Wikipedia, wolna encyklopedia","Algorytm Dijkstry – Wikipedia, wolna encyklopedia","Algorytm_Dijkstry","Algorytmu Dijkstry","Automatically finding routes","Camino Mínimo","DIJKSTRA ALGORITHM","DIJKSTRA'S ALGORITHM","DIjkstra","Dajkstrinog algoritma","Dajkstrinom algoritmu","Deikstros","Dijksta","Dijksta Anim.gif","Dijksta's Algorithm","Dijksta-Algorithmus","Dijkstr'a algorithm","Dijkstra 's algorithm - Wikipedia, the free encyclopedia","Dijkstra Algo.","Dijkstra Algorime","Dijkstra Algorithmus","Dijkstra Algorithmus in der Wikipedia","Dijkstra Algorithmus – Wikipedia","Dijkstra Algoritması","Dijkstra Algoritme","Dijkstra Algoritmus","Dijkstra SPF","Dijkstra Shortest Path First","Dijkstra Shortest Path First algorithm","Dijkstra algo","Dijkstra algorithm","Dijkstra algorithm (Wikipedia)","Dijkstra algorithm description","Dijkstra algorithm page","Dijkstra algorithm.","Dijkstra algoritm","Dijkstra algoritması","Dijkstra algoritmasının","Dijkstra algoritme","Dijkstra algoritmis","Dijkstra algoritmu","Dijkstra algoritmus","Dijkstra algoritmus (Wiki link)","Dijkstra bei Wikipedia","Dijkstra em Python","Dijkstra is your man.","Dijkstra magic","Dijkstra path finder","Dijkstra pathfinder","Dijkstra s algorithm - Wikipedia, the free encyclopedia","Dijkstra s algorithm Wikipedia the free encyclopedia","Dijkstra shortest path","Dijkstra shortest path @wikipaedia","Dijkstra shortest route algorithm","Dijkstra shortest-path","Dijkstra single source shortest path","Dijkstra su Wikipedia","Dijkstra wiki","Dijkstra एल्गोरिथ्म","Dijkstra एल्गोरिथ्म है","Dijkstra のアルゴリズム","Dijkstra 演算法","Dijkstra 算法","Dijkstra 의 최단 거리 알고리즘","Dijkstra%27s_algorithm","Dijkstra& - Wikipedia, the free encyclopedia","Dijkstra&#39;s algorithm - Wikipedia, the free encyclopedia","Dijkstra&#8217;s","Dijkstra'","Dijkstra''s algorithm","Dijkstra's (shortest path) Algorithm","Dijkstra's Alg","Dijkstra's Algorithm (SPF)","Dijkstra's Algorithm / Link-State Protocol (Wikipedia)","Dijkstra's Algorithm 2","Dijkstra's Algorithm Wiki","Dijkstra's Algorithm bei Wikipedia (englisch, aber mit Animation","Dijkstra's Algorithm!","Dijkstra's Algorithm's page","Dijkstra's Algorithm,","Dijkstra's Algorithm, Wikipedia","Dijkstra's Algorithm.","Dijkstra's Navigation Algorithm","Dijkstra's Pathfinding","Dijkstra's Shorest Path algorithm","Dijkstra's Shortest Path","Dijkstra's Shortest Path Algorithm","Dijkstra's Single Source Shortest Path algorithm","Dijkstra's algo","Dijkstra's algorihtm","Dijkstra's algorith","Dijkstra's algorithm (Wikipedia)","Dijkstra's algorithm (Ш)","Dijkstra's algorithm - Wikipedia","Dijkstra's algorithm - Wikipedia :: The free encyclopedia","Dijkstra's algorithm - Wikipedia, the free ...","Dijkstra's algorithm - Wikipedia, the free encyclopedia →","Dijkstra's algorithm Wikipedia article.","Dijkstra's algorithm Wikipedia the free encyclopedia","Dijkstra's algorithm by Wikipedia","Dijkstra's algorithm for this problem","Dijkstra's algorithm from Wikipedia","Dijkstra's algorithm on shortest paths (SP)","Dijkstra's algorithm runtime","Dijkstra's algorithm(ospf)","Dijkstra's algorithm.","Dijkstra's algorithm: Algorithm","Dijkstra's algorithm: Related problems and algorithms","Dijkstra's algorithm? It's such a good node-based","Dijkstra's algoritm","Dijkstra's algoritme","Dijkstra's algoritme op Wikipedia","Dijkstra's alogrithm","Dijkstra's graph search algorithm","Dijkstra's shortest path","Dijkstra's shortest path algorithm.","Dijkstra's shortest-path algorithm","Dijkstra's single-source shortest path algorithm","Dijkstra's single-source shortest path problem algorithm","Dijkstra's 算法","Dijkstra's_algorithm","Dijkstra's_algorithm-wp","Dijkstra's算法","Dijkstra(single source shortest path)","Dijkstra(迪杰斯特拉)算法","Dijkstra-","Dijkstra-Algorithmus","Dijkstra-Algorithmus (Wikipedia)","Dijkstra-Algorithmus ? Wikipedia","Dijkstra-Algorithmus Wikipedia","Dijkstra-Algorithmus in","Dijkstra-Algorithmus unter Verwendung eines Fibonacci-Heaps","Dijkstra-Algorithmus â€“ Wikipedia","Dijkstra-Algorithmus – Wikipedia","Dijkstra-Algorthmus","Dijkstra-Suche","Dijkstra-algoritme","Dijkstra-algoritmus","Dijkstra-algoritmus - Wikip?dia","Dijkstra-algoritmus - WikipÃĐdia","Dijkstra-algoritmus - Wikipédia","Dijkstra-féle algoritmust","Dijkstra...","Dijkstra;","Dijkstra?s algorithm","Dijkstran","Dijkstran algoritmi","Dijkstran algoritmia","Dijkstraren algoritmo","Dijkstraren algoritmo - Wikipedia, entziklopedia askea.","Dijkstras","Dijkstras Algorithm","Dijkstras Algorithm...WIKI","Dijkstras Algorithmus","Dijkstras Algorithmus bei Wikipedia (deutsch)","Dijkstras Algoritm","Dijkstras SSSP Algorithmus","Dijkstras algorithm","Dijkstras algorithm Wikipedia the free encyclopedia","Dijkstras algoritm","Dijkstras algoritm - Wikipedia","Dijkstras algoritme","Dijkstras_Algorithmus","Dijkstrasalgoritm","Dijkstra´s algorithm","Dijkstra»s algorithm","Dijkstraのが","Dijkstraのアルゴリズム","Dijkstraのアルゴリズムは","Dijkstraのアルゴリズムは、","Dijkstraのアルゴリズムを","Dijkstra演算法","Dijkstra的","Dijkstra的算法","Dijkstra算法","Dijkstra算法-迪科斯彻算法-维基百科，自由的百科全书","Dijkstra算法的","Dijkstra﻿ Algorithmus","Dijkstrin algoritam - Wikipedija","Dijkstrinim algoritmom","Dijkstros algoritmas","Dijkstrov algoritem","Dijkstrov algoritem @ Wikipedia","Dijkstrov algoritmus","Dijkstrov algoritmus - Wikipédia","Dijkstrova algoritmu","Dijkstrovým algoritmem","Dijkstru","Dijkstruv algoritmus - Wikipedie","Dijkstrův","Dijkstrův algoritmus","Dijkstrův algoritmus - Wikipedie","Dijkstrův algortimus","Dijktra's Algorithm","Dijktrov algoritmus","Dijsktra Algorithm","Dijsktra Algorythm","Dijsktra's","Dijsktra's Algorithm","Dijsktra's algorithm","Dijsktras Algorithmus","Dijsktras algorithm","Dijstra","Dijstra's algorithm","Dijstra's shortest path algorithm","Dikjsta's Algorithm","Dikjstra's Shortest Path","Dj Xtra: Let go rythm","Djikstra Algorithm","Djikstra algorithm","Djikstra algoritmus","Djikstra di algoritmo","Djikstra ของ ขั้น ตอน วิธี","Djikstra's","Djikstra's Algorithm","Djikstra's algorithm","Djikstra's algoritme","Djikstra-Algorithmus","Djikstra-Algorithmus,","Djikstras Algorithm","Djikstraのアルゴリズム","Djikstra的算法","Djikstra의 알고리즘을","Djkstra-Algorithmus","Drevo najkrajših poti","Driva's Algorithm","Dykstra algorithm","Dykstra's algorithm","Dykstraalgorithmus","E. W. Dijkstra: A note on two problems in","E.W. Dijkstra's famous algorithm","Edsger Dijkstras single source shortest path-algorithm","El algoritmo de Dijkstra","El algoritmo de Disjktra","Fredman & Tarjan 1984","G(V,E)","Game Player - Sesame Street","Here is the algorithm and pseudo-code","Hier gibt es einen Wikiartikel","Itt olvasd","Java Algorithm Graph shortest path algorithm","Klasycznym algorytme Dijkstry i //problemem najkrótszej ścieżki//","Kleinberg‟s algorithm.","Kortste Pad Algoritme","Kortste Pad algoritme","Kortste pad algoritme","Kortste padprobleem","Kortstepad algoritme Wikipedia","Kortstepad-algoritme","Kortstepad-algoritme - Wikipedia","Kortstepadalgoritme","Kürzeste-Wege-Algorithmen","Kürzeste-Wege-Algorithmus Dijkstra","L' Algoritmo di Dijkstra","L'algorithme de Dijkstra","L'algorithme du Djikstra","L'algoritmo di Dijkstra","Learn about Dijkstra's algorithm>>>","Lexikon: Dijkstra Algorithmus ...","Lexikon: Dijkstra-Algorithmus - ComputerBase","Leyzorek et al. 1957","Link zu einem der Algorithmen","Netherlands, developed the algorithm of","O algoritmo Dijkstra","O(M * log N)","Odkaz na wikipédiu","On the algorithm on Wikipedia","R5.1a","R5.1b","Read More About dijkstra's algorithm - wikipedia the free","Read More dijkstra's algorithm wikipedia the free encyclopedia","Ref: Dijkstra's Algorithm","SATO Yozo: ダイクストラ法 - Wikipedia","SPF algorithm","SPF algoritmus","SPF algoritmů","SPF calculation","SPF算法","Screenshot http://www.computerbase.de/lexikon/Dijkstra-Algorithmus","Shortest Path Algorithm","Shortest Path Firs","Shortest Path First","Shortest Path First (SPF) algorithm","Shortest Path First,","Shortest Path algorithm","Shortest path Algorithm","Shortest path Algorithm.","Shortest path Dijkstra Algorithm","Shortest path first","Shortest path tree (Dijkstra)","Shortest_path_first","Suggested: dijkstra's algorithm","Thuật toán Dijkstra","Thuật toán Djikstra's","W: Dijkstra's algorithm","What is algorithm of Dijkstra algorithm?","What is algorithm of Dijkstra's shortest path algorithm","Wiki Dijkstra","Wiki: Dijkstra's Algorithm","WikiPedia on Dijkstra's Algorithm","Wikipedia - Dijkstra Algo","Wikipedia - Dijkstra's algorithm","Wikipedia Dijkstra","Wikipedia Dijkstra's Algorithm Pseudocode","Wikipedia article Algorithme de Dijkstra","Wikipedia article Algoritma Dijkstra","Wikipedia article Algoritmo de Dijkstra","Wikipedia article Algoritmo di Dijkstra","Wikipedia article Algorytm Dijkstry","Wikipedia article Dijkstra algorithm","Wikipedia article Dijkstra's algorithm","Wikipedia article Dijkstra's_algorithm","Wikipedia article Dijkstran algoritmi","Wikipedia article Dijkstras algoritm","Wikipedia article Dijkstrin algoritam","Wikipedia article Dijkstrův algoritmus","Wikipedia article Shortest Path First","Wikipedia article Shortest path first","Wikipedia article on Algoritmo de Dijkstra","Wikipedia article on Dijkstra algorithm","Wikipedia article on Dijkstra's algorithm","Wikipedia article אלגוריתם דייקסטרה","Wikipedia article الگوریتم دیکسترا","Wikipedia article ขั้นตอนวิธีของไดค์สตรา","Wikipedia artikel Algoritme van Dijkstra","Wikipedia artikel Kortstepadalgoritme","Wikipedia is slightly helpful","Wikipedia l'articolo Algoritmo di Dijkstra","Wikipedia page on Dijkstra's algorithm","Wikipedia にある疑似コード","Wikipedia の Dijkstra's algorithm の説明","Wikipedia$ダイクストラ法","Wikipedia's Page on Dijkstra's Algorithm","Wikipedia- Artikel zum Dijkstra- Algorithmus","Wikipedia-Artikel Algorithmus von Dijkstra","Wikipedia-Artikel Dijkstra-Algorithmus","Wikipedia-Artikel Dijkstras Algorithmus","Wikipedia-Seite zu 'Algorithmus von Dijkstra'","Wikipedia-Seite zu 'Dijkstra-Algorithmus'","Wikipedia-dijkstra","Wikipedia.jp:ダイクストラ法","Wikipedia: Algorithmus von Dijkstra","Wikipedia: Dijkstra","Wikipedia: Dijkstra's Algorithm","Wikipedia: Dijkstra's algorithm","Wikipedia: Dijkstra's algoritme","Wikipedia::Dijkstra's_algorithm","Wikipedia:Algoritmo_di_Dijkstra","Wikipedia:Dijkstra's_algorithm","Wikipedia:ダイクストラ法","Wikipedia_cs - Dijktrův algoritmus","Wikipedia_en - Dijkstra's algorithm","Wikipediaで「ダイクストラ法」を調べる","Wikipedija - Dijkstrov algoritem","Zapis w pseudokodzie","[4] Dijkstra's algorithm to solve the single-source","[Dijkstra]","[http://es.wikipedia.org/wiki/Algoritmo_de_Dijkstra]","a quick path finding algorithm","ad http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm","algo du plus court chemin, souvenirs d'école","algorisme de Dijkstra","algorisme que duu el seu nom","algorithm (breadth-fir","algorithm for finding shortest paths in a graph","algorithme de Dijkstra","algorithme de Disjkstra","algorithme de Djikstra","algoritma Dijkstra","algoritma jalan terpendek","algoritma-nya om Dijkstra","algoritme van Dijkstra","algoritmo Dijkstra","algoritmo de Dijkastra","algoritmo de Dijkst","algoritmo de Dijkstra","algoritmo de Dijkstra.","algoritmo de Djikstra","algoritmo de camino de costo mínimo en un","algoritmo de estado del enlace de Dijkstra LSA","algoritmo de menor caminho","algoritmo desenvolvido por Djikstra","algoritmo di Dijkstra","algoritmului lui Djikstra","algoritmus Dijkstra","algorythme de Dijkstra","algorytm Dijkstra","algorytm Dijkstry","algorytm Dijkstry szukania drogi","algorytmem optymalizacji wyszukiwania ścieżek","algorytmu Dijkstry","alli hay una implementación en C++","already been solved by Dijkstra","an easy problem to solve","aplicar un algoritmo","aplicándole dijsktra","artigo da Wikipédia Algoritmo de Dijkstra","artículo de Wikipedia Algoritmo de Dijkstra","artículo de Wikipedia Algoritmo de caminos mínimos","ca.wikipedia.org/wiki/Algorisme_de_Dijkstra","ce lien?","criador do caminho mínimo","cálculo de caminos mínimos","d http://en.wikipedia.org/wiki/Dijkstra's_algorithm","de Dijkstra","de.wikipedia.org/wik...rithmus_von_Dijkstra","de.wikipedia.org/wiki/Dijkstra-Algorithmus","de.wikipedia.org/wiki/Dijkstra-Algorithmus#Zeitkomplexit.C3","del algoritmo Djikstra","del algoritmo de Dijkstra","der Algorithmus von Dijkstra","di Dijkstra","dijksta","dijkstra algorithm","dijkstra algorithmus","dijkstra's","dijkstra's algorithm","dijkstra's algorithm - Wikipedia, the free encyclopedia","dijkstra's shortest path algorithm","dijkstra's 算法","dijkstras algoritm","dijkstra算法","dijsktra algorithm","dikjstra algorithm","djikstra-algorithm","drevesa najkrajših poti v grafu","drumul de cost minim in grafuri","e : http://en.wikipedia.org/wiki/Dijkstra's algorithm","e Quantum Physics and Information Processing.","ecord which nodes link to w","el algoritmo de Dijkstra","el algoritmo de Djikstra","el algorítmo de Dijkstra","en.wikipedia.org/...Dijkstra%27s_algorithm","en.wikipedia.org/...Dijkstra's_algorithm","en.wikipedia.org/wiki/Dijks ...","en.wikipedia.org/wiki/Dijks...","en.wikipedia.org/wiki/Dijkstra%27s_algorithm","en.wikipedia.org/wiki/Dijkstra%27s_algorithm.","en.wikipedia.org/wiki/Dijkstra's_algorithm","en.wikipedia.org/wiki/Dij…","en:Dijkstra's algorithm","es.wikipedia.org/wiki/Algoritmo_de_Dijkstra","famoso algortimo","finding the best route between multiple destinations","formal algorithm","fr.wikipedia.org/wiki/Algorithme_de_Dijkstra","full description of the algorithm here","graph pictured here","heap-based dijkstra implementation","het algoritme van Dijkstra","het kortste pad algoritme","http ://fr.wikipedia.org/wiki/-","http ://fr.wikipedia.org/wiki/Algorithme_de_Dijkstra","http://cs.wikipedia.org/wiki/Dijkstr%C5%AFv_algoritmus","http://cs.wikipedia.org/wiki/Dijkstrův_algoritmus","http://de.wikipedia....tra-Algorithmus","http://de.wikipedia.org/wiki/Algorithmus_von_Dijkstra","http://de.wikipedia.org/wiki/Di jkstra-Algorithmus","http://de.wikipedia.org/wiki/Dijkstra-","http://de.wikipedia.org/wiki/Dijkstra-A ... s","http://de.wikipedia.org/wiki/Dijkstra-A ... tkomplexit","http://de.wikipedia.org/wiki/Dijkstra-Al","http://de.wikipedia.org/wiki/Dijkstra-Algorit...","http://de.wikipedia.org/wiki/Dijkstra-Algorithmus","http://de.wikipedia.org/wiki/Dijkstra-Algorithmus#Implementierung","http://de.wikipedia.org/wiki/Dijkstra-Algorithmus#Zeitkomplexit","http://de.wikipedia.org/wiki/Dijkstra-Algorithmus.","http://de.wikipedia.org/wiki/Dijkstra-Al…ler_Algorithmus","http://de.wikipedia.org/wiki/Dijkstras_","http://de.wikipedia.org/wiki/Dijkstras_Algorithmus","http://en.Liarpedia.org/wiki/Dijkstra%27s_algorithm","http://en.wikipedia.org/wiki/Dij...","http://en.wikipedia.org/wiki/Dijkstr...thm#Pseudocode","http://en.wikipedia.org/wiki/Dijkstra 27s_algorithm%","http://en.wikipedia.org/wiki/Dijkstra algorithm.","http://en.wikipedia.org/wiki/Dijkstra% 27s% 5Falgorithm","http://en.wikipedia.org/wiki/Dijkstra% 27s_algorithm","http://en.wikipedia.org/wiki/Dijkstra% [...] #Running_time","http://en.wikipedia.org/wiki/Dijkstra%27s%5Falgorithm","http://en.wikipedia.org/wiki/Dijkstra%27s_","http://en.wikipedia.org/wiki/Dijkstra%27s_alg...","http://en.wikipedia.org/wiki/Dijkstra%27s_algorith","http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm","http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Pseudocode","http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Python_code_implementation","http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm.","http://en.wikipedia.org/wiki/Dijkstra%27…","http://en.wikipedia.org/wiki/Dijkstra' s_algorithm","http://en.wikipedia.org/wiki/Dijkstra's algorithm","http://en.wikipedia.org/wiki/Dijkstra's_algorithm#C","http://en.wikipedia.org/wiki/Dijkstra's_algorithm#Pseudocode","http://en.wikipedia.org/wiki/Dijkstra's_algorithm#Running_time","http://en.wikipedia.org/wiki/Dijkstra's_…","http://en.wikipedia.org/wiki/Dijkstra\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'s_algorithm","http://en.wikipedia.org/wiki/Dijkstra_algorithm","http://en.wikipedia.org/wiki/Dijkstra_algorithm#Pseudocode","http://en.wikipedia.org/wiki/Dijkstra％-27％5Falgorithm","http://en.wikipedia.org/wiki/Dijkstra％27s_algorithm","http://en.wikipedia.org/wiki/Dijkstra％27秒","http://en.wikipedia.org/wiki/Dijkstra％の27s_algorithm","http://en.wikipedia.org/wiki/File ijksta_Anim.gif","http://en.wikipedia.org/wiki/File:Dijksta_Anim.gif","http://en.wikipedia.org/wiki/Shortest_Path_First","http://en.wikipedia.org/wiki/Shortest_path_first","http://en.wikipedia.org/wikiDijkstra's_algorithm","http://en.wikipedia.​org/wiki/Dijkstra%27​s_algorithm","http://es.wikipedia....tmo_de_Dijkstra","http://es.wikipedia.org/wiki/Algoritmo_de_Dijkstr","http://es.wikipedia.org/wiki/Algoritmo_de_Dijkstra","http://es.wikipedia.org/wiki/Algoritmo_de_Dijkstra#Pseudoc.C3","http://es.wikipedia.org/wiki/Algoritmo_de_Dijkstra#Python","http://et.wikipedia.org/wiki/Dijkstra_algoritm","http://fi.wikipedia.org/wiki/Dijkstran_algoritmi","http://fr.wikipedia.org/wiki/Algorit..._et_la_ville_J","http://fr.wikipedia.org/wiki/Algorit...a#Applications","http://fr.wikipedia.org/wiki/Algorit...ra#Pseudo","http://fr.wikipedia.org/wiki/Algorithme_de_Di","http://fr.wikipedia.org/wiki/Algorithme_de_Dijkstra","http://fr.wikipedia.org/wiki/Algorithme_de_Dijkstra#Distance_entre_la_ville_A_et_la_ville_J","http://fr.wikipedia.org/wiki/Algorithme_de_Dijkstra.","http://g4ac.co.za/wVmcC","http://he.wikipedia.org/wiki/אלגוריתם_דייקסטרה","http://hr.wikipedia.org/wiki/Dijkstrin_algoritam","http://hu.wikipedia....stra-algoritmus","http://hu.wikipedia.org/wiki/Dijkstra-algoritmus","http://id.wikipedia.org/wiki/Algoritma_Dij","http://id.wikipedia.org/wiki/Algoritma_Dijkstra","http://id.wikipedia.org/wiki/Algoritma_D…","http://it.wikipedia.org/wiki/Algoritmo_di_Dijkstra","http://ja.wikipedia.org/wiki/ダイクストラ法","http://ja.wikipedia.org/wiki/ダイクストラ法#.E6.93","http://ko.wikipedia.org/wiki/%eb%8d%b0","http://ko.wikipedia.org/wiki/데이크스트라_알고리즘","http://lt.wikipedia.org/wiki/Dijkstros_algoritmas","http://nl.wikipedia.org/wiki/Kortste_Pad_Algoritme","http://nl.wikipedia.org/wiki/Kortstepad-algoritme","http://nl.wikipedia.org/wiki/Kortstepadalgori...","http://nl.wikipedia.org/wiki/Kortstepadalgoritme","http://no.wikipedia.org/wiki/Dijkstras_algoritme","http://pl.wikipedia.org/wiki/A[...]#Z.C5","http://pl.wikipedia.org/wiki/Algorytm_Dijkstry","http://pl.wikipedia.org/wiki/Algorytm_Dijkstry#Z.C5","http://pt.wikipedia....tmo_de_Dijkstra","http://pt.wikipedia.org/wiki/Algoritmo_de_Dijkstra","http://ro.wikipedia.org/wiki/Algoritmul_lui_Dijkstra","http://ru.wikipedia.org/wiki/Алгоритм Дейкстры","http://ru.wikipedia.org/wiki/Алгоритм_Де...","http://ru.wikipedia.org/wiki/Алгоритм_Дейкстры","http://ru.wikipedia.org/wiki/Дейкстры_алгоритм","http://sk.wikipedia.org/wiki/Dijkstrov_algoritmu","http://sk.wikipedia.org/wiki/Dijkstrov_algoritmus","http://sl.wikipedia.org/wiki/Dijkstrov_algoritem","http://student.uci.agh.edu.pl/~wasikows/grafy","http://sv.wikipedia.org/wiki/Dijkstras_algoritm","http://zh.wikipedia.org/wiki/Dijkstra%E7%AE","hu:Dijkstra-algoritmus","i http://fr.wikipedia.org/wiki/Algorithme_de_Dijkstra","id:Algoritma Dijkstra","ijkstra's algorithm.","ijkstra's shortest path algorithm","it.wikipedia.org/...Algoritmo_di_Dijkstra","ko:데이크스트라 알고리즘","kortste pad-probleem","kortste route tussen twee punten","kortste-padalgoritme","kortstepadalgoritme","l'algo de Dijkstra","l'algorisme de Dijkstra","l'algorithme Dijkastra","l'algorithme Djikstra de","l'algorithme de Dijkstra","l'algorithme de Dijktra","l'algoritmo Djikstra's","l'algoritmo di Dijkstra","l'algoritmo di Dijkstra:","least-cost-routing algorithm","les plus courts chemins","link to Dijkstra's algorithm","logaritmo de Dijkstra","lowest cost path algorithm","lt:Dijkstros algoritmas","min path","more awesome version","networking algorithm","nieoceniona jest tu Wikipedia","nl.wikipedia.org/wiki/Kortstepadalgoritme","ou même vraiment compliqués","pl.wikipedia.org/wiki/Algorytm_Dijkstry","problèmes de plus court chemin","pseudo code implementation","pseudo-code of Wikipedia","pseudocode implementation in wikipedia","psuedo-code","pt.wikipedia.org/wiki/Algoritmo_de_Dijkstra","publicado em 1959","really easy to solve","reference to Dijkstra","remarkably consistent and very robust","ro:Algoritmul lui Dijkstra","rozwiązanie Dijkstry","rupedia:Алгоритм Дейкстры","samodzielnie (","shortest path algo","shortest path first","shortest-path graph algorithm","some guy called Dijkstra had gotten there first","source-example","sv.wikipedia.org/wiki/Dijkstras_algoritm","taking the longest path to wherever we're","thuật toán Dijkstra","thuật toán Dijtra","ttp://de.wikipedia.org/wiki/Dijkstra-Algorithmus.","ttp://en.wikipedia.org/wiki/Dijkstra's_algorithm","tym pseudokodzie","uk:Алгоритм Дейкстри","uk:Алгоритм_Дейкстри","vi.wikipedia.org/wiki/Thuật_toán_Dijkstra","voir l'algorithme de Dijkstra","w: Dijkstra's algorithm","w:Dijkstra's algorithm","what it should have been doing","wheel you were re-inventing","wiki - ダイクストラ法","wiki:Алгоритм_Дейкстры","wikipedia page for Djikstra's algorithm","wikipedia.org/wiki/Dijkstra","wikipedia: Dijkstra's algorithm","wikipedia:Dijkstra's algorithm","wikipedia:ダイクストラ法","wikipediaの説明中","with Dijkstra's algorithm","works in the following manner","| source-example","~ Dijkstra's algorithm","Αλγόριθμος Ντάικστρα","Αλγόριθμος του Dijkstra","Δευτεροτομίτες-Δικτυάδες;","Σκατό number two.","αλγόριθμος του Djikstra","А вот еще хороший алгоритм.","Алгори́тм Де́йкстры","Алгоритм Djikstra","Алгоритм Дейкстри","Алгоритм Дейкстры","Алгоритм Дейкстры — Википедия","Алгоритм Дейкстры.","Алгоритм Дейкстры. Википедия","Алгоритм дейкстры","Алгоритм поиска кратчайших путей в графе","Алгоритма Дейкстры","Алгоритъм на Дейкстра","Алгоритъм на Дийкстра","Википедии статью Алгоритм Дейкстры","Википедия: Алгоритм Дейкстры","Дајкстрином алгоритму","Дейкстры Алгоритм","Дейкстры, заключается в том, что он способен работать","Дийкстра","Об алгоритме Дейкстры в Википедии","Поиска кратчайшего пути на графе","Ссылка N1","Это википедия","алгоритм Djikstra's","алгоритм Дейкстри","алгоритм Дийстры","алгоритм дейкстры","алгоритме Дейкстры","алгоритмом Дейкстры","алгоритъма на Дикстра","алгоритъмът на Дейкстра","в алгоритме Дейкстры","известный алгоритмом нахождения кратчайшего пути","иид ЛЛ вКл д Кгж Лл Л зиж","немного умная ссылка, которая всё проясняет","поиск кратчайшего пути в графе","статья об этом на вики","אלגוריתם Dijkstra","אלגוריתם דייקסטרה","אלגוריתם דייקסטרה – ויקיפדיה","דייקסטרה בויקיפדיה","דיקסטרה של האלגוריתם","האלגוריתם של דייקסטרא","האלגוריתם של דייקסטרה","האלגוריתם של דיקסטרה","הגדרת דיאקסטרא בויקיפדיה","ויקיפדיה - 'אלגוריתם דייקסטרה'","المقالة التالية بموقع ويكيبيديا","الگوریتم Dijkstra","الگوریتم دایجکسترا","الگوریتم دیکسترا","الگوریتم دیکسترا - ویکیپدیا","الگوریتم کوتاهترین مسیر","دایکسترا ویکیپدیا","لاقيتها","وديكسترا خوارزمية","डिज्कस्ट्रा","डिज्कस्ट्रा और","तो","है Dijkstra एल्गोरिथ्म","ডায়াকস্ট্রা","ขั้นตอนวิธีของไดค์สตรา","“Dijkstra's algorithm - Wikipedia, the free encyclopedia”, en.wikipedia","“кратчайшего пути”","「ダイクストラ法」についてWikipediaで調査","「ダイクストラ法」をWikipediaで調べる","ウィキペディアの記事 ダイクストラ法","ダイクストラ アルゴリズム(2)","ダイクストラのアルゴリズム","ダイクストラのアルゴリズムでは、","ダイクストラのアルゴリズムの","ダイクストラのアルゴリズムは、","ダイクストラのアルゴリズムを","ダイクストラアルゴリズムを","ダイクストラ法","ダイクストラ法 - Wikipedia","ダイクストラ法 -wikipedia","ダイクストラ法 dijkstra's algorithm","ダイクストラ法 – Wikipedia","ファイル:Dijksta Anim.gif - Wikipedia","使用Dijkstra","可以使用","如Dijkstra","戴克斯特拉算法","維基百科的文章“ Dijkstra算法”","維基百科的文章“ 迪科斯彻算法”","维基百科的文章“ Dijkstra算法”","维基百科的文章“ 迪科斯彻算法”","迪克斯加演算法","迪克斯加算法","迪克斯特拉算法","迪科斯彻最短路径算法","迪科斯彻算法","迪科斯彻算法 - 维基百科，自由的百科全书","迪科斯彻算法- 维基百科，自由的百科","迪科斯彻算法- 维基百科，自由的百科全书","다익스트라 교수님이 제안하신 방법","데이 크 스트라 알고리즘을","데이 크 스트라와","데이크스트라 알고리즘","데이크스트라 알고리즘 - 위키백과, 우리 모두의 ...","위키 피 디아 문서 데이크스트라 알고리즘","위키 피 디아 문서 데익스트라 알고리즘","위키페디아 딕스트라의 파이썬 코드 틀림. 어디가 틀렸을까연~","위키피디아 본문 보기","ﾀﾞｲｸｽﾄﾗ法-wikipedia"],"name":"Dijkstra's algorithm","categories":["1959 in computer science","Articles with example pseudocode","Combinatorial optimization","Commons category with local link same as on Wikidata","Dutch inventions","Graph algorithms","Routing algorithms","Search algorithms","Use dmy dates from February 2011"],"tag_line":"Dijkstra's algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks."}}
,{"_index":"throwtable","_type":"algorithm","_id":"harmony-search","_score":0,"_source":{"description":"In computer science and operations research, harmony search (HS) is a phenomenon-mimicking algorithm (also known as metaheuristic algorithm, soft computing algorithm or evolutionary algorithm) inspired by the improvisation process of musicians proposed by Zong Woo Geem in 2001. In the HS algorithm, each musician (= decision variable) plays (= generates) a note (= a value) for finding a best harmony (= global optimum) all together. Proponents claim the following merits:\nHS does not require differential gradients, thus it can consider discontinuous functions as well as continuous functions.\nHS can handle discrete variables as well as continuous variables.\nHS does not require initial value setting for the variables.\nHS is free from divergence.\nHS may escape local optima.\nHS may overcome the drawback of GA's building block theory which works well only if the relationship among variables in a chromosome is carefully considered. If neighbor variables in a chromosome have weaker relationship than remote variables, building block theory may not work well because of crossover operation. However, HS explicitly considers the relationship using ensemble operation.\nHS has a novel stochastic derivative applied to discrete variables, which uses musician's experiences as a searching direction.\nCertain HS variants do not require algorithm parameters such as HMCR and PAR, thus novice users can easily use the algorithm.","alt_names":["- Harmony search :","Harmony Search","Harmony Search Algorithm","Harmony search","Harmony search (","Harmony search - Wikipedia :: The free encyclopedia","Harmony search - Wikipedia, the free encyclopedia","Harmony search Wikipedia the free encyclopedia","Harmony search Wikipedia the free encyclopedia - result","Harmony search – Wikipedia, the free encyclopedia","Harmony search: a metaheuristic inspired by musical improvisation","Harmony_search","Harmonysearch - Wikipedia, the free encyclopedia","Harmy search","Other Related Algorithms","Source Wikipedia.org Arcticle - Harmony search","The Harmony Search Algorithm","Wikipedia article Harmony search","Wikipedia article about Harmony search","Wikipedia article on Harmony search","Wikipedia entry for Harmony search","Wohlklang-Suche","en.wikipedia.org/wiki/Harmony_search","en: Harmony search","harmony search","http://en.wikipedia.org/wiki/Harmony_se arch","http://en.wikipedia.org/wiki/Harmony_sea","http://en.wikipedia.org/wiki/Harmony_search","http://en.wikipedia.org/wiki/H​armony_search","improved harmony search","x 1 ... x k","yago-res:Harmony search","和弦搜尋法"],"name":"Harmony search","categories":["All NPOV disputes","All articles lacking in-text citations","All articles with unsourced statements","Articles lacking in-text citations from April 2013","Articles with unsourced statements from April 2013","Combinatorial optimization","Evolutionary algorithms","NPOV disputes from April 2013","Optimization algorithms and methods","Wikipedia articles with possible conflicts of interest from April 2013"],"tag_line":"In computer science and operations research, harmony search (HS) is a phenomenon-mimicking algorithm (also known as metaheuristic algorithm, soft computing algorithm or evolutionary algorithm) inspired by the improvisation process of musicians proposed by Zong Woo Geem in 2001."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bottleneck-traveling-salesman-problem","_score":0,"_source":{"description":"The Bottleneck traveling salesman problem (bottleneck TSP) is a problem in discrete or combinatorial optimization. It is stated as follows: Find the Hamiltonian cycle in a weighted graph which minimizes the weight of the most weighty edge of the cycle.\nThe problem is known to be NP-hard. The decision problem version of this, \"for a given length x, is there a Hamiltonian cycle in a graph g with no edge longer than x?\", is NP-complete.\nIn an asymmetric bottleneck TSP, there are cases where the weight from node A to B is different from the weight from B to A (e. g. travel time between two cities with a traffic jam in one direction).\nEuclidean bottleneck TSP, or planar bottleneck TSP, is the bottleneck TSP with the distance being the ordinary Euclidean distance. The problem still remains NP-hard, however many heuristics work better.\nIf the graph is a metric space then there is an efficient approximation algorithm that finds a Hamiltonian cycle with maximum edge weight being no more than twice the optimum.\n^ a b Michael R. Garey and David S. Johnson (1979). Computers and Intractability: A Guide to the Theory of NP-Completeness. W.H. Freeman. ISBN 0-7167-1045-5.  A2.3: ND24, pg.212.\n^ R. Garey Parker and Ronald L. Rardin (1984). \"Guaranteed performance heuristics for the bottleneck traveling salesman problem\". Operations Research Letters.  2(6):269–272","alt_names":["...more on Wikipedia about Bottleneck traveling salesman problem","Bottleneck traveling salesman","Bottleneck traveling salesman problem","Bottleneck traveling salesman problem - Wikipedia, the free","Bottleneck traveling salesman problem - Wikipedia, the free ...","Bottleneck traveling salesman problem - Wikipedia, the free ... ...","Bottleneck traveling salesman problem - Wikipedia, the free encyclopedia","Bottleneck traveling salesman problem Wikipedia the free","Bottleneck traveling salesman problem by Wikipedia","Bottleneck traveling salesman problem the free ...","Wikipedia article ''Bottleneck traveling salesman problem''","Wikipedia article Bottleneck traveling salesman","Wikipedia article on Bottleneck traveling salesman problem","Wikipedia entry for Bottleneck traveling salesman problem","bottleneck traveling salesman","bottleneck travelling salesman problem","http://en.wikipedia.org/wiki/Bottleneck_","http://en.wikipedia.org/wiki/Bottleneck_traveling_salesman_problem","ttp://en.wikipedia.org/wiki/Bottleneck_traveling_salesman_problem"],"name":"Bottleneck traveling salesman problem","categories":["Combinatorial optimization","Graph algorithms","Hamiltonian paths and cycles"],"tag_line":"The Bottleneck traveling salesman problem (bottleneck TSP) is a problem in discrete or combinatorial optimization."}}
,{"_index":"throwtable","_type":"algorithm","_id":"robinson–schensted-correspondence","_score":0,"_source":{"description":"In mathematics, the Robinson–Schensted correspondence is a bijective correspondence between permutations and pairs of standard Young tableaux of the same shape. It has various descriptions, all of which are of algorithmic nature, it has many remarkable properties, and it has applications in combinatorics and other areas such as representation theory. The correspondence has been generalized in numerous ways, notably by Knuth to what is known as the Robinson–Schensted–Knuth correspondence, and a further generalization to pictures by Zelevinsky.\nThe simplest description of the correspondence is using the Schensted algorithm (Schensted 1961), a procedure that constructs one tableau by successively inserting the values of the permutation according to a specific rule, while the other tableau records the evolution of the shape during construction. The correspondence had been described, in a rather different form, much earlier by Robinson (Robinson 1938), in an attempt to prove the Littlewood–Richardson rule. The correspondence is often referred to as the Robinson–Schensted algorithm, although the procedure used by Robinson is radically different from the Schensted–algorithm, and almost entirely forgotten. Other methods of defining the correspondence include a nondeterministic algorithm in terms of jeu de taquin.\nThe bijective nature of the correspondence relates it to the enumerative identity:\n\nwhere  denotes the set of partitions of n (or of Young diagrams with n squares), and tλ denotes the number of standard Young tableaux of shape λ.","alt_names":[],"name":"Robinson–Schensted correspondence","categories":["Algebraic combinatorics","Combinatorial algorithms","Permutations","Representation theory of finite groups"],"tag_line":"In mathematics, the Robinson–Schensted correspondence is a bijective correspondence between permutations and pairs of standard Young tableaux of the same shape."}}
,{"_index":"throwtable","_type":"algorithm","_id":"branch-and-cut","_score":0,"_source":{"description":"Branch and cut is a method of combinatorial optimization for solving integer linear programs (ILPs), that is, linear programming (LP) problems where some or all the unknowns are restricted to integer values. Branch and cut involves running a branch and bound algorithm and using cutting planes to tighten the linear programming relaxations. Note that if cuts are only used to tighten the initial LP relaxation, the algorithm is called cut and branch.","alt_names":["- Branch and cut :","...more on Wikipedia about Branch and cut","Branch & Cut","Branch and Cut","Branch and Cut (angla versio)","Branch and Cut (version anglesa)","Branch and Cut (versió anglesa)","Branch and Cut (versión inglesa)","Branch and Cut (versão inglesa)","Branch and Cut algorithm","Branch and cut","Branch and cut - Wikipedia, the free encyclopedia","Branch and cut - Wikipédia","Branch and cut Wikipedia the free encyclopedia","Branch and price - Wikipédia","Branch-and-Cut","Branch-and-Cut bei der wikipedia","Branch-and-Cut – Wikipedia","Branch-and-cut","Branch_and_Cut bei der wikipedia","Branch_and_cut","Lexikon: Branch-and-Cut - ComputerBase","Wikipedia article Branch and cut","Wikipedia article on Branch and cut","Wikipedia entry for Branch and cut","Wikipedia-Artikel Branch and Cut","Wikipedia-Artikel Branch-and-Cut","Wikipedia-Seite zu 'Branch-and-Cut'","Wikipedia: Branch and Cut","branch and cut","branch-and-cut","de:Branch-and-Cut","http://de.wikipedia.org/wiki/Branch-and-Cut","http://en.wikipedia.org/wiki/Branch_and_cut","http://en.wikipedia.org/wiki/Branch_and_cut (External Link","http://fr.wikipedia.org/wiki/Branch_and_cut","ko:분기 절단법","or cut","ramificación y corte","분기 절단법","분기 절단법 - 위키백과, 우리 모두의 백과사전","위키 피 디아 문서 분기 절단법"],"name":"Branch and cut","categories":["Combinatorial optimization","Optimization algorithms and methods"],"tag_line":"Branch and cut is a method of combinatorial optimization for solving integer linear programs (ILPs), that is, linear programming (LP) problems where some or all the unknowns are restricted to integer values."}}
,{"_index":"throwtable","_type":"algorithm","_id":"combinatorial-search","_score":0,"_source":{"description":"In computer science and artificial intelligence, combinatorial search studies search algorithms for solving instances of problems that are believed to be hard in general, by efficiently exploring the usually large solution space of these instances. Combinatorial search algorithms achieve this efficiency by reducing the effective size of the search space or employing heuristics. Some algorithms are guaranteed to find the optimal solution, while others may only return the best solution found in the part of the state space that was explored.\nClassic combinatorial search problems include solving the eight queens puzzle or evaluating moves in games with a large game tree, such as reversi or chess.\nA study of computational complexity theory helps to motivate combinatorial search. Combinatorial search algorithms are typically concerned with problems that are NP-hard. Such problems are not believed to be efficiently solvable in general. However, the various approximations of complexity theory suggest that some instances (e.g. \"small\" instances) of these problems could be efficiently solved. This is indeed the case, and such instances often have important practical ramifications.","alt_names":[],"name":"Combinatorial search","categories":["All articles lacking in-text citations","Analysis of algorithms","Articles lacking in-text citations from January 2013","Combinatorial optimization","Computational complexity theory","Game artificial intelligence","Search algorithms"],"tag_line":"In computer science and artificial intelligence, combinatorial search studies search algorithms for solving instances of problems that are believed to be hard in general, by efficiently exploring the usually large solution space of these instances."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fisher–yates-shuffle","_score":0,"_source":{"description":"The Fisher–Yates shuffle (named after Ronald Fisher and Frank Yates), also known as the Knuth shuffle (after Donald Knuth), is an algorithm for generating a random permutation of a finite set—in plain terms, for randomly shuffling the set. A variant of the Fisher–Yates shuffle, known as Sattolo's algorithm, may be used to generate random cyclic permutations of length n instead. The Fisher–Yates shuffle is unbiased, so that every permutation is equally likely. The modern version of the algorithm is also rather efficient, requiring only time proportional to the number of items being shuffled and no additional storage space.\nFisher–Yates shuffling is similar to randomly picking numbered tickets (combinatorics: distinguishable objects) out of a hat without replacement until there are none left.","alt_names":[],"name":"Fisher–Yates shuffle","categories":["Combinatorial algorithms","Monte Carlo methods","Permutations","Randomness"],"tag_line":"The Fisher–Yates shuffle (named after Ronald Fisher and Frank Yates), also known as the Knuth shuffle (after Donald Knuth), is an algorithm for generating a random permutation of a finite set—in plain terms, for randomly shuffling the set."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bsd-checksum","_score":0,"_source":{"description":"The BSD checksum algorithm is a commonly used, legacy checksum algorithm. It has been implemented in BSD and is also available through the GNU sum command line utility.\n\n","alt_names":["- BSD checksum :","BSD Legacy CRC","BSD checksum","BSD checksum - Wikipedia, the free encyclopedia","BSD checksum; it is used under the","BSD_checksum","What are sources of BSD checksum","Wikipedia article on BSD checksum","Wikipedia entry for BSD checksum","http://en.wikipedia.org/wiki/BSD_checksum","yago-res:BSD checksum"],"name":"BSD checksum","categories":["Checksum algorithms"],"tag_line":"The BSD checksum algorithm is a commonly used, legacy checksum algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"depth-first-search","_score":0,"_source":{"description":"Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. One starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.\nA version of depth-first search was investigated in the 19th century by French mathematician Charles Pierre Trémaux as a strategy for solving mazes.\n^ Charles Pierre Trémaux (1859–1882) École Polytechnique of Paris (X:1876), French engineer of the telegraph\nin Public conference, December 2, 2010 – by professor Jean Pelletier-Thibert in Académie de Macon (Burgundy – France) – (Abstract published in the Annals academic, March 2011 – ISSN: 0980-6032)\n^ Even, Shimon (2011), Graph Algorithms (2nd ed.), Cambridge University Press, pp. 46–48, ISBN 978-0-521-73653-4 .\n^ Sedgewick, Robert (2002), Algorithms in C++: Graph Algorithms (3rd ed.), Pearson Education, ISBN 978-0-201-36118-6 .","alt_names":["Depth-First-Search","processing order","parcours en profondeur","Depth-first search","depth-first","depth-first search","Tiefensuche","Depth-First Search","http://en.wikipedia.org/wiki/Depth-first_search","'Depth first'","(Deep Search First)","(http://en.wikipedia.org/wiki/Depth-first_search)","*Algoritmo de busca em profundidade (*DFS)","- Depth first search :","- Depth-first :","- Depth-first search :","-> Read the article about 'Depth-first search'","-En primer lugar la búsqueda de profundidad","-Prima ricerca di profondità","-Tìm theo chiều sâu","-prima ricerca in profondità","...Wikipedia Algorithme de parcours en profondeur","...Wikipedia Busca em profundidade","...Wikipedia Búsqueda en profundidad","...Wikipedia Depth First Search","...Wikipedia Przeszukiwanie w głąb","...mehr auf Wikipedia über Tiefensuche","...more on Wikipedia about Depth-first search","1 Output of a depth-first search","1 깊이 제한과 백트래킹","1.1 Vertex orderings","2 Kết quả của thuật toán","2.1 Duyệt các đỉnh","2.2 Ứng dụng","3 Output of a depth-first search","3 장점과 단점","3.1 Vertex orderings","4 Giải thuật (C++)","4 Implementation in Java","4 시간과 저장공간 분석","4.1 Depth-first search","5 Implementation in Python","5Fsearch http://en.wikipedia.org/wiki/Depth-first","5Fsearch% http://en.wikipedia.org/wiki/Depth-first",": prima ricerca approfondita","A depth-first-search","Algorithme de parcours en profondeur","Algorithme de parcours en profondeur - Wikipédia","Algoritmo de B@Ãº em profundidade (DFS)","Algoritmo de búsqueda en profundidad (DFS)","Auftragsdatenverarbeitung","B?squeda en profundidad - Wikipedia, la enciclopedia libre","Beispiel Algorithmus(formal)","Busca em profundidade","Busca em profundidade - Wikipédia, a enciclopédia livre","Busca em profundidade – Wikipédia","Busca em profundidade – Wikipédia, a enciclopédia livre","Búsqueda de profundidad (DFS):","Búsqueda en profundidad","Búsqueda en profundidad (DFS)","Búsqueda en profundidad - Wikipedia, la enciclopedia libre","Búsqueda_en_profundidad","Búsquedas en profundidad","Cerca en profunditat","Cerca en profunditat - ViquipÃ¨dia","Comme les autres algorithmes de parcours de graphe","DFS (Depth First Search)","DFS (Depth-First Search)","DFS (Depth-first search)","DFS (Tiefensuche)..","DFS (búsqueda en profundidad primero)..","DFS (depth first search).","DFS (depth-first search)","DFS (diepte eerste zoekactie).","DFS (hloubka prohledávání).","DFS (kedalaman pertama pencarian)..","DFS (primeira pesquisa de profundidade)..","DFS (primera búsqueda de profundidad).","DFS (profondità prima ricerca).","DFS (recherche en profondeur d'abord)..","DFS (ricerca approfondita prima)..","DFS (tìm kiếm sâu đầu tiên)..","DFS (глубина первой поиска)..","DFS (глубиной первого поиска).","DFS (ลึก ค้นหา แรก)..","DFS Algorithms","DFS algorithm (Depth-first search)","DFS on Wikipedia.","DFS on a date","DFS on wikipedia","DFS wiki","DFS wiki page","DFS 深度優先搜索","DFS(depth first search).","DFS(depth-first search，深度優先搜尋)","DFS-Baum","DFS-Depth First Search","DFS-haku","DFS-hakualgoritmia","DFS-hakualgoritmin","DFSem","DFSの","DFSを","DFS的（深度优先搜索）。 。","DFS的（深度优先搜索）。。","DFS的（深度優先搜索）。。","DFS는","DFS는 (깊이가 첫 번째 검색)..","DFS（http://en.wikipedia.org/wiki/Depth-first_search","DFS（深さ優先探索を）。 。","DFS（深度优先搜索）。","DFT (depth-first traversal)","DSF,","DSFが","Deep-First Search","Depth First","Depth First Search","Depth First Search (DFS)","Depth First Search Algorithm","Depth First Search DFS","Depth First Search Wiki","Depth First Search Wikipedia The Free Encyclopedia","Depth First Search algorithm,","Depth First Search, Búsqueda en profundidad para grafos","Depth First Traversal","Depth First search","Depth first","Depth first Search","Depth first seach (DFS)","Depth first search","Depth first search Wikipedia the free encyclopedia","Depth-First","Depth-First Search (DFS)","Depth-First Search - Wikipedia","Depth-First Search Algorithm","Depth-First Search algorithm","Depth-First Search.","Depth-First Traversierung","Depth-First search","Depth-First search (DFS)","Depth-First search algorithm","Depth-First-","Depth-First-Suche","Depth-First-Suche.","Depth-first","Depth-first Search","Depth-first Search - Wikipedia, The Free Encyclopedia","Depth-first Search algorithm,","Depth-first order","Depth-first seach","Depth-first searc","Depth-first search (Búsqueda en profundidad)","Depth-first search (DFS)","Depth-first search (DFS) is an algorithm for","Depth-first search (DFS).","Depth-first search (englische Wikipedia)","Depth-first search - Wikipedia","Depth-first search - Wikipedia :: The free encyclopedia","Depth-first search - Wikipedia, the free encyclop...","Depth-first search - Wikipedia, the free encyclopedia","Depth-first search - Wikipedia, the free encyclopedia ...","Depth-first search by Wikipedia","Depth-first search from Wikipedia","Depth-first search#Output of a depth-first","Depth-first search; it is used under the","Depth-first searching (DFS)","Depth-first sorting","Depth-first traversal","Depth-first traversal.","Depth-first tree search in PHP","Depth-first_search","Depthth-first sorting","Diafnsuach","Diafnsuach. Aus Wikipedia","Diepte Zoek eerst","Diepte eerst zoeken","Diepte-eerst zoeken","Djup-först sökning","Djup-först-sökning","Dybde Første Søg","Dybde første søgning","Dybde-First Search","Dybde-først søgning","Formally, DFS is an uninformed search that progresses","Głębokość Najpierw szukaj","Głębokość Pierwszy Szukaj","Głębokość Szukaj Pierwszy","Hloubky hledání","In theoretical computer science, DFS is typically used","Kiếm theo chiều sâu","La búsqueda en profundidad","Lalim Unang-Search.","Le parcours d'un arbre en profondeur","Learn about Depth-first search>>>","Output of a depth-first search","Paieška į gylį","Pesquisa em Profundidade na Wikipedia","Procura em profundidade","Programa em Pascal de Busca em Profundidade","Prohledavaní do hloubky","ProhledÃ¡vÃ¡nÃ do hloubky - Wikipedie","Prohledávání do hloubky","Prohledávání do hloubky - Wikipedie","Przeszukiwanie w gb wolna encyklopedia","Przeszukiwanie w glab – Wikipedia, wolna encyklopedia","Przeszukiwanie w głąb","Przeszukiwanie w głąb – Wikipedia, wolna encyklopedia","Read More busca em profundidade wikipédia a enciclopédia","Read More depthfirst search wikipedia the free encyclopedia","Reverse postorder","Ricerca depth-first","Ricerca depth-first - Wikipedia","Ricerca in profondità","Ricerca per profondità","Syvyyssuuntainen läpikäynti","También en ingles.","Tiefe Verwendung-first-Suche","Tiefe gegen-first search (DFS).","Tiefe gehen-erste erschöpfende Suche.","Tiefensuche (deutsche Wikipedia)","Tiefensuche - Wikipedia","Tiefensuche ? Wikipedia","Tiefensuche â€“ Wikipedia","Tiefensuche – Wikipedia","Tiefensuche,","Tiefensuchen Algorithmus für Graphen","Tm kim theo chiu su ting Vit","Traverse depth-first","Tree Search algorithm","Tìm ki?m theo chi?u sâu","Tìm kiếm theo chiều sâu","Tìm kiếm theo chiều sâu - Wikipedia tiếng Việt","Tìm kiếm theo chiều sâu – Wikipedia tiếng Việt","T√¨m ki·∫øm theo chi·ªÅu s","Visita depth-first","Visita in profondit? - Wikipedia","Visita in profondità - Wikipedia","W.412 Wikipedia: Depth-first search","W: Depth-first search","What is DFS algorithm's example?","What is Depth first search's example?","What is formal definition of DFS algorithm?","Wiki: Ang lalim-unang paghahanap","Wiki: Busca em profundidade","Wiki: Depth-first search","Wiki: La búsqueda en profundidad","Wiki: Tiefensuche","Wiki: ricerca in profondità","Wiki: tìm kiếm theo chiều sâu","Wiki: Поиск в глубину","Wiki: ความ ลึก ของ การ ค้นหา ก่อน","Wiki:Depth-first search","Wikipedia (Busca em profundidade)","Wikipedia : Depth-first Search","Wikipedia Tiefensuche","Wikipedia article Busca em profundidade","Wikipedia article Búsqueda en profundidad","Wikipedia article Depth first search","Wikipedia article Depth-first","Wikipedia article Depth-first search","Wikipedia article Depth-first_search","Wikipedia article Tiefensuche","Wikipedia article on Depth-first search","Wikipedia article on Primero en profundidad","Wikipedia article Пошук у глибину","Wikipedia article אלגוריתם חיפוש לעומק","Wikipedia artikel Diepte-eerst zoeken","Wikipedia entry for Depth-first search","Wikipedia sur Parcours en profondeur","Wikipedia – Depth First Search","Wikipedia-Artikel Depth-First Search","Wikipedia-Artikel Tiefensuche","Wikipedia-Seite zu 'Depth-First Search'","Wikipedia-Seite zu 'Tiefensuche'","Wikipedia-Seite: Tiefensuche","Wikipedia: DFS (Depth First Search)","Wikipedia: Depth-First Search","Wikipedia: Depth-first search","Wikipedia: Dybde-først søk","Wikipedia: Parcurgere în adâncime","Wikipedia: Tiefensuche","Wikipedia: depth-first search","Wikipedia::Depth-first_search","Wikipedia:Depth-first search","Wikipedia:Depth-first_search","Wikipedia:Visita_in_profondità","Wikipedia_DFS","Wikipediaで「深さ優先探索」を調べる","Wikipédia artigo Busca em profundidade","[8] Depth-first search","a depth-first-search graph traversal","algorithm: Depth-first search - Wikipedia, the free encyclopedia","algorithme de parcours en profondeur","algorithme de parcours en profondeur sans marquage","algoritmus,","algorytm przeszukiwania w głąb","artigo da Wikipédia Busca em profundidade","artículo de Wikipedia Busqueda en profundidad","artículo de Wikipedia Búsqueda en profundidad","artículo de Wikipedia Primero en profundidad","back edge","bar:Diafnsuach","busca em profundidade","búsqueda en profundidad","búsqueda en profundidad (DFS).","búsqueda en profundidad,","búsqueda en profundidad-o","ca:Cerca en profunditat","cerca en profunditat","chiều sâu một-lần đầu tiên mang tính","chiều sâu đầu tìm kiếm.","chiều sâu-đầu tiên tìm kiếm,","cs:Prohledávání do hloubky","de sesiones de búsqueda en profundidad","de verwerking van order","de:Tiefensuche","deep search","deep-first search","depth Search (DFS ):","depth first","depth first algorithm","depth first crawl","depth first manner","depth first recursion","depth first search","depth first search (DFS)","depth first search algorithm","depth first search order","depth first traversal algorithm","depth first tree search","depth first tree searching algorithm","depth-first algortimen","depth-first exhaustive search","depth-first graph traversal","depth-first order","depth-first seach","depth-first search (DFS)","depth-first search strategy","depth-first searches","depth-first searching","depth-first traveral","depth-first tree traversal","depth-first-retrieval technique","depth-first-search","depth-first-search order","depthfirst","diepte eerst zoeken","diepte eerste","diepte-eerst","diepte-eerst zoeken","do hloubky","dsf,","dybde først søk","dybde første søgning","dybde-først","dybde-først søgning","dybden-first søgning","el procesamiento de pedidos","en profondeur d'abord","en profundidad de la búsqueda","en.wikipedia.org/wiki/Depth-first_search","en.wikipedia.org/wiki/Depth_first_search","en:Depth-first search","epth-first search","es:Búsqueda en profundidad","external image 300px-Depth-first-tree.svg.png","fa:الگوریتم جستجوی اول عمق","fa:الگوریتم جستجوی عمق اول","fi:Syvyyssuuntainen läpikäynti","fr.wikipedia.org/...thme_de_parcours_en_profondeur","fr:Algorithme de parcours en profondeur","gylis iš pradžių ieško","głębokość wyszukiwania pierwszym","he:אלגוריתם חיפוש לעומק","http ://fr.wikipedia.org/wiki/Algorithme de parcours","http://bar.wikipedia.org/wiki/Diafnsuach","http://cs.wikipedia.org/wiki/Prohledávání_do_hloubky","http://de.wikipedia.org/wiki/Depth-First_Search","http://de.wikipedia.org/wiki/Ti efensuche","http://de.wikipedia.org/wiki/Ti efensuche#Laufzeit","http://de.wikipedia.org/wiki/Tiefensuche","http://en.wikipedia.org/wiki/Depth-first","http://en.wikipedia.org/wiki/Depth-first (l","http://en.wikipedia.org/wiki/Depth-first 5Fsearch","http://en.wikipedia.org/wiki/Depth-first _search","http://en.wikipedia.org/wiki/Depth-first search","http://en.wikipedia.org/wiki/Depth-first% 5Fsearch","http://en.wikipedia.org/wiki/Depth-first%5Fsearch","http://en.wikipedia.org/wiki/Depth-first...","http://en.wikipedia.org/wiki/Depth-first_sear...","http://en.wikipedia.org/wiki/Depth-first_searc","http://en.wikipedia.org/wiki/Depth-first_search#Applications","http://en.wikipedia.org/wiki/Depth-first_search#Formal_definition","http://en.wikipedia.org/wiki/Depth-first_search#Implementation_in_Python","http://en.wikipedia.org/wiki/Depth-first_search#Vertex_orderings","http://en.wikipedia.org/wiki/Depth-first_search.","http://en.wikipedia.org/wiki/Depth-first…","http://en.wikipedia.org/wiki/Depth-first％5Fsearch","http://en.wikipedia.org/wiki/Depth-first％の","http://en.wikipedia.org/wiki/Depth_fir","http://en.wikipedia.org/wiki/Depth_first_search","http://en.wikipedia.org/wiki/Depth_first…","http://en.wikipedia.org/wiki/Depth−first_search","http://en.wikipedia.org/wiki/depth-first_search","http://es.wikipedia.org/wiki/B%C3%BAsqueda_en_profundidad","http://es.wikipedia.org/wiki/Busqueda_en_profundidad","http://fr.wikipedia....s_en_profondeur","http://fr.wikipedia.org/wiki/Algorit..._en_profondeur","http://fr.wikipedia.org/wiki/Algorithme_de...s_en_profondeur","http://fr.wikipedia.org/wiki/Algorithme_de_parcours_en_profondeur","http://he.wikipedia.org/wiki/DFS","http://he.wikipedia.org/wiki/אלגוריתם_חיפוש_לעומק","http://it.wikipedia.org/wiki/Depth-first_search","http://it.wikipedia.org/wiki/Ricerca_depth-first","http://it.wikipedia.org/wiki/Visita_in_profondit%C3%A0","http://ja.wikipedia.org/wiki/深さ優先探索","http://ko.wikipedia.org/wiki/%EA%B9%8A","http://nl.wikipedia.org/wiki/Diepte-eerst_zoeken","http://pl.wikipedia....ukiwanie_w_głąb","http://pl.wikipedia.org/wiki/Depth_First_Search","http://pl.wikipedia.org/wiki/Przeszukiwanie_w_g%C5%82","http://pl.wikipedia.org/wiki/Przeszukiwanie_w_głąb","http://pl.wikipedia.org/wiki/Pżeszukiwanie_w_g%C5%82","http://pt.wikipedia....em_profundidade","http://pt.wikipedia.org/wiki/Busca_em_profundidade","http://ru.wikipedia.org/wiki/Поиск_в_глу...","http://ru.wikipedia.org/wiki/Поиск_в_глубину","http://zh.wikipedia.org/wiki/深度优先搜索","in profondità","it:Depth-first search","it:Ricerca depth-first","ja.wikipedia.org/wiki/深さ優先探索","ja:深さ優先探索","kedalaman-pertama pencarian lengkap.","kiếm theo chiều sâu (DFS).","ko:깊이 우선 탐색","like O(n)","lt:Paieška į gylį","maggiori info su DFS","malalim na-unang paghahanap,","modifica del DFS","mélységi bejárás","möglichen Anwendungen für die Tiefensuche","n DFS search","najpierw wgłąb","nl:Diepte-eerst zoeken","paiešką į gylį","pencarian depth-first,","pl:Przeszukiwanie w głąb","pořadí zpracování","preorder numbers","prima profondità","prima ricerca in profondità","primeiro profundidade","primera búsqueda de profundidad","primera búsqueda en profundidad","primero en profundidad","primo Profondità della ricerca","procura em profundidade,","profondeur d'abord,","profondeur d'abord-ou","profondeur de première recherche exhaustive.","profondità Ricerca","profondità prima ricerca","profondità prima ricerca esaustiva.","profundidad Primera Búsqueda","profundidad Primera Consulta.","profundidad de búsqueda exhaustiva primero.","profundidad primera búsqueda","profundidad primero","profundidade de pesquisa de primeira","profundidade primeira pesquisa (DFS).","profundidade primeira pesquisa exaustiva.","prohledávání do hloubky","przeszukiwania w głąb","przyszło Ci na myśl coś takiego","pseudo code for DFS from wikipedia:","pt:Busca em profundidade","pth-first r","på djupet","realizacji zamówienia","recherche en profondeur","recherche en profondeur d'abord (DFS).","reverse post order","reverse post-order","reverse postorder","reverse postorder traversal","ricerca in profondità (DFS).","ricerca in profondità,","ricerca in profondità-o","ru:Поиск в глубину","sv:Djup-först-sökning","syvyyshaulla","traversing it","tìm kiếm theo chiều sâu","tìm kiếm theo độ sâu","uk:Пошук в глибину","uk:Пошук у глибину","vi:Tìm kiếm theo chiều sâu","visita in profondità","w:Depth-first search","wglab","wglab wyszukiwania","wikipedia:Depth-first_search","wikipedia:深さ優先探索","wp:Depth-first search","zh:深度优先搜索","zovoort","Đọc thêm ở đây","độ sâu-đầu-tìm kiếm","į gylį","άρθρο από Wikipedia","Википедии статью Поиск в глубину","Обход в глубину на ru.wikipedia.org","Поиск в глубину","Поиск в глубину (DFS, Depth-First Search)","Поиск в глубину - Википедия","Пошук в глибину","Пошук у глибину","Пошук у глибину — Вікіпедія","алгоритм обхода графа в глубину","в глубину","в глубину поиска (DFS).","глубина первой","глубиной первого поиска","глубиной перебора.","глубину-поиска","гүний нэвтрэлт","обработка заказов","обход графа в глубину","обхода графа в глубину","первых Глубина поиска","поиск в глубину","поиска в глубину","поиска в глубину,","поиска в глубину.","поиском в глубину","אלגוריתם חיפוש לעומק","אלגוריתם חיפוש לעומק – ויקיפדיה","ויקיפדיה - 'אלגוריתם חיפוש לעומק'","חיפוש DFS בגרף","الگوریتم جستجوی اول عمق","الگوریتم جستجوی عمق اول","الگوریتم جستجوی عمق اول - ویکیپدیا","جستجوي عمقي يا dfs","جستجوی عمق اول","جستوجوي عمق اول","جستوجوی عمق اول","गहराई पहले खोज","पहले या गहराई","ডি.এফ.এস.","ความ ลึก การ ค้นหา ครั้ง แรก,","ความ ลึก การ ค้นหา หมดจด แรก.","ความ ลึก การ ค้นหา แรก (DFS).","ความ ลึก ของ การ ค้นหา ก่อน","ความ ลึก-First Search.","ลึก","“depth first search”","“depth-first”","、DFSの","、DFS（http://en.wikipedia.org/wiki/Depth-first_search","、最初の検索","、深さ優先探索（DFS）を","「深さ優先探索」をWikipediaで調べる","のDFS（深さ優先検索）。","の深さ","ウィキペディアの記事 深さ優先探索","ウィキ：深さ優先探索","バックトラック法(深さ優先探索法)","反向边、交叉边","处理顺序","娣卞害浼樺厛鎼滅储锛岃嚜鐢辩殑鐧剧鍏ㄤ功- 缁村熀鐧剧","深さ優先","深さ優先の検索","深さ優先探索","深さ優先探索 - Wikipedia","深さ優先探索 – Wikipedia","深さ優先探索(depth-first search,DFS)","深さ優先探索-wikipedia","深さ優先探索は、","深さ優先探索を","深さ優先探索（バックトラック法） - Wikipedia","深さ優先検索","深さ優先検索 (DFS)","深さ第一","深度优先","深度优先搜索","深度优先搜索- 维基百科，自由的百科全书","深度优先搜索法","深度优先搜索（DFS） 。","深度优先搜索（DFS）的","深度优先搜索，自由的百科全书- 维基百科","深度优先穷举搜索","深度優先尋訪（depth-first traversal）","深度優先搜尋(Depth-First Search，DFS)","深度優先搜索","深度優先搜索（DFS）的","深度優先窮舉搜索","的DFS","的深度优先搜索","維基百科的文章“ 深度优先搜索”","維基百科的文章“ 深度优先搜索法”","維基百科～Depth-first_search","維基：深度優先搜索","縦型探索法 (深さ優先探索法) depth-first search","维基百科的文章“ 深度优先搜索”","维基：深度优先搜索","色散位移光纖","色散位移光纤","깊이 - 우선 검색을위한","깊이 우선 탐색","깊이 우선 탐색 - 위키백과, 우리 모두의 백과사전","깊이 우선 탐색(DFS)","깊이 최초로 검색","깊이에 최초로 검색 (DFS의)","깊이와","심층 최초 검색,","위키 : 깊이 최초로 검색","최초로 검색","（http://en.wikipedia.org/wiki/Depth-first％"],"name":"Depth-first search","categories":["All articles needing additional references","Articles containing video clips","Articles needing additional references from July 2010","Articles with example pseudocode","Commons category with local link same as on Wikidata","Graph algorithms","Search algorithms"],"tag_line":"Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bidirectional-search","_score":0,"_source":{"description":"Bidirectional search is a graph search algorithm that finds a shortest path from an initial vertex to a goal vertex in a directed graph. It runs two simultaneous searches: one forward from the initial state, and one backward from the goal, stopping when the two meet in the middle. The reason for this approach is that in many cases it is faster: for instance, in a simplified model of search problem complexity in which both searches expand a tree with branching factor b, and the distance from start to goal is d, each of the two searches has complexity O(bd/2) (in Big O notation), and the sum of these two search times is much less than the O(bd) complexity that would result from a single search from the beginning to the goal.\nAs in A* search, bi-directional search can be guided by a heuristic estimate of the remaining distance to the goal (in the forward tree) or from the start (in the backward tree).\nIra Pohl (1971) was the first one to design and implement a bi-directional heuristic search algorithm. Andrew Goldberg and others explained the correct termination conditions for the bidirectional version of Dijkstra’s Algorithm.","alt_names":["Bidirectional Algorithm","- Bidirectional search :","...more on Wikipedia about Bidirectional search","Bi-Directional","Bi-directional search","Bidirectional Search","Bidirectional Search.","Bidirectional search","Bidirectional search - Wikipedia :: The free encyclopedia","Bidirectional search - Wikipedia, the free encyclopedia","Bidirectional search by Wikipedia","Bidirektionale Suche","Bidirektionale Suche ? Wikipedia","Bidirektionale Suche – Wikipedia","Busca Bi-Direcional","Busca bidirecional","Wikipedia (Bidirectional search)","Wikipedia article Bidirectional search","Wikipedia article on Bidirectional search","Wikipedia entry for Bidirectional search","Wikipedia-Artikel Bidirektionale Suche","Wikipediaで「双方向探索」を調べる","bi-directional search algorithm","bi-directional searching","bidirectional BFS","bidirectional breadth-first search","bidirectional searc","bidirectional search","bidirektionale Suchschemata","de:Bidirektionale Suche","en.wikipedia.org/wiki/Bidirectional_search","http://de.wikipedia.org/wiki/Bidirektionale_Suche","http://en.wikipedia.org/wiki/Bidirectional_se...","http://en.wikipedia.org/wiki/Bidirectional_search","http://ru.wikipedia.org/wiki/Двунаправленный_поиск","kétirányú keresés","recherche bi-directionnelle","recherche bidirectionnelle","ricerca bidirezionale","Википедии статью Двунаправленный поиск","Двунаправленный поиск","ウィキペディアの記事 双方向探索","双方向探索","双方向探索 - Wikipedia","双方向探索 -wikipedia","双方向探索とは？ (Wikipediaへのリンク)"],"name":"Bidirectional search","categories":["Graph algorithms","Search algorithms"],"tag_line":"Bidirectional search is a graph search algorithm that finds a shortest path from an initial vertex to a goal vertex in a directed graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"euclidean-shortest-path","_score":0,"_source":{"description":"The Euclidean shortest path problem is a problem in computational geometry: given a set of polyhedral obstacles in a Euclidean space, and two points, find the shortest path between the points that does not intersect any of the obstacles.\nIn two dimensions, the problem can be solved in polynomial time in a model of computation allowing addition and comparisons of real numbers, despite theoretical difficulties involving the numerical precision needed to perform such calculations. These algorithms are based on two different principles, either performing a shortest path algorithm such as Dijkstra's algorithm on a visibility graph derived from the obstacles or (in an approach called the continuous Dijkstra method) propagating a wavefront from one of the points until it meets the other.\nIn three (and higher) dimensions the problem is NP-hard in the general case , but there exist efficient approximation algorithms that run in polynomial time based on the idea of finding a suitable sample of points on the obstacle edges and performing a visibility graph calculation using these sample points.\nThere are many results on computing shortest paths which stays on a polyhedral surface. Given two points s and t, say on the surface of a convex polyhedron, the problem is to compute a shortest path that never leaves the surface and connects s with t. This is a generalization of the problem from 2-dimension but it is much easier than the 3-dimensional problem.\nAlso, there are variations of this problem, where the obstacles are weighted, i.e., one can go through an obstacle, but it incurs an extra cost to go through an obstacle. The standard problem is the special case where the obstacles have infinite weight. This is termed as the weighted region problem in the literature.","alt_names":["Euclidean shortest path","Euclidean shortest path - Wikipedia, the free encyclopedia","Euclidean shortest path - Wikipedia, the free encyclopedia ...","Euclidean shortest path Wikipedia the free encyclopedia","Euclidean shortest paths","Overview: Euclidean Shortest-Path Calculations","Wikipedia article Euclidean shortest path","Wikipedia article on Euclidean shortest path","Wikipedia entry for Euclidean shortest path","http://en.wikipedia.org/wiki/Euclidean shortest path","http://en.wikipedia.org/wiki/Euclidean_shortest_path","„Euclidean shortest path problem“"],"name":"Euclidean shortest path","categories":["All stub articles","Combinatorics stubs","Computational geometry","Geometric algorithms","Geometry stubs"],"tag_line":"The Euclidean shortest path problem is a problem in computational geometry: given a set of polyhedral obstacles in a Euclidean space, and two points, find the shortest path between the points that does not intersect any of the obstacles."}}
,{"_index":"throwtable","_type":"algorithm","_id":"blossom-algorithm","_score":0,"_source":{"description":"The blossom algorithm is an algorithm in graph theory for constructing maximum matchings on graphs. The algorithm was developed by Jack Edmonds in 1961, and published in 1965. Given a general graph G = (V, E), the algorithm finds a matching M such that each vertex in V is incident with at most one edge in M and |M| is maximized. The matching is constructed by iteratively improving an initial empty matching along augmenting paths in the graph. Unlike bipartite matching, the key new idea is that an odd-length cycle in the graph (blossom) is contracted to a single vertex, with the search continuing iteratively in the contracted graph.\nA major reason that the blossom algorithm is important is that it gave the first proof that a maximum-size matching could be found using a polynomial amount of computation time. Another reason is that it led to a linear programming polyhedral description of the matching polytope, yielding an algorithm for min-weight matching. As elaborated by Alexander Schrijver, further significance of the result comes from the fact that this was the first polytope whose proof of integrality \"does not simply follow just from total unimodularity, and its description was a breakthrough in polyhedral combinatorics.\"","alt_names":[],"name":"Blossom algorithm","categories":["CS1 errors: invisible characters","Graph algorithms","Matching"],"tag_line":"The blossom algorithm is an algorithm in graph theory for constructing maximum matchings on graphs."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bron–kerbosch-algorithm","_score":0,"_source":{"description":"In computer science, the Bron–Kerbosch algorithm is an algorithm for finding maximal cliques in an undirected graph. That is, it lists all subsets of vertices with the two properties that each pair of vertices in one of the listed subsets is connected by an edge, and no listed subset can have any additional vertices added to it while preserving its complete connectivity. The Bron–Kerbosch algorithm was designed by Dutch scientists Joep Kerbosch and Coenraad Bron, who published its description in 1973. Although other algorithms for solving the clique problem have running times that are, in theory, better on inputs that have few maximal independent sets, the Bron–Kerbosch algorithm and subsequent improvements to it are frequently reported as being more efficient in practice than the alternatives. It is well-known and widely used in application areas of graph algorithms such as computational chemistry.\nA contemporaneous algorithm of Akkoyunlu (1973), although presented in different terms, can be viewed as being the same as the Bron–Kerbosch algorithm, as it generates the same recursive search tree.","alt_names":[],"name":"Bron–Kerbosch algorithm","categories":["Articles with example pseudocode","Graph algorithms"],"tag_line":"In computer science, the Bron–Kerbosch algorithm is an algorithm for finding maximal cliques in an undirected graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"borůvka's-algorithm","_score":0,"_source":{"description":"Borůvka's algorithm is an algorithm for finding a minimum spanning tree in a graph for which all edge weights are distinct.\nIt was first published in 1926 by Otakar Borůvka as a method of constructing an efficient electricity network for Moravia. The algorithm was rediscovered by Choquet in 1938; again by Florek, Łukasiewicz, Perkal, Steinhaus, and Zubrzycki in 1951; and again by Sollin  in 1965. Because Sollin was the only computer scientist in this list living in an English speaking country, this algorithm is frequently called Sollin's algorithm, especially in the parallel computing literature.\nThe algorithm begins by first examining each vertex and adding the cheapest edge from that vertex to another in the graph, without regard to already added edges, and continues joining these groupings in a like manner until a tree spanning all vertices is completed.","alt_names":[],"name":"Borůvka's algorithm","categories":["CS1 Czech-language sources (cs)","CS1 French-language sources (fr)","CS1 maint: Unrecognized language","Graph algorithms","Spanning tree"],"tag_line":"Borůvka's algorithm is an algorithm for finding a minimum spanning tree in a graph for which all edge weights are distinct."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bland's-rule","_score":0,"_source":{"description":"In mathematical optimization, Bland's rule (also known as Bland's algorithm or Bland's anti-cycling rule) is an algorithmic refinement of the simplex method for linear optimization.\nWith Bland's rule, the simplex algorithm solves feasible linear optimization problems without cycling. There are examples of degenerate linear optimization problems on which the original simplex algorithm would cycle forever. Such cycles are avoided by Bland's rule for choosing a column to enter the basis.\nBland's rule was developed by Robert G. Bland, now a professor of operations research at Cornell University.","alt_names":["Bland's rule","- Bland's rule :","Bland's Rule","Bland's anti-cycling rule","Bland's rule - Wikipedia, the free ...","Bland's rule - Wikipedia, the free encyclopedia","Bland's_rule","What is algorithm of Bland's rule","Wikipedia (Bland's rule)","Wikipedia article Bland's Rule","Wikipedia article Bland's rule","en.wikipedia.org/wiki/Bland's_rule","http://en.wikipedia.org/wiki/Bland%27s_rule","least-index pivoting rule of Bland"],"name":"Bland's rule","categories":["Exchange algorithms","Optimization algorithms and methods","Oriented matroids"],"tag_line":"In mathematical optimization, Bland's rule (also known as Bland's algorithm or Bland's anti-cycling rule) is an algorithmic refinement of the simplex method for linear optimization."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dijkstra–scholten-algorithm","_score":0,"_source":{"description":"The Dijkstra–Scholten algorithm (named after Edsger W. Dijkstra and Carel S. Scholten) is an algorithm for detecting termination in a distributed system. The algorithm was proposed by Dijkstra and Scholten in 1980.\nFirst, let us consider the case of a simple process graph which is a tree. A distributed computation which is tree-structured is not uncommon. Such a process graph may arise when the computation is strictly a divide-and-conquer type. A node starts the computation and divides the problem in two (or more, usually a multiple of 2) roughly equal parts and distribute those parts to other processors. This process continues recursively until the problems are of sufficiently small size to solve in a single processor.","alt_names":[],"name":"Dijkstra–Scholten algorithm","categories":["Graph algorithms","Termination algorithms"],"tag_line":"The Dijkstra–Scholten algorithm (named after Edsger W. Dijkstra and Carel S. Scholten) is an algorithm for detecting termination in a distributed system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"knuth's-simpath-algorithm","_score":0,"_source":{"description":"Simpath is an algorithm introduced by Donald Knuth that constructs a zero-suppressed decision diagram (ZDD) representing all simple paths between two vertices in a given graph.\n^ Knuth, Donald (2009). The Art of Computer Programming, Volume 4, Fascicle 1. Addison-Wesley Professional: Boston, MA, USA. \n^ \"Finding All Solutions and Instances of Numberlink and Slitherlink by ZDDs\". Algorithms 5: 176–213. 2012. doi:10.3390/a5020176.","alt_names":[],"name":"Knuth's Simpath algorithm","categories":["Algorithms and data structures stubs","All stub articles","Commons category without a link on Wikidata","Computer science stubs","Graph algorithms","Mathematical logic","Theoretical computer science"],"tag_line":"Simpath is an algorithm introduced by Donald Knuth that constructs a zero-suppressed decision diagram (ZDD) representing all simple paths between two vertices in a given graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"johnson's-algorithm","_score":0,"_source":{"description":"Johnson's algorithm is a way to find the shortest paths between all pairs of vertices in a sparse, edge weighted, directed graph. It allows some of the edge weights to be negative numbers, but no negative-weight cycles may exist. It works by using the Bellman–Ford algorithm to compute a transformation of the input graph that removes all negative weights, allowing Dijkstra's algorithm to be used on the transformed graph. It is named after Donald B. Johnson, who first published the technique in 1977.\nA similar reweighting technique is also used in Suurballe's algorithm for finding two disjoint paths of minimum total length between the same two vertices in a graph with non-negative edge weights.","alt_names":["Johnsona","Johnson's algorithm - Wikipedia, the free encyclopedia","- Johnson's algorithm :","...more on Wikipedia about Johnson's algorithm","Algoritmo de Johnson","Algoritmo de Johnson - Wikipedia, la enciclopedia libre","Algoritmo de Johnson – Wikipédia, a enciclopédia livre","Algorytm Johnsona","Algorytm Johnsona – Wikipedia, wolna encyklopedia","El algoritmo de Johnson","Johnson Algorithm","Johnson algo","Johnson algorithm","Johnson s algorithm - Wikipedia, the free encyclopedia","Johnson s algorithm Wikipedia the free encyclopedia","Johnson のアルゴリズム","Johnson&#39;s algorithm - Wikipedia, the free encyclopedia","Johnson''s algorithm","Johnson's Algorithm","Johnson's algorithm","Johnson's algorithm (Ш)","Johnson's algorithm - Wikipedia :: The free encyclopedia","Johnson's algorithm - Wikipedia on Ask.com","Johnson's algorithm - Wikipedia, the free ...","Johnson's algorithm by Wikipedia","Johnson's algorithm from Wikipedia","Johnson's algorithm: Algorithm description","Johnson's algorithm: Example","Johnson's algoritme","Johnson's_algorithm","Johnsonův algoritmus","Learn about Johnson's algorithm>>>","What is Johnson algorithm's example","Wikipedia (Johnson's algorithm)","Wikipedia article Algoritmo de Johnson","Wikipedia article Algorytm Johnsona","Wikipedia article Johnson algorithm","Wikipedia article Johnson's algorithm","Wikipedia::Johnson's_algorithm","[9] Johnson's algorithm to find the shortest paths","algoritmo de Johnson","algortime de Johnson","algorytm Johnsona","cs:Johnsonův_algoritmus","en.wikipedia.org/wiki/Johnson%27s_algorithm","en.wikipedia.org/wiki/Johnson's_algorithm","es.wikipedia.org/wiki/Algoritmo_de_Johnson","fa9eef150b92c4aa7fc1aee5d00a ...","frequency of shortest","http://cs.wikipedia.org/wiki/Johnson%C5%AFv_algoritmus","http://en.wikipedia.org/wiki/Johnson%27s_algorithm","http://en.wikipedia.org/wiki/Johnson's_algorithm","http://en.wikipedia.org/wiki/Johnson's_algorithm.","http://en.wikipedia.org/wiki/Johnson_algo-","http://en.wikipedia.org/wiki/Johnson_algorithm","http://es.wikipedia.org/wiki/Algoritmo_de_Johnson","http://pl.wikipedia.org/wiki/Algorytm_Johnsona","l'algoritmo di Johnson","m Wikipedia::Johnson's_algorithm","pl.wikipedia.org/wiki/Algorytm_Johnsona","ru:Алгоритм Джонсона","t path structure).","w:Johnson's algorithm","Алгоритм Джонсона","АлгоритмДжонсона","алгоритм Джонсона","האלגוריתם של ג'ונסון","האלגוריתם של ג'ונסון – ויקיפדיה","ויקיפדיה - 'האלגוריתם של ג'ונסון'","الگوریتم جانسون","الگوریتم جانسون - ویکیپدیا","ジョンソンのアルゴリズムを","约翰逊的算法"],"name":"Johnson's algorithm","categories":["Graph algorithms"],"tag_line":"Johnson's algorithm is a way to find the shortest paths between all pairs of vertices in a sparse, edge weighted, directed graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"kosaraju's-algorithm","_score":0,"_source":{"description":"In computer science, Kosaraju's algorithm (also known as the Kosaraju–Sharir algorithm) is a linear time algorithm to find the strongly connected components of a directed graph. Aho, Hopcroft and Ullman credit it to an unpublished paper from 1978 by S. Rao Kosaraju. The same algorithm was independently discovered by Micha Sharir and published by him in 1981. It makes use of the fact that the transpose graph (the same graph with the direction of every edge reversed) has exactly the same strongly connected components as the original graph.\n\n","alt_names":["new algorithm","Kosaraju's algorithm - Wikipedia, the free encyclopedia","Kosaraju's algorithm","- Kosaraju's algorithm :","5.1 Strongly connected components","Agoritmo","Kosaraju algoritme","Kosaraju algoritms","Kosaraju algoritmus","Kosaraju s algorithm Wikipedia the free encyclopedia","Kosaraju's","Kosaraju's Algorithm","Kosaraju's Algorithm?","Kosaraju's algorithm - Wikipedia :: The free encyclopedia","Kosaraju's algorithm - Wikipedia, the free ...","Kosaraju's algorithm by Wikipedia","Kosaraju's algorithm.","Kosaraju's algoritme","Kosaraju's_algorithm","Kosaraju-Algorithmus","Kosaraju-Sharir","Kosarajuのアルゴリズム","Kosaraju的算法","Kosaraju算法","Kosoraju","Wikipedia article Kosaraju's algorithm","algoritmo de Kosaraju","algoritmo de S. Rao Kosaraju","algoritmul lui Kosaraju","http://en.wikipedia.org/wiki/Kosaraju%27s_algorithm","http://en.wikipedia.org/wiki/Kosaraju's_algorithm","http://en.wikipedia.​org/wiki/Kosaraju%27​s_algorithm","l'algoritmo Kosaraju","los algoritmos Kosaraju","w Algorithm Kosaraju","Алгоритм Kosaraju","Алгоритм Косарайю","Википедии статью Алгоритм Косарайю"],"name":"Kosaraju's algorithm","categories":["Graph algorithms","Graph connectivity"],"tag_line":"In computer science, Kosaraju's algorithm (also known as the Kosaraju–Sharir algorithm) is a linear time algorithm to find the strongly connected components of a directed graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"karger's-algorithm","_score":0,"_source":{"description":"In computer science and graph theory, Karger's algorithm is a randomized algorithm to compute a minimum cut of a connected graph. It was invented by David Karger and first published in 1993.\nThe idea of the algorithm is based on the concept of contraction of an edge  in an undirected graph . Informally speaking, the contraction of an edge merges the nodes  and  into one, reducing the total number of nodes of the graph by one. All other edges connecting either  or  are \"reattached\" to the merged node, effectively producing a multigraph. Karger's basic algorithm iteratively contracts randomly chosen edges until only two nodes remain; those nodes represent a cut in the original graph. By iterating this basic algorithm a sufficient number of times, a minimum cut can be found with high probability.","alt_names":["Karger's algorithm - Wikipedia, the free encyclopedia","Karger's algorithm","Karger&#39;s algorithm - Wikipedia, the free encyclopedia","Karger's algorithm by Wikipedia","Karger's algorithm from Wikipedia","What is algorithm of Karger's algorithm","Wikipedia article Karger's algorithm","en.wikipedia.org/wiki/Karge...","en.wikipedia.org/wiki/Karger's_algorithm","http://en.wikipedia.org/wiki/Karger%27s_algorithm","http://en.wikipedia.org/wiki/Karger%27s_…"],"name":"Karger's algorithm","categories":["Graph algorithms","Graph connectivity"],"tag_line":"In computer science and graph theory, Karger's algorithm is a randomized algorithm to compute a minimum cut of a connected graph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"stoer-wagner-algorithm","_score":0,"_source":{"description":"In Graph theory, a cut is a partition of the vertices of a graph into two disjoint subsets. A Minimum cut is that the size or weight of the cut is not larger than the size of any other cut. For an unweighted graph, the minimum cut would simply be the cut with the least edges. For a weighted graph, the sum of all edges' weight on the cut determine whether it is a minimum cut. In practical, the minimum cut problem is always discussed with the Maximum flow problem, to explore the maximum capacity of a network, since the minimum cut is a bottleneck in a graph or network.\nThe Stoer Wanger algorithm is a Recursive algorithm to solve the Minimum cut problem in undirected weighted graphs. This algorithm was proposed by Mechthild Stoer and Frank Wagner in 1995. The essential idea of this algorithm is to shrink the graph by merging the most intensive vertices, until the graph only contains two combined vertex sets. After each shrinking, the weight of the merged cut would be stored in a list. Finally, the minimum weight cut in the list will be the minimum of the graph.\n[[Category:Minimum cut]]\n\n","alt_names":[],"name":"Stoer Wagner Algorithm","categories":["Graph algorithms","Graph connectivity","Minimum cut"],"tag_line":"In Graph theory, a cut is a partition of the vertices of a graph into two disjoint subsets."}}
,{"_index":"throwtable","_type":"algorithm","_id":"iterative-compression","_score":0,"_source":{"description":"Iterative compression is an algorithmic technique invented by Reed, Smith and Vetta to show that the problem Odd Cycle Transversal was solvable in time O(3k kmn). Odd Cycle Transversal was a longstanding central open question in parameterized complexity. This technique later proved very useful in showing fixed-parameter tractability results. It is now considered to be one of the fundamental techniques in the area of parameterized algorithmics.\nIterative compression has been used successfully in many problems, for instance odd cycle transversal (see below) and edge bipartization, feedback vertex set, cluster vertex deletion and directed feedback vertex set. It has also been used successfully for exact exponential time algorithms for independent set.","alt_names":[],"name":"Iterative compression","categories":["Analysis of algorithms","Computational complexity theory","Graph algorithms","Network flow","Pages using citations with accessdate and no URL","Parameterized complexity"],"tag_line":"Iterative compression is an algorithmic technique invented by Reed, Smith and Vetta to show that the problem Odd Cycle Transversal was solvable in time O(3k kmn)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"k-shortest-path-routing","_score":0,"_source":{"description":"The K shortest path routing algorithm is an extension algorithm of the shortest path routing algorithm in a given network.\nIt is sometimes crucial to have more than one path between two nodes in a given network. In the event there are additional constraints, other paths different from the shortest path can be computed. To find the shortest path one can use shortest path algorithms such as Dijkstra’s algorithm or Bellman Ford algorithm and extend them to find more than one path. The K Shortest path routing algorithm is a generalization of the shortest path problem. The algorithm not only finds the shortest path, but also K-1 other paths in order of increasing cost. K is the number of shortest paths to find. The problem can be restricted to have the K shortest path without loops (loopless K shortest path) or with loop.","alt_names":[],"name":"K shortest path routing","categories":["Computational problems in graph theory","Graph algorithms","Network theory","Polynomial-time problems"],"tag_line":"The K shortest path routing algorithm is an extension algorithm of the shortest path routing algorithm in a given network."}}
,{"_index":"throwtable","_type":"algorithm","_id":"kleitman–wang-algorithms","_score":0,"_source":{"description":"The Kleitman–Wang algorithms are two different algorithms in graph theory solving the digraph realization problem, i.e. the question if there exists for a finite list of nonnegative integer pairs a simple directed graph such that its degree sequence is exactly this list. For a positive answer the list of integer pairs is called digraphic. Both algorithms construct a special solution if one exists or prove that one cannot find a positive answer. These constructions are based on recursive algorithms. Kleitman and Wang  gave these algorithms in 1973.","alt_names":[],"name":"Kleitman–Wang algorithms","categories":["Graph algorithms"],"tag_line":"The Kleitman–Wang algorithms are two different algorithms in graph theory solving the digraph realization problem, i.e."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hierarchical-clustering-of-networks","_score":0,"_source":{"description":"Hierarchical clustering is one method for finding community structures in a network. The technique arranges the network into a hierarchy of groups according to a specified weight function. The data can then be represented in a tree structure known as a dendrogram. Hierarchical clustering can either be agglomerative or divisive depending on whether one proceeds through the algorithm by adding links to or removing links from the network, respectively. One divisive technique is the Girvan–Newman algorithm.","alt_names":[],"name":"Hierarchical clustering of networks","categories":["Graph algorithms","Network analysis"],"tag_line":"Hierarchical clustering is one method for finding community structures in a network."}}
,{"_index":"throwtable","_type":"algorithm","_id":"edmonds–karp-algorithm","_score":0,"_source":{"description":"In computer science, the Edmonds–Karp algorithm is an implementation of the Ford–Fulkerson method for computing the maximum flow in a flow network in O(V E2) time. The algorithm was first published by Yefim (Chaim) Dinic in 1970 and independently published by Jack Edmonds and Richard Karp in 1972. Dinic's algorithm includes additional techniques that reduce the running time to O(V2E).","alt_names":[],"name":"Edmonds–Karp algorithm","categories":["Graph algorithms","Network flow"],"tag_line":"In computer science, the Edmonds–Karp algorithm is an implementation of the Ford–Fulkerson method for computing the maximum flow in a flow network in O(V E2) time."}}
,{"_index":"throwtable","_type":"algorithm","_id":"heapsort","_score":0,"_source":{"description":"In computer science, heapsort is a comparison-based sorting algorithm. Heapsort can be thought of as an improved selection sort: like that algorithm, it divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. The improvement consists of the use of a heap data structure rather than a linear-time search to find the maximum.\nAlthough somewhat slower in practice on most machines than a well-implemented quicksort, it has the advantage of a more favorable worst-case O(n log n) runtime. Heapsort is an in-place algorithm, but it is not a stable sort.\nHeapsort was invented by J. W. J. Williams in 1964. This was also the birth of the heap, presented already by Williams as a useful data structure in its own right. In the same year, R. W. Floyd published an improved version that could sort an array in-place, continuing his earlier research into the treesort algorithm.\n\n","alt_names":["Smooth Sort","Heap Sort","Heapsort","* (at your option) any later version.","- Heap sort :","- Heapsort :","- Smoothsort :","--Hier ein Link--","-> Read the article about 'Heapsort'","...Wikipedia Heapsort","...Wikipedia Sortowanie przez kopcowanie","...Wikipedia Tri par tas","...mehr auf Wikipedia über Heapsort","...mehr auf Wikipedia über Smoothsort","...more on Wikipedia about Heapsort","...more on Wikipedia about Smoothsort","1. Heapsort - Wikipedia, the free encyclopedia","1.3 Heap Sort Algorithm","3 Comparison with other sorts","5 C-code","@ 힙 정렬(위키피디아)","An animation","Better worst-case performance","Click here for your reference","Comparison with other sorts","Dijkstra's Smoothsort","Encyclopedia: Heapsort","Heap HeapSort=BuildHeap+Swap+Heapify","Heap Sort (Takes forever to implement by hand","Heap Sort - Wikipedia","Heap Sort Algorithm","Heap Sort Algoritme","Heap Sort algorithm in the wikipedia","Heap Sort-Algorithmus","Heap algoritmu třídění","Heap sort","Heap sort - Wikipedia","Heap sort algorithm","Heap sort на c++","Heap sort(Wikipedia)","Heap sort; it is used under the","Heap sorteer algoritme","Heap-Sort","Heap-Sort.","HeapSort","HeapSort algorithm","HeapSort at Wikipedia (DE)","HeapSort at Wikipedia (EN)","HeapSort bei Wikipedia (DE)","HeapSort bei Wikipedia (EN)","HeapSort sorting algorithm","HeapSorter","HeapSort를","Heap_Sort bei der wikipedia","Heapsor","Heapsort (Wikipedia)","Heapsort (as PQ Sort)","Heapsort -","Heapsort - A simple O(n lg(n)) algorithm","Heapsort - Wikipedia","Heapsort - Wikipedia, la enciclopedia libre","Heapsort - Wikipedia, the free encyclopedia","Heapsort - Wikipédia, a enciclopédia livre","Heapsort ; Wikipedia","Heapsort ? Wikipedia","Heapsort Wikipedia","Heapsort Wikipedia the free encyclopedia","Heapsort Wikipedia, the free ...","Heapsort Wikipediaartikel","Heapsort algorithm","Heapsort animation. This is the kind of thing","Heapsort bei der wikipedia","Heapsort from Wikipedia","Heapsort für n-äre Heaps","Heapsort here","Heapsort |","Heapsort â€“ Wikipedia","Heapsort – Wikipedia","Heapsort – Wikipédia, a enciclopédia livre","Heapsort, Wikipedia","Heapsort- Algorithmus","Heapsort-Algorithmus","Heapsort-Wikipedia","Heapsort:","Heapsort; it is used under the","Heapsort@Wikipedia","Hrúguröðun","Krūvos rikiavimo algoritmas","Kupacrendezés","Kupacrendezés - Wikipédia","Le tri par tas","Learn about Smoothsort>>>","More info on wikipedia for heapsorting","Ordenamiento HeapSort","Ordenamiento por Montículos","Ordenamiento por montículos","Ordenar suave","Phân loại mịn","Rahat sıralama","Reference: Heapsort","Smooth Classificar","Smooth Ordina","Smooth Trier","Smooth Urutkan","Smooth sort","Smooth sortieren","Smoothsort","Smoothsort (Dijkstra 1981)","Smoothsort - Wikipedia, the free encyclopedia","Smoothsort - Wikipédia","Smoothsort bei der wikipedia","Smoothsort |","Smoothsort – Wikipedia","Smoothsort.gif","Smoothsort; it is used under the","Sortowanie przez kopcowanie","Sortowanie przez kopcowanie – Wikipedia, wolna encyklopedia","Sortowanie przez kopcowanie, zad 5 - 1 minuta szukania","Source Wikipedia.org Arcticle - Smoothsort","Suggested: heapsort","Sắp xếp vun đống","Sắp xếp vun đống - Wikipedia tiếng Việt","The Heap Sort","The article on Heapsort","Tiré de la page Wikipedia","Tri par tas","Tri par tas - Wikip?dia","Tri par tas - Wikipédia","Urejanje s kopico","Urejanje s kopico pedija prosta enciklopedija","What is unique about Smoothsort's operations","Wiki -> Heapsort (mit guter Animation)","Wiki : Heapsort","Wiki Animation","Wiki: Heap Sort","Wikipedia (Heapsort)","Wikipedia : Heapsort","Wikipedia Heapsort","Wikipedia Heapsort page","Wikipedia article ''Smoothsort''","Wikipedia article Heap sort","Wikipedia article Heapsort","Wikipedia article Smoothsort","Wikipedia article Urejanje s kopico","Wikipedia article about Heapsort","Wikipedia article about Smoothsort","Wikipedia article explaining heapsort/sift","Wikipedia article on Heap sort","Wikipedia article on Heapsort","Wikipedia article on Smoothsort","Wikipedia article on heap sort","Wikipedia article Řazení haldou","Wikipedia article Կույտային դասակարգում","Wikipedia article ഹീപ് സോർട്ട്","Wikipedia artikel Heapsort","Wikipedia entry for Heapsort","Wikipedia entry for Smoothsort","Wikipedia entry on heap sort","Wikipedia l'articolo Heap sort","Wikipedia l'articolo Heapsort","Wikipedia on Heap sort","Wikipedia page on heapsort","Wikipedia – Heapsort","Wikipedia-Artikel Heap Sort","Wikipedia-Artikel Heapsort","Wikipedia-Artikel Smoothsort","Wikipedia-Seite zu 'Heapsort'","Wikipedia: Heapsort","Wikipedia::Heapsort","Wikipedia:ヒープソート","Wikipediaeintrag über Heapsort","Wikipedia「ヒープソート」","Wikipediaで「ヒープソート」を調べる","Wikipédia artigo Heap sort","Wikipédia artigo HeapSort","Wikipédia artigo Heapsort","Yığın Sıralaması","Yığın sıralaması","Yığın sıralaması - Vikipedi","[B.5] http://en.wikipedia.org/wiki/Heapsort","a versão wikipedia","algorytmu Heap Sort","artigo da Wikipédia Heapsort","artículo de Wikipedia Heapsort","artículo de Wikipedia Ordenamiento por montículos","better worst case performance","bunke slags","cs:Heapsort","cs:Řazení haldou","de hoop type","de.wikipedia.org/wiki/Heapsort","de.wikipedia.org/wiki/Heapsort#n-.C3.A4re_Heaps","de:Heapsort","den Heap Art","die Art Haufen","druh haldy","el heap tipo","en.wikipedia.org/Heap_sort","en.wikipedia.org/Heapsort","en.wikipedia.org/wiki/Heap_sort#Pseudocode","en.wikipedia.org/wiki/Heapsort","en.wikipedia.org/wiki/Smoothsort","en:Heapsort","en:Heapsort#Variations","es:Heapsort","especie montón?","espécie de pilha.","fr:Tri par tas","haldy řazení","he:מיון ערימה","heap sort","heap sort.","heap sorting does not parallelize easily","heap-sort","heapsort","heapsort algorithm","heapsort article","heapsort entry","heapsort wikipedia the free encyclopedia","heapsortom","heapsortu","het soort hoop","hoop soort","http://bit.ly/cVbf9","http://cs.wikipedia.org/wiki/%C5%98azen%C3","http://de.wikipedia.org/wiki/He apsort","http://de.wikipedia.org/wiki/Heap_Sort","http://de.wikipedia.org/wiki/Heapsort","http://de.wikipedia.org/wiki/Heapsort#Laufzeit","http://de.wikipedia.org/wiki/Heapsort?","http://de.wikipedia.org/wiki/Smoothsort","http://en.wikipedia....wiki/Smoothsort","http://en.wikipedia.org/wiki/Heap_sort","http://en.wikipedia.org/wiki/Heap_sort>heap","http://en.wikipedia.org/wiki/Heapsort","http://en.wikipedia.org/wiki/Heapsort Heap sort","http://en.wikipedia.org/wiki/Heapsort#Comparison_with_other_sorts","http://en.wikipedia.org/wiki/Heapsort#Pseudocode","http://en.wikipedia.org/wiki/Smoothsort","http://en.wikipedia.org/wiki/Smoothsort#Variations","http://es.wikipedia.org/wiki/Heapsort","http://es.wikipedia.org/wiki/Ordenamiento_por_mont%C3%ADculos","http://fr.wikipedia.org/wiki/Smoothsort","http://fr.wikipedia.org/wiki/Tri par tas","http://fr.wikipedia.org/wiki/Tri_par_tas","http://hu.wikipedia.org/wiki/Kupacrendez%C3%A9s","http://it.wikipedia.org/wiki/Heap_sort","http://it.wikipedia.org/wiki/Smoothsort","http://ja.wikipedia.org/wiki/ヒープソート","http://lb.wikipedia.org/wiki/Heapsort","http://nl.wikipedia.org/wiki/Heapsort","http://pl.wikipedia.org/wiki/Sortowanie ... kopcowanie","http://pl.wikipedia.org/wiki/Sortowanie_przez_kopcowanie","http://pl.wikipedia.org/wiki/Sortowanie_pżez_kopcowanie","http://pt.wikipedia.org/wiki/Heapsort","http://pt.wikipedia.org/wiki/Heapsort#C.C3","http://ru.wikipedia.org/wiki/Heapsort","http://ru.wikipedia.org/wiki/Пирамидальн...","http://ru.wikipedia.org/wiki/Пирамидальная_сортировка","http://sl.wikipedia.org/wiki/Urejanje_s_kopico","http://tinyurl.com/o8lq5","http://www.de.wikipedia.org/wiki/Heapsort","http://zh.wikipedia.org/zh-tw/% E5% A0","hu:Kupacrendezés","hy:Heapsort","ich habe ein Beispiel anhand eines Baumes","il mucchio type","il tipo heap","is:Hrúguröðun","it:Heap sort","ja:ヒープソート","ko:힙 정렬","kupacrendezés","l'article de Wikipédia Smoothsort","la version wikipedia","la versione di Wikipedia","la versión de wikipedia","lb:Heapsort","le tas de type","le type tas","ml:ഹീപ് സോര്ട്ട്","ml:ഹീപ് സോർട്ട്","nl:Heapsort","o tipo de pilha","ordenación por montículo","ordenación por montículo.","par tas","phiên bản của wikipedia","pila de clasificación del algoritmo","pilha tipo","pl:Sortowanie przez kopcowanie","przez kopcowanie","pt:Heapsort","r http://de.wikipedia.org/wiki/Heapsort","r http://fr.wikipedia.org/wiki/Tri_par_tas pou","rodzaj sterty","ru:Пирамидальная сортировка","semacam tumpukan.","semacam tumpukan?","skiribilla: heapsort","smoothsort","sorta di heap.","sorta mucchio","sorte de tas.","sorte de tas?","sortowanie przez kopcowanie","sortowanie stogowe","sắp xếp heap?","sắp xếp đống.","the Wikipedia page for heapsort","the heap sort","tipo de pilha?","tipo del montón","tr:Rahat Sıralama","tr:Rahat sıralama","tri en tas","tri par tas","tri tête","unabhängig von der Sprache","vi:Sắp xếp vun đống","w:Пирамидальная сортировка","wiki:Heapsort","wikipedia/Пирамидальная_сортировка","wikipedia:ヒープソート","wp:Heapsort","yago-res:Smoothsort","zh:堆積排序","Überführung in einen Max-Heap","Řazení haldou","Википедии статью Heapsort","Википедии статью Пирамидальная сортировка","Гладкие Сортировка","Пирамидальная","Пирамидальная сортировка","Пирамидальная сортировка — Википедия","Пирамидальной сортировки","Пірамідальне сортування","версией в википедии","кучи алгоритм сортировки","кучи сортировки","кучи сортировки.","кучи типа","кучу рода","кучу рода?","пирамидално сортиране","пирамидальным методом","пірамідальне сортування","сортировки с помощью пирамиды","типа куча","ויקיפדיה - 'מיון ערימה'","מיון ערימה","מיון ערימה – ויקיפדיה","الگوریتم مرتبسازی هرمی","مرتبسازی روان","مرتبسازی روان - ویکیپدیا","مرتبسازی هرمی","مرتبسازی هرمی - ویکیپدیا","هموار","कर सकता","ढेर सॉर्ट करें","ढेर सॉर्ट करें.","ഹീപ് സോർട്ട്","ของรุ่นวิกิพีเดีย","จัด เรียง กอง?","เรียงกอง","เรียงเรียบ","“Smoothsort - Wikipedia, the free encyclopedia”, en.wikipedia.org","→ Статья «Пирамидальная сортировка»","「ヒープソート」についてWikipediaで調査","「ヒープソート」をWikipediaで調べる","「ヒープソート」をWikiで調べる","こういうことらしいです。（Wikiリンク）","のヒープソート","の並べ替え。ヒープ","スムーズな並べ替え","タイプのヒープ","バージョン。","ヒープのタイプ","ヒープの並べ替え","ヒープソート","ヒープソート - Wikipedia","ヒープソートは","ヒープソートを","ヒープソートアルゴリズムを","光滑排序","堆型","堆排序","堆排序。","堆排序算法","堆积排序","堆积排序- 维基百科，自由的百科全书","堆積排序","推排序","类型堆","維基百科的文章“ 堆排序”","維基百科的文章“ 堆積排序”","維基百科的版本","维基百科- 堆积排序","维基百科的文章“ 堆積排序”","维基百科的版本","부드럽게 정렬","위키 피 디아의 버전","힙 정렬","힙 정렬의","힙 정렬합니다.","ﾋｰﾌﾟｿｰﾄ - Wikipedia"],"name":"Heapsort","categories":["All articles with unsourced statements","Articles with example pseudocode","Articles with unsourced statements from June 2012","Articles with unsourced statements from September 2014","Comparison sorts","Heaps (data structures)","Sorting algorithms","Use dmy dates from July 2012"],"tag_line":"In computer science, heapsort is a comparison-based sorting algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"tree-traversal","_score":0,"_source":{"description":"In computer science, tree traversal (also known as tree search) is a form of graph traversal and refers to the process of visiting (examining and/or updating) each node in a tree data structure, exactly once. Such traversals are classified by the order in which the nodes are visited. The following algorithms are described for a binary tree, but they may be generalized to other trees as well.","alt_names":["level-order traversal","Suchbaum","MPTT","tree traversal","Tree traversal","*search* tree","- Search tree :","- Tree search algorithm :","-> Read more about Search tree","-> Read more about Tree traversal","-> Read the article about 'Search tree'","-Traversierung eines Baumes","...Wikipedia Przechodzenie drzewa","...mehr auf Wikipedia über Suchbaum","...mehr auf Wikipedia über Traversierung","...more on Wikipedia about Tree traversal","1 Traversal methods","3 Functional traversal","4 Iterative traversal","<span style=color: black;>http://en.wikipedia.org","Albero Traversal","Albero di attraversamenti.","Algoritmos de procura em grafos:","Attraversamenti albero","Attraversamento Tree","BFS, DFS","Backward inorder traversal","Baum Traversierung","Baum-Traversal","Boom Traversal","Boom aflopen van","Breadth-first Tree traversal - Wikipedia, the free encyclopedia","Breadth-first_Traversal","Cây Traversals.","Depth-first Traversal","Drzewo Traversal","Free Traversal","Functional traversal","Graph Search Algorithms","Here is one other link","In computer science, a search tree is a","In-, post-, and pre-order traversal","In-order iteration","In-order traversal","Inorder","Inorder traversal","It is particularly common to use an inorder","Iterative Lösungen","Iterative Traversal","Iterative Traversing","Iterative traversing","Level-order traversal","Modified Preorder Tree Traversal","Modified Preorder Tree Traversal Algorithm","Other Search Trees","Parcours d'arbres.","Pohon Traversals.","Post-order traversal","Postorder traversal","Pre-Order and an In-Order visit of","Pre-order traversal","Preorder traversal tree","Przechodzenie drzewa","Przechodzenie drzewa â�“ Wikipedia, wolna encyklopedia","Przechodzenie drzewa – Wikipedia, wolna encyklopedia","Queue-based level order traversal","Recorridos de árboles","Recorridos de árboles.","Search Tree - Wikipedia, The Free Encyclopedia","Search Trees","Search tree","Search tree - Wikipedia, the free encyclopedia","Search tree Wikipedia the free encyclopedia - result","Search tree; it is used under the","Search trees","Search trees at Wikipedia","Search_tree","Simply traverse the tree","Suchbaum ? Wikipedia","Suchbaum in","Suchbaum – Wikipedia","Suchbaums","Suchbäume","Suchbäumen","Suggested: tree traversal","The Wikipedia article on tree traversal","Traversal","Traversal 2","Traversal reference","Traversals","Traversals Tree.","Traversering","Traversering - Wikipedia","Traversieren","Traversieren:","Traversierung - Wikipedia","Traversierung ? Wikipedia","Traversierungen","Traversierungsreihenfolge","Travesieren","Travessias de árvores.","Tree Search Algorithms","Tree Traversal","Tree Traversal (Wiki)","Tree Traversal - Wikipedia, The Free Encyclopedia","Tree Traversal Algorithms","Tree Traversal Wikipedia The Free Encyclopedia","Tree Traversal tutorial","Tree Traversal.","Tree Traversals","Tree Traversals.","Tree Traversierungen.","Tree search","Tree search algorithm","Tree search algorithms","Tree traversa","Tree traversal (Wiki)","Tree traversal - Wikipedia, the free encycl","Tree traversal - Wikipedia, the free encyclopedia","Tree traversal Wikipedia the free encyclopedia","Tree traversal Wikipedia the free encyclopedia - result","Tree traversal by Wikipedia","Tree traversal from Wikipedia","Tree traversal on wikipedia","Tree traversal – Wikipedia, the free encyclopedia","Tree traversal.","Tree traversal; it is used under the","Tree traversals","Tree обходы.","Tree-pedia","Tree-traversal in preorder","Tree/Graph traversals","Tree_search","Tree_traversal","Tree_traversal.","Visita in profondità","Wiki on Tree Traversal Algorithms","Wiki: Tree Traversal","WikiPedia: Tree traversal","Wikipeadia entry Tree_traversal","Wikipedia - Tree search algorithm","Wikipedia @ Suchbaum","Wikipedia Tree Search Algorithm","Wikipedia article Post-order traversal","Wikipedia article Search tree","Wikipedia article Suchbaum","Wikipedia article Tree search algorithm","Wikipedia article Tree traversal","Wikipedia article on Post-order traversal","Wikipedia article on tree traversal","Wikipedia entry for Tree traversal","Wikipedia über Suchbäume allgemein","Wikipedia's Tree traversal entry","Wikipedia, iterative Wege, einen Baum zu durchwandern","Wikipedia, “Tree traversal”, http://en.wikipedia.org/wiki","Wikipedia-Artikel Suchbaum","Wikipedia-Artikel Traversierung","Wikipedia-Artikel Wirbeltraversierung","Wikipedia-Seite zu 'Suchbaum'","Wikipedia-Seite zu 'Traversierung'","Wikipedia: Tree traversal","Wirbeltraversierung - Wikipedia","aflopen van Tree","algorithm-friendly","algoritmo di attraversamento di alberi","algorytm przechodzenia drzewa","an algorithm for that using a queue","bardzo pomocne","boom traversal","bunch of traversel algorithms","commonly used tree/graph traversal algorithms on wikipedia","de.wikipedia.org/wiki/Suchbaum","de:Suchbaum","dell'albero di attraversamento","depth-first and symmetrical traversals","en.wikipedia.org/...Tree_traversal","en.wikipedia.org/Search_tree","en.wikipedia.org/Tree_search","en.wikipedia.org/wiki/Tree traversal","en.wikipedia.org/wiki/Tree_traversal","en.wikipedia.org/wiki/Tree_traversal#Iterative_Traversal","expansive list of ways to search a tree","graph/tree search algorithm","http://de.wikipedia.org/wiki/Suchbaum","http://de.wikipedia.org/wiki/Traversierung","http://en.Liarpedia.org/wiki/Tree_traversal","http://en.wikipedia..../Tree_traversal","http://en.wikipedia.org/wi ki/Tree_traversal","http://en.wikipedia.org/wiki/Post-order_traversal","http://en.wikipedia.org/wiki/Search_tree","http://en.wikipedia.org/wiki/Tree_search","http://en.wikipedia.org/wiki/Tree_search_algorithm","http://en.wikipedia.org/wiki/Tree_search_algorithm#Traversal_methods","http://en.wikipedia.org/wiki/Tree_tr...mplementations","http://en.wikipedia.org/wiki/Tree_tr...tive_Traversal","http://en.wikipedia.org/wiki/Tree_tra...erative_Traversal","http://en.wikipedia.org/wiki/Tree_trave ... _Traversal","http://en.wikipedia.org/wiki/Tree_trave ... _traversal","http://en.wikipedia.org/wiki/Tree_trave ... al_methods","http://en.wikipedia.org/wiki/Tree_traver","http://en.wikipedia.org/wiki/Tree_traversa","http://en.wikipedia.org/wiki/Tree_traversal","http://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_Traversal","http://en.wikipedia.org/wiki/Tree_traversal#Depth-first_Traversal","http://en.wikipedia.org/wiki/Tree_traversal#Example","http://en.wikipedia.org/wiki/Tree_traversal#Examples","http://en.wikipedia.org/wiki/Tree_traversal#I...","http://en.wikipedia.org/wiki/Tree_traversal#Iterative_Traversal","http://en.wikipedia.org/wiki/Tree_traversal#Iterative_traversing","http://en.wikipedia.org/wiki/Tree_traversal#Queue-based_level_order_traversal","http://en.wikipedia.org/wiki/Tree_traversal#Sample_implementations","http://en.wikipedia.org/wiki/Tree_traversal#Traversal","http://en.wikipedia.org/wiki/Tree_traversal#Traversal_methods","http://en.wikipedia.org/wiki/Tree_traversal#Traversing_with_parent_pointers","http://en.wikipedia.org/wiki/Tree_traversal.","http://en.wikipedia.org/wiki/Tree_traver…","http://en.wikipedia.org/…ee_traversal","http://pl.wikipedia.org/wiki/Przechodzenie_drzewa","http://pl.wikipedia.org/wiki/Pżehodzenie_dżewa","http://vi.wikipedia....BB%87t_c%C3%A2y","http://vi.wikipedia.org/wiki/Duy%E1%...B","http://vi.wikipedia.org/wiki/Duy%E1%..._g","in order and pre order traversals","in order tree traversal","in preorder","in-order sequence","in-order traversal","in-order traversal of a tree","in-order traversal of a tree with parent","in-order traversals","inorder","inorder traversal","inorderly","iterationsmetoder","iterative preorder traversal","iterative traversal","level order","level-order","level-order (L-R breadth-first)","many results","mga paraan","more information on tree traversal","pl:Przechodzenie drzewa","post order traversal","post order tree traveral","post order visit","post-order","post-order traversal","postfix traversal","postorder doorheen lopen","postorder te bezoeken","postorder traversal","pre- und post-order walk","pre-order Traversierung","pre-order průchod","pre-order traversal","pre-order, in-order and post-order","pre-ordine di attraversamento","prefix traversal","preorder depth-first","preorder traversal","preorder tree traversal","przechodzenia drzewa","przejścia pre-order po drzewie","przejść drzewo sposobem in-order","qui c'è qualcosa","recorrido de árbol","recorrido del árbol","recorrido pre-orden","recursive traversal","search strategies","search tree - Wikipedia, the free encyclopedia","search tree property","search trees and tree traversal","search_tree","simple traversa","strom traversal algoritmus","study this link","sv:Traversering","symmetric (in-order) traversal","the Wikipedia article on tree traversal","the tree-traversing algorithms","this Wikipedia article on tree traversal","this sample tree","thuật toán tìm kiếm trong đồ thị","traversal example on Wikipedia","traversal methoden","traversal methods","traversal om","traversal order","traversal stromu","traverse that tree","traversing binary trees","tree search algorithm","tree search algorithms","tree searching","tree transversal","tree trav","tree traversable","tree traversal algorithm","tree traversal algorithms","tree traversal algortihm","tree traversal approach","tree traverse","tree traversers","tree traversing","tree-traversal","uk:Обхід дерева","usually done via recursion","vi:Duyệt cây","walking the tree","why I didn't I see this before","zh:树的遍历","Árbol de recorrido.","überführt","Бесстековый обход","Обхід дерева","Украинском","алгоритм обхода бинарного дерева","дерева обхода","должности посетить порядке","методами обхода","обход дерева.","обхода дерева","обході його зліва направо","очень полезным","порядке обхода предварительно","путей","پيمايش درخت","پیمایش درخت","پیمایش درخت - ویکیپدیا","क्रमोत्तर यात्रा","ट्री Traversals","पेड़ traversal","“pre-order”, “in-order”, and “post-order” traversals","ツリーの全検索","ツリーをたどる","ツリートラバーサルを","プレオーダートラバーサル","前序遍历","后的顺序","和树","图遍历","尋訪（traversal）","树的遍历","树的遍历- 维基百科，自由的百科全书","树遍历","樹的遍歷","樹遍歷","維基百科的文章“ 图遍历”","維基百科的文章“ 树的遍历”","維基百科的文章“ 遍历”","维基百科的文章“ 图遍历”","遍历","遍歷","나무에","방법을","위키 피 디아의 문서입니다.","위키피디아의 예제","트리 순회","트리 순회 - 위키백과, 우리 모두의 백과사전","트리 탐색."],"name":"Tree traversal","categories":["All articles needing additional references","Articles needing additional references from June 2013","Articles needing additional references from May 2009","Articles with example Haskell code","Articles with example Java code","Articles with example pseudocode","Graph algorithms","Iteration in programming","Recursion","Trees (data structures)"],"tag_line":"In computer science, tree traversal (also known as tree search) is a form of graph traversal and refers to the process of visiting (examining and/or updating) each node in a tree data structure, exactly once."}}
,{"_index":"throwtable","_type":"algorithm","_id":"counting-sort","_score":0,"_source":{"description":"In computer science, counting sort is an algorithm for sorting a collection of objects according to keys that are small integers; that is, it is an integer sorting algorithm. It operates by counting the number of objects that have each distinct key value, and using arithmetic on those counts to determine the positions of each key value in the output sequence. Its running time is linear in the number of items and the difference between the maximum and minimum key values, so it is only suitable for direct use in situations where the variation in keys is not significantly greater than the number of items. However, it is often used as a subroutine in another sorting algorithm, radix sort, that can handle larger keys more efficiently.\nBecause counting sort uses key values as indexes into an array, it is not a comparison sort, and the Ω(n log n) lower bound for comparison sorting does not apply to it. Bucket sort may be used for many of the same tasks as counting sort, with a similar time analysis; however, compared to counting sort, bucket sort requires linked lists, dynamic arrays or a large amount of preallocated memory to hold the sets of items within each bucket, whereas counting sort instead stores a single number (the count of items) per bucket.","alt_names":["Counting sort","- Counting sort :","-> Read the article about 'Counting sort'","...Wikipedia Count sort","...Wikipedia Counting sort","...Wikipedia Sortowanie przez zliczanie","...Wikipedia Tri comptage","...mehr auf Wikipedia über Countingsort","...more on Wikipedia about Counting sort","1 Characteristics of counting sort","2 Tally sort","3 The algorithm","3.1 C implementation","4 Single-pass variant","4.1 C pseudocode","4.2 Arrays of 8-bit and 16-bit","4.3 Parallel Implementations","COUNTING SORT","Characteristics of counting sort","Contar Ordenar","Count Sort","Count sort","Counting Sort","Counting Sort (Wikipedia)","Counting Sort algorithm","Counting Sorter","Counting Sortuj","Counting sort -","Counting sort - Wikipedia","Counting sort - Wikipedia, the free encyclopedia","Counting sort - Wikipedie","Counting sort – Wikipédia, a enciclopédia livre","Counting sort.","Counting sort; it is used under the","Counting sort?","Counting sorts","Counting sortu","CountingSort","Counting_sort","Countingsort","Countingsort - Wikipedia","Countingsort ? Wikipedia","Countingsort – Wikipedia","Countingsort.","Die Stelle mit dem größten Index, an dem","Integer sort","Laskentalajittelu","Laufzeitanalyse","Liczenie Sortuj","Licząc według","Ordenamiento por cuentas","Ordina conteggio","Počítání Seřadit","Počítání Řadit","Počítání řazení","Sayarak sıralama","Sortowanie przez zliczanie","Sortowanie przez zliczanie – Wikipedia,…","Tally sort","Tri comptage","Tri comptage (C)","Tri comptage - Wikipedia","Tri comptage - Wikipédia","Urejanje s štetjem","Wikipedia (Counting sort)","Wikipedia article Counting sort","Wikipedia article Tally sort","Wikipedia article on Counting sort","Wikipedia article on Ordenamiento por cuentas","Wikipedia article Հաշվողական տեսակավորում","Wikipedia article കൗണ്ടിങ്ങ് സോർട്ട്","Wikipedia artikel Count sort","Wikipedia artikel Counting sort","Wikipedia entry for Counting sort","Wikipedia l'articolo Counting sort","Wikipedia sur Tri par dénombrement","Wikipedia | Count_sort","Wikipedia-Artikel Countingsort","Wikipedia-Seite zu 'Countingsort'","Wikipedia/Counting sort","Wikipedia:Counting_sort","Wikipedia|Count_sort","Wikipédia artigo Count sort","Wikipédia artigo Counting sort","a sorting algorithm","artículo de Wikipedia Counting sort","artículo de Wikipedia Ordenamiento por cuentas","c&ETH;&frac34;&Ntilde;&Ntilde;&ETH;&cedil;&Ntilde;&ETH","contar especie","contare ordinare","conteo Ordenar","count sort","counting Sort","counting sort","counting sortu","counting-sorta","counting_sort","countsort","cs:Counting sort","cортировка подсчётом","de contagem de classificação.","de conteo tipo","de:Countingsort","een classificatie-algoritme","een sorteer-algoritme","ein Sortieralgorithmus","eine Klassifizierung Algorithmus","einen Sortieralgorithmus","el recuento especie.","en sortering algoritme","en.wikipedia.org/wiki/Counting_sort","es:Ordenamiento por cuentas","fa:الگوریتم مرتبسازی شمارشی","fa:مرتبسازی شمارشی","fi:Laskentalajittelu","fr:Tri comptage","he:מיון מנייה","het tellen van sorteren","http://cs.wikipedia.org/wiki/Counting_sort","http://de.wikipedia.org/wiki/Countingsor","http://de.wikipedia.org/wiki/Countingsort","http://en.wikipedia....le-pass_variant","http://en.wikipedia.org/wiki/Counting_so","http://en.wikipedia.org/wiki/Counting_sort","http://en.wikipedia.org/wiki/Counting_so…","http://en.wikipedia.org/wiki/Tally_sort","http://es.wikipedia.org/wiki/Counting_sort","http://es.wikipedia.org/wiki/Counting_so…","http://es.wikipedia.org/wiki/Ordenamiento_por_cuentas","http://fi.wikipedia.org/wiki/Laskentalajittelu","http://fr.wikipedia.org/wiki/Tri_comptage","http://fr.wikipedia.org/wiki/Tri_comptage(...)","http://fr.wikipedia.org/wiki/Tri_comptag…","http://it.wikipedia.org/wiki/Counting_sort","http://it.wikipedia.org/wiki/Integer_sort","http://nl.wikipedia.org/wiki/Counting_sort","http://pl.wikipedia.org/wiki/Sortowanie_przez_zliczanie","http://pl.wikipedia.org/wiki/Sortowanie_pżez_zliczanie","http://ru.wikipedia.org/wiki/Сортировка_подсчётом","http://zh.wikipedia.org/zh-tw/% E8% AE","hy:Հաշվողական տեսակավորում","il conteggio di ordinamento","it:Counting sort","le tri par comptage.","liczenie sortowania","liczyć sortowania","ml:കൗണ്ടിങ്ങ് സോര്ട്ട്","ml:കൗണ്ടിങ്ങ് സോർട്ട്","nl:Counting sort","ordenamiento por cuentas","pagbibilang ng uri.","pl:Sortowanie przez zliczanie","počítání třídit","počítání řazení","pt:Counting sort","rt http://en.wikipedia.org/wiki/Counting_sort","ru:Сортировка подсчётом","semacam menghitung.","sort an array in O(n+k)","sortarea prin numărare","sorting by count","sortowanie przez zliczanie","sur l'article Wikipédia","t http://de.wikipedia.org/wiki/Countingsort","tally sort","tellen sorteren","the counting sort algorithm","this wiki explaination","tr:Sayarak sıralama","tri comptage","tælle slags","tính sắp xếp.","um algoritmo de classificação","um algoritmo de ordenação","un algorithme de classification","un algorithme de tri","un algoritmo de clasificación","un algoritmo di classificazione","un algoritmo di ordinamento","w:Counting sort","wp:Counting sort","zh:计数排序","| Count_sort","Википедия: Сортировка подсчетом","Вот ссылка Вики","Подсчет Сортировать","Подсчет Сортировка","Подсчётом","Сортировка подсчетом","Сортировка подсчётом","Сортировка подсчётом Википедия","Сортировка подсчётом на Википедии","Сортировка подсчётом — Википедия","Сортировку подсчетом (Counting sort)","алгоритм классификации","броене на честоти","подсчет Сортировать","подсчет рода","подсчет сортировки","подсчета рода","подсчётом","сортировка подсчетом","сортировка подсчётом","сортировки подсчетом","сортировки подсчетом.","сортировки подсчётом","сортировку подсчетом","сортування підрахунком","ויקיפדיה - 'מיון מנייה'","מיון מנייה","מיון מנייה – ויקיפדיה","مرتبسازی شمارشی","مرتبسازی شمارشی - ویکیپدیا","तरह गिनती","นับ เรียง.","の並べ替えを数える","カウンティングソート","ソートのアルゴリズム","ソートカウント","一个分类算法","一个排序算法","並べ替えをカウント","並べ替えを数える","並べ替えカウント","分類するアルゴリズムを","的计数","種を数える","計数ソートを","計數排序","计数排序","计数排序- 维基百科，自由的百科全书","计数排序的特征","這是wiki 上的說明以及C 的實作.","일종의 카운트를","카운트 정렬"],"name":"Counting sort","categories":["Sorting algorithms","Stable sorts"],"tag_line":"In computer science, counting sort is an algorithm for sorting a collection of objects according to keys that are small integers; that is, it is an integer sorting algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"comparison-sort","_score":0,"_source":{"description":"A comparison sort is a type of sorting algorithm that only reads the list elements through a single abstract comparison operation (often a \"less than or equal to\" operator or a three-way comparison) that determines which of two elements should occur first in the final sorted list. The only requirement is that the operator obey two of the properties of a total order:\nif a ≤ b and b ≤ c then a ≤ c (transitivity)\nfor all a and b, either a ≤ b or b ≤ a (totalness or trichotomy).\nIt is possible that both a ≤ b and b ≤ a; in this case either may come first in the sorted list. In a stable sort, the input order determines the sorted order in this case.\nA metaphor for thinking about comparison sorts is that someone has a set of unlabelled weights and a balance scale. Their goal is to line up the weights in order by their weight without any information except that obtained by placing two weights on the scale and seeing which one is heavier (or if they weigh the same).","alt_names":["(tipo","(сравнение рода)","(เรียง ลำดับ เปรียบเทียบ)","(비교 일종)가","- Comparison sort :","-> Leggi tutto l'articolo su 'Algoritmi di ordinamento","...more on Wikipedia about Comparison sort","2 f ( n ) ≥ n !","450. Comparison sort - Wikipedia, the free encyclopedia","5Fsort% http://en.wikipedia.org/wiki/Comparison # Ilość","Algoritmi di ordinamento comparativi","Algoritmi di ordinamento comparativi - Wikipedia","Art von Vergleich","Comparison Based","Comparison Sort","Comparison Sort Complexity","Comparison Sort Verfahren","Comparison Sorts","Comparison sort","Comparison sort - Wikipedia, the free encyclopedia","Comparison sort Wikipedia the free encyclopedia","Comparison sort en.wikipedia.org/wiki/Comparison_sort","Comparison sort – Wikipedia, the free encyclopedia","Comparison sort: Examples","Comparison sort; it is used under the","Comparison sorts","Comparison-based sorting algorithms","Number of comparisons ...","Number of comparisons required to sort a list","Ordenação por comparação","Ordinamento comparativo","Performance limits ...","Performance limits and advantages","Vergleich Art)","What are some examples of Comparison sort","Wikipedia - Comparison Sort","Wikipedia article Comparison sort","Wikipedia article Ordenação por comparação","Wikipedia article on Comparison sort","Wikipedia article താരതമ്യ സോർട്ട്","Wikipedia entry for Comparison sort","Wikipedia: Comparison sort","Wikipedia:Algoritmi_di_ordinamento_comparativi","a comparison sor","a comparison sort","algoritm de sortare pe baza de comparatii","algoritmi di ordinamento comparativi","barreira teórica de complexidade","comparision алгоритмов","comparison based sort","comparison function","comparison sort","comparison sort algorithm","comparison sorting","comparison sorts","comparison-based","comparison-based sort","comparison-based sorting","comparison-based sorting algorithms","comparison-sort","en.wikipedia.org/.../Comparison_sort","en.wikipedia.org/...Comparison_sort","en.wikipedia.org/wiki/Comparison_sort","http://en.wikipedia.org/wiki/Compar...o_ sort_a_list","http://en.wikipedia.org/wiki/Comparison ... ort_a_list","http://en.wikipedia.org/wiki/Comparison 5Fsort #% Número","http://en.wikipedia.org/wiki/Comparison 5Fsort% #% Numero","http://en.wikipedia.org/wiki/Comparison% 5Fsort # Anzahl","http://en.wikipedia.org/wiki/Comparison% 5Fsort # Количество","http://en.wikipedia.org/wiki/Comparison%5Fsort#Number","http://en.wikipedia.org/wiki/Comparison_sort","http://en.wikipedia.org/wiki/Comparison_sort#Lower_bound_for_the_average_number_of_comparisons","http://en.wikipedia.org/wiki/Comparison_sort#Number_of_comparisons_required_to_sort_a_list","http://it.wikipedia.org/wiki/Algoritmi_di_ordinamento_comparativi","lower bound for comparison-based sorting","loại so sánh)","ml:താരതമ്യ സോര്ട്ട്","omparison-based","ordenação por comparação","perbandingan sejenis)","rodzaju porównanie","sorta di confronto)","sorte de comparaison)","tipo de comparación","tipo de comparación)","tipo de comparação","tipo di confronto","type de comparaison","uri ng paghahambing)","vorm van vergelijking","вид сравнения","основанный на сравнениях","سورت مقایسه ای","مرتب سازی بر اساس مقایسه","താരതമ്യ സോർട്ട്","⌈ log 2 ( n ! ) ⌉","作比較","作比较","比較のような","比較の並べ替え","比较排序","比较排序算法","的比较类型","비교 정렬"],"name":"Comparison sort","categories":["Sorting algorithms"],"tag_line":"A comparison sort is a type of sorting algorithm that only reads the list elements through a single abstract comparison operation (often a \"less than or equal to\" operator or a three-way comparison) that determines which of two elements should occur first in the final sorted list."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pancake-sorting","_score":0,"_source":{"description":"Pancake sorting is the colloquial term for the mathematical problem of sorting a disordered stack of pancakes in order of size when a spatula can be inserted at any point in the stack and used to flip all pancakes above it. A pancake number is the maximum number of flips required for a given number of pancakes. In this form, the problem was first discussed by American geometer Jacob E. Goodman. It is a variation of the sorting problem in which the only allowed operation is to reverse the elements of some prefix of the sequence. Unlike a traditional sorting algorithm, which attempts to sort with the fewest comparisons possible, the goal is to sort the sequence in as few reversals as possible. A variant of the problem is concerned with burnt pancakes, where each pancake has a burnt side and all pancakes must, in addition, end up with the burnt side on bottom.\n^ Simon Singh (November 14, 2013). \"Flipping pancakes with mathematics\". The Guardian. Retrieved March 25, 2014.","alt_names":["-> Read more about Pancake sorting","...more on Wikipedia about Pancake sorting","Burned Pancake Problem","Burnt Pancake","Burnt Pancake Problem","Burnt Pancake Problem (Wikipedia)","Burnt Pancake problem","Burnt Pancake sort problem","Learn about Pancake sorting>>>","Lees meer over het burnt pancake problem","Ordinamento delle frittelle","Ordinamento delle frittelle - Wikipedia","Ordinamento delle frittelle - Wikipedia- /w/opensearch_desc.php title","Palaneet letut -probleemissa","Pancake Problem","Pancake Sort","Pancake Sorting","Pancake sort","Pancake sorting","Pancake sorting - Wikipedia :: The free encyclopedia","Pancake sorting - Wikipedia, the free encyclopedia","Pancake sorting - Wikipedia,...","Pancake sorting - wikipedia","Pancake sorting Wikipedia the free encyclopedia","Pancake sorting algorithm – Wikipedia","Pancake sorting from Wikipedia","Pancake sorting problem","Read More About pancake sorting - wikipedia the free","Related Integer Sequences","Simple pancake sort","The Burnt Pancake Problem","Tri de crêpes","What is algorithm of Pancake sorting","Wikipedia article Pancake sorting","Wikipedia article on Pancake sorting","Wikipedia article on pancake sorting","Wikipedia article Նրբաբլիթային տեսակավորում","Wikipedia entry for Pancake sorting","Wikipedia: Pancake sorting","burnt pancake","burnt pancake -ongelmaa","burnt pancake problem","dell'ordinamento delle frittelle","en.wikipedia.org/wiki/Pancake_sorting","fr:Tri de crêpes","http://en.wikipedia.org/wiki/Burnt_pancake_problem","http://en.wikipedia.org/wiki/Pancake_sor","http://en.wikipedia.org/wiki/Pancake_sorting","http://en.wikipedia.org/wiki/Pancake_sorting#cite_note-4","http://en.wikipedia.org/wiki/Pancake_sorting.","http://en.wikipedia.org/wiki/Pancake_sorting?","http://en.wikipedia.org/wiki/Pancake_sor…","http://fr.wikipedia.org/wiki/Tri_de_cr%C3%AApes","http://fr.wikipedia.org/wiki/Tri_de_cr%C…","http://it.wikipedia.org/wiki/Ordinamento_delle_frittelle","http://ru.wikipedia.org/wiki/Блинная_сортировка","hy:Նրբաբլիթային տեսակավորում","in één keer omgedraaid","it:Ordinamento delle frittelle","menyortir serabi","ordinamento delle frittelle","pancake problem","pancake sort","pancake sorting","pancake sorting problem","pancake sorting,","pancake-sort","pancake_sorting","pannenkoeken probleem","pannkookide sorteerimise kombinatoorikaülesande","prefix reversal","problema de ordenamiento de las tortillas quemadas","ru:Блинная сортировка","sort a stack of pancakes","the pancake problem","Блинная сортировка","Блинная сортировка — Википедия","блинной сортировки","блинную сортировку","сортировке подгоревших блинчиков","Նրբաբլիթային ...","Նրբաբլիթային տեսակավորում","کلوچه ای","প্যানকেক সর্টিং","どんだけだい？","パンケーキソート"],"name":"Pancake sorting","categories":["Articles with inconsistent citation formats","Sorting algorithms","Use mdy dates from October 2014"],"tag_line":"Pancake sorting is the colloquial term for the mathematical problem of sorting a disordered stack of pancakes in order of size when a spatula can be inserted at any point in the stack and used to flip all pancakes above it."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cycle-sort","_score":0,"_source":{"description":"Cycle sort is an in-place, unstable sorting algorithm, a comparison sort that is theoretically optimal in terms of the total number of writes to the original array, unlike any other in-place sorting algorithm. It is based on the idea that the permutation to be sorted can be factored into cycles, which can individually be rotated to give a sorted result.\nUnlike nearly every other sort, items are never written elsewhere in the array simply to push them out of the way of the action. Each value is either written zero times, if it's already in its correct position, or written one time to its correct position. This matches the minimal number of overwrites required for a completed in-place sort.\nMinimizing the number of writes is useful when making writes to some huge data set is very expensive, such as with EEPROMs like Flash memory where each write reduces the lifespan of the memory.","alt_names":["code on Wikipedia","- Cycle sort :","Cycle Sort","Cycle sort","Cycle sort - Wikipedia, the free encyclopedia","Cycle sort: in place, unstable, and theoretically optimal","Cycle sort; it is used under the","Cycle_sort","Wikipedia article Cycle sort","Wikipedia article on Cycle sort","cycle sort","cyclesort","en.wikipedia.org/wiki/Cycle_sort","http://en.wikipedia.org/wiki/Cycle_sort"],"name":"Cycle sort","categories":["Articles with example pseudocode","Comparison sorts","Online sorts","Sorting algorithms"],"tag_line":"Cycle sort is an in-place, unstable sorting algorithm, a comparison sort that is theoretically optimal in terms of the total number of writes to the original array, unlike any other in-place sorting algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"odd–even-sort","_score":0,"_source":{"description":"In computing, an odd–even sort or odd–even transposition sort (also known as brick sort) is a relatively simple sorting algorithm, developed originally for use on parallel processors with local interconnections. It is a comparison sort related to bubble sort, with which it shares many characteristics. It functions by comparing all odd/even indexed pairs of adjacent elements in the list and, if a pair is in the wrong order (the first is larger than the second) the elements are switched. The next step repeats this for even/odd indexed pairs (of adjacent elements). Then it alternates between odd/even and even/odd steps until the list is sorted.","alt_names":[],"name":"Odd–even sort","categories":["Accuracy disputes from July 2014","All stub articles","Articles containing proofs","Articles with example pseudocode","Comparison sorts","Computer science stubs","Sorting algorithms","Stable sorts"],"tag_line":"In computing, an odd–even sort or odd–even transposition sort (also known as brick sort) is a relatively simple sorting algorithm, developed originally for use on parallel processors with local interconnections."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cartesian-tree","_score":0,"_source":{"description":"In computer science, a Cartesian tree is a binary tree derived from a sequence of numbers; it can be uniquely defined from the properties that it is heap-ordered and that a symmetric (in-order) traversal of the tree returns the original sequence. Introduced by Vuillemin (1980) in the context of geometric range searching data structures, Cartesian trees have also been used in the definition of the treap and randomized binary search tree data structures for binary search problems. The Cartesian tree for a sequence may be constructed in linear time using a stack-based algorithm for finding all nearest smaller values in a sequence.","alt_names":[],"name":"Cartesian tree","categories":["Binary trees","CS1 French-language sources (fr)","Sorting algorithms"],"tag_line":"In computer science, a Cartesian tree is a binary tree derived from a sequence of numbers; it can be uniquely defined from the properties that it is heap-ordered and that a symmetric (in-order) traversal of the tree returns the original sequence."}}
,{"_index":"throwtable","_type":"algorithm","_id":"flashsort","_score":0,"_source":{"description":"Flashsort is a distribution sorting algorithm showing linear computational complexity  for uniformly distributed data sets and relatively little additional memory requirement. The original work was published in 1998 by Karl-Dietrich Neubert.","alt_names":["Flashsort","Flashsort - Wikipedia, the free encyclopedia","Flashsort |","K ( A i ) = 1 + INT ( m - 1 ) A","Learn about Flashsort>>>","What is Flashsort's efficiency","Wikipedia article Flashsort","Wikipedia article on Flashsort","Wikipedia entry for Flashsort","en.wikipedia.org/wiki/Flashsort","flash sort","flashsort","http://en.wikipedia.org/wiki/Flashsort"],"name":"Flashsort","categories":["Sorting algorithms"],"tag_line":"Flashsort is a distribution sorting algorithm showing linear computational complexity  for uniformly distributed data sets and relatively little additional memory requirement."}}
,{"_index":"throwtable","_type":"algorithm","_id":"huffman-coding","_score":0,"_source":{"description":"In computer science and information theory, a Huffman code is a particular type of optimal prefix code that is commonly used for lossless data compression. The process of finding and/or using such a code proceeds by means of Huffman coding, an algorithm developed by David A. Huffman while he was a Ph.D. student at MIT, and published in the 1952 paper \"A Method for the Construction of Minimum-Redundancy Codes\".\nThe output from Huffman's algorithm can be viewed as a variable-length code table for encoding a source symbol (such as a character in a file). The algorithm derives this table from the estimated probability or frequency of occurrence (weight) for each possible value of the source symbol. As in other entropy encoding methods, more common symbols are generally represented using fewer bits than less common symbols. Huffman's method can be efficiently implemented, finding a code in linear time to the number of input weights if these weights are sorted. However, although optimal among methods encoding symbols separately, Huffman coding is not always optimal among all compression methods.\n\n","alt_names":["variable-length decoding","Huffmann","The Wikipedia reference","HUFFMAN","variable-length coding","huffman","Main properties","Huffman Code","Huffman code","Huffman Coding","http://en.wikipedia.org/wiki/Huffman_coding","(EN) Codifica di Huffman (da wikipedia)","(Huffman Code)","- Huffman code :","-> Leggi tutto l'articolo su 'Codifica di Huffman","-> Read the article about 'Huffman coding'","...Wikipedia Codage de Huffman","...Wikipedia Codifica di Huffman","...Wikipedia Codificación Huffman","...Wikipedia Codificação de Huffman","...Wikipedia Kodowanie Huffmana","...more on Wikipedia about Huffman coding","1 Кодирование Хаффмана","11 Lên kết ngoài","2 Dẫn nhập","2 Адаптивное сжатие","2.1 Informal description","2.1 Mã tiền tố (prefix-free binary code","2.2 Biểu diễn mã tiền tố trên cây","2.2 Formalized description","2.3 Mã tiền tố tối ưu","2.3 Samples","250px-Huffman_coding_example. ...","3 Basic technique","3 Bài toán","3 Переполнение","3.1 Dữ liệu","4 Giải thuật","4 Main properties","4 Масштабирование весов узлов дерева Хаффмана","5 Giải thuật tham lam","5.1 n-ary Huffman coding","5.2 Adaptive Huffman coding","5.3 Huffman template algorithm","5.4 Length-limited Huffman coding","5.5 Huffman coding with unequal letter costs","5.6 Optimal alphabetic binary trees (Hu-Tucker coding","5.7 The canonical Huffman code","5.8 Model reconstruction","7 Hàng đợi có ưu tiên","8 Mã giả","8.1 Tạo hàng đợi bằng đống (heap)","8.2 Xây dựng cây Huffman","8.3 Xây dựng bộ mã","8.4 Nén file bằng mã Huffman","93f6a8cf382b97ccad472e4b ...","::link1:: Huffman Wikipedia(En)","??d???p???s? Huffman - ????pa?de?a","Algorisme_d'Huffman","Algorytm Huffmana","Article on Huffman coding","Brug korte bit-sekvenser til at repræsentere værdier","Codage de Huffman","Codage de Huffman - Wikip?dia","Codage de Huffman - Wikipédia","Codage de Huffman - Wikipédia http://fr.wikipedia.org","Code de Huffman","Coder/compresser","Codici di Huffman","Codifica di Huffman","Codifica di Huffman (da wikipedia)","Codifica di Huffman - Wikipedia","Codifica di Huffman,","Codificació de Huffman","Codificació de Huffman - Viquipèdia","Codificación Huffman","Codificación Huffman (Wikipedia)","Codificación Huffman - Wikipedia, la enciclopedia libre","Codificación Huffman,","Codificación de Huffman","Codificación de Huffmann","Codificação Huffman","Codificação de Huffman","Codificação de Huffman - Wikipédia, a enciclopédia livre","Codificação de Huffman – Wikipédia, a enciclopédia livre","Codificação de Huffman,","Codurile Huffman","Compresion sin perdidas","Código Huffman","Código Huffman adaptable","David Huffman in 1951 at MIT","El método de Huffman","El uso a corto secuencias de bits para","Gebruik korte bit-sequenties regelmatig vertegenwoordigen de waarden","Haffman code","Hafmanovo kodiranje","Hoffman code","Hoffman coding","How to apply for Huffman Compression?","How to apply for Huffman algorithm?","Huffman Bäume","Huffman Codificación","Huffman Coding (Wikipedia)","Huffman Coding (engl.)","Huffman Coding :: The First Compression Method I Ever","Huffman Coding Algorithm","Huffman Coding Explanation","Huffman Coding Tree","Huffman Coding 에 대한 정의 대충 훑기","Huffman Coding,","Huffman Compression","Huffman Data Compression","Huffman Decoding","Huffman Encoding","Huffman Encoding WikiPedia","Huffman Kodierung","Huffman Squeeze","Huffman Sıkıştırma Algoritması","Huffman Tree","Huffman Trees","Huffman Træ.","Huffman algorithm","Huffman boom","Huffman code a","Huffman code i","Huffman code,","Huffman codebooks","Huffman coded","Huffman coded data","Huffman coder","Huffman codering","Huffman coders","Huffman codes","Huffman codiert","Huffman codifica","Huffman codificado","Huffman codificati","Huffman codificação","Huffman coding","Huffman coding - Wikipedia :: The free encyclopedia","Huffman coding - Wikipedia, the free encyclopedia","Huffman coding - Wikipedia, the free encyclopedia ...","Huffman coding - Wikipedia, the free encyclopedia In computer","Huffman coding Wikipedia the free encyclopedia","Huffman coding algorithm","Huffman coding and Algorithm","Huffman coding for loseless data compression","Huffman coding per wikipedia","Huffman coding wikipedia article","Huffman coding(霍夫曼编码)","Huffman coding.","Huffman coding: History","Huffman codés","Huffman compression","Huffman cây","Huffman decoding","Huffman decoding (Huffman trees)","Huffman encoded","Huffman encoder","Huffman encoders","Huffman encoding","Huffman encoding tree","Huffman encodings","Huffman gecodeerd","Huffman il terribile","Huffman kodet","Huffman kodlaması","Huffman kodning","Huffman kodowane","Huffman kodu","Huffman kodu - Vikipedi","Huffman kodu - Vikipedi - Wikipedia","Huffman koodaukseen","Huffman koodaukseen.","Huffman kódované","Huffman kódování","Huffman kódování,","Huffman kóðunin","Huffman mã hóa","Huffman style","Huffman tables","Huffman trees","Huffman træ","Huffman árboles","Huffman кодирования","Huffman कूटबन्धन","Huffman कोडन","Huffman पेड़","Huffman รหัส","Huffman เข้ารหัส","Huffman's Static","Huffman's algorithm","Huffman's coding","Huffman's compression algorithm","Huffman's greedy algorithm","Huffman's method","Huffman's original algorithm","Huffman- kodning - Wikipedia, den frie en...","Huffman-Algorithmus","Huffman-Baum","Huffman-Codierung,","Huffman-Kodierung,","Huffman-coded","Huffman-codering","Huffman-coding","Huffman-encoded","Huffman-koding","Huffman-kodning","Huffman-kodning - Wikipedia, den frie en...","Huffman-koodauksella","Huffman-а","Huffman.","Huffman_Wikipedia","Huffman_code","Huffman_coding","Huffman_encoding","Huffmancodering","Huffmancodering - Wikipedia","Huffmancodering-algoritme","Huffmancodierung","Huffmani kodeerimine","Huffmani kodeerimine - Vikipeedia, vaba entsüklopeedia","Huffmani kodeerimise","Huffmani koodi","Huffmanin koodaus","Huffmanin koodaus – Wikipedia","Huffmanin koodausta","Huffmankodet","Huffmankodning","Huffmann Coding","Huffmann coding","Huffmannin koodaus","Huffmanov kod","Huffmanova kodovani","Huffmanova kódování","Huffmanovo kódování","Huffmanovo kódování - Wikipedie","Huffmanovo kódování @ cs.Wikipedia","Huffmanovo kódování @ en.Wikipedia","Huffmanovog algoritma","Huffmanově kódování","Huffman符号","Huffman編碼","Huffman编码","Huffman编码的","Kodierung Huffman","Kodowanie Huffmana","Kodowanie Huffmana - Wikipedia, wolna encyklopedia","Kodowanie Huffmana – Wikipedia, wolna encyklopedia","Kodowanie_Huffmana","La codifica Huffman","Le codage Huffman","Learn about Huffman coding>>>","M Huffman Wikipedia ting Vit","M Huffman ting Vit","More Info On Wiki","Mr Huffman","Mã Huffman","Mã Huffman – Wikipedia tiếng Việt","Mã hóa Huffman","Mã hóa Huffman – Wikipedia tiếng Việt","One thing you can do with a frequency","Pohon Huffman","Pourriez-codage Huffman","Používat krátké bit-sekvence představují hodnoty, které se","Read More About huffman coding - wikipedia the free","Read More huffman coding wikipedia the free encyclopedia","TIL that the Black Eyed Peas have an","Thumbnail of screenshot of Huffman coding - Wikipedia, the","Un uso a breve sequenze di bit per","Use short bit-sequences to represent the values","Używaj krótkich sekwencji bitów do reprezentowania wartości, które","Variable-Length Decoding","Variable-Length Decoding (VLD)","Variable-length decoding (VLD)","Verwenden Sie kurze bit-Sequenzen, um die Werte","Vikipedi'deki Huffman","Voir explication sur","What are variations of Huffman code?","What are variations of Huffman tree?","What is the history of Data compression/Huffman","What is the history of Huffman Compression algorithm","What is the history of Huffman-Shannon-Fano","Wiki Article on an easy to understand Lossless","Wikipedia - Huffman Coding","Wikipedia - Huffman coding","Wikipedia :code de Huffman","Wikipedia Codificación Huffman","Wikipedia Entry: Huffman Coding","Wikipedia article Algorisme d'Huffman","Wikipedia article Codificação de Huffman","Wikipedia article Huffman code","Wikipedia article Huffman encoding","Wikipedia article Huffmanin koodaus","Wikipedia article Huffmankodning","Wikipedia article Kodowanie Huffmana","Wikipedia article on Codificación Huffman","Wikipedia article on Codificación de Huffman","Wikipedia article on Huffman coding","Wikipedia article קוד הופמן","Wikipedia article ترميز هوفمان","Wikipedia article รหัสฮัฟแมน และ รหัสแชนนอน-ฟาโน","Wikipedia artikel Huffman codering","Wikipedia artikel Huffmancodering","Wikipedia entry for Huffman Coding","Wikipedia entry for Huffman coding","Wikipedia explains that Huffman coding is","Wikipedia l'articolo Codifica di Huffman","Wikipedia on Huffman algorithm","Wikipedia page on Huffman Coding","Wikipedia sur Code de Huffman","Wikipedia – Huffmanův kód","Wikipedia's encyclopedia entry on Huffman coding","Wikipedia,the free encyclopedia.Huffman coding","Wikipedia. Huffman coding","Wikipedia: Huffman Coding","Wikipedia: Huffman coding","Wikipedia:Codifica_di_Huffman","Wikipedia:Huffman","Wikipedian Huffman coding -artikkeli","Wikipediaで「ハフマン符号」を調べる","Wikipediaのハフマン符号の例","Wikipédia, Codage de Huffman","Zie bijvoorbeeld Huffmancodering.","[COLOR=window****]Huffman coding[/COLOR]","``Huffman coding'' on Wikipedia","a http://en.wikipedia.org/wiki/Huffman_coding","alberi di Huffman","albero di Huffman","algorithme d'Huffman","algoritma hufman","algoritma hufman.","algoritmo di Huffman","algoritmul Huffman","algoritmus Huffmanovho kódovania","algorytmem Huffmana","algorytmu Huffmana","alphabetic coding","arbre d'Huffman","arbres Huffman","artículo de Wikipedia Codificación Huffman","artículo de Wikipedia Codificación de Huffman","ca.wikipedia.org/wiki/Codificaci%C3%B3_de_Huffman","ca:Codificació de Huffman","codage de Huffman","codage de Huffman.","codage de huffman","codari Huffman","codifica Huffman","codifica a lunghezza variabile","codifica di Huffman","codifica di Hufman","codifica di huffman","codificación Huffman","codificación de","codificación de Huffman","codificación de huffman","codificação Huffman","codificação de Huffman","codificação huffman","coding tree","codurilor Huffman","complex ideas","compression Huffman","compression de Huffman","cây Huffman","código Huffman","códigos de Huffman","description available here","di Huffman","di Huffman Coding","di codifica Huffman","dosyalar?n? ufaltabilme","dosyalarini ufaltabilme","dosyalarını ufaltabilme","drzewa Huffmana","e Huffman","economic encoder.","efficiently encoded","en.wikipedia.org/...Huffman_coding","en.wikipedia.org/wiki/Huffm...","en.wikipedia.org/wiki/Huffman_code","en.wikipedia.org/wiki/Huffman_coding","en.wikipedia.org/wiki/Huffman_encoding","encodage de Huffman","es.wikipedia.org/wiki/Codificaci%C3%B3n_Huffman","f Huffman encodin","g Huffman coding","http://ca.wikipedia.org/wiki/Algorisme_d'Huffman","http://ca.wikipedia.org/wiki/Codificaci%C3%B3_de_Huffman","http://ca.wikipedia.org/wiki/Huffman_coding","http://cs.wikipedia.org/wiki/Huffmanovo_k%C3%B3dov","http://cs.wikipedia.org/wiki/Huffmanovo_kódování","http://cs.wikipedia.org/wiki/Huffmanovo_kódování...","http://da.wikipedia.org/wiki/Huffman-kodning","http://el.wikipedia.org/wiki/%CE%9A%...%CE","http://el.wikipedia.org/wiki/Κωδικοποίηση_Huffman","http://en.wikipedia..../Huffman_coding","http://en.wikipedia....ki/Huffman_code","http://en.wikipedia.org/wiki/Huf...","http://en.wikipedia.org/wiki/Huffma","http://en.wikipedia.org/wiki/Huffma...","http://en.wikipedia.org/wiki/Huffman coding","http://en.wikipedia.org/wiki/Huffman...Huffman_coding","http://en.wikipedia.org/wiki/Huffman...ain_properties","http://en.wikipedia.org/wiki/Huffman...asic_technique","http://en.wikipedia.org/wiki/Huffman_","http://en.wikipedia.org/wiki/Huffman_Coding","http://en.wikipedia.org/wiki/Huffman_co ... _technique","http://en.wikipedia.org/wiki/Huffman_co … _technique","http://en.wikipedia.org/wiki/Huffman_cod","http://en.wikipedia.org/wiki/Huffman_cod?","http://en.wikipedia.org/wiki/Huffman_code","http://en.wikipedia.org/wiki/Huffman_coding (Ap","http://en.wikipedia.org/wiki/Huffman_coding#","http://en.wikipedia.org/wiki/Huffman_coding#Applications","http://en.wikipedia.org/wiki/Huffman_coding#Applications.","http://en.wikipedia.org/wiki/Huffman_coding#Basic_technique","http://en.wikipedia.org/wiki/Huffman_coding#External_links","http://en.wikipedia.org/wiki/Huffman_coding#History","http://en.wikipedia.org/wiki/Huffman_coding#Huffman_coding_with_unequal_letter_costs","http://en.wikipedia.org/wiki/Huffman_coding#The_canonical_Huf...","http://en.wikipedia.org/wiki/Huffman_coding#The_canonical_Huffma","http://en.wikipedia.org/wiki/Huffman_coding#The_canonical_Huffman_code","http://en.wikipedia.org/wiki/Huffman_coding#The_canonical_Huffman_codehttp://mitpress","http://en.wikipedia.org/wiki/Huffman_coding#n-ary_","http://en.wikipedia.org/wiki/Huffman_coding#n-ary_Huffman_coding","http://en.wikipedia.org/wiki/Huffman_coding.","http://en.wikipedia.org/wiki/Huffman_coding...","http://en.wikipedia.org/wiki/Huffman_coding~~V","http://en.wikipedia.org/wiki/Huffman_cod…","http://en.wikipedia.org/wiki/Huffman_encoding","http://en.wikipedia.org/wiki/Huffman_encoding#History","http://en.wikipedia.org/wiki/Huffman_enc…","http://es.wikipedia.org/wiki/Codificaci%C3%B3n_Huffman","http://es.wikipedia.org/wiki/Codificaci%C3%B3n_de_Huffman","http://es.wikipedia.org/wiki/Codificaci%c3%b3n_Huffman","http://et.wikipedia.org/wiki/Huffmani_kodeerimine","http://fa.wikipedia.org/wiki/کد%E2%80","http://fa.wikipedia.org/wiki/کدگذاری_هافمن","http://fi.wikipedia.org/wiki/Huffmanin_koodaus","http://fr.wikipedia.org/wiki/Codage_de_Huffman","http://fr.wikipedia.org/wiki/Codage_de_H…","http://he.wikipedia.org/wiki/%D7%A7...%A4","http://it.wikipedia....fica_di_Huffman","http://it.wikipedia.org/wiki/Codifica_Huffman","http://it.wikipedia.org/wiki/Codifica_di_Huffman","http://it.wikipedia.org/wiki/Huffman","http://ja.wikipedia.org/wiki/ハフマン符号","http://nl.wikipedia.org/wiki/Huffmancode","http://nl.wikipedia.org/wiki/Huffmancodering","http://pl.wikipedia....owanie_Huffmana","http://pl.wikipedia.org/wiki/Algorytm_Huffmana","http://pl.wikipedia.org/wiki/Kodowanie_Huffmana","http://pl.wikipedia.org/wiki/Kodowanie_Huffmana#Algorytm_statycznego_kodowania_Huffmana","http://pt.wikipedia.org/wiki/Codific...A3o_de_Huffman","http://pt.wikipedia.org/wiki/Codificação_de_Huffman","http://ru.wikipedia.org/wiki/Алгоритм_Ха...","http://ru.wikipedia.org/wiki/Алгоритм_Хаффмана","http://ru.wikipedia.org/wiki/Код_Хаффман...","http://ru.wikipedia.org/wiki/Код_Хаффмана","http://tr.wikipedia.org/wiki/Huffman","http://vi.wikipedia....M%C3%A3_Huffman","http://vi.wikipedia.org/wiki/M%C3%A3_Huffman","http://zh.wikipedia.org/wiki/%25E9%259C%258D","http://zh.wikipedia.org/zh-tw/%25E9%259C","huffman code","huffman coded","huffman coder","huffman codes","huffman coding","huffman coding here","huffman coding the free encyclopedia","huffman encoding","huffman tree","huffmancodering","huffmankodade","huffmankodning","huffmann coding","huffmannya","huffmanovo kodovanie","it is taken from &quot;Wikipedia&quot;","it.wikipedia.org/wiki/Codifica_di_Huffman","k-ary Huffman encoding","ke Huffman","kodami Huffmana","kode Huffman","kodowania Huffmana","kodowania Huffmana.","kodowanie Huffmana","kodowanie Hufmana","kodowaniu Huffmana","kompresi Huffman.","kódování Huffmana","l'algorithme de Huffman","l'algorithme de compression de Huffman","la codifica Huffman","la codifica di Huffman","la codificación Huffman","la codificación Huffman,","la codificación de Huffman","la compression selon Huffman","le codage Huffman","le codage Huffman,","le codage d'Huffman","le codage de Huffman","length-limited Huffman code","lim w &rightarrow; 0 + log 2 1 w","mã hoá Huffman","mã hóa Huffman","método de Huffman","n Huffman coding on Wikipedia","n-ary Huffman coding","ng Huffman","nl.wikipedia.org/wiki/Huffman_codering","no:Huffman-koding","nén Huffman","pl.wikipedia.org/wiki/Kodowanie_Huffmana","prefix-free Huffman encoding","quello di Huffman","re Huffman codin","ru:Код Хаффмана","t http://en.wikipedia.org/wiki/Huffman_coding","the Huffman one","thuật toán Huffman","variable-length coding tables","vi.wikipedia.org/wiki/M%C3%A3_Huffman","vi.wikipedia.org/wiki/Mã_Huffman","vi.wikipedia.org/wiki/Mã_hóa_Huffman","vi:Mã hóa Huffman","w:Huffman coding","wen:Huffman coding","wikipedia: Huffman encoding","zde(anglicky)","zde(česky)","árbol de Huffman","árvores Huffman","ƒ ƒ•ƒžƒ³ Â","Κωδικοποίηση Huffman","Κωδικοποίηση Huffman - Βικιπαίδεια","κωδικοποίηση Huffman","Алгоритм Хафмана","Алгоритм Хаффмана","Алгоритм Хаффмана (ссылка в интернет!)","Алгоритм Хаффмана — Википедия","Википедии статью Алгоритм Хаффмана","Википедии статью Код Хаффмана","Википедии статью Кодирование Хаффмана","Используйте короткие бит-последовательности, представляющие ценности, которые появляются","Код Хаффмана","Код Хаффмана — Википедия","КодХаффмана","Кодирование Хаффмана","Кодирование Хаффмана,","Метод сжатия Хаффмана","Перепиши код на C","Сжатие (в том числе текстов)","Хафман деревьев","Хафман код","Хаффман закодированы","Хаффмана","Хаффмана закодированы","Хаффману","Хъфман","алгоритм Хаффмана","алгоритм или код Хаффмана","алгоритма Хаффмана","алгоритмом Хаффмана","алгоритму Хаффмана","вКл д Кгж Лл ЛРй б в г","взят из «Википедии»","дерево Хаффмана","иид ЛЛ жКл д Кгж Лл Л г","код Хаффмана","кодами Хаффмана","кодирование Хаффмана","кодирование Хаффмана,","кодирования Хаффмана","методу Хафф-","методу Хаффмана","сжатием по Хаффману","сжатия Хаффмана","старый добрый Huffman","технологию кодирования Хаффмана","хаффмановского","ויקיפדיה - 'קוד הופמן'","קוד Huffman","קוד הופמן","קוד הופמן – ויקיפדיה","קוד הופמן – ויקיפדיה - Wikipedia","קידוד הופמן","קידוד הפמן","الگوریتم huffman","بتشفير هوفمان","ترميز هوفمان","شفرة هوفمان","هافمن","کد گذاریه هافمن","کدگذاری هافمن","کدگذاری هافمن - ویکیپدیا","कोडन Huffman","การ บีบ อัด Huffman","ต้นไม้ Huffman","รหัส Huffman","รหัสฮัฟแมน และ รหัสแชนนอน-ฟาโน","รหัสฮัฟแมน และ รหัสแชนนอน-ฟาโน - วิกิพีเดีย","“Huffman coding - Wikipedia, the free encyclopedia”, en.wikipedia","• Huffman coding","→ Huffman","♦ Huffman coding - Wikipedia, the free encyclopedia","『ハフマン符号』の解説","ウィキペディアの記事 ハフマン符号","ハフマンは","ハフマンを","ハフマンコーディング","ハフマンコーディングが","ハフマンコーディングを","ハフマンツリー","ハフマン圧縮","ハフマン法","ハフマン符号","ハフマン符号 - Wikipedia","ハフマン符号 – Wikipedia","ハフマン符号の","ハフマン符号は、","ハフマン符号化","ハフマン符号化の","ハフマン符号化を","ハフマン符号化法","ハフマン符合","使用して短いビットシーケンスがより頻繁に表示される値を表す","使用短的位序列代表的价值观出现较频繁","哈夫曼","哈夫曼树","哈夫曼樹","哈夫曼編碼","哈夫曼编码","着陸地点","維基百科的文章“ 哈夫曼树”","維基百科的文章“ 哈夫曼编码”","維基百科的文章“ 霍夫曼编码”","维基百科的文章“ 哈夫曼树”","维基百科的文章“ 哈夫曼编码”","维基百科的文章“ 霍夫曼编码”","胡夫曼编码树","霍夫曼压缩","霍夫曼壓縮","霍夫曼树","霍夫曼樹","霍夫曼編碼","霍夫曼编码","霍夫曼编码- 维基百科，自由的百科全书","霍夫曼（Huffman）编码","위키 피 디아 문서 허프만 부호화","위키 피 디아 문서 허프만 코딩","코딩 퍼레이드가","퍼레이드 나무","퍼레이드는 코딩","허프만 부호화","허프만 부호화 - 위키백과, 우리 모두의 백과사전","허프만 압축","허프만 코딩","허프만 코딩(Huffman coding)방식","허프만 코딩,","허프만 코딩입니다.","허프만부호화- 위키백과, 우리 모두의 백과사전","，Huffman編碼","，Huffman编码","ﾊﾌﾏﾝ符号-wikipedia"],"name":"Huffman coding","categories":["1952 in computer science","All articles lacking in-text citations","Articles lacking in-text citations from January 2011","Binary trees","Commons category with local link same as on Wikidata","Lossless compression algorithms","Wikipedia articles needing clarification from February 2012"],"tag_line":"In computer science and information theory, a Huffman code is a particular type of optimal prefix code that is commonly used for lossless data compression."}}
,{"_index":"throwtable","_type":"algorithm","_id":"radix-sort","_score":0,"_source":{"description":"In computer science, radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value. A positional notation is required, but because integers can represent strings of characters (e.g., names or dates) and specially formatted floating point numbers, radix sort is not limited to integers. Radix sort dates back as far as 1887 to the work of Herman Hollerith on tabulating machines.\nMost digital computers internally represent all of their data as electronic representations of binary numbers, so processing the digits of integer representations by groups of binary digit representations is most convenient. Two classifications of radix sorts are least significant digit (LSD) radix sorts and most significant digit (MSD) radix sorts. LSD radix sorts process the integer representations starting from the least digit and move towards the most significant digit. MSD radix sorts work the other way around.\nLSD radix sorts typically use the following sorting order: short keys come before longer keys, and keys of the same length are sorted lexicographically. This coincides with the normal order of integer representations, such as the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11.\nMSD radix sorts use lexicographic order, which is suitable for sorting strings, such as words, or fixed-length integer representations. A sequence such as \"b, c, d, e, f, g, h, i, j, ba\" would be lexicographically sorted as \"b, ba, c, d, e, f, g, h, i, j\". If lexicographic ordering is used to sort variable-length integer representations, then the representations of the numbers from 1 to 10 would be output as 1, 10, 2, 3, 4, 5, 6, 7, 8, 9, as if the shorter keys were left-justified and padded on the right with blank characters to make the shorter keys as long as the longest key for the purpose of determining sorted order.\n\n","alt_names":["Radix sort","radix sort","* http://en.wikipedia.org/wiki/Radix_sort","- Radix sort :","-> Read the article about 'Radix sort'","...Wikipedia Radix sort","...Wikipedia Sortowanie pozycyjne","...Wikipedia Tri par base","...mehr auf Wikipedia über Radixsort","...more on Wikipedia about Radix sort","1 - Radix sort - Wikipedia, the free encyclopedia","2 - Radix sort - Wikipédia","2 Least significant digit radix sorts","2.2 An example","2.3 Iterative version using queues","2.4 Example in Python","3 Most significant digit radix sorts","3.1.1 Implementation","3.2 Recursive forward radix sort example","3.3 In-place MSD radix sort implementations","3.4 Stable MSD radix sort implementations","3.5 Hybrid approaches","3.6 Application to parallel computing","3.7 Incremental trie-based radix sort","3.7.1 Snow White analogy","@ 기수 정렬(위키피디아)","A radix sorting algorithm was originally used to","Basamağa göre sıralama","Basamağa göre sıralama - Vikipedi","Basistyp","Binary MSD radix sort, also called binary quicksort","Clasificar Radix","En lugar de base tipo MSD","Encyclopedia: Radix sort","Fachverteilung","In-place MSD radix sort","Kantalukulajittelu","Kantalukulajittelu – Wikipedia","LSD Radix Sort","Learn about Radix sort>>>","Least Significant Digit Radix Sort","Least significant digit radix sort","Least significant digit radix sorts","MSD Radix Sort","MSD radix","Most Significant Digit Radix Sort","Most significant digit radix sorts","Ordenamiento Radix","Ordenamiento Radix - Wikipedia, la enciclopedia libre","Ordenamiento RadixSort","Ordinamento digitale","Phân loại Radix","RADIX sort","Radix Ordenar","Radix Ordenar!","Radix Seřadit","Radix Sort","Radix Sort (Wikipedia)","Radix Sort - Wikipedia, The Free Encyclopedia","Radix Sort Algorithm","Radix Sort!","Radix Sort.","Radix Sorteer","Radix Sorteer!","Radix Sorter","Radix Sorteren","Radix Sorting","Radix Sortuj","Radix Sortuj!","Radix Sortér","Radix Sortér!","Radix Trier","Radix Třídit","Radix druh","Radix sort -","Radix sort - Wikipedia","Radix sort - Wikipedia, the free encyclopedia","Radix sort - Wikipedie","Radix sort - WikipÃ©dia, a enciclopÃ©dia livre","Radix sort - Wikipédia","Radix sort @ Wikipedia","Radix sort Wikipedia","Radix sort Wikipedia the free encyclopedia","Radix sort Wikipedia the free encyclopedia - result","Radix sort algorithm","Radix sort is O(n)","Radix sort on Wikipedia","Radix sort ou tri par base","Radix sort with links to other sorting algos","Radix sort – Wikipédia, a enciclopédia livre","Radix sortere algoritme","Radix sorteren","Radix tipo","Radix Řadit!","Radix řazení algoritmus","Radix Сортировать","Radix алгоритм сортировки","Radix сортировки","Radix-Sort-Variante","Radix-sort","RadixExchangeSort","RadixSort","Radix_sort","Radixsort","Radixsort – Wikipedia","Radixsort.","Read More about radix sort wikipedia the free","Read More radix sort wikipedia the free encyclopedia","Sort radix","Sortowanie pozycyjne","Sortowanie pozycyjne – Wikipedia, wolna encyklopedia","Sortuj Radix","Sắp xếp theo cơ số","Tri par base","Unstable implementations of in-place sorting","Urut radix","What is the efficiency of Radix sort?","Why not use non comparison based sorting techniques","Wiki : Radix sort","Wikipedia (Radix sort)","Wikipedia article ''Radix sort''","Wikipedia article Radix sort","Wikipedia article Sortowanie pozycyjne","Wikipedia article on Radix sort","Wikipedia article Կարգային տեսակավորում","Wikipedia entry for Radix sort","Wikipedia entry for radix sort","Wikipedia page on Radixsort","Wikipedia-Artikel Radix sort","Wikipedia-Artikel Radixsort","Wikipedia-Seite zu 'Radixsort'","Wikipedia: Radix sort","WikipediaのRadix sort","Wikipédia artigo Radix sort","adix sort","adresem...","algorytm Radix sort","artículo de Wikipedia Ordenamiento Radix","basistype","bucket trie","classificar radix","cs:Radix sort","cơ số","cơ số sắp xếp","cơ số sắp xếp.","de tri radix","de tri radix.","de.wikipedia.org/Radixsort","de:Radixsort","en.wikipedia.org/Radix_sort","en.wikipedia.org/wiki/Radix...","en.wikipedia.org/wiki/Radix_sort","en.wikipedia.org/wiki/Radix_sort#Efficiency","es:Ordenamiento Radix","especie RADICAL","especie RADIX","espécie radix","fa:الگوریتم مرتبسازی پایهای","fa:مرتبسازی پایهای","fi:Kantalukulajittelu","finite numeric representation","fr:Tri par base","grundtal sortere","he:מיון בסיס","http://cs.wikipedia.org/wiki/Radix_sort","http://de.wikipedia.org/wiki/Radix_sort","http://de.wikipedia.org/wiki/Radixsort","http://de.wikipedia.org/wiki/Radixsort#Beispiel","http://en.wikipedia....wiki/Radix_sort","http://en.wikipedia.org/wiki/Radix% 5Fsort","http://en.wikipedia.org/wiki/Radix%5Fsort","http://en.wikipedia.org/wiki/Radix_sort","http://en.wikipedia.org/wiki/Radix_sort # Efektywność","http://en.wikipedia.org/wiki/Radix_sort # Effektivitet","http://en.wikipedia.org/wiki/Radix_sort # Efficiency","http://en.wikipedia.org/wiki/Radix_sort # Eficiencia","http://en.wikipedia.org/wiki/Radix_sort # Эффективность","http://en.wikipedia.org/wiki/Radix_sort # क्षमता","http://en.wikipedia.org/wiki/Radix_sort ... _in_Python","http://en.wikipedia.org/wiki/Radix_sort Radix sort","http://en.wikipedia.org/wiki/Radix_sort … mentations","http://en.wikipedia.org/wiki/Radix_sort#Efficiency","http://en.wikipedia.org/wiki/Radix_sort#In-place_MSD_radix_sort_implementations","http://en.wikipedia.org/wiki/Radix_sort#Incremental_trie-based_radix_sort","http://en.wikipedia.org/wiki/Radix_sort#Least_significant_digit_radix_sorts","http://en.wikipedia.org/wiki/Radix_sort#Most_significant_digit_radix_sorts","http://en.wikipedia.org/wiki/Radix_sort#Sa...implementations","http://en.wikipedia.org/wiki/Radix_sort#Sampl e_implementations","http://en.wikipedia.org/wiki/Radix_sort)","http://en.wikipedia.org/wiki/Radix_sort,","http://en.wikipedia.org/wiki/Radix_sort.","http://en.wikipedia.org/wiki/Radix_sort＃效率","http://en.wikipedia.org/wiki/Radix％5Fsort","http://en.wikipedia.org/wiki/Radix％5Fsortを","http://es.wikipedia....wiki/Radix_sort","http://es.wikipedia.org/wiki/Ordenamiento_Radix","http://es.wikipedia.org/wiki/Radix_sort","http://es.wikipedia.org/wiki/Radix_sort#…","http://fi.wikipedia.org/wiki/Kantalukulajittelu","http://fr.wikipedia.org/wiki/Tri_par_base","http://it.wikipedia.org/wiki/Radix_sort","http://ja.wikipedia.org/wiki/基数ソート","http://lt.wikipedia.org/wiki/Skaitmeninis_rikiavimas","http://nl.wikipedia.org/wiki/Radix_sort","http://pl.wikipedia....wanie_pozycyjne","http://pl.wikipedia.org/wiki/Sortowanie_pozycyjne","http://pt.wikipedia.org/wiki/Radix_s...B3digo_em_Java","http://pt.wikipedia.org/wiki/Radix_sort","http://pt.wikipedia.org/wiki/Radix_sort#C.C3","http://ru.wikipedia.org/wiki/Radix_sort","http://ru.wikipedia.org/wiki/Поразрядная_сортировка","http://sk.wikipedia.org/wiki/Radix_sort","http://www.wikipedia.org/wiki/Radix_sort","http://zh.wikipedia.org/zh-tw/% E5% 9F","hy:Կարգային տեսակավորում","in-place radix sort","incremental trie-based radix sort","it:Radix sort","ja:基数ソート","ko:기수 정렬","le tri par base","le type de base","les miens","loại cơ số","lt:Skaitmeninis rikiavimo algoritmas","most significant digit radix sort","most-significant-digit radix sort","nl:Radix sort","ordenación por residuos","ordenamiento Radix","ordenar radix","ordinamento di radice","ordinamento digitale","par base","pl:Sortowanie pozycyjne","porządkowania pozycyjnego","pt:Radix sort","radix semacam","radix seperti","radix soort","radix sort algorithm","radix sort wikipedia the free encyclopedia","radix sort.","radix sorteren","radix sortering","radix sorting","radix sortu","radix řazení","radix-sort","radixsort","recursive forward radix sort example","recursively subdividing radix sort algorithm","ru:Поразрядная сортировка","semacam radix","sk:Radix sort","sort radix","sortowanie RADIX","sortowanie Radix","sortowanie pozycy...","sortowanie pozycyjne","specie radice","sắp xếp cơ số","tipo Radix","tipo base","tipo de base","tipo di base","tr:Basamağa göre sıralama","tri par base","tri par racine (radix sort)","tri radix","třídit RADIX","ugat sort.","ugat-uri-uriin","uk:Сортування за розрядами","un ordinamento digitale","vi:Sắp xếp theo cơ số","w:Поразрядная сортировка","wikipedia - radix sort","wp:Radix sort","zh:基数排序","В месте поразрядной сортировки MSD","Википедии статью Поразрядная сортировка","Корень Сортировать","Корень Сортировать!","Лексикографичкская или поразрядная сортировка","На википедии описание есть.","Поразрядная","Поразрядная сортировка","Поразрядная сортировка на Википедии","Поразрядная сортировка — Википедия","Сортировать Radix","Сортування за розрядами","Цифровая сортировка","Цифрове сортування","базовым типом","вид RADIX","за розрядами","основание рода","поразрядная сортировка","поразрядной сортировки","системы счисления рода","сортування за розрядами","счисления","счисления Сортировка","счисления рода","счисления рода.","цифровая сортировка","Կարգային տեսակավորում - Վիքի...","ויקיפדיה - 'מיון בסיס'","מיון בסיס","מיון בסיס – ויקיפדיה","الگوریتم مرتبسازی پایهای","مرتبسازی پایهای","مرتبسازی پایهای - ویکیپدیا","پایه ای","मूलांक के आधार पर क्रमबद्ध!","मूलांक तरह","सकते हैं मूलांक","การ จัด เรียง radix","จัด เรียง radix","เรียง Radix","เรียง ลำดับ","→ Статья «Поразрядная сортировка»","「基数ソート」をWikiで調べる","ウィキペディアの記事 基数ソート","ラディックス","使用基数","基排","基数の並べ替え","基数ソート","基数ソート - Wikipedia","基数ソート(radix sort)","基数ソートは","基数ソートは、","基数ソートを","基数ソートアルゴリズムを","基数ソート！","基数排序","基数排序- 维基百科，自由的百科全书","基数排序算法","基数排序！","基数ｿｰﾄ-wikipedia","基數排序","基數排序- 維基百科，自由的百科全書","基本型の","的基本类型","維基百科的文章“ 基数排序”","기수 정렬","기수 정렬의","기수 정렬하려고","어근이나","위키 피 디아 문서 기수 정렬","＃効率をhttp://en.wikipedia.org/wiki/Radix_sort~~ROOT","，http://en.wikipedia.org/wiki/Radix_sort"],"name":"Radix sort","categories":["Articles with example C code","Sorting algorithms","Stable sorts","String sorting algorithms","Use dmy dates from January 2012"],"tag_line":"In computer science, radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value."}}
,{"_index":"throwtable","_type":"algorithm","_id":"schwartzian-transform","_score":0,"_source":{"description":"The Schwartzian transform is a computer science programming idiom used to improve the efficiency of sorting a list of items. This idiom is appropriate for comparison-based sorting when the ordering is actually based on the ordering of a certain property (the key) of the elements, where computing that property is an intensive operation that should be performed a minimal number of times. The Schwartzian transform is notable in that it does not use named temporary arrays.\nThe idiom is named after Randal L. Schwartz, who first demonstrated it in Perl shortly after the release of Perl 5 in 1994. The term \"Schwartzian transform\" applied solely to Perl programming for a number of years, but it has later been adopted by some users of other languages, such as Python, to refer to similar idioms in those languages. However, the algorithm was already in use in other languages (under no specific name) before it was popularized among the Perl community in the form of that particular idiom by Schwartz. The term \"Schwartzian transform\" indicates a specific idiom, and not the algorithm in general.\nFor example, to sort the word list (\"aaaa\",\"a\",\"aa\") according to word length: first build the list ([\"aaaa\",4],[\"a\",1],[\"aa\",2]), then sort it according to the numeric values getting ([\"a\",1],[\"aa\",2],[\"aaaa\",4]), then strip off the numbers and you get (\"a\",\"aa\",\"aaaa\"). That was the algorithm in general, so it does not count as a transform. To make it a true Schwartzian transform, it would be done in Perl like this:\n\nThe Schwartzian transform is a version of a Lisp idiom known as decorate-sort-undecorate, which avoids recomputing the sort keys by temporarily associating them with the input items. This approach is similar to memoization, which avoids repeating the calculation of the key corresponding to a specific input value. By comparison, this idiom assures that each input item's key is calculated exactly once, which may still result in repeating some calculations if the input data contains duplicate items.","alt_names":["http://en.wikipedia.org/wiki/Schwartz...","certain functions","...more on Wikipedia about Schwartzian transform","A Transformada Schwartziana.","Ang Schwartzian magbagong-anyo.","Các Transform Schwartzian.","Decorate-sort-undecorate","Die Schwartzsche Transformation","Die Schwartzsche Transformation.","El sitio web de La transformada en wikipedia","La transformada Schwartzian.","La transformée Schwartzienne.","Learn about Schwartzian transform>>>","Read More schwartzian transform wikipedia the free encyclopedia","Schartzian-transform","Schwartian transform","Schwartz Transform","Schwartzian","Schwartzian Transform","Schwartzian Transform in Wikipedia","Schwartzian Transform on Wikipedia","Schwartzian Transform.","Schwartzian Transformation","Schwartzian Transforms","Schwartzian Transform”","Schwartzian biến đổi","Schwartzian forvandle","Schwartzian omdanne","Schwartzian przekształcenia","Schwartzian przekształcić","Schwartzian te transformeren","Schwartzian transfor","Schwartzian transform","Schwartzian transform - Wikipedia","Schwartzian transform - Wikipedia, the free encyclopedia","Schwartzian transform - Wikipedia, the free encyclopedia wikipedia.org","Schwartzian transform - Wikipedia, the free encyclopedia »","Schwartzian transform technique","Schwartzian transformace","Schwartzian transformacji","Schwartzian transformar","Schwartzian transformation","Schwartzian transforms","Schwartzian trasformare","Schwartzian át","Schwartzian रूपांतरण","Schwartzian เปลี่ยน","Schwartzian แปลง","Schwartzian 변환.","Schwartzian_Transform","Schwartzian_transform","Schwartzian_transform.","Schwartziana transformar","Schwartzian变换","Schwartzian變換","Schwartzian轉化","Schwartzian과","Schwartzian지도의","Schwartzienne transformer","Schwartzsche Transformation","Schwartzsche verwandeln","Schwartz変換","Schwarzian transform","Schwarztian biến","Schwarztian ibahin ang anyo","Schwarztian transform","Schwarztian transformar","Schwarztian transformer","Schwarztian trasformare","Schwarztian verwandeln","Schwarztian แปลง","Schwarztian改造","Shwarzian Transform","The Perl idiom","The Schwartzian Transform","The Schwartzian Transform.","Transform Schwartz","Transform Schwartzian","Transformada Schwartzian","Transformada Schwartziana","Trasforma il Schwartzian.","Trasformata di Schwartz","What is the history of Schwartzian Transform","Wikipedia article Decorate-sort-undecorate","Wikipedia article Schwartzian Transform","Wikipedia article Schwartzian transform","Wikipedia article on Decorate-sort-undecorate","Wikipedia article on Schwartzian transform","Wikipedia entry for Schwartzian transform","Wikipedia: Schwartzian transform","Wikipedia:Schwartzian_transform","[1] http://en.wikipedia.org/wiki/Schwartzian_transform","[[Schwartzian Transform]]","at http://en.wikipedia.org/wiki/Schwartzian_","biến đổi Schwartzian","decorate-sort-undecorate pattern","en.wikipedia.org/...Schwartzian_transform","en.wikipedia.org/wiki/Schwartzian_transform","explanation and analysis","http://en.wikipedia.org/wiki/Decorate-sort-undecorate","http://en.wikipedia.org/wiki/Schwart...nsform#History","http://en.wikipedia.org/wiki/Schwartzian","http://en.wikipedia.org/wiki/Schwartzian_Tran...","http://en.wikipedia.org/wiki/Schwartzian_Transform","http://en.wikipedia.org/wiki/Schwartzian_Transform>","http://en.wikipedia.org/wiki/Schwartzian_tran...","http://en.wikipedia.org/wiki/Schwartzian_transform","http://en.wikipedia.org/wiki/Schwartzian_transform#History","http://en.wikipedia.org/wiki/Schwartzian_transform. R","http://en.wikipedia.org/wiki/Schwartzian_transform>","http://en.wikipedia.org/wiki/Schwartzian_transformのthumbnail","http://en.wikipedia.org/wiki/Schwartzian…","http://en.wikipedia.org/wiki/Schwarzian_transform","http://tinyurl.com/yklhuf","la transformée Schwartzienne","mengubah Schwartzian","mengubah Schwarztian","schwartzian transform","semi-transformada de Schwartz","the Schwartzian transform","tp://en.wikipedia.org/wiki/Schwartzian_Transform","transformace Schwartzian","transformación Schwartzian","transformación de Schwartz","transformada Schwartziana","transformada de Schwartz","transformada schwartziana","transformation Schwarzienne","trasformazione di Schwartz","ttp://en.wikipedia.org/wiki/Schwartzian_Transform","wikipedia-en:Schwartzian_transform","Шварца преобразование","Шварца преобразований.","Шварца преобразования","преобразование Schwarztian","преобразование Шварца","เปลี่ยน Schwartzian.","シュワルツの変換","シュワルツの変換が","シュワルツ変換","シュワルツ変換 (Schwartzian transform)","シュワルツ変換は、","シュワルツ変換を","一个Schwartzian","在Schwartzian变换","在Schwartzian變換","変換Schwarztian、","変換シュワルツ","変換シュワルツを","它也允许有用内省。例如当你传递块或到Array.sort 的一个子程序，和那代码确切期望一个参数时， Schwartzian 变换","施瓦茨变换","변환 Schwarztian"],"name":"Schwartzian transform","categories":["All articles needing style editing","Articles with example Perl code","Articles with example Racket code","Perl","Programming idioms","Sorting algorithms","Wikipedia articles needing style editing from September 2014"],"tag_line":"The Schwartzian transform is a computer science programming idiom used to improve the efficiency of sorting a list of items."}}
,{"_index":"throwtable","_type":"algorithm","_id":"context-adaptive-binary-arithmetic-coding","_score":0,"_source":{"description":"Context-adaptive binary arithmetic coding (CABAC) is a form of entropy encoding used in the H.264/MPEG-4 AVC and High Efficiency Video Coding (HEVC) standards. It is a lossless compression technique, although the video coding standards in which it is used are typically for lossy compression applications. CABAC is notable for providing much better compression than most other entropy encoding algorithms used in video encoding, and it is one of the key elements that provides the H.264/AVC encoding scheme with better compression capability than its predecessors.\nIn H.264/MPEG-4 AVC, CABAC is only supported in the Main and higher profiles of the standard, as it requires a larger amount of processing to decode than the simpler scheme known as context-adaptive variable-length coding (CAVLC) that is used in the standard's Baseline profile. CABAC is also difficult to parallelize and vectorize, so other forms of parallelism (such as spatial region parallelism) may be coupled with its use. In HEVC, CABAC is used in all profiles of the standard.","alt_names":["CABAC","( en ) CABAC : Context-adaptive binary arithmetic coding","( en ) CABAC: Context-adaptive binary arithmetic coding","( en )CABAC: Context-adaptive binary arithmetic coding","(en) CABAC: Context-adaptive binary arithmetic coding","...Wikipedia CABAC","CABAC - Wikipedia, la enciclopedia libre","CABAC ? Wikipedia, wolna encyklopedia","CABAC entropy coding","CABAC.","CABAC），它能够灵活的将各种语法元素，在已知相应上下文机率分布的状况下进行更有效的无损","Content-based Adaptive Binary Arithmetic Coding","Context Adaptive Binary Arithmetic Coding","Context Adaptive Binary Arithmetic Coding ? Wikipedia","Context Adaptive Binary Arithmetic Coding – Wikipedia","Context Adaptive Binary Arithmetic Coding –…","Context adaptive binary arithmetic coding","Context-adaptive binary arithmetic coding","Context-adaptive binary arithmetic coding (CABAC)","Context-adaptive binary arithmetic coding - Viquipèdia","Context-adaptive binary arithmetic coding - Wikipedia :: The free","Context-adaptive binary arithmetic coding - Wikipedia, the ...","Context-adaptive binary arithmetic coding - Wikipedia, the free","Context-adaptive binary arithmetic coding - Wikipédia","Context-adaptive binary arithmetic coding; it is used","Context-adaptive_binary_arithmetic_coding","Context-based adaptive binary arithmetic coding","Context_Adaptive_Binary_Arithmetic_Coding","De context-adaptief binaire rekenkunde code","WP: CABAC","What is algorithm of Context-adaptive binary arithmetic","What is algorithm of Context-based adaptive binary","Wikipedia (Context-adaptive binary arithmetic coding)","Wikipedia article CABAC","Wikipedia article Context-adaptive binary arithmetic coding","Wikipedia article Context-based adaptive binary arithmetic coding","Wikipedia article about CABAC","Wikipedia article on CABAC","Wikipedia entry for Context-adaptive binary arithmetic coding","Wikipedia-Artikel CABAC","Wikipedia-Seite zu 'CABAC'","Wikipedia-Seite zu 'Context Adaptive Binary Arithmetic Coding","Wikipedia: Context Adaptive Binary Arithmetic Coding","ca:Context-adaptive_binary_arithmetic_coding","context-adaptive binary arithmetic coding","context-based adaptive binary arithmetic coding","es:CABAC","http://de.wikipedia.org/wiki/Context_Ada","http://de.wikipedia.org/wiki/Context_Adaptive_Binary_Arithmetic_Coding","http://en.wikipedia.org/wiki/CABAC","http://en.wikipedia.org/wiki/Context-ad ... tic_coding","http://en.wikipedia.org/wiki/Context-adaptive_binary_arithmetic_coding","http://en.wikipedia.org/wiki/Context-adaptive_binary_arithmetic_coding#","http://en.wikipedia.org/wiki/Context-based_adaptive_binary_ar...","http://en.wikipedia.org/wiki/Context...thmetic_coding","http://en.wikipedia.org/wiki/Context−adaptive_binary_arithmetic_coding","http://es.wikipedia.org/wiki/CABAC","http://fr.wikipedia.org/wiki/Context-adaptive_binary_arithmetic_coding","http://pl.wikipedia.org/wiki/CABAC","http://ru.wikipedia.org/wiki/CABAC","ru:CABAC","substantially greater","前文參考之適應性二元算術編碼","前文參考之適應性二元算術編碼- 維基百科，自由的百科全書","維基百科的文章“ CABAC ”","維基百科的文章“ 前文參考之適應性二元算術編碼”","维基百科的文章“ CABAC ”","维基百科的文章“ 前文參考之適應性二元算術編碼”"],"name":"Context-adaptive binary arithmetic coding","categories":["Lossless compression algorithms","MPEG","Video compression"],"tag_line":"Context-adaptive binary arithmetic coding (CABAC) is a form of entropy encoding used in the H.264/MPEG-4 AVC and High Efficiency Video Coding (HEVC) standards."}}
,{"_index":"throwtable","_type":"algorithm","_id":"huffyuv","_score":0,"_source":{"description":"Huffyuv (or HuffYUV) is a lossless video codec created by Ben Rudiak-Gould which is meant to replace uncompressed YCbCr as a video capture format. The codec can also compress in the RGB color space.\n\"Lossless\" means that the output from the decompressor is bit-for-bit identical with the original input to the compressor. Lossless only occurs when the compression color space matches the input and output color space. When the color spaces do not match, a low loss compression is performed.\nHuffyuv's algorithm is similar to that of lossless JPEG, in that it predicts each sample and then Huffman-encodes the error.","alt_names":["http://ja.wikipedia.org/wiki/Huffyuv","Huffyuv","-> Leggi tutto l'articolo su 'Huffyuv'","-> Read more about Huffyuv","-> Read the article about 'Huffyuv'","->huffyuv<-","...mehr auf Wikipedia über HuffYUV","...more on Wikipedia about Huffyuv","Detailed HuffYUV information","Du weist schon dass Huffyuv nur mit YUV","HUFFYUV","HuffYUV","HuffYUV - LossLess YCbCr Video Codec","HuffYUV - Wikipedia","HuffYUV - WikipÃ©dia","HuffYUV - Wikipédia","HuffYUV YCbCr Lossless Video","HuffYUV – Wikipedia","HuffYUV – Wikipédia, a enciclopédia livre","HuffYUV-Codec","HuffYuv","Huffies","Huffyuv - Wikipedia","Huffyuv - Wikipedia, the free ...","Huffyuv - Wikipedia, the free encyclopedia","Huffyuv @ Wikipedia","Huffyuv Codec","Huffyuv Huffyuv Huffyuv","Huffyuv Related Content:","Huffyuv Wikipedia the free encyclopedia","Huffyuv from Wikipedia","Huffyuv — Википедия","Huffyuv-wikipedia","Huffyuv; it is used under the","View Huffyuv on Wikipedia","Vikipedi'deki HuffYUV","What are implementations of HuffYUV?","Wiki:Huffyuv","Wikipedia article HUFFYUV","Wikipedia article HuffYUV","Wikipedia article Huffyuv","Wikipedia article on HuffYUV","Wikipedia article on Huffyuv","Wikipedia entry for Huffyuv","Wikipedia l'articolo HuffYUV","Wikipedia l'articolo Huffyuv","Wikipedia sur HuffYUV","Wikipedia-Artikel HuffYUV","Wikipedia-Artikel Huffyuv","Wikipedia-Seite zu 'HuffYUV'","Wikipediaseite des HuffYUV-Videocodec","Wikipediaで「Huffyuv」を調べる","Wikipédia artigo HuffYUV","article Huffyuv","cs:Huffyuv","de.wikipedia.org/wiki/HuffYUV","de:HuffYUV","en:Huffyuv","fr:HuffYUV","http:/ / EN.Wikipedia.org / Вики / HuffYUV","http:/ / EN.Википедия.org / Wiki / HuffYUV","http:/ / En.Wikipedia.org / Wiki / Huffyuv","http:/ / En.ויקיפדיה.org / Wiki / huffyuv","http:/ / Es.Wikipedia.org / Wiki / huffyuv","http:/ / Fr.Wikipedia.org / Wiki / huffyuv","http:/ / It.Wikipedia.org / Wiki / HuffYUV","http:/ / en.Wikipedia.org / wiki / HuffYUV","http:/ / en.ויקיפדיה.org / wiki / huffyuv","http:/ / es.Wikipedia.org / wiki / huffyuv","http:/ / it.Wikipedia.org / wiki / HuffYUV","http:/ / pt.Wikipedia.org / wiki / HuffYUV","http:/ / én.ويكيبيديا.org / الويكي / huffyuv","http:/ / एन.Wikipedia.org / wiki / huffyuv","http:/ /アン.ウィキペディア.org /ウィキ/ huffyuv","http:/ /恩.维基百科.org /维基/ huffyuv","http:/ Pt.Wikipedia.org / Wiki / Huffyuv","http://cs.wikipedia.org/wiki/Huffyuv","http://de.wikipedia.org/wiki/HuffYUV","http://de.wikipedia.org/wiki/Huffyuv","http://en.wikipedia.org / ويكي / huffyuv","http://en.wikipedia.org/wiki/HuffYUV","http://en.wikipedia.org/wiki/Huffyuv","http://fr.wikipedia.org/wiki/HuffYUV","http://it.wikipedia.org/wiki/Huffyuv","http://pl.wikiped...ki/Huffyuv","http://pl.wikipedia.org/wiki/Huffyuv","http://ru.wikipedia.org/wiki/HuffYUV","http://ru.wikipedia.org/wiki/Huffyuv","http:एन /.विकिपीडिया.org / Wiki / huffyuv","huffyuv","huffyuv-wikipedia","hufyuv","it:Huffyuv","ja.wikipedia.org/wiki/Huffyuv","ja:Huffyuv","ko:Huffyuv","mit Verlustfreien Codec","pl:Huffyuv","pt:HuffYUV","ru:Huffyuv","tr:HuffYUV","verlustfreier Codec.","Википедии статью HuffYUV","Википедии статью Huffyuv","∙ HuffYUV - Wikipédia","ウィキペディアの記事 Huffyuv","위키 피 디아 문서 Huffyuv"],"name":"Huffyuv","categories":["Free video codecs","Lossless compression algorithms"],"tag_line":"Huffyuv (or HuffYUV) is a lossless video codec created by Ben Rudiak-Gould which is meant to replace uncompressed YCbCr as a video capture format."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sort-(c++)","_score":0,"_source":{"description":"sort is a function in C++ Standard Library that takes two random-access iterators, the start and the end, as arguments and performs a comparison sort on the range of elements between the two iterators, front-inclusive and end-exclusive: [start, end).\nThe specific sorting algorithm is not mandated and may vary across implementations. However, the worst-case complexity must be O(n log n). In previous versions of C++, such as C++03, only average complexity was required to be O(n log n). This was to allow the use of algorithms like (median-of-3) quicksort, which are fast in the average case, indeed significantly faster than other algorithms like heap sort with optimal worst-case complexity, and where the worst-case quadratic complexity rarely occurs. The introduction of hybrid algorithms such as introsort allowed both fast average performance and optimal worst-case performance, and thus the complexity requirements were tightened in later standards.\nDifferent implementations use different algorithms. The GNU Standard C++ library, for example, uses a 3-part hybrid sorting algorithm: introsort is performed first (introsort itself being a hybrid of quicksort and heap sort), to a maximum depth given by 2×log2 n, where n is the number of elements, followed by an insertion sort on the result.","alt_names":["C++ sort reference on Wikipedia","Sort (C++)","Sort Wiki Link","Sort Wiki Link.","Usually Introsort","Wikipedia article Sort (C++)","[url=http://en.wikipedia.org/wiki/Sort_(C","a wikipedia page consecrated to std::sort()","about sort","en.wikipedia.org/wiki/Sort_(C++)","http://en.wikipedia....wiki/Sort_(C++)","http://en.wikipedia.org/wiki/Sort_%28C%2B","http://en.wikipedia.org/wiki/Sort_(C%2B","http://en.wikipedia.org/wiki/Sort_(C++)","sort (C ) - Wikipedia, the free encyclopedia","sort (C++)","sort (C++) - Wikipedia, the free encyclopedia","sort C","sort C - Wikipedia, the free encyclopedia","sort()","sort(C++)","快多倍","快多倍(C可用宏或人手编码去解决此问题)。另一方面，C/C++能直接映射机器码，之间没有另一层中间语言"],"name":"Sort (C++)","categories":["C++ Standard Library","Sorting algorithms","Use dmy dates from January 2012"],"tag_line":"sort is a function in C++ Standard Library that takes two random-access iterators, the start and the end, as arguments and performs a comparison sort on the range of elements between the two iterators, front-inclusive and end-exclusive: [start, end)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"proxmap-sort","_score":0,"_source":{"description":"ProxmapSort, or Proxmap sort, is a sorting algorithm that works by partitioning an array of data items, or keys, into a number of \"subarrays\" (termed buckets, in similar sorts). The name is short for computing a \"proximity map,\" which indicates for each key K the beginning of a subarray where K will reside in the final sorted order. Keys are placed into each subarray using insertion sort. If keys are \"well distributed\" among the subarrays, sorting occurs in linear time. The computational complexity estimates involve the number of subarrays and the proximity mapping function, the \"map key,\" used. It is a form of bucket and radix sort.\nOnce a ProxmapSort is complete, ProxmapSearch can be used to find keys in the sorted array in  time if the keys were well distributed during the sort.\nBoth algorithms were invented in the late 1980s by Prof. Thomas A. Standish at the University of California, Irvine.","alt_names":["- Proxmap sort :","Proxmap sort","Proxmap sort - Wikipedia, the free encyclopedia","Proxmap sort ·","Proxmap_sort","Wikipedia article Proxmap sort","Wikipedia article on Proxmap sort","http://en.wikipedia.org/wiki/Proxmap_sort"],"name":"Proxmap sort","categories":["All articles that may contain original research","All articles with unsourced statements","Articles that may contain original research from May 2015","Articles with example pseudocode","Articles with unsourced statements from May 2015","Sorting algorithms","Stable sorts"],"tag_line":"ProxmapSort, or Proxmap sort, is a sorting algorithm that works by partitioning an array of data items, or keys, into a number of \"subarrays\" (termed buckets, in similar sorts)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"samplesort","_score":0,"_source":{"description":"Samplesort is a sorting algorithm that is a divide and conquer algorithm often used in parallel processing systems. Conventional divide and conquer sorting algorithms partitions the array into sub-intervals or buckets. The buckets are then sorted individually and then concatenated together. However, if the array is non-uniformly distributed, the performance of these sorting algorithms can be significantly throttled. Samplesort addresses this issue by selecting a sample of size s from the n-element sequence, and determining the range of the buckets by sorting the sample and choosing m -1 elements from the result. These elements (called splitters) then divide the sample into m equal-sized buckets. Samplesort is described in the 1970 paper, \"Samplesort: A Sampling Approach to Minimal Storage Tree Sorting\", by W D Frazer and A C McKellar.","alt_names":["Samplesort","Samplesort - Wikipedia","Samplesort - Wikipedia, the free encyclopedia","Wikipedia article Samplesort","http://de.wikipedia.org/wiki/Samplesort","http://en.wikipedia.org/wiki/Samplesort","sample sort","samplesort","yago-res:Samplesort"],"name":"Samplesort","categories":["Distributed algorithms","Sorting algorithms"],"tag_line":"Samplesort is a sorting algorithm that is a divide and conquer algorithm often used in parallel processing systems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"geohash-36","_score":0,"_source":{"description":"The Geohash-36 geocode is an opensource compression algorithm for world coordinate data. It was developed as a variation of the OpenPostcode format developed as a candidate geolocation postcode for the Republic of Ireland. It is similar in function to the original public domain Geohash code. It is calculated differently and uses a more accurate base 36 (or rather radix 36) representation rather than the original base 32 representation.","alt_names":[],"name":"Geohash-36","categories":["All articles needing additional references","Articles needing additional references from June 2012","Compression algorithms","Geocodes"],"tag_line":"The Geohash-36 geocode is an opensource compression algorithm for world coordinate data."}}
,{"_index":"throwtable","_type":"algorithm","_id":"opus-(audio-format)","_score":0,"_source":{"description":"Opus is a lossy audio coding format developed by the Internet Engineering Task Force (IETF) that is particularly suitable for interactive real-time applications over the Internet.\nOpus incorporates technology from two other audio coding formats: the speech-oriented SILK and the low-latency CELT. Opus can be adjusted seamlessly between high and low bitrates, and internally, it transitions between linear predictive coding at lower bitrates and transform coding at higher bitrates (as well as a hybrid for a short overlap). Opus has a very low algorithmic delay (26.5 ms by default), which is a necessity for use as part of a low audio latency communication link, which can permit natural conversation, networked music performances, or lip sync at live events. Opus permits trading-off quality or bitrate to achieve an even smaller algorithmic delay, down to 5 ms. Its delay is very low compared to well over 100 ms for popular music formats such as MP3, Ogg Vorbis and HE-AAC; yet Opus performs very competitively with these formats in terms of quality per bitrate. Unlike Ogg Vorbis, Opus does not require the definition of large codebooks for each individual file, making it preferable to Vorbis for short clips of audio.\nAs an open format standardized through RFC 6716, a reference implementation audio codec called opus-tools is available under the New BSD License. All known software patents which cover Opus are licensed under royalty-free terms.","alt_names":[],"name":"Opus (audio format)","categories":["All articles with unsourced statements","Articles with hAudio microformats","Articles with unsourced statements from March 2015","CS1 Russian-language sources (ru)","CS1 errors: external links","Free audio codecs","Lossy compression algorithms","Software using the BSD license","Speech codecs","Xiph.Org projects"],"tag_line":"Opus is a lossy audio coding format developed by the Internet Engineering Task Force (IETF) that is particularly suitable for interactive real-time applications over the Internet."}}
,{"_index":"throwtable","_type":"algorithm","_id":"zpaq","_score":0,"_source":{"description":"ZPAQ is an open source (GPL) command line archiver for Windows and Linux. It uses a journaling or append-only format which can be rolled back to an earlier state to retrieve older versions of files and directories. It supports fast incremental update by adding only files whose last-modified date has changed since the previous update. It compresses using deduplication and several algorithms (LZ77, BWT, and context mixing) depending on the data type and the selected compression level. To preserve forward and backward compatibility between versions as the compression algorithm is improved, it stores the decompression algorithm in the archive. The ZPAQ source code includes a public domain API, libzpaq, which provides compression and decompression services to C++ applications. The format is believed to be unencumbered by patents.\n\n","alt_names":["Context calculation","Read More zpaq wikipedia the free encyclopedia","Wikipedia article ZPAQ","ZPAQ","ZPAQ - Wikipedia, the free encyclopedia","Zpaq","en.wikipedia.org/wiki/ZPAQ","http://en.wikipedia.org/wiki/ZPAQ","http://en.wikipedia.org/wiki/ZPAQ#Implementations","n7:ZPAQ"],"name":"ZPAQ","categories":["All articles lacking reliable references","All articles with topics of unclear notability","Archive formats","Articles lacking reliable references from October 2013","Articles with topics of unclear notability from October 2013","Free data compression software","Lossless compression algorithms","Open formats","Wikipedia articles with possible conflicts of interest from October 2013"],"tag_line":"ZPAQ is an open source (GPL) command line archiver for Windows and Linux."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lempel–ziv–storer–szymanski","_score":0,"_source":{"description":"Lempel–Ziv–Storer–Szymanski (LZSS) is a lossless data compression algorithm, a derivative of LZ77, that was created in 1982 by James Storer and Thomas Szymanski. LZSS was described in article \"Data compression via textual substitution\" published in Journal of the ACM (pp. 928–951).\nLZSS is a dictionary encoding technique. It attempts to replace a string of symbols with a reference to a dictionary location of the same string.\nThe main difference between LZ77 and LZSS is that in LZ77 the dictionary reference could actually be longer than the string it was replacing. In LZSS, such references are omitted if the length is less than the \"break even\" point. Furthermore, LZSS uses one-bit flags to indicate whether the next chunk of data is a literal (byte) or a reference to an offset/length pair.","alt_names":[],"name":"Lempel–Ziv–Storer–Szymanski","categories":["Lossless compression algorithms"],"tag_line":"Lempel–Ziv–Storer–Szymanski (LZSS) is a lossless data compression algorithm, a derivative of LZ77, that was created in 1982 by James Storer and Thomas Szymanski."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lzrw","_score":0,"_source":{"description":"Lempel–Ziv Ross Williams (LZRW) refers to variants of the LZ77 lossless data compression algorithms with an emphasis on improving compression speed through the use of hash tables and other techniques. This family was explored by Ross Williams, who published a series of algorithms beginning with LZRW1 in 1991.\nThe variants are:\nLZRW1\nLZRW1-A\nLZRW2\nLZRW3\nLZRW3-A\nLZRW4\nLZRW5\nThe LZJB algorithm used in ZFS is derived from LZRW1.","alt_names":["(http://en.wikipedia.org/wiki/LZRW","- LZRW :","LZRW","LZRW - Wikipedia, the free encyclopedia","LZRW1","LZRW; it is used under the","Lempel–Ziv Ross Williams","Lzrw","Wikipedia article LZRW","Wikipedia article on LZRW","Wikipedia entry for LZRW","Wikipedia: LZRW","http://en.wikipedia.org/wiki/LZRW","http://en.wikipedia.org/wiki/LZRW#","yago-res:LZRW"],"name":"LZRW","categories":["All stub articles","Computer science stubs","Free data compression software","Lossless compression algorithms"],"tag_line":"Lempel–Ziv Ross Williams (LZRW) refers to variants of the LZ77 lossless data compression algorithms with an emphasis on improving compression speed through the use of hash tables and other techniques."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lzjb","_score":0,"_source":{"description":"LZJB is a lossless data compression algorithm invented by Jeff Bonwick to compress crash dumps and data in ZFS. It includes a number of improvements to the LZRW1 algorithm, a member of the Lempel–Ziv family of compression algorithms. The name LZJB is derived from its parent algorithm and its creator—Lempel Ziv Jeff Bonwick. Bonwick is also one of two architects of ZFS, and the creator of the Slab Allocator.","alt_names":["<http://en.wikipedia.org/wiki/LZJB>","LZJB","LZJB - Wikipedia, the free encyclopedia","LZJB compression algorithm","LZJB on wikipedia.org","LZJB; it is used under the","Lempel-Ziv Jeff Bonwick","Lempel–Ziv Jeff Bonwick","Lzjb","Wikipedia article LZJB","Wikipedia article on LZJB","Wikipedia entry for LZJB","http://en.Liarpedia.org/wiki/Chris Keenan","http://en.wikipedia.org/wiki/LZJB","http://en.wikipedia.org/wiki/LZJB#","lzjb","yago-res:LZJB"],"name":"LZJB","categories":["All stub articles","Computer science stubs","Lossless compression algorithms","Sun Microsystems software"],"tag_line":"LZJB is a lossless data compression algorithm invented by Jeff Bonwick to compress crash dumps and data in ZFS."}}
,{"_index":"throwtable","_type":"algorithm","_id":"quad-(compressor)","_score":0,"_source":{"description":"QUAD is a high-performance data compressor based on the LZ algorithms (LZ77, LZ78, LZW). It's designed to produce small files but still decompress fast and with little memory. QUAD is licensed under the LGPL.","alt_names":["QUAD (compressor)","QUAD (compressor) - Wikipedia, the free encyclopedia","QUAD compressor","Quad (Compressor)","Wikipedia article QUAD (compressor)","Wikipedia entry for QUAD (compressor)","http://en.wikipedia.org/wiki/QUAD_(compressor)","yago-res:QUAD_(compressor)"],"name":"QUAD (compressor)","categories":["All articles lacking reliable references","All articles with topics of unclear notability","All stub articles","Archive formats","Articles lacking reliable references from May 2013","Articles with topics of unclear notability from May 2013","Free data compression software","Lossless compression algorithms","Storage software stubs"],"tag_line":"QUAD is a high-performance data compressor based on the LZ algorithms (LZ77, LZ78, LZW)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lzwl","_score":0,"_source":{"description":"LZWL is a syllable-based variant of the character-based LZW compression algorithm that can work with syllables obtained by all algorithms of decomposition into syllables. The algorithm can be used for words too.","alt_names":["LZWL","LZWL - Wikipedia, the free encyclopedia","LZWL on wikipedia.org","LZWL; it is used under the","Learn about LZWL>>>","Lzwl","What is algorithm of LZWL","Wikipedia article LZWL","Wikipedia article on LZWL","Wikipedia entry for LZWL","Wikipedia: LZWL","en.wikipedia.org/wiki/LZWL","http://en.wikipedia.org/wiki/LZWL","http://en.wikipedia.org/wiki/LZWL#","yago-res:LZWL"],"name":"LZWL","categories":["All articles needing additional references","All articles needing style editing","Articles needing additional references from January 2013","Lossless compression algorithms","Wikipedia articles needing style editing from August 2009"],"tag_line":"LZWL is a syllable-based variant of the character-based LZW compression algorithm that can work with syllables obtained by all algorithms of decomposition into syllables."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lempel–ziv–oberhumer","_score":0,"_source":{"description":"Lempel–Ziv–Oberhumer (LZO) is a lossless data compression algorithm that is focused on decompression speed.","alt_names":[],"name":"Lempel–Ziv–Oberhumer","categories":["All articles lacking reliable references","All articles needing additional references","All stub articles","Articles lacking reliable references from March 2015","Articles needing additional references from July 2014","C libraries","Free data compression software","Lossless compression algorithms","Software stubs"],"tag_line":"Lempel–Ziv–Oberhumer (LZO) is a lossless data compression algorithm that is focused on decompression speed."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lz4-(compression-algorithm)","_score":0,"_source":{"description":"LZ4 is a lossless data compression algorithm that is focused on compression and decompression speed. It belongs to the LZ77 family of byte-oriented compression schemes.","alt_names":[],"name":"LZ4 (compression algorithm)","categories":["C libraries","Free data compression software","Lossless compression algorithms"],"tag_line":"LZ4 is a lossless data compression algorithm that is focused on compression and decompression speed."}}
,{"_index":"throwtable","_type":"algorithm","_id":"vocoder","_score":0,"_source":{"description":"A vocoder (/ˈvoʊkoʊdər/, short for voice encoder) is a category of voice codec that analyzes and synthesizes the human voice signal for audio data compression, multiplexing, voice encryption, voice transformation, etc.\nThe earliest type of vocoder, the channel vocoder, was originally developed as a speech coder for telecommunications applications in the 1930s, the idea being to code speech in order to reduce bandwidth (i.e. audio data compression) for multiplexing transmission. In the channel vocoder algorithm, among the two components of an analytic signal, considering only the amplitude component and simply ignoring the phase component tends to result in an unclear voice; on methods for rectifying this, see phase vocoder.\nIn the encoder, the input is passed through a multiband filter, then each band is passed through an envelope follower, and the control signals from the envelope followers are transmitted to the decoder. The decoder applies these (amplitude) control signals to corresponding filters for re-synthesis. Since these control signals change only slowly compared to the original speech waveform, the bandwidth required to transmit speech can be reduced. This allows more speech channels to share a single communication channel, such as a radio channel or a submarine cable (i.e. multiplexing).\nBy encrypting the control signals, voice transmission can be secured against interception. Its primary use in this fashion is for secure radio communication. The advantage of this method of encryption is that none of the original signal is sent, only envelopes of the bandpass filters. The receiving unit needs to be set up in the same filter configuration to re-synthesise a version of the original signal spectrum.\nThe vocoder has also been used extensively as an electronic musical instrument (see #Uses in music). The decoder portion of the vocoder, called a voder, can be used independently for speech synthesis (see #History).\n\n","alt_names":["breath controller","vocoding","vocorder","вокодера","Voder","Dynacord","vocoder","Vocoder","'vocoded'","- Vocoder :","- Vocoders :","- Voder :","-> Leggi l'articolo completo su Vocoder","-> Leggi tutto l'articolo su 'Vocoder'","-> Read the article about 'Vocoder'",". http://en.wikipedia.org/wiki/Vocoder.","...Wikipedia Vocoder","...Wikipedia Wokoder","...mehr auf Wikipedia über Vocoder","...mehr auf Wikipedia über Voder","...more on Wikipedia about Vocoder","1 How a vocoder works","1 Vocoder theory","1.1 Vocoder theory","1.2 Early vocoders","1.3 Linear prediction-based vocoders","1.4 Modern vocoder implementations","2 Musical applications","2.1 Analog vocoders","2.2 Linear prediction-based vocoders","3 Modern vocoder implementations","3 Television and film applications","4 Musical applications","4.1 Musical history","4.2 Other voice effects","4.3 Television, film and game applications","4.3.1 Television","5 Analogue vocoder models","6 Hardware DSP vocoder models","7 Software vocoder models","<span style=color:#000000;>vocoder</span>","A vocoder","Analogue vocoder models","Bell Labs' Voder","Buscar Vocoder en Wikipedia España","C'est la méthode la plus ancienne","Cerca Vocoder in Wikipedia Italia","Cerca vocoder in Wikipedia Italia","Cher'","Click here for a fuller description.","Click here to read more about the vocoder","Das Klangspektrum wird mit Hilfe einer Bandpass-Filterbank","Definición de Vocoder más completo","Echolette","Echolette – Wikipedia","Example of vocoder","FREAKIN' VOCODER","File:Vocoder demo.ogg","Hier vind je het hele artikel","Här / Vocoder","LINK: (http://en.wikipedia.org/wiki/Vocoder)","Masvidal","Modern vocoder implementations","Musical applications","Pesquisar Vocoder na Wikipedia Portugal","Pesquisar vocoder na Wikipedia Portugal","Phase Vocoding","ROLAND VP-330","ROLAND Vocoder Plus","Roland VP-330","Roland vp-330+","Sample of a Vocoder","Search for Vocoder on Wikipedia!","Search for Vocoders on Wikipedia!","Search info on Vocoder at Wikipedia","Search info on Vocoders at Wikipedia","Search info on Voder at Wikipedia","Siehe die Beschreibung hier","Source Wikipedia.org Arcticle - Vocoder","Stimmenwandler","Suggested: vocoder","Sök Vocoder på Wikipedia Sverige","T-Pain thingymajig","Teoría del vocoder","The Vocoder","The Voder","The Wendy Carlos / Bob Moog Vocoder","VOCODED","VOCODER","VOCODER puedes ller mas sobre el aqui.","VOCODERS","View Vocoder on Wikipedia","Vo-coder","Vocader","Vocoda","Vocode","Vocoded","Vocoder (de)","Vocoder (en)","Vocoder (es)","Vocoder (fr)","Vocoder (he)","Vocoder (it)","Vocoder (nl)","Vocoder (no)","Vocoder (pl)","Vocoder (wikipedia)","Vocoder - Software vocoder models","Vocoder - Wikip?dia","Vocoder - Wikipedia","Vocoder - Wikipedia, la enciclopedia libre","Vocoder - Wikipedia, the free encyclopedia","Vocoder - Wikipedia, the free encyclopedia http://en.wikipedia","Vocoder - Wikipedia, the free encyclopedia wikipedia.org A","Vocoder - Wikipedia, wolna encyklopedia","Vocoder - Wikipédia","Vocoder <http://en.wikipedia.org/wiki/Vocoder>","Vocoder ? Wikipedia","Vocoder History","Vocoder R3","Vocoder Wiki","Vocoder Wikipedia the free encyclopedia","Vocoder Wikipedia the free encyclopedia - result","Vocoder Wikipedia, the free ...","Vocoder bei Wikipedia","Vocoder bei der wikipedia","Vocoder demo.ogg","Vocoder in","Vocoder in Wikipedia Nederland zoeken","Vocoder on Wikipedia","Vocoder on Wikipedia, with example","Vocoder på Wikipedia","Vocoder theory","Vocoder â€“ Wikipedia","Vocoder â€“ Wikipedia, wolna encyklopedia","Vocoder – Wikipedia","Vocoder – Wikipedia, wolna encyklopedia","Vocoder – Wikipédia, a enciclopédia livre","Vocoder – ויקיפדיה","Vocoder)","Vocoder),","Vocoder,","Vocoder- und Tuningtechniken","Vocoder.","Vocoder/Talkbox","Vocoder:","Vocoder? Wikipedia","Vocoderem","Vocodern","Vocoderresko","Vocoders","Vocoderstimme","Vocoder™","Vocodeur","Vocodeur - WikipÃ©dia","Vocodeur - Wikipédia","Vocoding","Voder bei der wikipedia","Voder – Wikipedia","Voice Operation Demonstrator","Voice Operation Demonstrator - Wikipedia","Voice encoder","VoiceCode","Voice_Operation_Demonstrator bei der wikipedia","Vokooderi","Vokooderi (fi)","Vokooderi – Wikipedia","Vopoder","What is a vocoder?","Wiki on vocoder","Wikipedia (Vocoder)","Wikipedia + info","Wikipedia : ヴォコーダー","Wikipedia Vocoder","Wikipedia Vocoder Page","Wikipedia Vocoder page","Wikipedia article Vocoder","Wikipedia article about Vocoder","Wikipedia article about Voder","Wikipedia article on Vocoder","Wikipedia article on Vocoders","Wikipedia article Вокодер","Wikipedia artikel Vocoder","Wikipedia entry for Vocoder","Wikipedia sur Vocodeur","Wikipedia-Artikel Echolette","Wikipedia-Artikel Vocoder","Wikipedia-Artikel Voder","Wikipedia-Artikel Voice Operation Demonstrator","Wikipedia-Seite zu 'Echolette'","Wikipedia-Seite zu 'Vocoder'","Wikipedia: 'Vocoder'","Wikipedia: 'Vocodeur'","Wikipedia: 'Vokooderi'","Wikipedia: 'Вокодер'","Wikipedia: 'ヴォコーダー'","Wikipedia:Vocoder","Wikipediaで「ボコーダー」を調べる","Wikipediaで「ヴォコーダー」を調べる","Wikiの解説はむつかしいので","Wikiペディア（ヴォコーダー）","Yeah. That's exactly how it happened, damnit!","[más información sobre el VOCODER]","[vocoder]","allez vous cultiver sur WP","article Vocoder","artículo de Wikipedia Vocoder","channel vocoder","click here to visit the Vocoder Wikipedia Article","copious use of the vocoder","de.wikipedia.org/wiki/Echolette","de:Vocoder","digital manipulator","distinto sonido","electronic device that filters audio to match the","en.wikipedia - Vocoder","en.wikipedia.org/Vocoder","en.wikipedia.org/wiki/Voc...","en.wikipedia.org/wiki/Vocoder","en.wikipedia.org/wiki/Vocoder#Musical_applications","en:Vocoder","es.wikipedia.org/Vocoder","es:Vocoder","fr.wikipedia.org/wiki/Vocoder","fr:Vocoder","general vocoder page","hand-operated vocoders","he:Vocoder","heel veel vocoder","highly processed voice","http://de.wikipedia.org/wiki/Echolette","http://de.wikipedia.org/wiki/Vo coder#Musikbeispiele","http://de.wikipedia.org/wiki/Vocoder","http://de.wikipedia.org/wiki/Voder","http://en.wikipedia.org/wiki /Vocoder","http://en.wikipedia.org/wiki/The_Voder","http://en.wikipedia.org/wiki/V ocoder","http://en.wikipedia.org/wiki/Voc...","http://en.wikipedia.org/wiki/Vocode r","http://en.wikipedia.org/wiki/Vocode...al_applications","http://en.wikipedia.org/wiki/Vocoder","http://en.wikipedia.org/wiki/Vocoder#Analogue_vocoder_models","http://en.wikipedia.org/wiki/Vocoder#History","http://en.wikipedia.org/wiki/Vocoder#Mu ... plications","http://en.wikipedia.org/wiki/Vocoder#Mu … plications","http://en.wikipedia.org/wiki/Vocoder#Musical_appli cations","http://en.wikipedia.org/wiki/Vocoder#Musical_applications","http://en.wikipedia.org/wiki/Vocoder#Musical_applications]vocoded","http://en.wikipedia.org/wiki/Vocoder#Musical_history","http://en.wikipedia.org/wiki/Vocoder#Software_vocoder_models","http://en.wikipedia.org/wiki/Vocoder#Television.2C_film_and_game_applications","http://en.wikipedia.org/wiki/Vocoder)","http://en.wikipedia.org/wiki/Vocoder..._voice_effects","http://en.wikipedia.org/wiki/Vocoder...l_applications","http://en.wikipedia.org/wiki/Vocoders","http://en.wikipedia.org/wiki/Voc…","http://en.wikipedia.org/wiki/Voder","http://en.wikipedia.org/wiki/Voder#Analog_vocoders","http://en.wikipedia.org/wiki/Voder#Musical_applications","http://en.wikipedia.org/wi​ki/Vocoder","http://es.wikipedia.org/wiki/Vocoder","http://fr.wikipedia.org/wiki/Vocoder","http://fr.wikipedia.org/wiki/Vocoder#Application_musicale","http://fr.wikipedia.org/wiki/Vocodeur","http://he.wikipedia.org/wiki/Vocoder","http://it.wikipedia.org/wiki/Vocoder","http://ja.wikipedia.org/wiki/ヴォコーダー","http://nl.wikipedia.org/wiki/Vocoder","http://pl.wikipedia.org/wiki/Vocode...","http://pl.wikipedia.org/wiki/Vocoder","http://pt.wikipedia.org/wiki/Vocoder","http://ru.wikipedia.org/wiki/Вокодер","http://sv.wikipedia.org/wiki/Vocoder","info vocoder","it.wikipedia.org/wiki/Vocoder","it:Vocoder","ja:ヴォコーダー","le vocoder expliqué","modern telecommunications","musical vocoder","nl.wikipedia.org/wiki/Voc...","nl.wikipedia.org/wiki/Vocoder","nl:Vocoder","no:Vocoder","originally invented at Bell Labs for wartime communications","phase-vocoder","pl.wikipedia.org/wiki/Vocoder","pl:Vocoder","puhesyntetisaattorilta","radio sicura","ru.wikipedia - Вокодер","secure radio","that's what it's called.","the Vocoder","the Voder","the vocoder","un vocoder,","vocal manipulation","vococorder","vocode","vocoded","vocoder effect","vocoder in Wikipedia Nederland zoeken","vocoder is a totaly different device","vocoder thing","vocoder's","vocoder,","vocoder-ul","vocoder.","vocoder?","vocodera","vocodere","vocodered","vocoderes","vocoderise","vocoderisierter","vocoderisés","vocoderized","vocodern","vocoders","vocoders [2]","vocoders on wiki","vocodervocoder","vocoderów","vocoderį","vocoderů","vocoder의","vocodeur","vocodeur à canaux","vocodeurs","vocodée","vocodées","vocording","voder","voice Vocoder","voice encoder algorithm","voice machine","voice synthesizing machine","voix vocodée","vokoder","vokooderi","vokooderia","vokooderin","vokoodriline","vokóder","voz de Vocoder","wikipedia: vocoding","wokoderem","|vocoder|","ВОКОДЕР","Википедии статью Вокодер","Вокодер","Вокодер — Википедия","Вокодер!!!","Вокодера","ТЕБЕ в помощь","Так и называется...","вокодер","вокодер ефекти","вокодерами","вокодери","вокодеров","вокодером","вокодеры","вокодига","בווקודר","הווקודר","ווקודר","همان افکت هایی","ตัวอย่าง vocoder","“Vocoder - Wikipedia, the free encyclopedia”, en.wikipedia.org","☆ヴォコーダー","「ボコーダー」をWikipediaで調べる","「ヴォコーダー」","「ヴォコーダー」をWikipediaで調べる","ボコーダ","ボコーダー","ボコーダー - wikipedia","ボコーダーとはなんぞや？という方はこちらへ","マイクの横のホース","ロボットボイス","ロボット声","ヴォコーダ","ヴォコーダー","ヴォコーダー - Wikipedia","ヴォコーダー - wikipeida","ヴォコーダー – Wikipedia","ヴォコーダー(vocoder)","ヴォコーダーって何？？って人は","ヴォコーダー（Vocoder）","ヴォコーダー（wikipedia）","声码器","聲碼器","音乐合成器或者变音器","보코더","ｳﾞｫｺｰﾀﾞｰ(vocoder)","ｳﾞｫｺｰﾀﾞｰ-wikipedia","ﾎﾞｺｰﾀﾞｰ-wikipedia"],"name":"Vocoder","categories":["All articles needing additional references","All articles with unsourced statements","Articles needing additional references from May 2013","Articles with hAudio microformats","Articles with specifically marked weasel-worded phrases from July 2014","Articles with unsourced statements from July 2012","Articles with unsourced statements from July 2014","Articles with unsourced statements from June 2011","Articles with unsourced statements from March 2015","Articles with unsourced statements from October 2008","Audio effects","CS1 German-language sources (de)","Electronic musical instruments","Lossy compression algorithms","Music hardware","Robotics","Speech codecs","Wikipedia articles needing clarification from December 2015"],"tag_line":"A vocoder (/ˈvoʊkoʊdər/, short for voice encoder) is a category of voice codec that analyzes and synthesizes the human voice signal for audio data compression, multiplexing, voice encryption, voice transformation, etc."}}
,{"_index":"throwtable","_type":"algorithm","_id":"division-algorithm","_score":0,"_source":{"description":"A division algorithm is an algorithm which, given two integers N and D, computes their quotient and/or remainder, the result of division. Some are applied by hand, while others are employed by digital circuit designs and software.\nDivision algorithms fall into two main categories: slow division and fast division. Slow division algorithms produce one digit of the final quotient per iteration. Examples of slow division include restoring, non-performing restoring, non-restoring, and SRT division. Fast division methods start with a close approximation to the final quotient and produce twice as many digits of the final quotient on each iteration. Newton–Raphson and Goldschmidt fall into this category.\nDiscussion will refer to the form , where\nN = Numerator (dividend)\nD = Denominator (divisor)\nis the input, and\nQ = Quotient\nR = Remainder\nis the output.\n\n","alt_names":["http://en.wikipedia.org/wiki/Division_al…","Modulo-Operator","Division algorithm","4.1 Definition","Divisionsrest","Modulo-Operation","division entière","Division mit Rest","division euclidienne","(Modulo/Rest)","- Division algorithm :","-> Read more about Division algorithm","-> Read the article about 'Division algorithm'","...mehr auf Wikipedia über Division mit Rest","...mehr auf Wikipedia über Modulo (Rest)","...more on Wikipedia about Division algorithm","1 Statement of theorem","3.1 Existence","3.2 Uniqueness","4 Generalized division algorithm and b-parts of","4.2 The generalized division algorithm.","4.3 Number theoretic explanation of b-Parts",">klick2<","Algoritmo de la divisi?n - Wikipedia, la enciclopedia","Algoritmo de la división - Wikipedia, la enciclopedia libre","Als Nummernbereich ist derzeit (2005 年 9 月","Dalybos algoritmas","Die Modulo-Funktion","Division Algorithm","Division algorithm - Wikipedia :: The free encyclopedia","Division algorithm - Wikipedia, the free encyclopedia","Division algorithm for integers","Division algorithm on wikipedia.org","Division algorithm: Existence","Division algorithm: Uniqueness","Division algorithm; it is used under the","Division euclidienne","Division euclidienne - Wikip?dia","Division euclidienne - Wikipédia","Division euclidienne - Wikipédia - Wikipedia","Division euclidienne - Wikipédia http://fr.wikipedia.org/wiki","Division mit Rest - Wikipedia","Division mit Rest ? Wikipedia","Division mit Rest Wikipedia","Division mit Rest â€“ Wikipedia","Division mit Rest – Wikipedia","Division theorem","Division von Zahlen mit Rest","Division_algorithm","Division_mit_Rest","Divisione con resto","Divisione euclidea","Divisione euclidea - Wikipedia","Divisione_euclidea","Divisionsreste","Divisió euclidiana","Divison mit Rest","El resto","Euclid's division lemma","Existenz zweier Methoden zur Berechnung","Generalized division algorithm and b-parts of real","Jakoyhtälö","Lies hier, 1. Satz","MODULO","Modulo (Rest)","Modulo (Rest) - Wikipedia","Modulo 1","Modulo ? Wikipedia","Modulo Division","Modulo Rechnung","Modulo Rechnung guckst du hier","Modulo auf de.wikipedia.org","Modulo bei der wikipedia","Modulo – Wikipedia","Modulo-Division (Rest beim Teilen)","Modulo-Funktion","Modulo-Operator (%)","Modulo-rechnung","Modulo_(Rest)","Modulo_(Rest) bei der wikipedia","Modulofunktion","Quotient euclidien","Read More About division algorithm wikipedia the free","Rest aus der Division","Rest der Division","Rest einer Division","Screenshot http://de.wikipedia.org/wiki/Division_mit_Rest","Source Wikipedia.org Arcticle - Division algorithm","Teorema împărțirii cu rest","The Division Algorithm","Twierdzenie o dzieleniu z resztą","Was ist Modulo?","What are some examples of Division algorithm?","Wiki, Modulo, mathematische Variante","Wikipedia - Modulo","Wikipedia - Modulo (Rest)","Wikipedia article ''Division algorithm''","Wikipedia article Algoritmo de la división","Wikipedia article Dalybos algoritmas","Wikipedia article Division algorithm","Wikipedia article Division algorithm for integers","Wikipedia article Division euclidienne","Wikipedia article Division mit Rest","Wikipedia article about Division algorithm","Wikipedia article on Algoritmo de la división","Wikipedia article on Division algorithm","Wikipedia entry for Division algorithm","Wikipedia hilft dir immer gerne weiter.","Wikipedia sur Rapport (mathématiques)","Wikipedia, Division algorithm","Wikipedia, Modulo","Wikipedia-Artikel Division mit Rest","Wikipedia-Artikel Divisionsrest","Wikipedia-Artikel Modulo","Wikipedia-Artikel Modulo (Rest)","Wikipedia-Seite zu 'Division mit Rest'","Wikipedia-Seite zu 'Modulo (Rest)'","Wikipedia-Seite zu 'Modulo'","Wikipedia: Division mit Rest","Wikipedia:Divisione_con_resto","Wikipedia:Divisione_euclidea","algoritma pembagian","algoritmo de la división","algoritmo della divisione","algoritmo di divisione euclidea","algoritmo que resuelve una división","article Division algorithm","artículo de Wikipedia Algoritmo de la division","artículo de Wikipedia Algoritmo de la división","b &Zopf;","bei WIKI auch","dalīšanas algoritms","de.wikipedia.org/wik..._der_Modulo-Funktion","de.wikipedia.org/wiki/Division_mit_Rest","de.wikipedia.org/wiki/Modulo","de.wikipedia.org/wiki/Modulo#Beispiel_2","de:Division mit Rest#Modulo","de:Modulo","defining property","dividende (numérateur)","dividir euclídeamente","division entière.","division euclidienne.","division theorem","divisione euclidea","divisione_euclidea","divisió euclidiana","en.wikipedia.org/...Division_algorithm","en:Division algorithm","fi:Jakoyhtälö","fr.wikipedia.org/wiki/Division_euclidienne","http//de.wikipedia.org/wiki/Division_mit_Rest","http//de.wikipedia.org/wiki/Division_mit_Rest#Nat.C3","http//de.wikipedia.org/wiki/Modulo#Modulo","http://de.wikipedia.org/wiki/Divi sion_mit_Rest#Nat","http://de.wikipedia.org/wiki/Divisio...Crliche_Zahlen","http://de.wikipedia.org/wiki/Divisio...Programmierung","http://de.wikipedia.org/wiki/Division_mi","http://de.wikipedia.org/wiki/Division_mi....BCrlichen_Zahl","http://de.wikipedia.org/wiki/Division_mit_Res...","http://de.wikipedia.org/wiki/Division_mit_Rest","http://de.wikipedia.org/wiki/Division_mit_Rest#Modulo","http://de.wikipedia.org/wiki/Division_mit_Rest#Nat.C3","http://de.wikipedia.org/wiki/Division_mit_Rest#Verallgemeinerung:_Reelle_Zahlen","http://de.wikipedia.org/wiki/Division_mi…","http://de.wikipedia.org/wiki/DivisionmitRest#Modulo","http://de.wikipedia.org/wiki/Divisionsrest","http://de.wikipedia.org/wiki/Mo dulo_(Rest","http://de.wikipedia.org/wiki/Modulo","http://de.wikipedia.org/wiki/Modulo#...ezielle_Teiler","http://de.wikipedia.org/wiki/Modulo#Modulo","http://de.wikipedia.org/wiki/Modulo_%28Rest%29","http://de.wikipedia.org/wiki/Modulo_(Rest)","http://en.wikipedia.org/wiki/Division_al...","http://en.wikipedia.org/wiki/Division_algorithm","http://en.wikipedia.org/wiki/Division_algorithm#De","http://en.wikipedia.org/wiki/Division_algorithm#Definition&quot;","http://en.wikipedia.org/wiki/Division_algorithm#Proof","http://en.wikipedia.org/wiki/Division_algorithm.","http://es.wikipedia.org/wiki/Algorit..._divisi%C3","http://es.wikipedia.org/wiki/Algoritmo_de_la_di...","http://es.wikipedia.org/wiki/Algoritmo_de_la_divisi%C3%B3n","http://fr.wikipedia.org/wiki/Division_e ... de_binaire","http://fr.wikipedia.org/wiki/Division_enti%C3%A8re","http://fr.wikipedia.org/wiki/Division_enti%C3...","http://fr.wikipedia.org/wiki/Division_euclidienne","http://fr.wikipedia.org/wiki/Division_euclidienne#Algorithme(...)","http://fr.wikipedia.org/wiki/Division_eu…","http://it.wikipedia.org/wiki/Divisione_con_resto","http://it.wikipedia.org/wiki/Divisione_euclidea","http://it.wikipedia.org/wiki/Divisione_e…","http://pl.wikipedia.org/wiki/Twierdzenie_o_dzieleniu_z_reszt%C4%85","ivision algorithm,","ivisionsreste","ivisionsreste,","jakoyhtälö","jakoyhtälön","lt:Dalybos algoritmas","metodo della divisione euclidea","modulo Operator","modulo arithmetik","modulo-Rechnung","perfectly unambiguous definitions for quotient and modulus","resztę z dzielenia","sich widersprechende Möglichkeiten","symmetrische Variante","teorema della divisione","teorema sulla divisione euclidea","teoremei impartirii cu rest","the division algorithm","wiki-articles","wikipedia:Modulo","zur Null hin gerundeten Quotienten","الگوريتم تقسيم","الگوریتم تقسیم","الگوریتم تقسیم - ویکیپدیا","قضيه تقسيم","قضیه تقسیم","除法定理","나눗셈 정리","위키 피 디아를하거나"],"name":"Division algorithm","categories":["All articles to be expanded","All articles with unsourced statements","All pages needing factual verification","Articles to be expanded from September 2012","Articles with example pseudocode","Articles with unsourced statements from February 2012","Articles with unsourced statements from February 2014","Binary arithmetic","Computer arithmetic","Computer arithmetic algorithms","Division (mathematics)","Wikipedia articles needing clarification from July 2015","Wikipedia articles needing factual verification from June 2015"],"tag_line":"A division algorithm is an algorithm which, given two integers N and D, computes their quotient and/or remainder, the result of division."}}
,{"_index":"throwtable","_type":"algorithm","_id":"karatsuba-algorithm","_score":0,"_source":{"description":"The Karatsuba algorithm is a fast multiplication algorithm. It was discovered by Anatoly Karatsuba in 1960 and published in 1962. It reduces the multiplication of two n-digit numbers to at most  single-digit multiplications in general (and exactly  when n is a power of 2). It is therefore faster than the classical algorithm, which requires n2 single-digit products. For example, the Karatsuba algorithm requires 310 = 59,049 single-digit multiplications to multiply two 1024-digit numbers (n = 1024 = 210), whereas the classical algorithm requires (210)2 = 1,048,576.\nThe Karatsuba algorithm was the first multiplication algorithm asymptotically faster than the quadratic \"grade school\" algorithm. The Toom–Cook algorithm is a faster generalization of Karatsuba's method, and the Schönhage–Strassen algorithm is even faster, for sufficiently large n.","alt_names":["Karatsuba","Karatsuba Algorithm","Karatsuba algorithm","'algorithme de Karatsuba","...Wikipedia Algorithme de Karatsuba","...mehr auf Wikipedia über Karatsuba-Algorithmus","3 n log 2 3 &approx; 3 n","9e8c0fe5b70782f6e66019c03ca2e ...","Algorithme de Karatsuba","Algorithme de Karatsuba - Wikipédia","Algoritmo de Karacuba","Algoritmo de Karacuba - Vikipedio","Algoritmo de Karatsuba","Algoritmo de Karatsuba - Wikipedia, la enciclopedia libre","Algoritmo di Karacuba","Algoritmo di Karatsuba","Algoritmo di Karatsuba - Wikipedia","Algoritmo_di_Karatsuba","Algorytm Karatsuby","Efficiency analysis","Erläuterungen zum Karatsuba-Algorithmus bei Wikipedia, Deutsch","Fast and simple algorithm here","Heiltölumargföldun","Karacuba-szorzás","Karatsuba Algorithmus","Karatsuba algorithm - Wikipedia :: The free encyclopedia","Karatsuba algorithm - Wikipedia, the free encyclopedia","Karatsuba algorithm Wikipedia the free encyclopedia","Karatsuba algorithm on Wikipedia","Karatsuba algorithm →","Karatsuba algorithm: Example","Karatsuba algorithm; it is used under the","Karatsuba algoritme","Karatsuba algoritmo","Karatsuba algoritmus","Karatsuba multiplication","Karatsuba's","Karatsuba's algorithm","Karatsuba's method of efficient multiplication","Karatsuba's multiplication algorithm","Karatsuba),","Karatsuba-","Karatsuba-Algorithm on Wikipedia, English","Karatsuba-Algorithmus","Karatsuba-Algorithmus - Wikipedia","Karatsuba-Algorithmus ? Wikipedia","Karatsuba-Algorithmus bei Wikipedia","Karatsuba-Algorithmus in","Karatsuba-Algorithmus – Wikipedia","Karatsuba-Algorithmus: http://de.wikipedia.org/wiki/Karatsuba","Karatsuba-Ofman Multiplikation","Karatsuba-Ofman algorithm","Karatsuba-algorithm","Karatsuba-algoritme","Karatsuba_algorithm","Karatsuba_multiplication","Karatsuban","Karatsubas Algorithmus","Karatsubaのアルゴリズムを","Karatsubaアルゴリズム","Karatsuba法","Karatsuba法 - Wikipedia","Karatsuba法(Wikipedia)","Karatsuba法-wikipedia","More about Karatsuba multiplication","More information about Karatsuba Multiplication from Wikipedia","Ofman","The Karatsuba multiplication","What is the history of Karatsuba Multiplication?","What is the history of Karatsuba algorithm","Wikipedia (DE): Karatsuba-Algorithmus","Wikipedia - Karatsuba-Algorithmus","Wikipedia article Algoritmo de Karacuba","Wikipedia article Algorytm Karatsuby","Wikipedia article Karatsuba algorithm","Wikipedia article Karatsuba multiplication","Wikipedia article Karatsuba-Ofman algorithm","Wikipedia article The Karatsuba multiplication","Wikipedia article on Karatsuba algorithm","Wikipedia article on Karatsuba algorithm for large integer","Wikipedia entry for Karatsuba algorithm","Wikipedia-Artikel Karatsuba-Algorithmus","Wikipedia-Seite zu 'Karatsuba-Algorithmus'","Wikipediaで「Karatsuba法」を調べる","algorithme de Karatsuba","algoritmo Karatsuba","algoritmo de Karatsuba","algoritmo di Karatsuba","algoritmo di karatsuba","algorytm Karatsuba","algorytm Karatsuby","de.wikipedia.org/wik...aratsuba-Algorithmus","de.wikipedia.org/wiki/Karatsuba-Algorithmus","de:Karatsuba-Algorithmus","divide and conquer trick","due to Karatsuba","edia (http://en.wikipedia.org/wiki/Karatsuba_algorithm","el algoritmo de Karatsuba","el de Karatsuba","en.wikipedia.org/...Karatsuba_algorithm","en.wikipedia.org/wiki/Karatsuba_algorithm","en:Karatsuba algorithm","eo:Algoritmo de Karacuba","es:Algoritmo de Karatsuba","f) Karatsuba-Algorithmus","fr:Algorithme de Karatsuba","http://de.wikipedia.org/wiki/Karatsuba-A","http://de.wikipedia.org/wiki/Karatsuba-Algorithmus","http://de.wikipedia.org/wiki/Karatsuba-Algorithmus#Laufzeitanalyse","http://en.Liarpedia.org/wiki/Karatsuba_algorithm","http://en.wikipedia.org/wiki/Karatsu...orithm#Example","http://en.wikipedia.org/wiki/Karatsuba algorithm","http://en.wikipedia.org/wiki/Karatsuba-Ofman_algorithm","http://en.wikipedia.org/wiki/Karatsuba_a","http://en.wikipedia.org/wiki/Karatsuba_algorithm","http://en.wikipedia.org/wiki/Karatsuba_algorithm#Algorithm","http://en.wikipedia.org/wiki/Karatsuba_algorithm)","http://en.wikipedia.org/wiki/Karatsuba_a…","http://en.wikipedia.org/wiki/Karatsuba_multiplication","http://eo.wikipedia.org/wiki/Algoritmo_de_Karatsuba","http://eo.wikipedia.org/wiki/Multipliko_de_Karatsuba","http://es.wikipedia.org/wiki/Algoritmo_de_Karatsuba","http://fr.wikipedia.org/wiki/Algorithme_de_Karatsuba","http://it.wikipedia.org/wiki/Algoritmo_di_Karatsuba","http://ja.wikipedia.org/wiki/Karatsuba%E6%B3","http://ja.wikipedia.org/wiki/Karatsuba法","http://pl.wikipedia.org/wiki/Algorytm_Karatsuby","http://ru.wikipedia.org/wiki/Умножение_Карацубы","it:Algoritmo di Karatsuba","ja:Karatsuba法","ja:カラツバ法","ko:카라슈바 알고리즘","l'algorithme de Karatsuba","pl:Algorytm Karatsuby","ru.wikipedia.org/wiki/Умножение_Карацубы","ru:Умножение Карацубы","ttp://en.wikipedia.org/wiki/Karatsuba_algorith","ttp://ja.wikipedia.org/wiki/Karatsuba%E6%B3","Википедии статью Умножение Карацубы","Карацуба алгоритм","См. вики","Умножение Карацубы","алгоритм Карацуба","алгоритм Карацубы","вики тоже в курсе","метод Карацубы","метод умножения Карацубы (Karatsuba)","способ умножения Карацубы (Karatsuba)","умножение Карацубы","умножения Карацубы","للعنكلوفونية","、http://en.wikipedia.org/wiki/Karatsuba_algorithm","はKaratsubaアルゴリズム","ウィキペディアの記事 Karatsuba法","カラツバ法 - Wikipedia","카라슈바 알고리즘","카라슈바알고리즘 - 위키백과, 우리 모두의 백과사전","ｶﾗﾂﾊﾞ法-wikipedia"],"name":"Karatsuba algorithm","categories":["Computer arithmetic algorithms","Multiplication","Pages with syntax highlighting errors"],"tag_line":"The Karatsuba algorithm is a fast multiplication algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"mpir-(mathematics-software)","_score":0,"_source":{"description":"Multiple Precision Integers and Rationals (MPIR) is an open-source software multiprecision integer library forked from the GNU Multiple Precision Arithmetic Library (GMP) project. It consists of much code from past GMP releases, and some original contributed code.\nAccording to the MPIR developers, some of the main goals of the MPIR project are:\nDeveloping parallel algorithms for multiprecision arithmetic including support for graphics processing units (GPU) and other multi-core processors.\nMaintaining compatibility with GMP - so that MPIR can be used as a replacement for GMP.\nProviding build support for Linux, Mac OS, Solaris and Windows systems.\nSupporting building MPIR using Microsoft based build tools for use in 32- and 64-bit versions of Windows.\nMPIR is optimised for many processors (CPUs). Assembly language code exists for these as of 2012: ARM, DEC Alpha 21064, 21164, and 21264, AMD K6, K6-2, Athlon, K8 and K10, Intel Pentium, Pentium Pro-II-III, Pentium 4, generic x86, Intel IA-64, Core 2, i7, Atom, Motorola-IBM PowerPC 32 and 64, MIPS R3000, R4000, SPARCv7, SuperSPARC, generic SPARCv8, UltraSPARC.","alt_names":["MPIR","MPIR (mathematics software)","MPIR (mathematics software) - Wikipedia, the free encyclopedia","Wikipedia article MPIR (mathematics software)","Wikipedia article on MPIR (mathematics software)","http://en.Liarpedia.org/wiki/Lenny Williams_(mathematics_software","http://en.wikipedia.org/wiki/MPIR_(mathematics_software)"],"name":"MPIR (mathematics software)","categories":["All articles containing potentially dated statements","All articles with unsourced statements","Articles containing potentially dated statements from 2012","Articles with unsourced statements from April 2014","C libraries","Computer arithmetic","Computer arithmetic algorithms","Free software programmed in C","Numerical software"],"tag_line":"Multiple Precision Integers and Rationals (MPIR) is an open-source software multiprecision integer library forked from the GNU Multiple Precision Arithmetic Library (GMP) project."}}
,{"_index":"throwtable","_type":"algorithm","_id":"liu-hui's-π-algorithm","_score":0,"_source":{"description":"Liu Hui's π algorithm was invented by Liu Hui (fl. 3rd century), a mathematician of Wei Kingdom. Before his time, the ratio of the circumference of a circle to diameter was often taken experimentally as three in China, while Zhang Heng (78–139) rendered it as 3.1724 (from the proportion of the celestial circle to the diameter of the earth, 92/29) or as . Liu Hui was not satisfied with this value. He commented that it was too large and overshot the mark. Another mathematician Wan Fan (219–257) provided π ≈ 142/45 ≈ 3.156. All these empirical π values were accurate to two digits (i.e. one decimal place). Liu Hui was the first Chinese mathematician to provide a rigorous algorithm for calculation of π to any accuracy. Liu Hui's own calculation with a 96-gon provided an accuracy of five digits: π ≈ 3.1416.\nLiu Hui remarked in his commentary to the The Nine Chapters on the Mathematical Art, that the ratio of the circumference of an inscribed hexagon to the diameter of the circle was three, hence π must be greater than three. He went on to provide a detailed step-by-step description of an iterative algorithm to calculate π to any required accuracy based on bisecting polygons; he calculated π to between 3.141024 and 3.142708 with a 96-gon; he suggested that 3.14 was a good enough approximation, and expressed π as 157/50; he admitted that this number was a bit small. Later he invented an ingenious quick method to improve on it, and obtained π ≈ 3.1416 with only a 96-gon, with an accuracy comparable to that from a 1536-gon. His most important contribution in this area was his simple iterative π algorithm.","alt_names":[],"name":"Liu Hui's π algorithm","categories":["All articles that may contain original research","Articles that may contain original research from March 2009","Cao Wei","Chinese mathematics","Pi","Pi algorithms"],"tag_line":"Liu Hui's π algorithm was invented by Liu Hui (fl."}}
,{"_index":"throwtable","_type":"algorithm","_id":"borwein's-algorithm","_score":0,"_source":{"description":"In mathematics, Borwein's algorithm is an algorithm devised by Jonathan and Peter Borwein to calculate the value of 1/π. They devised several other algorithms. They published a book: Jonathon M. Borwein, Peter B. Borwein, Pi and the AGM - A Study in Analytic Number Theory and Computational Complexity, Wiley, New York, 1987. Many of their results are available in: Jorg Arndt, Christoph Haenel, Pi Unleashed, Springer, Berlin, 2001, ISBN 3-540-66572-2.","alt_names":["...more on Wikipedia about Borwein's algorithm","...more on Wikipedia about Borwein's algorithm (others)","Algorisme de Borwein","Algoritmo de Borwein","Algoritmo di Borwein","Borwein algoritmo","Borwein&#39;s algorithm - Wikipedia, the free encyclopedia","Borwein's Algorithm","Borwein's algorithm","Borwein's algorithm (others)","Borwein's algorithm - Wikipedia :: The free encyclopedia","Borwein's algorithm - Wikipedia, the free ...","Borwein's algorithm - Wikipedia, the free encyclopedia","Borwein's algorithm for calculating Pi","Borwein's algorithm that have Nonic convergence","Borwein's algoritm","Borwein's quartic convergence algorithm on pi finding","Borwein's_algorithm","Borweinov algoritmus","Borweins algorithm","Borwein二次收敛法","Más algoritmos","Quadratic Convergence of Borwein","Then a k converges nonically to 1/π; that","Wikipedia Algoritmo de Borwein","Wikipedia article Borwein's algorithm","Wikipedia article Borwein's algorithm (others)","Wikipedia article Borweins algorithm","Wikipedia article about Borwein's algorithm","Wikipedia article on Algoritmo de Borwein","algoritmo de Borwein","artículo de Wikipedia Algoritmo de Borwein","artículo de Wikipedia Borwein (algoritmo)","d14ae320531fc796f6ca23de6a5e66 ...","en.wikipedia.org/wiki/Borwein's_algorithm","http://en.wikipedia.org/wiki/Borwein%27s_a...hm_","http://en.wikipedia.org/wiki/Borwein%27s_algorithm","http://en.wikipedia.org/wiki/Borwein%27s_algorithm#Jonathan_Borwein_and_Peter_Borwein","http://en.wikipedia.org/wiki/Borwein%27s_algorithm#Nonic_convergence","http://en.wikipedia.org/wiki/Borwein%27s_algorithm_%28others","http://en.wikipedia.org/wiki/Borwein%27s…","http://en.wikipedia.org/wiki/Borwein's_algorithm","http://en.wikipedia.org/wiki/Borwein's_algorithm_(others","http://en.wikipedia.org/wiki/Borwein's_a…","http://en.wikipedia.org/wiki/Borwein....27s_algorithm","http://es.wikipedia.org/wiki/Algoritmo_de_Borwein","nonic convergence","p 0 = 2 + 2","page for Borwein's Algorithm","s 0 = ( 1 - r 0 3 ) 1 / 3","τετραγωνικής σύγκλισης του"],"name":"Borwein's algorithm","categories":["All articles with unsourced statements","Articles with unsourced statements from June 2011","Pi algorithms"],"tag_line":"In mathematics, Borwein's algorithm is an algorithm devised by Jonathan and Peter Borwein to calculate the value of 1/π."}}
,{"_index":"throwtable","_type":"algorithm","_id":"quote-notation","_score":0,"_source":{"description":"Quote notation is a number system for representing rational numbers which was designed to be attractive for use in computer architecture. In a typical computer architecture, the representation and manipulation of rational numbers is a complex topic. In quote notation, arithmetic operations take particularly simple, consistent forms, and can produce exact answers with no roundoff error.\nQuote notation’s arithmetic algorithms work with a typical right-to-left direction, in which the addition, subtraction, and multiplication algorithms have the same complexity for natural numbers, and division is easier than a typical division algorithm.\nThe notation was invented by Eric Hehner of the University of Toronto and Nigel Horspool, then at McGill University, and published in the SIAM Journal on Computing, v.8, n.2, May 1979, pp. 124–134. The construction of this system follows the approach of Kurt Hensel's p-adic numbers.","alt_names":["- Quote notation :","6'7","Quote Notation","Quote Notation - Wikipedia, The Free Encyclopedia","Quote notation","Quote notation - Wikipedia :: The free encyclopedia","Quote notation - Wikipedia, the free encyclopedia","Quote notation by Wikipedia","Quote notation on wikipedia.org","Quote notation: Subtraction","Wikipedia article ''Quote notation''","Wikipedia article on Quote notation","Wikipedia entry for Quote notation","http://en.wikipedia.org/wiki/Quote notation","http://en.wikipedia.org/wiki/Quote_notat","http://en.wikipedia.org/wiki/Quote_notation","quote notation"],"name":"Quote notation","categories":["Computer arithmetic algorithms"],"tag_line":"Quote notation is a number system for representing rational numbers which was designed to be attractive for use in computer architecture."}}
,{"_index":"throwtable","_type":"algorithm","_id":"kochanski-multiplication","_score":0,"_source":{"description":"Kochanski multiplication is an algorithm that allows modular arithmetic (multiplication or operations based on it, such as exponentiation) to be performed efficiently when the modulus is large (typically several hundred bits). This has particular application in number theory and in cryptography: for example, in the RSA cryptosystem and Diffie-Hellman key exchange.\nThe most common way of implementing large-integer multiplication in hardware is to express the multiplier in binary and enumerate its bits, one bit at a time, starting with the most significant bit, perform the following operations on an accumulator:\nDouble the contents of the accumulator (if the accumulator stores numbers in binary, as is usually the case, this is a simple \"shift left\" that requires no actual computation).\nIf the current bit of the multiplier is 1, add the multiplicand into the accumulator; if it is 0, do nothing.\nFor an n-bit multiplier, this will take n clock cycles (where each cycle does either a shift or a shift-and-add).\nTo convert this into an algorithm for modular multiplication, with a modulus r, it is necessary to subtract r conditionally at each stage:\nDouble the contents of the accumulator.\nIf the result is greater than or equal to r, subtract r. (Equivalently, subtract r from the accumulator and store the result back into the accumulator if and only if it is non-negative).\nIf the current bit of the multiplier is 1, add the multiplicand into the accumulator; if it is 0, do nothing.\nIf the result of the addition is greater than or equal to r, subtract r. If no addition took place, do nothing.\nThis algorithm works. However, it is critically dependent on the speed of addition.\nAddition of long integers suffers from the problem that carries have to be propagated from right to left and the final result is not known until this process has been completed. Carry propagation can be speeded up with carry look-ahead logic, but this still makes addition very much slower than it needs to be (for 512-bit addition, addition with carry look-ahead is 32 times slower than addition without carries at all).\nNon-modular multiplication can make use of carry-save adders, which save time by storing the carries from each digit position and using them later: for example, by computing 111111111111+000000000010 as 111111111121 instead waiting for the carry to propagate through the whole number to yield the true binary value 1000000000001. That final propagation still has to be done to yield a binary result but this only needs to be done once at the very end of the multiplication.\nUnfortunately the modular multiplication method outlined above needs to know the magnitude of the accumulated value at every step, in order to decide whether to subtract r: for example, if it needs to know whether the value in the accumulator is greater than 1000000000000, the carry-save representation 111111111121 is useless and needs to be converted to its true binary value for the comparison to be made.\nIt therefore seems that one can have either the speed of carry-save or modular multiplication, but not both.","alt_names":["Kochanski multiplicati","Kochanski multiplication","Kochanski multiplication - Wikipedia, the free encyclopedia","Kochanski multiplication Wikipedia the free encyclopedia","Kochanski multiplication; it is used under the","What are alternatives to Kochanski multiplication","Wikipedia article Kochanski multiplication","Wikipedia entry for Kochanski multiplication","http://en.wikipedia.org/wiki/Kochanski multiplication","http://en.wikipedia.org/wiki/Kochanski_multiplication","yago-res:Kochanski multiplication"],"name":"Kochanski multiplication","categories":["Cryptographic algorithms","Modular arithmetic"],"tag_line":"Kochanski multiplication is an algorithm that allows modular arithmetic (multiplication or operations based on it, such as exponentiation) to be performed efficiently when the modulus is large (typically several hundred bits)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dekker's-algorithm","_score":0,"_source":{"description":"Dekker's algorithm is the first known correct solution to the mutual exclusion problem in concurrent programming. The solution is attributed to Dutch mathematician Th. J. Dekker by Edsger W. Dijkstra in an unpublished paper on sequential process descriptions and his manuscript on cooperating sequential processes. It allows two threads to share a single-use resource without conflict, using only shared memory for communication.\nIt avoids the strict alternation of a naïve turn-taking algorithm, and was one of the first mutual exclusion algorithms to be invented.","alt_names":["Dekker's algorithm - Wikipedia, the free encyclopedia","Dekker's algorithm","- Dekker's algorithm :","-> Read the article about 'Dekker's algorithm'","...Wikipedia Algoritmo de Dekker","...Wikipedia Algoritmo di Dekker","...Wikipedia Algorytm Dekkera","...mehr auf Wikipedia über Dekker-Algorithmus","Algorisme de Dekker","Algorithme de Dekker","Algorithme de Dekker - Wikip?dia","Algorithme de Dekker - Wikipédia","Algoritmo de Dekker","Algoritmo de Dekker - Wikipedia, la enciclopedia libre","Algoritmo di Dekker","Algoritmo di Dekker - Wikipedia","Algorytm Dekkera","Algorytm Dekkera – Wikipedia, wolna encyklopedia","Articolo originale su Algoritmo de Dekker","Dekker Algorithm","Dekker algorithm","Dekker algoritması","Dekker algoritması - Vikipedi","Dekker 算法","Dekker's Algorithm","Dekker's Algorithm:","Dekker's algorithm.","Dekker's protocol","Dekker-Algorithmus","Dekker-Algorithmus in","Dekker-like","Dekkers algorithm","Dekkerのアルゴリズム","Learn about Dekker's algorithm>>>","Lexikon: Dekker-Algorithmus - ComputerBase","Suggested: dekker's algorithm","TANIGUCHI Fumitake: デッカーのアルゴリズム - Wikipedia","TH。 J.德克尔的解决方案","Th 'S Dekker soluzione J.","Th 'S Деккер решение J.","Th A solução de Dekker J.","Th Dekker 's oplossing J.","Th s solution J. Dekker","Th. 'S soluzione Dekker J.","Th. Dekker 's Lösung J.","Th. Dekker 's solución J.","Th. J. Dekker 's-oplossing","Th. J. Dekker's solution","Th. S решение Дж. Деккер","Th。 jのデッカーのソリューションは","Thデッカーの解jの","Wikipedia (Dekker's algorithm)","Wikipedia article Algorisme de Dekker","Wikipedia article Algoritmo di Dekker","Wikipedia article Algorytm Dekkera","Wikipedia article Dekker's algorithm","Wikipedia article Dekker-Algorithmus","Wikipedia article on Algoritmo de Dekker","Wikipedia article on Algorytm Dekkera","Wikipedia article Դեկկերի ալգորիթմ","Wikipedia-Artikel Dekker-Algorithmus","Wikipedia-Seite zu 'Dekker-Algorithmus'","Wikipedia:Algoritmo_di_Dekker","algorithme de Dekker","algoritmo de Dekker","algoritmo di Dekker","artículo de Wikipedia Algoritmo de Dekker","ca:Algorisme de Dekker","de:Dekker-Algorithmus","diese eine","en.wikipedia.org/wiki/Dekke...","en.wikipedia.org/wiki/Dekker's_algorithm","es:Algoritmo de Dekker","fr:Algorithme de Dekker","http://de.wikipedia.org/wiki/Dekker-Algo","http://de.wikipedia.org/wiki/Dekker-Algorithmus","http://en.wikipedia.org/wiki/Dekker%27s_algorithm","http://en.wikipedia.org/wiki/Dekker%27s_algorithm#Pseudocode","http://en.wikipedia.org/wiki/Dekker%27s_…","http://en.wikipedia.org/wiki/Dekker's algorithm","http://en.wikipedia.org/wiki/Dekker's_algorithm","http://en.wikipedia.org/wiki/Dekker's_algorithm#Pseudocode","http://en.wikipedia.org/wiki/Dekker's_al…","http://en.wikipedia.org/wiki/Dekker...ithm#Pseudocode","http://en.wikipedia.org/wiki/Dekker_algorithm","http://es.wikipedia.org/wiki/Algoritmo_de_Dekker","http://fr.wikipedia.org/wiki/Algorithme_de_Dekker","http://it.wikipedia.org/wiki/Algoritmo_di_Dekker","http://ja.wikipedia.org/wiki/デッカーのアルゴリズム","http://pl.wikipedia.org/wiki/Algorytm_Dekkera","hy:Դեկկերի ալգորիթմ","it:Algoritmo di Dekker","ja:デッカーのアルゴリズム","ko:데커의 알고리즘","l'algoritmo di Dekker","mutex algorithm","pl:Algorytm Dekkera","problemas de la exclusión mutua","ru:Алгоритм Деккера","tr:Dekker algoritması","uk:Алгоритм Декера","wikipedia:ru:Алгоритм Деккера","Алгоритм Деккера","алгоритм Деккера","デッカーのアルゴリズム","デッカーのアルゴリズム - Wikipedia","デッカーのアルゴリズム – Wikipedia","钍德克尔的解决方案j的","데커의 알고리즘","ﾃﾞｯｶｰのｱﾙｺﾞﾘｽﾞﾑ","ﾃﾞｯｶｰのｱﾙｺﾞﾘｽﾞﾑ-wikipedia"],"name":"Dekker's algorithm","categories":["All articles needing additional references","Articles needing additional references from May 2015","Concurrency control algorithms","Dutch inventions"],"tag_line":"Dekker's algorithm is the first known correct solution to the mutual exclusion problem in concurrent programming."}}
,{"_index":"throwtable","_type":"algorithm","_id":"common-scrambling-algorithm","_score":0,"_source":{"description":"The Common Scrambling Algorithm (or CSA) is the encryption algorithm used in the DVB digital television broadcasting for encrypting video streams.\nCSA was specified by ETSI and adopted by the DVB consortium in May 1994. It is being succeeded by CSA3, based on a combination of 128-bit AES and a confidential block cipher, XRC. However, CSA3 is not yet in any significant use, so CSA continues to be the dominant cipher for protecting DVB broadcasts.","alt_names":["Common Scrambling Algorithm","- Common Scrambling Algorithm :","...Wikipedia Common Scrambling Algorithm","...mehr auf Wikipedia über Common-Scrambling-Algorithmus","...more on Wikipedia about Common Scrambling Algorithm","CSA (Common Scrambling Algorithm)","CSA:n","Comm Scrambling Algorithm","Common Scrambling Algorithm (CSA)","Common Scrambling Algorithm - Wikipedia","Common Scrambling Algorithm - Wikipedia :: The free encyclopedia","Common Scrambling Algorithm - Wikipedia, la enciclopedia libre","Common Scrambling Algorithm - Wikipedia, the free encyclopedia","Common Scrambling Algorithm - Wikipedia, the free encyclopedia ...","Common Scrambling Algorithm â�“ Wikipedia, wolna encyklopedia","Common Scrambling Algorithmus (CSA)","Common-Scrambling-Algorithmus","Common-Scrambling-Algorithmus – Wikipedia","Control Words","Control-Wörter","Definición de Common Scrambling Algorithm más completo","KLOCK","What is the history of Common Scrambling Algorithm","Wikipedia article ''Common Scrambling Algorithm''","Wikipedia article Common Scrambling Algorithm","Wikipedia entry for Common Scrambling Algorithm","Wikipedia-Artikel Common-Scrambling-Algorithmus","Wikipedia-Seite zu 'Common-Scrambling-Algorithmus'","Wikipedia: Common Scrambling Algorithm","artículo de Wikipedia Common Scrambling Algorithm","artículo de Wikipedia DVB-CSA","en.wikipedia.org/...Common_Scrambling_Algorithm","en:Common_Scrambling_Algorithm","http://de.wikipedia....ing-Algorithmus","http://de.wikipedia.org/wiki/Comm... lgorithmus","http://de.wikipedia.org/wiki/Common-...ng-Algorithmus","http://de.wikipedia.org/wiki/Common-Scra","http://de.wikipedia.org/wiki/Common-Scrambling-Algorithmus","http://en.wikipedia.org/wiki/C...ithm","http://en.wikipedia.org/wiki/Common_...ling_Algorithm","http://en.wikipedia.org/wiki/Common_Scr ... _Algorithm","http://en.wikipedia.org/wiki/Common_Scra...","http://en.wikipedia.org/wiki/Common_Scrambling_Algorithm","http://es.wikipedia.org/wiki/Common_Scrambling_Algorithm","http://nl.wikipedia.org/wiki/Common_Scrambling_Alg","http://pl.wikipedia.org/wiki/Common_Scrambling_Algorithm","yago-res:Common Scrambling Algorithm"],"name":"Common Scrambling Algorithm","categories":["Cryptographic algorithms","Digital Video Broadcasting"],"tag_line":"The Common Scrambling Algorithm (or CSA) is the encryption algorithm used in the DVB digital television broadcasting for encrypting video streams."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hs-algorithm","_score":0,"_source":{"description":"The HS Algorithm is named after Dan Hirschberg and J. B. Sinclair. It is a distributed algorithm designed for the Leader Election problem in a Synchronous Ring.\nThe algorithm requires the use of unique IDs (UID) for each process. The algorithm works in phases and sends its UID out in both directions. The message goes out a distance of 2Phase Number hops and then the message heads back to the originating process. While the messages are heading \"out\" each receiving process will compare the incoming UID to its own. If the UID is greater than its own UID then it will continue the message on. Otherwise if the UID is less than its own UID, it will not pass the information on. At the end of a phase, a process can determine if it will send out messages in the next round by if it received both of its incoming messages. Phases continue until a process receives both of its out messages, from both of its neighbors. At this time the process knows it is the largest UID in the ring and declares itself the leader.","alt_names":["HS algorithm","HS algorithm - Wikipedia, the free encyclopedia","HS algorithm; it is used under the","HS_algorithm","Wikipedia article HS algorithm","Wikipedia entry for HS algorithm","en.wikipedia.org/wiki/HS_algorithm","http://en.wikipedia.org/wiki/HS_algorith","http://en.wikipedia.org/wiki/HS_algorithm","yago-res:HS algorithm"],"name":"HS algorithm","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Distributed algorithms"],"tag_line":"The HS Algorithm is named after Dan Hirschberg and J."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cannon's-algorithm","_score":0,"_source":{"description":"In computer science, Cannon's algorithm is a distributed algorithm for matrix multiplication for two-dimensional meshes first described in 1969 by Lynn Elliot Cannon.\nIt is especially suitable for computers laid out in an N × N mesh. While Cannon's algorithm works well in homogeneous 2D grids, extending it to heterogeneous 2D grids has been shown to be difficult.\nThe main advantage of the algorithm is that its storage requirements remain constant and are independent of the number of processors.\nThe Scalable Universal Matrix Multiplication Algorithm (SUMMA) is a more practical algorithm that requires less workspace and overcomes the need for a square 2D grid. It is used by the ScaLAPACK, PLAPACK, and Elemental libraries.","alt_names":["Cannon's algorithm","Cannon's algorithm - Wikipedia, the free encyclopedia","Cannon's Algorithm","Opis algorytmu w Wikipedii","[3] Cannon's algorithm","http://en.wikipedia.org/wiki/Cannon %27s_algorithm","http://en.wikipedia.org/wiki/Cannon%27s_algorithm"],"name":"Cannon's algorithm","categories":["All stub articles","Applied mathematics stubs","Distributed algorithms","Matrix multiplication algorithms"],"tag_line":"In computer science, Cannon's algorithm is a distributed algorithm for matrix multiplication for two-dimensional meshes first described in 1969 by Lynn Elliot Cannon."}}
,{"_index":"throwtable","_type":"algorithm","_id":"algorithm","_score":0,"_source":{"description":"In mathematics and computer science, an algorithm (/ˈælɡərɪðəm/ AL-gə-ri-dhəm) is a self-contained step-by-step set of operations to be performed. Algorithms exist that perform calculation, data processing, and automated reasoning.\nAn algorithm is an effective method that can be expressed within a finite amount of space and time and in a well-defined formal language for calculating a function. Starting from an initial state and initial input (perhaps empty), the instructions describe a computation that, when executed, proceeds through a finite number of well-defined successive states, eventually producing \"output\" and terminating at a final ending state. The transition from one state to the next is not necessarily deterministic; some algorithms, known as randomized algorithms, incorporate random input.\nThe concept of algorithm has existed for centuries, however a partial formalization of what would become the modern algorithm began with attempts to solve the Entscheidungsproblem (the \"decision problem\") posed by David Hilbert in 1928. Subsequent formalizations were framed as attempts to define \"effective calculability\" or \"effective method\"; those formalizations included the Gödel–Herbrand–Kleene recursive functions of 1930, 1934 and 1935, Alonzo Church's lambda calculus of 1936, Emil Post's \"Formulation 1\" of 1936, and Alan Turing's Turing machines of 1936–7 and 1939. Giving a formal definition of algorithms, corresponding to the intuitive notion, remains a challenging problem.\n\n","alt_names":["Logical errors","Lösungsalgorithmus","Wikipedia tietää kaiken.","algorithm's","algoritma.","算法的","خوارزميات","algorisme","2.4 Implementación","ალგორითმი","9 Disciplinas relacionadas","簡単な解説","алгоритм","Algorithmes","αλγορίθμων","算法","algorytmu","Algoritmer","algoritmeja","algoritms","software algorithms","algorithms","Algoritmo","Algoritam","Algorithm","algoritam","8 Disciplinas relacionadas","алгоритму","Lösungsverfahren","ALGORITMO","deterministic procedure","2.1 Termination","אלגוריתם","algorithms,","algoritmas","'algoritme'","algoritmasını","algoritmien","алгоритмы","3 Formalization","厳密な定義","אלגוריתמים","алгоритмов","3.1 Termination","algorith","algorithme","Алгоритм","Algorithme","Naïve algorithm","algorithmen","الخوارزمية","algoritmu","Algoritem","l'algoritmo","naÃ¯ve","ALGORITHMS","another algorithm","Algorithmen","algoritmo","Algoritmi","Algorithmus","algoritmer","Алгоритам","Algoritmos","algorytmów","algoritmos","algorithmes","Algoritm","algorítmico","algorithmic approach","algoritmů","computer algorithms","algoritme","αλγόριθμος","well-defined procedure","http://de.wikipedia.org/wiki/Algorithmus","الگوریتم","algoritmi","アルゴリズム","algoritmus","algorytm","الگوریتمی","알고리즘","http://fr.wikipedia.org/wiki/Algorithme","algorithmically","алгоритма","Algorytm","algoritma","Algoritma","algoritmen","thuật toán","langkah","' algoritmo","'algorith","'algorithme","'algoritmo","(algorith","(algorithm","(algorithm) i","(http://es.kioskea.net/langages/langages.php3)","(حوالہ)","**//algoritmo//**","**algoritmo**","**http://es.wikipedia.org/wiki/Algoritmo**","**procedures**","*algorithm","*algorithms","*algoritmos","*an *algorithmic",", bedanya jawaban dari submasalah tidak perlu diketahui dalam","- Algorithm :","- Algorithmic :","- Algorithms :","- Algoritmus","- Naïve algorithm :","- Sequential algorithm :","-Algorithmus - Mit dem Design-Paradigma",". Algoritmy","...Wikipedia Algorithmique","...Wikipedia Algoritm","...Wikipedia Algoritmo","...Wikipedia Algorytm","...mehr auf Wikipedia über Algorithmus","...more on Wikipedia about Algorithm","// Resumo de Algorítimo","//algorithm//","//algoritmo//","/wiki/Algorithmus","/wiki/Algoritmo","1 Algorytmy komputerowe","1 Características de los algoritmos","1 Características principales y definición formal","1 Medios de expresión de un algoritmo","1 Sejarah istilah algoritma","1 Sejarah istilah “algoritma”","1 Why algorithms are necessary: an informal definition","1 Why algorithms passe necessary: an informal definition","1 Алгоритмын төрлүүд","1 알고리듬의 조건","1 알고리즘의 조건","1. Algorithm - Wikipedia, the free encyclopedia","1.1 Diagrama de flujo","1.1 Implementacja","1.2 Algorytm a opisujący go język","1.2 Pseudocódigo","1.3 Klasyfikacja","1.3 Máquina de Turing","1.4 Implementación","1.4 Przykłady","1.5 Błędy w implementacji","10 Libros sobre Algoritmia","10 Temas relacionados","10.1 Secondary references","10Referencias","11 Disciplinas relacionadas","11 History: Development of the notion of algorithm","11.1 Discrete and distinguishable symbols","11.1 Secondary references","11.2 Manipulation of symbols as place holders for","11.3 Mechanical contrivances with discrete states","11.4 Mathematics during the 1800s up to the","11.5 Emil Post (1936) and Alan Turing (1936","11.6 J. B. Rosser (1939) and S. C. Kleene (1943","11.7 History after 1950","11Bibliografía","12 Libros sobre Algoritmia","14.1 Secondary references","16][17][18","1799. Wikipedia (en)","1800. Wikipedia (ro)","1</span> Tanımı</span>","1Características principales y definición formal","2 Algoritmos y funciones","2 Algorytmy poza komputerami","2 Características de los algoritmos","2 Formalization of algorithms","2 Jenis-jenis Algoritma","2 Medios de expresión de un algoritmo","2 Why algorithms are necessary: an informal definition","2 stage algorithm","2 Алгоритмыг зохиох аргачлал","2 大雑把な定義","2 알고리듬의 연구 분야","2 알고리즘의 연구 분야","2.1 Diagrama de flujo","2.1Diagrama de flujo","2.2 Expressing algorithms","2.2 Pseudocódigo","2.2 Étude systématique","2.2Pseudocódigo","2.3 Computer algorithms","2.3 Máquina de Turing","2.3 Sistemas formales","2.3Sistemas formales","2.4Implementación","2.6 Estructuras secuenciales","220px-Euclid's_algorithm_ ...","231. Wikipedia (en)","232. Wikipedia (ro)","2552. Wikipedia (en)","2553. Wikipedia (ro)","2</span> Tarihi</span>","2Medios de expresión de un algoritmo","3 Algoritmos como funciones","3 Algoritmos y funciones","3 Análisis de algoritmos","3 Exemples d'algorithme","3 Formalization of algorithms","3 Przyszłość algorytmów","3 Алгоритмын чанарууд","3 厳密な定義","3 알고리듬의 분석 기준","3 알고리즘의 분석 기준","3. Algorithm - Wikipedia, the free encyclopedia","3. Algoritmos","3. הסבר: מהו אלגוריתם (מתוך ויקיפדיה)","3.1 Algorithm analysis","3.1 Ograniczenia algorytmów","3.1 Дискрет чанар","3.2 Algorytmy sztucznej inteligencji","3.2 Expressing algorithms","3.2 Тодорхой чанар","3.3 Algorytmy kwantowe","3.3 Computer algorithms","3.3 Төгсгөлөг чанар","3.4 Algorytmy równoległe","3.4 Үр дүнтэй чанар","3.5 Нийтлэг чанар","35. Wikipedia (ro)","3960. Wikipedia (en)","3961. Wikipedia (ro)","3962. Wikipedia (en)","3963. Wikipedia (ro)","3</span> Önemli algoritma türleri</span>","3Algoritmos como funciones","3D алгоритми","4 Algorithmic analysis","4 Análisis de algoritmos","4 Complexité algorithmique","4 Computer algorithms","4 Ejemplo de algoritmo","4 Medios de expresión de un algoritmo","4 Przykład algorytmu","4 Алгоритмын үндсэн алхмууд","4 アルゴリズムの定式化","4 평균과 최악의 경우 분석","4.1 Algorithm analysis","4.1 Algorithmic analysis","4.1 Classification by implementation","4.1 Descripción de alto nivel","4.1 Diagrama de flujo","4.1 Formal versus empirical","4.1 Мэдээллийг оруулах алхам","4.1 停止性","4.1.1 Abstract versus empirical","4.2 Classification by design paradigm","4.2 Descripción formal","4.2 Pseudocódigo","4.2 Бодолтын утга олгох алхам","4.2 アルゴリズムの表現","4.3 Classification by field of study","4.3 Implementación","4.3 Máquina de Turing","4.3 Мэдээллийг бичиж гаргах алхам","4.3 実装","4.4 Análisis","4.4 Classification by complexity","4.4 Effektivität","4.4 Implementación","4.4 Салаалуулах алхам","447. Wikipedia (en)","448. Wikipedia (ro)","4</span> Ayrıca bakınız</span>","4Análisis de algoritmos","5 Algorithmic analysis","5 Análisis de algoritmos","5 Ejemplo de algoritmo","5 Historia algorytmów","5 Quelques indications sur l'efficacité des algorithmes","5 Tipos de algoritmos según su función","5 Алгоритмыг дүрслэх","5 例","5. Algorithm - Wikipedia, the free encyclopedia","5.1 By implementation","5.1 Classification by implementation","5.1 Descripción de alto nivel","5.1 Formal versus empirical","5.1 Początki","5.1 Sorting example","5.1 アルゴリズム解析","5.1Descripción de alto nivel","5.2 By design paradigm","5.2 Classification by design paradigm","5.2 Descripción formal","5.2 Euclid's algorithm","5.2 Rozwój maszyn liczących","5.2.1 Computer (computor) language for Euclid's algorithm","5.2.1 Computer(computor) language for Euclid's algorithm","5.2.2 An inelegant program for Euclid's algorithm","5.2.3 An elegant program for Euclid's algorithm","5.2Descripción formal","5.3 By field of study","5.3 Classification by field of study","5.3 Implementación","5.3 Komputery","5.3 Testing the Euclid algorithms","5.3Implementación","5.4 By complexity","5.4 Classification by complexity","5.4 Measuring and improving the Euclid algorithms","5.4 Zobacz też","5.5 Bibliografia","5.5 By computing power","5.6 Linki zewnętrzne","5Ejemplo de algoritmo","6 Algorithmic analysis","6 Ejemplo de algoritmo","6 History: Development of the notion of algorithm","6 Les heuristiques","6 Tipos de algoritmos según su función","6 Técnicas de diseño de algoritmos","6 Ténicas de diseño de algoritmos","6.1 By implementation","6.1 Descripción de alto nivel","6.1 Formal versus empirical","6.1 Origin of the word","6.1 実装による分類","6.2 By design paradigm","6.2 Descripción formal","6.2 Discrete and distinguishable symbols","6.2 設計パラダイムによる分類","6.3 By field of study","6.3 Implementación","6.3 Manipulation of symbols as place holders for","6.3 研究分野による分類","6.4 Análisis","6.4 By complexity","6.4 Mechanical contrivances with discrete states","6.4 計算量による分類","6.5 By computing power","6.5 Mathematics during the 1800's up to the","6.5 計算能力による分類","6.6 Emil Post (1936) and Alan Turing (1936","6.7 J. B. Rosser (1939) and S. C. Kleene (1943","6Tipos de algoritmos según su función","7 Etymology of the word Algorithm","7 History: Development of the notion of algorithm","7 Técnicas de diseño de algoritmos","7 法的問題","7.1 By implementation","7.1 Origin of the word","7.2 By design paradigm","7.2 Discrete and distinguishable symbols","7.3 By field of study","7.3 Manipulation of symbols as place holders for","7.4 By complexity","7.4 Mechanical contrivances with discrete states","7.5 Mathematics during the 1800s up to the","7.6 Emil Post (1936) and Alan Turing (1936","7.7 J. B. Rosser (1939) and S. C. Kleene (1943","7.8 History after 1950","7Técnicas de diseño de algoritmos","8 Continuous algorithms","8 History: Development of the notion of algorithm","8 History: Development of the notion of “algorithm","8 Temas relacionados","8 Tipos de algoritmos según su función","8 代表的なアルゴリズム","8.1 Discrete and distinguishable symbols","8.1 Origin of the word","8.1 Tipos de algoritmos según su función","8.2 Discrete and distinguishable symbols","8.2 Manipulation of symbols as place holders for","8.2 Técnicas de diseño de algoritmos","8.3 Algorytmy genetyczne","8.3 Manipulation of symbols as place holders for","8.3 Manipulation of symbols as “place holders” for","8.3 Mechanical contrivances with discrete states","8.4 Algorytmy kwantowe","8.4 Disciplinas relacionadas","8.4 Mathematics during the 1800s up to the","8.4 Mechanical contrivances with discrete states","8.5 Algorytmy równoległe","8.5 Emil Post (1936) and Alan Turing (1936","8.5 Mathematics during the 1800s up to the","8.6 Emil Post (1936) and Alan Turing (1936","8.6 J. B. Rosser (1939) and S. C. Kleene (1943","8.7 History after 1950","8.7 J. B. Rosser (1939) and S. C. Kleene (1943","8.8 History after 1950","8Temas relacionados","9 Libros sobre Algoritmia","9 Técnicas de diseño de algoritmos","9.1 Secondary references","9.1 計算可能性と複雑性の理論の関連","9.2 計算モデル関連","952. Wikipedia (en)","953. Wikipedia (ro)","9Disciplinas relacionadas",": http://en.wikipedia.org/wiki/Algorithm","<http://en.wikipedia.org/wiki/Algorithm","<http://en.wikipedia.org/wiki/Algorithm>","> more at: Wikipedia/Algorithmique","> more at: Wikipedia/Algoritmi","> more at: Wikipedia/Algoritmos",">> εδώ <<",">klick 1<","???????? (arz)","???????? (be)","????????? (be-x-old)","???????ĩ?? - ????pa?de?a","???????ľ?? - ????pa?de?a","A language enables a programmer to precisely specify","A program combines multiple protocols, tests, steps into","ALGORITHM","ALGORITMA","ALGORITMI","ALGORITMICA","ALGORITMOS","ALGORITMOS 1","ALGORITMOS PARA LOS INGENIEROS CIVILES INFORMATICOS","ALGORTIMO","ALgoritmische","ALgoritmo","ARTICULO DE ALGORITMO","About algorithms","Additional reading on programs, algorithms and pseudo-code","Ahora bien, Ethernet como protocolo es considerado CSMA","Al Goritmi","Al khowarizmi","Al-Gore-ithm…","AlGorithm","Alghorithme","Alghorithmus","Algorerhythmus","Algorhithmus","Algorisme","Algorisme - Viquipèdia","Algorismes","Algorismo","Algorismo (an)","Algorismo - Biquipedia, a enziclopedia libre","Algorisse","Algorisse - Wikipedia","Algoritam - Wikipedia","Algoritam - Wikipedia, slobodna enciklopedija - Википедија, слободн...","Algoritam - Wikipedija","Algoritam - Википедија","Algoritem - Wikipedija, prosta enciklopedija","Algorithim","Algorithm (Wikipedia)","Algorithm (wikipedia)","Algorithm - By design paradigm","Algorithm - Examples","Algorithm - Expressing algorithms","Algorithm - In base alla progettazione paradigma","Algorithm - Przez paradygmat projekt","Algorithm - Simple English Wikipedia, the free encyclopedia","Algorithm - Simple English Wikipedia, the free encyclopedia An","Algorithm - Wikipedia","Algorithm - Wikipedia :: The free encyclopedia","Algorithm - Wikipedia, The Free Encyclopedia","Algorithm - Wikipedia, the free ...","Algorithm - Wikipedia, the free encycl","Algorithm - Wikipedia, the free encyclopedi","Algorithm - Wikipedia, the free encyclopedia","Algorithm - Wikipedia, the free encyclopedia Flowcharts are often","Algorithm - Wikipedia, the free encyclopedia In mathematics and","Algorithm - Wikipedia, the free encyclopedia In mathematics, computer","Algorithm - Wikipedia, the free encyclopedia This is an","Algorithm - Wikipedia, the free encyclopedia wikipedia.org In","Algorithm - Wikipedia, the free encyclopedia:","Algorithm - Wikipedia, the free encyclopediaIn mathematics and","Algorithm - Wikipedia, the free encyclopediaIn mathematics and computer","Algorithm - Wikipedia, the free en…","Algorithm - Wikipediathe free encyclopedia","Algorithm @ Wikipedia","Algorithm Related Content:","Algorithm Simple English Wikipedia the free encyclopedia","Algorithm Simple English Wikipedia the free encyclopedia.","Algorithm Studies.","Algorithm Wiki","Algorithm Wikipedia The Free Encyclopedia","Algorithm Wikipedia the free encyclopedia","Algorithm Wikipedia the free encyclopedia - result","Algorithm Wikipedia the free encyclopedia.","Algorithm Wikipedia, the free ...","Algorithm [wikipedia]","Algorithm at Wikipedia","Algorithm from Wikipedia","Algorithm knowledge","Algorithm on Wikipedia","Algorithm page on Wikipedia","Algorithm theorists","Algorithm |","Algorithm – Wikipedia, the free encyclopedia","Algorithm#Expressing_algorithms","Algorithm(Wikipedia)","Algorithm, the free encyclopedia - Wikipedia","Algorithm, wikipedia","Algorithm-Wikipedia","Algorithm:","Algorithm: Classification by design paradigm - Wikipedia, the free","Algorithm: Example","Algorithme de Wiki","Algorithme sur Wikipedia","Algorithmen!","Algorithmen,","Algorithmenentwurf und Analyse","Algorithmes (ou suites d'opérations)","Algorithmes!","Algorithmic Process","Algorithmically","Algorithmik","Algorithmique","Algorithmique - Wikip?dia","Algorithmique - Wikipédia","Algorithmique - Wikipédia http://fr.wikipedia.org/wiki/Algorithmique","Algorithmique - Wikipédia, l'encyclopédie gratuite et libre","Algorithmique sur Wikipédia","Algorithmique, structures de données","Algorithmische Bilderzeugung","Algorithmisierung","Algorithmo","Algorithmo - Wikipedia, le encyclopedia libere","Algorithmo - Wikipedia, le encyclopedia libere http://ia.wikipedia","Algorithms - Wikipedia","Algorithms - Wikipedia entry","Algorithms - Wikipedia, the free encyclopedia","Algorithms Themself","Algorithms Wiki","Algorithms and their analysis","Algorithms are essential to the way computers process","Algorithms at Wikipedia","Algorithms by Wikipedia","Algorithms in General","Algorithms in the Wikipedia","Algorithms on Wikipedia","Algorithms:1","Algorithmus (Wikipedia)","Algorithmus (Wortgeschichte)","Algorithmus - Wikipedia","Algorithmus ? Wikipedia","Algorithmus Wiki","Algorithmus Wikipedia","Algorithmus auf wikipedia nachschlagen","Algorithmus i","Algorithmus in","Algorithmus – Wikipedia","Algorithmus)","Algorithmusbegriffs","Algorithmusdefinition und Beispiele bei Wikipedia","Algorithmusses","Algorithmustheorie","Algorithm）说白了就是是解决问题的步骤.可以把算法定义成解决一个分类问题的任意一种特殊的方法. 编程世界中算法+数据结构=程序. 而数据结构往往是封装在不同编程语言中.","Algoritimo","Algoritimos","Algoritm - Vikipeedia, vaba entsüklopeedia","Algoritm - Wikipedia","Algoritm på svenska Wikipedia","Algoritm. Från Wikipedia","Algoritma (yöntem mantığı)","Algoritma - Vikipedi","Algoritma - Wikipedia Bahasa Melayu, ensiklopedia bebas","Algoritma - Wikipedia bahasa Indonesia, ensiklopedia bebas","Algoritma - WikipÃ©dia","Algoritma - Wikipédia","Algoritma :: Wikipedia Bahasa Indonesia","Algoritma Wikipedia Bahasa Melayu ensiklopedia bebas.","Algoritma Wikipedia bahasa Indonesia ensiklopedia bebas","Algoritma Wikipedia bahasa Indonesia ensiklopedia bebas.","Algoritma Wikipédia","Algoritma i","Algoritma ifadesi","Algoritma!","Algoritmai","Algoritmalar","Algoritmalara","Algoritmanya","Algoritmar","Algoritmas","Algoritmas – Vikipedija","Algoritme","Algoritme (Wikipedia)","Algoritme (af)","Algoritme (matematisk)","Algoritme - Wikipedia","Algoritme - Wikipedia, den frie encyklop...","Algoritme - Wikipedia, den frie encyklopædi","Algoritme Wikipedia","Algoritme Wikipedia den frie encyklop di","Algoritme trading","Algoritme:","Algoritmi - Wikipedia","Algoritmi de numero Indorum","Algoritmi su Wikipedia","Algoritmi – Wikipedia","Algoritmi-Vikipedija","Algoritmia","Algoritmia (wikipedia)","Algoritmica","Algoritmico","Algoritmiek","Algoritmik","Algoritmilla","Algoritmit","Algoritmo - Vikipedio","Algoritmo - Wikipedia","Algoritmo - Wikipedia, a enciclopedia libre","Algoritmo - Wikipedia, entziklopedia askea.","Algoritmo - Wikipedia, la ...","Algoritmo - Wikipedia, la enciclopedia libre","Algoritmo - Wikipedia, la enciclopedia…","Algoritmo - Wikipedia- /w/opensearch_desc.php title= Wikipedia (it","Algoritmo - WikipÃ©dia, a enciclopÃ©dia livre","Algoritmo - Wikipédia","Algoritmo - Wikipédia, a enciclopédia livre","Algoritmo ? Wikip?dia, a enciclop?dia livre","Algoritmo Wikipedia la enciclopedia libre","Algoritmo en Wikipedia","Algoritmo secondo Wikipedia","Algoritmo segun wikipedia","Algoritmo su Wikipedia.org","Algoritmo – Wikipedia, la enciclopedia libre","Algoritmo – Wikipédia","Algoritmo – Wikipédia, A Enciclopédia Livre","Algoritmo – Wikipédia, a enciclopédia livre","Algoritmo-Wikipédia","Algoritmo. Origem: Wikipédia, a enciclopédia livre. Ir para","Algoritmo:","Algoritmoa","Algoritmos - Wikipedia","Algoritmos Computacionais","Algoritmos I","Algoritmos como funciones","Algoritmos de programación","Algoritmos y Estructuras de Datos","Algoritmos y Pseudocodigos","Algoritmos!","Algoritmos-Wikipedia","Algoritms","Algoritms - Vikipēdija","Algoritmu","Algoritmu (ast)","Algoritmul","Algoritmus - Wikipedie","Algoritmus - Wikipedie, otevřená encyklopedie","Algoritmus - Wikipédia","Algoritmus - wikipedie","Algoritmus » Etymologie","Algoritmus-Wiki","Algoritmusok","Algoritmusokkal","Algoritmy","Algoritmų","Algortimes","Algortma","Algorythm","Algorytm ? Wikipedia, wolna encyklopedia","Algorytm Wikipedia, wolna encyklopedia","Algorytm â�“ Wikipedia, wolna encyklopedia","Algorytm – Wikipedia, wolna encyklopedia","Algorytmika","Algorytmy","Algorytmy sztucznej inteligencji","Algorytmy-kliknij","Algorìtmo","Algorìtmo:","Algorítmica","Algorítmo","Algorîtman","Algprithm","Alguritmu","Algurìttimu","Algôhitmes","Alkhawarizmi","Allgemeine Definition des Begriffs Algorithmus in der deutschen","Allgorithmen","Alogrithm","Alqoritm","Alqoritm (az)","Alqoritm - Vikipediya","AlqoritmVikipediya http://az.wikipedia.org/wiki/Alqoritm","Analisis & Algoritmos de Funcionamiento","AnswerQuestions article on Algorithm","Articolul despre algoritmi","Artículo Wikipedia - Algoritmos","Artículo de la Wikipedia sobre Algoritmos.","Boolos & Jeffrey","Boolos & Jeffrey (1974, 1999)","Boolos & Jeffrey 1974, 1999","Buscar algoritmo en Wikipedia España","Classes of algorithms by design paradigm","Classificació d'algorismes","Complete Definition and History of Algorithms","Computational Algorithms","Computational approaches","Computer science algorithms","Computer-Algorithmen","Conceitos de Algoritmos","Concepto de Algoritmo","Concepto de Algoritmos","Contiene definiciones, características, metodologìa de algoritmos y diagramas","Continuous algorithm","Control Algorithms","DESIGN OF ALGORITHMS","DONC WIKI WIKI (IMG:","Definción de algoritmo en Wikipedia","Definicion Algoritmo","Definición de Algoritmo","Definición de algoritmo","Definicja algorytmu","Definition Algorithmus","Definition of Algorithm","Definition von deterministisch und determiniert powered by Wikipedia","Definição de algoritmo","Descripción ALGORITMO","Diseño de Algoritmos","Dividir i vencer","Documento na íntegra","Efektyvi_procedūra","Encyclopedia: Algorithm","Entrada na Wikipedia sobre algoritmos","Esquemas algorítmicos","Etymology of the word algorithm","Exactes o aproximats","FICO algorithms","Flight Simulator (Examples)","For a detailed presentation of the various points","Formalization of algorithms","Formelle algoritmer (Wikipedia)","Giải thuật","Go to Wikipedia and Find out What They","Grasshopper is not a magic box or a","Haga clic para ver la página de algoritmos","Here's my inspiration for doing this.","Histoire de # mot http://de.wikipedia.org/wiki","History of algorithms","Http://en.wikipedia.org/wiki/Algorithm","INTRODUCCION A LOS ALGORITMOS Y DIAGRAMAS DE FLUJOS","Il codice fiscale personale, cioè delle persone fisiche","In informatica e matematica, con il termine algoritmo","In mathematics and computer science, an algorithm is","In mathematics, computer science, and related subjects, an","In mathematics, computing, linguistics and related disciplines, an","In mathematics, computing, linguistics, and related disciplines, an","Inducción a a algoritmos","Infoooo","Informacion sobre algoritmos","Informacje ....","Ir a Algoritmo - Wikipedia, la enciclopedia libre","Ián-sǹg-hoat","Ián-sǹg-hoat – Wikipedia","L'Algoritmo","L'algorithmique selon wikipédia","L'utente Ok e l'algoritmo vincente (social","La page Algorithmique de Wikipedia.org","Learn about Algorithm>>>","Leer más sobre Algoritmos","Les algoritmos","Lihat tentang algoritma yang lengkap","Linguagem Algorítmica","Los Algoritmos","Los algoritmos","Lösungsverfahrens","Mais »»»","Mas informacion sobre este tema","Mathematical Algorithm","Mathematics during the 1800s up to the mid","Medios de expresión ...","Mohammad ebne M ¯us¯a Khw¯arazm¯ı","More information about this topic","More on Algorithms","Naiv algoritmus","Naïve Algorithms","Naïve_algorithm","New Algorithms","Noção de Algoritmo","O conceito de algoritmo","Obtido em http://pt.wikipedia.org/wiki/Algoritmo","Origen del Algoritmo","Os algoritmos","Over Algoritme","Pesquisar algoritmo na Wikipedia Portugal","Popular computer science algorithms","Procesos de un Algoritmo","Procesos de un algoritmos","Projeto e análise de algoritmos","Pseudocódigo.","QUÉ ES ALGORITMO EN WIKIPEDIA","Que es Algoritmo","RC4 Algorithms","Read More About algorithm wikipedia the free encyclopedia","Read More About algoritma - wikipédia ...","Read More algorithm simple english wikipedia the free","Read More algorithm wikipedia the free encyclopedia","Read More algoritmo vikipedio","Read More algoritmo wikipedia","Rechenprozesses","Rechenverfahren","Rechenvorschrift","Reiknirit","Research : Algorithms","Screenshot http://de.wikipedia.org/wiki/Algorithmus","Search for Algorithm on Wikipedia!","Search for Algorithmic on Wikipedia!","Search for Algorithms on Wikipedia!","Sejarah Istilah Algoritma","Sequential Algorithm","Sequential algorithm - Wikipedia, the free encyclopedia","Serial algorithm","Software logic","Suggested: algorithm","The Wikipedia has some coverage as well","The word algorithm comes from the name of","Thema Algorithmus","This is algorithm.","Thuật Toán","Thuật giải","Thuật toán","Thuật toán – Wikipedia tiếng Việt","Tipos de algoritmos según su función","Uma definição de algoritmos na Wikipedia","Understand Algorithm","Veja aqui, na Wikipedia","Ver documento en WIKIPEDIA","View Algorithm on Wikipedia","View Algorithms on Wikipedia","Vikipedi: kelime algoritması tarih","Visit wikipedia to find out more about this","Voir l'article consacré à algorithmique dans Wikipedia","WIKI - DUTCH","WIKIPEDIA-Algorythmus","WIKIPEDIA: Algorithmus","What is Software logic's example?","What is an Algorithm?","What is an algorithm?","What is classification for Algorithms","What is the etymology of Algorithm segment?","What is the etymology of Software logic?","What is the example of Algorithm?","What is the example of Computer algorithms?","What's an Algorithm?","Why algorithms are ...","Why algorithms are necessary: an informal definition","Wiki algorithm","Wiki algoritması","Wiki: Algorithm","WikiPedia: Algoritme","WikiPedia:Algorithmiclly","Wikimedia Foundation, Inc. (2009, March 8 th 2009","Wikipedia (Algoritmo)","Wikipedia - Algoritam","Wikipedia - Algorithm","Wikipedia - Definição de Algoritmos","Wikipedia - Tema: Algoritmos","Wikipedia - アルゴリズム","Wikipedia : algorithmique","Wikipedia Algorithm","Wikipedia Algorithm definition","Wikipedia Algorithm definition - start here!","Wikipedia Algorithm page","Wikipedia Algorithms Entry","Wikipedia Algoritmos","Wikipedia Article about Algorithms","Wikipedia Info for Algorithm","Wikipedia Listing: algorithm","Wikipedia Page on Algorithm","Wikipedia algoritmo es: .","Wikipedia article Algorisme","Wikipedia article Algorismo","Wikipedia article Algorisse","Wikipedia article Algoritam","Wikipedia article Algoritem","Wikipedia article Algorithm","Wikipedia article Algorithm variable.","Wikipedia article Algorithmique","Wikipedia article Algorithmo","Wikipedia article Algorithmus","Wikipedia article Algoritm","Wikipedia article Algoritma","Wikipedia article Algoritmas","Wikipedia article Algoritme","Wikipedia article Algoritmi","Wikipedia article Algoritmo","Wikipedia article Algoritms","Wikipedia article Algoritmu","Wikipedia article Algoritmus","Wikipedia article Algorytm","Wikipedia article Algorîtma","Wikipedia article Alguritmu","Wikipedia article Alqoritm","Wikipedia article Naiv algoritmus","Wikipedia article Reiknirit","Wikipedia article Sequential algorithm","Wikipedia article about Algorithms","Wikipedia article on Algorithm","Wikipedia article on Algorithmic","Wikipedia article on Algorithms","Wikipedia article on Algoritmo","Wikipedia article on algorithms","Wikipedia article Αλγόριθμος","Wikipedia article Алгарытм","Wikipedia article Алгоритам","Wikipedia article Алгоритм","Wikipedia article Алгоритъм","Wikipedia article Альгарытм","Wikipedia article Алґорітм","Wikipedia article אלגוריתם","Wikipedia article الجوريتم","Wikipedia article الخوارزم","Wikipedia article الخوارزمي","Wikipedia article الگورتھم","Wikipedia article خوارزمية","Wikipedia article अल्गोरिदम","Wikipedia article अल्गोरिद्म","Wikipedia article অ্যালগরিদম","Wikipedia article படிமுறைத் தீர்வு","Wikipedia article అల్గారిథం","Wikipedia article അൽഗൊരിതം","Wikipedia article ඇල්ගොරිතම","Wikipedia article ขั้นตอนวิธี","Wikipedia article ຂັ້ນຕອນວິທີ","Wikipedia article အယ်လ်ဂေါ်ရစ်သမ်","Wikipedia article ალგორითმი","Wikipedia article アルゴリズム","Wikipedia artikel Algoritme","Wikipedia artikel Algoritmiek","Wikipedia description on algorithms","Wikipedia entry for Algorithm","Wikipedia entry for Sequential algorithm","Wikipedia hilft gern.","Wikipedia l'articolo Algoritmi","Wikipedia l'articolo Algoritmico","Wikipedia on Algorithm","Wikipedia on Algorithms","Wikipedia on algorithms","Wikipedia page for Algorithms","Wikipedia – Algorithms","Wikipedia's article on Algorithms.","Wikipedia(EN): Algorithm","Wikipedia, free Encyclopedia","Wikipedia, september 26th 2006","Wikipedia-Algorithms","Wikipedia-Artikel Algorithmen","Wikipedia-Artikel Algorithmus","Wikipedia-Artikel Lösungsverfahren","Wikipedia-Seite zu 'Algorithmen'","Wikipedia-Seite zu 'Algorithmus'","Wikipedia-Seite zu Algorithmen","Wikipedia-en:Algorithm","Wikipedia/Algorithm","Wikipedia: 'Algorisme'","Wikipedia: 'Algorismo'","Wikipedia: 'Algorisse'","Wikipedia: 'Algoritam'","Wikipedia: 'Algorithm'","Wikipedia: 'Algorithmique'","Wikipedia: 'Algorithmo'","Wikipedia: 'Algorithmus'","Wikipedia: 'Algoritm'","Wikipedia: 'Algoritma'","Wikipedia: 'Algoritmas'","Wikipedia: 'Algoritme'","Wikipedia: 'Algoritmi'","Wikipedia: 'Algoritmo'","Wikipedia: 'Algoritms'","Wikipedia: 'Algoritmu'","Wikipedia: 'Algoritmus'","Wikipedia: 'Algorytm'","Wikipedia: 'Algorîtma'","Wikipedia: 'Alguritmu'","Wikipedia: 'Alqoritm'","Wikipedia: 'Ián-sǹg-hoat'","Wikipedia: 'Reiknirit'","Wikipedia: 'Αλγόριθμος'","Wikipedia: 'Алгарытм'","Wikipedia: 'Алгоритам'","Wikipedia: 'Алгоритм'","Wikipedia: 'Алгоритъм'","Wikipedia: 'Альгарытм'","Wikipedia: 'Алґорітм'","Wikipedia: 'אלגאריטם'","Wikipedia: 'אלגוריתם'","Wikipedia: 'الجوريتم'","Wikipedia: 'الخوارزم'","Wikipedia: 'الخوارزمي'","Wikipedia: 'الگورتھم'","Wikipedia: 'الگوریتم'","Wikipedia: 'خوارزمية'","Wikipedia: 'अल्गोरिदम'","Wikipedia: 'अल्गोरिद्म'","Wikipedia: 'অ্যালগরিদম'","Wikipedia: 'অ্যালগোরিদম'","Wikipedia: 'படிமுறைத்_தீர்வு'","Wikipedia: 'അൽഗൊരിതം'","Wikipedia: 'ඇල්ගොරිතම'","Wikipedia: 'ขั้นตอนวิธี'","Wikipedia: 'ຂັ້ນຕອນວິທີ'","Wikipedia: 'အယ်လ်ဂေါ်ရစ်သမ်'","Wikipedia: 'ალგორითმი'","Wikipedia: 'アルゴリズム'","Wikipedia: '演算法'","Wikipedia: '算法'","Wikipedia: '알고리즘'","Wikipedia: Algorithm","Wikipedia: Algorithm Representation","Wikipedia: Algorithms","Wikipedia: Algorithmus","Wikipedia: Algorithmus Wortgeschichte","Wikipedia: Algoritme","Wikipedia: Algoritmo","Wikipedia: algorithm word story","Wikipedia: algorithms","Wikipedia: algoritme","Wikipedia: algoritmo di storia parola","Wikipedia: l'histoire de mot algorithme","Wikipedia:Algorithms","Wikipedia:Algoritmo","Wikipedia:アルゴリズム","Wikipedian artikkeli algoritmeista","Wikipedian kuvaus algoritmeista","Wikipediaではこう","Wikipedia日本語版 - アルゴリズム","Wikipedia（アルゴリズム）","Wikipédia artigo Algoritmo","Wikipédia artigo Algoritmos","Wikipédia artigo Algorítmo","Wikipédia: Verbete Algoritmo","[0.1] http://en.wikipedia.org/wiki/Algorithms","[1] Algorithm","[22] Algorithms (additional)","[37] Algorithm","[6] Algorithm","[7] Algorithm","[COLOR=window****]algorithms[/COLOR]","[FONT='Arial','sans-serif']الخوارزمية[/FONT]","[algorithmic","[维基百科] 算法","a Wikipedia article on algorithms","a algoritmo","a set of rules that precisely define a","a.2","ai aq iqneba yvelaferi algoritmze. sul boloshi naxe","al – GO – rhythm","al-gorithm","algartam","alghorithum","algo-","algorimtutveckling","algorismes","algorismo","algorisse","algoristisk","algorit","algorit mos","algoritama","algoritem","algorithimi","algorithimic","algorithm - Wikipedia, the free encyclopedia","algorithm and","algorithm chart","algorithm f","algorithm i","algorithm is","algorithm simple english wikipedia the free encyclopedia","algorithm t","algorithm wiki","algorithm wikipedia the encyclopedia","algorithm wikipedia the free encyclopedia","algorithm without using wikipedia","algorithm'","algorithm,","algorithm, click this shit to learn more about","algorithm, that was done in collaboration with","algorithm-based","algorithm:","algorithmLink: http://en.wikipedia.org/wiki/Algorithm","algorithm[wikipedia]","algorithma","algorithme e","algorithme,","algorithmes d","algorithmes d'ordinateur","algorithmes informatiques","algorithmi","algorithmic","algorithmic computation,","algorithmic pagtutuos,","algorithmic problem","algorithmical","algorithmie","algorithmique","algorithmique dans Wikipédia.","algorithmique,","algorithmiques","algorithmisch","algorithmische","algorithmischen","algorithmischen Berechnungen,","algorithmischer","algorithmisches","algorithmisches Spiel","algorithmo","algorithmos","algorithms *","algorithms a","algorithms t","algorithms.","algorithms;","algorithmsLink: http://en.wikipedia.org/wiki/Algorithm","algorithmum","algorithmus","algoritimo","algoritimos","algoritmO.","algoritma dan pemrograman","algoritma komputasi,","algoritma page rank","algoritma spanning tree","algoritma wikipedia bahasa indonesia ensiklopedia bebas","algoritma-nya","algoritmadan","algoritmadır","algoritmai","algoritmais","algoritmalar","algoritmalarÄ±","algoritmaları","algoritmaların","algoritmalarından","algoritmalarının","algoritmami","algoritmams","algoritması","algoritmasıdır","algoritmasının","algoritmayı","algoritme in Wikipedia Nederland zoeken","algoritme.","algoritmech","algoritmeilla","algoritmeissä","algoritmejä","algoritmelor","algoritmem","algoritmene","algoritmers","algoritmes","algoritmeteori","algoritmi c","algoritmi!","algoritmi,","algoritmia","algoritmiaiheisista","algoritmica","algoritmicamente","algoritmici","algoritmicky","algoritmických","algoritmico","algoritmid","algoritmiek","algoritmii","algoritmike","algoritmikus","algoritmil","algoritmiliselt","algoritmilla","algoritmima","algoritmin","algoritminen","algoritmipari","algoritmisch","algoritmische","algoritmische compositie","algoritmiseen","algoritmisen","algoritmisesti","algoritmiska","algoritmit","algoritmizate","algoritmizálható","algoritmiškai","algoritmo de indexação","algoritmo de matar","algoritmo matem&#225;tico","algoritmo matematico","algoritmo matemático","algoritmo,","algoritmoa","algoritmoak","algoritmoaren","algoritmoch","algoritmolgoritmo","algoritmom","algoritmon","algoritmon kiu, en nur tri paŝoj, ĝi permesas","algoritmos *","algoritmos de la computadora","algoritmos do computador","algoritmos matemáticos","algoritmos,","algoritmos做computador","algoritmov","algoritmui","algoritmul","algoritmus)","algoritmusa","algoritmuscsalád","algoritmuselméleti","algoritmusok","algoritmusok/problémamegoldás/gráfreprezentáció","algoritmusokat","algoritmusokkal","algoritmusoknak","algoritmusokon","algoritmusokra","algoritmusról","algoritmust","algoritmutveckling","algoritmy","algoritmų","algorritmo","algorthm","algortimo","algorythmn","algorythmus. wer hats erfunden?","algorythum","algorytm dzielenia wielomianu","algorytm wyznaczania przybliżonej wartości","algorytmach","algorytmami","algorytmem","algorytmicznego","algorytmicznej","algorytmie","algorytmizacji","algorytmom","algorytmu)","algorytmy","algorÃtmico","algorítimica","algorítimico","algorítimo","algorítimos","algorítmic","algorítmica","algorítmicamente","algorítmicos","algorítmo","algorítmos","algorîtma","alguritmu","algurìttimu","algóritminn","algóriþma","algôhitme","algôhitmen","algôhitmes","alogaritma","alogithm","alogorithm","alogrithm","alogrithme","alopexalgoritme","alqoritm","alqoritmi","an algori","an effective method expressed as a finite list","an effective method to reach a particular result","analyse d'algorithmes","and if you still are scratching your head","aradigma probabilístic i heurístic","argoritmo","around the definition of quot algorithm quot see","article Algorithmique","article Algorithms","article about algorithms","artículo de Wikipedia Algoritmia","artículo de Wikipedia Algoritmo","artículo de Wikipedia Algoritmos","arz:الجوريتم","ask programming.reddit: Is writing code out still","automatische procedure","az:Alqoritm","be-x-old:Альгарытм","buraya gözatabilirsiniz.","c algorithm","c thuật toá","calcul algorithmique arbitraires,","ceci au début","cliccare su questo link a Wikipedia","click me for a definition of an algorithm","complexité de l'algorithme","computational algorithm","computer algorithim","computer algorithims","computer program algorithm","computeralgoritmes","con algoritmos","concepto de algoritmo","contenu complet","continue reading http://en.wikipedia.org/wiki/Algorithm","cs.wikipedia.org/wiki/Algoritmus","các giải thuật","các thuật toán","cálculo algorítmico","cálculo algorítmico arbitraria,","d algoritm","d'ordinateur d'algorithmes de","d'ordinateur de los algorithmes de los","d'ordinateur dei algorithmes dei","d'ordinateur dos algorithmes dos","da.wikipedia.org/wiki/Algoritme","de.wikipedia.org/wik...lgorithmen_im_Alltag","de.wikipedia.org/wiki/Algorithmen","de.wikipedia.org/wiki/Algorithmus","definition of algorithm","definição de um algoritimo","descripción de alto nivel","description des étapes logiques permettant la résolution d","design and analysis of algorithms","detay için buraya tıklayın","deterministischen Algorithmus","develop algorithms","diseño de algoritmos","download algoritma","download siniii","déf. de algorithmique sur wikipédia","e Algorithmu","e algorit","e algorith","e algorithm","e algorithm ch","e algorithmiqu","e algorithmique","e algoritme","e algoritmo","echad un vistazo a la wikipedia","echenvorschrift v","ecursivitat","edit ] Sorting example http://en.wikipedia.org/wiki","educció","efektyvia procedūra","eikniritum.","el.wikipedia: αλγόριθμος","en.wikipedia.org/.../Algorithm","en.wikipedia.org/...Algorithm","en.wikipedia.org/Algorithm","en.wikipedia.org/Algorithms","en.wikipedia.org/wiki/Algorithm","en.wikipedia.org/wiki/Algorithm#By_design_paradigm","en.wikipedia.org/wiki/Algorithms","en.wikipedia: algorithm","en:Algorithm","en:Algorithms","encoding algorithm","entrée Wikipedia à ce sujet","er implementació","er paradigma o estratègia de resolució","erca i enumeració","es.wikipedia.org/wiki/Algoritmo","es.wikipedia.org/wiki/algoritmo","estrategias algorítmicas","eterminístics o no-determinístics","etymology of algorithm","even more simply","f algorithm","f algorithms","formale Handlungsvorschrift zur Lösung eines Problems oder einer","formally a type of effective method in which","formulations algorithmiques","fr.wikipedia.org/...Algorithmique","fr.wikipedia.org/wiki/Algorithmique","g algorithm","g algorytmiczneg","general scientific usage","giải thuật","giải-thuật","gorithm fo","gorithme d'","gorithmes d","gorithms","goritma h","he Parsons","he algorit","histoire mot http://de.wikipedia.org/wiki/Algorithmus","hr.wikipedia.org/Algoritam","http://af.wikipedia.org/wiki/Algori","http://af.wikipedia.org/wiki/Algoritme","http://af.wikipedia.org/wiki/Algoritmes","http://an.wikipedia.org/wiki/Algori","http://an.wikipedia.org/wiki/Algorismo","http://ar.wikipedia.org/wiki/خوارزمية","http://arz.wikipedia.org/wiki/الجوريتم","http://ast.wikipedia.org/wiki/Algoritmu","http://az.wikipedia.org/wiki/Alqori","http://az.wikipedia.org/wiki/Alqoritm","http://be-x-old.wikipedia.org/wiki/Альгарытм","http://be.wikipedia.org/wiki/Алгарытм","http://bg.wikipedia.org/wiki/Алгоритъм","http://bn.wikipedia.org/wiki/অ্যালগরিদম","http://bs.wikipedia.org/wiki/Algori","http://bs.wikipedia.org/wiki/Algoritam","http://ca.wikipedia.org/wiki/Algorisme","http://ca.wikipedia.org/wiki/Algoritme","http://cs.wikipedia.org/wiki/Algori","http://cs.wikipedia.org/wiki/Algoritmus","http://cs.wikipedia.org/wiki/Algoritmus...","http://da.wikipedia.org/wiki/Algori","http://da.wikipedia.org/wiki/Algoritme","http://da.wikipedia.org/wiki/Algoritme,","http://de.wikipedia....iki/Algorithmus","http://de.wikipedia.org/ wiki/ Algorithmus","http://de.wikipedia.org/wiki/A.....lgorithmus","http://de.wikipedia.org/wiki/Al gorithmen","http://de.wikipedia.org/wiki/Al gorithmus","http://de.wikipedia.org/wiki/Al gorithmus#Algorithmen_im_Alltag","http://de.wikipedia.org/wiki/Algorithmen","http://de.wikipedia.org/wiki/Algorithmus # word story","http://de.wikipedia.org/wiki/Algorithmus#Determinismus","http://de.wikipedia.org/wiki/Algorithmus#Finitheit","http://de.wikipedia.org/wiki/Algorithmus#Geschichte","http://de.wikipedia.org/wiki/Algorithmus#InformatikundMathematik","http://de.wikipedia.org/wiki/Algorithmus#Wortgeschichte","http://de.wikipedia.org/wiki/Algorithmus...orithmusbegriff","http://de.wikipedia.org/wiki/algorithmus.","http://el.wikipedia.org/wiki/Αλγόριθμος","http://en.wikiped...org/wiki/Algorithm","http://en.wikipedia....wiki/Algorithms","http://en.wikipedia.org/ wiki/ Algorithm","http://en.wikipedia.org/wiki/Algorit...2algorithm.22q","http://en.wikipedia.org/wiki/Algorithm","http://en.wikipedia.org/wiki/Algorithm http://en","http://en.wikipedia.org/wiki/Algorithm http://www","http://en.wikipedia.org/wiki/Algorithm# ... _empirical","http://en.wikipedia.org/wiki/Algorithm#Algorithm_analysis","http://en.wikipedia.org/wiki/Algorithm#Algorithmic_analysis","http://en.wikipedia.org/wiki/Algorithm#By_complexity","http://en.wikipedia.org/wiki/Algorithm#Classes","http://en.wikipedia.org/wiki/Algorithm#Classification_by_design_paradigm","http://en.wikipedia.org/wiki/Algorithm#Computer_algorithms","http://en.wikipedia.org/wiki/Algorithm#C…","http://en.wikipedia.org/wiki/Algorithm#E...","http://en.wikipedia.org/wiki/Algorithm#Etymology","http://en.wikipedia.org/wiki/Algorithm#Etymology_of_the_word_Algorithm","http://en.wikipedia.org/wiki/Algorithm#Evolution_as_an_algorithmic_process","http://en.wikipedia.org/wiki/Algorithm#Example","http://en.wikipedia.org/wiki/Algorithm#Expressing_algorithms","http://en.wikipedia.org/wiki/Algorithm#External_links","http://en.wikipedia.org/wiki/Algorithm#E…","http://en.wikipedia.org/wiki/Algorithm#Formalization","http://en.wikipedia.org/wiki/Algorithm#History","http://en.wikipedia.org/wiki/Algorithm#History:_Development_of_the_notion_of_","http://en.wikipedia.org/wiki/Algorithm#H…","http://en.wikipedia.org/wiki/Algorithm#Legal_issues","http://en.wikipedia.org/wiki/Algorithm#Origin_of_the_word","http://en.wikipedia.org/wiki/Algorithm#Termination","http://en.wikipedia.org/wiki/Algorithm#T…","http://en.wikipedia.org/wiki/Algorithm#Why_algorithms_are_necessary:_an_","http://en.wikipedia.org/wiki/Algorithm#Why_algorithms_are_necessary:_an_informal_definition","http://en.wikipedia.org/wiki/Algorithm#W…","http://en.wikipedia.org/wiki/Algorithm)","http://en.wikipedia.org/wiki/Algorithm...","http://en.wikipedia.org/wiki/Algorithm>, i.e","http://en.wikipedia.org/wiki/Algorithms","http://en.wikipedia.org/wiki/Algorithms#Etymology","http://en.wikipedia.org/wiki/Algorithms#History","http://en.wikipedia.org/wiki/Algorithms#Legal_issues","http://en.wikipedia.org/wiki/Algorithmを","http://en.wikipedia.org/wiki/Algorithm을","http://en.wikipedia.org/wiki/A​lgorithm","http://en.wikipedia.org/wiki/Na%C3%AFve_algorithm","http://en.wikipedia.org/wiki/Naïve_algo","http://en.wikipedia.org/wiki/Naïve_algorithm","http://en.wikipedia.org/wiki/Sequential_algorithm","http://en.wikipedia.org/wi​ki/Algorithm","http://en.wikipedia.org/wi​ki/Algorithm#Termination","http://eo.wikipedia.org/wiki/Algori","http://eo.wikipedia.org/wiki/Algoritmo","http://es.wikipedia.org/wiki/Algori","http://es.wikipedia.org/wiki/Algoritm","http://es.wikipedia.org/wiki/Algoritmia","http://es.wikipedia.org/wiki/Algoritmo","http://es.wikipedia.org/wiki/Algoritmo#A…","http://es.wikipedia.org/wiki/Algoritmo#Caracter.C3","http://es.wikipedia.org/wiki/Algoritmo#Definici.C3","http://es.wikipedia.org/wiki/Algoritmo#Descripci.C3","http://es.wikipedia.org/wiki/Algoritmo#Diagrama_de_flujo","http://es.wikipedia.org/wiki/Algoritmo#D…","http://es.wikipedia.org/wiki/Algoritmo#Enlaces_externos","http://es.wikipedia.org/wiki/Algoritmo#E…","http://es.wikipedia.org/wiki/Algoritmo#Historia","http://es.wikipedia.org/wiki/Algoritmo#H…","http://es.wikipedia.org/wiki/Algoritmo#Pseudoc.C3","http://es.wikipedia.org/wiki/Algoritmo#T.C3","http://es.wikipedia.org/wiki/Algoritmo#Tipos_de_algoritmos_seg.C3","http://es.wikipedia.org/wiki/Algoritmo#T…","http://es.wikipedia.org/wiki/Algoritmo#definiciones_de_algoritmo","http://es.wikipedia.org/wiki/Algoritmos","http://es.wikipedia.org/wiki/Algoritmos#Ejemplo_de_algoritmo","http://es.wikipedia.org/wiki/algoritmo","http://et.wikipedia.org/wiki/Algori","http://et.wikipedia.org/wiki/Algoritm","http://fi.wikipedia.org/wiki/Algori","http://fi.wikipedia.org/wiki/Algoritmi","http://fr.wikipedia....wiki/Algorithme","http://fr.wikipedia.org/wiki/Algori","http://fr.wikipedia.org/wiki/Algorit..._algorithmique","http://fr.wikipedia.org/wiki/Algorithme#Complexit.C3","http://fr.wikipedia.org/wiki/Algorithmes","http://fr.wikipedia.org/wiki/Algorithmi ... quit.C3","http://fr.wikipedia.org/wiki/Algorithmique","http://fr.wikipedia.org/wiki/Algorithmique#D.C3","http://fr.wikipedia.org/wiki/Algorithmiq…","http://fr.wikipedia.org/wi​ki/Algorithmique","http://gl.wikipedia.org/wiki/Algori","http://gl.wikipedia.org/wiki/Algoritmo","http://he.wikipedia....%99%D7%AA%D7%9D","http://hr.wikipedia.org/wiki/Algori","http://hr.wikipedia.org/wiki/Algoritam","http://hu.wikipedia.org/wiki/Algoritmus","http://id.wikipedia.org/wiki/Algori","http://id.wikipedia.org/wiki/Algoritma","http://io.wikipedia.org/wiki/Algori","http://io.wikipedia.org/wiki/Algoritmo","http://is.wikipedia.org/wiki/Alg%C3%B3ri","http://is.wikipedia.org/wiki/Reikni","http://it.wikipedia.org/wiki/Algorit...cio_Matematico","http://it.wikipedia.org/wiki/Algorit...istemi_lineari","http://it.wikipedia.org/wiki/Algoritmi","http://it.wikipedia.org/wiki/Algoritmica","http://it.wikipedia.org/wiki/Algoritmo","http://it.wikipedia.org/wiki/Algoritmo#Definizione","http://it.wikipedia.org/wiki/Algoritmo#Modelli_formali","http://ja.wikipedia.org/wiki/アルゴリズム","http://ja.wikipedia.org/wiki/アルゴリズム#.E6.B3","http://kaa.wikipedia.org/wiki/Algor","http://kaa.wikipedia.org/wiki/Algoritm","http://ko.wikipedia.org/wiki/Algorithm","http://ko.wikipedia.org/wiki/알고리즘","http://ku.wikipedia.org/wiki/Algor%","http://ku.wikipedia.org/wiki/Algor%C3%AEtma","http://lt.wikipedia.org/wiki/Algoritmas","http://lv.wikipedia.org/wiki/Algori","http://lv.wikipedia.org/wiki/Algoritms","http://mk.wikipedia.org/wiki/%D0%90%...82","http://ml.wikipedia.org/wiki/Algorithm","http://ms.wikipedia.org/wiki/Algori","http://ms.wikipedia.org/wiki/Algoritma","http://nl.wikipedia.org/wiki/Algori","http://nl.wikipedia.org/wiki/Algoritme","http://nl.wikipedia.org/wiki/Algoritme#Formele_algoritmen","http://nl.wikipedia.org/wiki/Algoritmiek","http://nn.wikipedia.org/wiki/Algori","http://nn.wikipedia.org/wiki/Algoritme","http://no.wikipedia.org/wiki/Algori","http://no.wikipedia.org/wiki/Algoritme","http://pl.wikipedia.org/wiki/Algorytm","http://pl.wikipedia.org/wiki/Algorytm#Algorytmy_komputerowe","http://pl.wikipedia.org/wiki/Algorytm#Definicja_klasyczna","http://pl.wikipedia.org/wiki/Algorytm#Implementacja","http://pl.wikipedia.org/wiki/Algorytmy","http://pt.wikipedia....wiki/Algoritmos","http://pt.wikipedia.org/wiki/Algor%C3%ADtmo","http://pt.wikipedia.org/wiki/Algori","http://pt.wikipedia.org/wiki/Algoritmo","http://pt.wikipedia.org/wiki/Algoritmo#An.C3","http://pt.wikipedia.org/wiki/Algoritmos","http://ro.wikipedia.org/wiki/Algori","http://ro.wikipedia.org/wiki/Algoritm","http://ru.wikipedia....%B8%D1%82%D0%BC","http://ru.wikipedia.org/wiki/Алгоритм","http://ru.wikipedia.org/wiki/Алгоритмиза...","http://ru.wikipedia.org/wiki/Алгоритмы","http://ru.wikipedia.org/wiki/алгоритм","http://sh.wikipedia.org/wiki/Algori","http://sh.wikipedia.org/wiki/Algoritam","http://simple.wikipe.../wiki/Algorithm","http://simple.wikipedia.org/wiki/Algorithm","http://simple.wikipedia.org/wiki/Algorithm#Putting_algorithms_together","http://sk.wikipedia....wiki/Algoritmus","http://sk.wikipedia.org/wiki/Algoritmus","http://sk.wikipedia.org/wiki/algoritmus","http://sl.wikipedia.org/wiki/Algori","http://sq.wikipedia.org/wiki/Algori","http://sr.wikipedia.org/wiki/Алгоритам","http://su.wikipedia.org/wiki/Algori","http://su.wikipedia.org/wiki/Algoritma","http://sv.wikipedia.org/wiki/Algori","http://sv.wikipedia.org/wiki/Algoritm","http://th.wikipedia.org/wiki/Algorithm","http://tl.wikipedia.org/wiki/Algori","http://tr.wikipedia.org/wiki/Algori","http://tr.wikipedia.org/wiki/Algoritma","http://tr.wikipedia.org/wi​ki/Algoritma","http://ur.wikipedia.org/wiki/Algorithm","http://wa.wikipedia.org/wiki/Algori","http://wa.wikipedia.org/wiki/Algorisse","http://wa.wikipedia.org/wiki/Algorite","http://war.wikipedia.org/wiki/Algor","http://www.de.wikipedia.org/wiki/Algorithmus","http://www.monografias.com/trabajos15/algoritmos/algoritmos.shtml","http://zh.wikipedia.org/wiki/%E7%AE","http://zh.wikipedia.org/wiki/算法","http://zh.wikipedia.org/zh-tw/算法","hu.wikipedia.org/wiki/Algoritmus","i algorytmów","id.wikipedia.org/wiki/Algoritma","id.wikipedia.org/wiki/Alg…","inefficient algorithm","io:Algoritmo","is:Reiknirit","it specia","it:Algoritmo","ivideix i venceràs","ja:アルゴリズム","kk:Алгоритм","klik disini kawan !","kompiuteriniams algoritmams","komprimeringsalgoritmer","l algorit","l algorithm","l mètode voraç","l'algorithm","l'algorithmique","l'algoritme","l'article de Wikipédia Algorithme","l'article de Wikipédia Algorithmique","la catalogazione degli algoritmi","la:Algorithmus","las matemáticas y a la programación","le language algorithmique","les algorithmes","lgorithm","lgorithm f","lgorithm t","lgorithm)","lgorithme","lgorithme a","lgorithmen f","lgorithmically","lgorithms","lgorithms t","lgorithms,","lgorithmus","lgoritm","lgoritm s","lgoritma","lgoritme","lgoritmi","lgoritmi.","lgoritmo","lgoritmo,","lgoritmos","lgoritmus","lgoritmy","lo:ຂັ້ນຕອນວິທີ","los algoritmos","m algoritmo","magic wand of algorithm","matematisk algoritm","mathematical algorithm","mathematical calculation","mathematical models of the concept of algorithm","mathematically driven, algorithms","mhr:Алгоритм","mk:Алгоритам","mn:Алгоритм","moteur heuristique","my:အယ်လ်ဂေါ်ရစ်သမ်","műveletsort","n Algorithmus","n algorith","n algoritm","n algoritmo","n algoritmos","n sèrie, en paral·lel o distribuït","naiivne","naivus","name of a Persian mathematician","naïve algorithm","naīve implementation","na茂ve","nel caso medio","nl.wikipedia.org/wiki/Algoritme","notion of algorithm","noun algorithm","o algoritm","o solve pro","o the way","oc:Algoritme","orithm fo","os algoritmos","parler de cela","paskaityti galima","pensiero algoritmico","pl.wikipedia.org/wiki/Algorytm","pl.wikipedia.org/wiki/Algorytm#Definicja_klasyczna","planear un algoritmo","pnb:الگورتھم","português estruturado","procedure Del Calcolatore","procedure del calcolatore","procedures.","pt.wikipedia.org/Algoritmos","pt.wikipedia.org/wiki/Algoritmo...","pásate por acá","quest'Algoritmo","quicksort-sorteeralgoritme","r Algorithme","reiknirit","reikniritið","reikniritum","rogramació dinàmica","rogramació lineal","rue:Алґорітм","s algorithmes","s algoritmos","scn:Alguritmu","secure 2 stage algorithm","self-improving algorithm","sequential (or serial) algorithm","seqüències","seqüência de instruções","sh:Algoritam","simplistic algorithm","sitio donde ubicara la informacion pertinente al tema","softwarealgoritmes","someone learns about the algorithm","stran Wikipedie za 'Algoritem'","su algorismo","sumarized","t algorith","te:అల్గారిథం","the algorit","the one I found","the origin of the word algorithm.","things that we can explain in detail","thuật giải","thuật toán!","thu�º*t toán","title=Algoritmo>algoritmo","tr.wikipedia.org/wiki/Algoritma","tr:Algoritma","tt:Алгоритм","ttp://fi.wikipedia.org/wiki/Algoritmi","ttp://fr.wikipedia.org/wiki/Algorithmique","ttp://tr.wikipedia.org/wiki/Algoritma","typically applied in a physical security context and","uk:Алгоритм","un conjunto preescrito de instrucciones o reglas bien","un système algorithmique","understanding an algorithm","uses Traffic:Content:Time), whatever is at the","uz:Algoritm","various algorithms","versleutelingsalgoritme","voir la définition d'algorithme dans Wikipedia","w:Algorithms","w:Algorithmus","w:serial algorithm","w:Αλγόριθμος","w:алгоритм","wa:Algorisse","well formed procedures","wiki algor ithm","wiki-algoritme","wiki: Algorithm","wikipedhiaで「アルゴリズム」を調べると","wikipedia 'algorithmus'","wikipedia-Algoritma nedir?","wikipedia: algorytm","wikipedia:アルゴリズム","wikipedia「アルゴリズム」","wikipl:Algorytm","wiskundig algoritme","www.es.wikipedia.org/wiki/algoritmo","y algoritmo","yago-res:Sequential algorithm","zalgorytmizowany","zh-yue:演算法","| algorithm","|Алгоритмы","¡Algoritmos!","«Алгоритм»","«алгоритм»","» Algorithmus","» Definizione di algoritmo (http://it.wikipedia.org/wiki","¿ Qué es un Algoritmo ?","Ã—Â Ã—ÂœÃ—Â'Ã—Â•Ã","ÇáÎæÇÑÒãíÉ","× ×œ×'×•×¨×™×ª×","à ëã îð è òì è","í algoritm","última etapa de","ý algoritmus","źródła internetowe","Αλγ?ριθμοι","Αλγόριθμοι","Αλγόριθμος","Αλγόριθμος - Βικιπαίδεια","Αλγόριθμος – Βικιπαίδεια","Αλγόριθμου","Περισσότερα για τους αλγορίθμους","αλγóριθμος","αλγορίθµους","αλγορίθμου","αλγορίθμους","αλγορίκμουσ","αλγοριθμικ","αλγοριθμικά","αλγοριθμική σκέψη","αλγόριθμοι","αλγόριθμους","αλγόρικμο","βασικες ιδιοτητες ενος Αλγοριθμου;","δες περισσότερα","ι αλγόριθμ","λγόριθμοι","Алгарытм — Вікіпедыя","Алгоритам - Википедија","Алгоритм - В соответствии с проектом парадигмы","Алгоритм - Википедиа","Алгоритм в Википедии","Алгоритм в википедии","Алгоритм — Википедия","Алгоритм — Вікіпедія","Алгоритми","Алгоритмов","Алгоритмы Википедия","Алгоритъм","Алгоритъм — Уикипедия","Алгоритъмът","Альгарытм","Альгарытм — Вікіпэдыя","Алґорітм","Алґорітм — Вікіпедія","В честь араба Аль-Хорезми","Википедии статью Алгоритм","Википедии статью Алгоритмы","История алгоритмов","Какими свойствами должны обладать алгоритмы","Криптографски алгоритми. Формални дефиниции. Класификация. 3.","Неиссякаемый источник матчасти","Описание понятия алгоритм в википедии","Определение аргоритма","Определения алгоритма","Понятие алгоритма","Понятие алгоритма необязательно относится к компьютерным программам, так","Само слово «алгоритм» происходит от имени учёного Абу","Свойства алгоритма","Статья про алгоритм из Википедии","ТУТ НАУЧНО ОБЪЯСНЯЮТ","Что такое алгоритм","Що таке алгоритм?","алгарытм","алгарытмаў","алгарытму","алгорит","алгоритам","алгоритама","алгоритамски","алгоритм - это точный набор инструкций","алгоритмам","алгоритмами","алгоритмах","алгоритми","алгоритмизации","алгоритмизировать","алгоритмизируемым","алгоритмистом","алгоритмичен","алгоритмических","алгоритмических вычислений,","алгоритмической","алгоритмичната","алгоритмични","алгоритмов!","алгоритмом , то блок удлиняется каким-либо способом. Как","алгоритмы,","алгоритмыг","алгоритмів","алгоритъм","алгоритъма","алгоритъмът","алгорифм","алгорифме","альгарытм","лгоритм","лгоритм р","лгоритмами.","перечень определений","последовательность действий,","последовательным алгоритмам","что такое алгоритм?","это точный набор инструкций","эффетивными и не эффективными","אַלגערידאַם","אלגאריטם","אלגאריטם – װיקיפּעדיע","אלגוריטם","אלגוריטמים","אלגוריתם [ויקיפדיה]","אלגוריתם בויקיפדיה","אלגוריתם – ויקיפדיה","אלגוריתמיות","אלגוריתמיים","אלגוריתמיקה","אלוגריתמים","האלגוריתם","המילה אלגוריתם מקורה בשמו של מתמטיקאי פרסי","התהליך המכני","ויקיפדיה - 'אלגוריתם'","חמדן אלגוריתמים חמדניים","לך תקרא בויקיפדיה","מושג האלגוריתם","الجوريتم","الجوريتم - ويكيبيديا","الجوريزم","الخوارزم","الخوارزمي - Wikipedia","الخوارزميات","الخوارزميات،","الخوارزميّات","المقالة؟؟","الڬوريتهم","الڬوريتهمس","الگورتھم - Wikipedia","الگوريتم","الگوريتمهايي","الگوریتم - ویکیپدیا","الگوریتم - ویکیپدیا - Wikipedia","الگوریتم های","الگوریتم های تصادفی","الگوریتم*های","الگوریتم.هایی","الگوریتمها","الگوریتمهای","الگوریتمهای تصادفی","الگوریتمهای تصادفی - ویکیپدیا","الگوریتمهایش","الگوریتمهایی","الگوریتمیک","تﺎﯾﻣزراوﺧ","تﺎﯾﻣزراوﺧﻟا","تﺎﯾﻣزراوﺧﻟاو","جو کہ مسلم ساینسدان الخوارزمی کے نام سے","خروزمياتها","خوارزمية","خوارزمية (algorithm)","خوارزمية - ويكيبيديا، الموسوعة الحرة","خوارزمی کیست و الگوریتم چیست؟","خورزميات","رویه خوش تعریف","ط§ظ„ع¯ظˆط±غŒطھظ…غŒ","ماهي الخوارزمية","نفس المقال بالعربي","نمایش نوشتاری","والإجراءات","والخوارزميّات","يكي الخوارزمية","یٕشیضٍِٛا","۱ خصوصیات یک الگوریتم","۱-خصوصیات یک الگوریتم","۲ ریشه واژهٔ الگوریتم","۲ مفهوم الگوریتم","۲ منشاء واژهٔ الگوریتم","۳ تحلیل الگوریتم","۳ نقش الگوریتمها در علوم رایانه","۴ جنبه حقوقی","۴ مفهوم الگوریتم","۵ تحلیل الگوریتم","۵ تحلیل خوارزمی","۶ جنبه حقوقی","अल्गो रिथ्म्स","अल्गोरिथम","अल्गोरिदम","अल्गोरिदम - विकिपीडिया","अल्गोरिद्म","अल्गोरिद्म - विकिपीडिया","एल्गोरिथम","एल्गोरिथ्म - प्रतिमान द्वारा डिजाइन","অ্যালগরিদম","অ্যালগরিদম - উইকিপিডিয়া","আলগরিদম তত্বের","நெறிமுறைகள் தொடர்ந்து மேம்படுத்தப்பட்டது.கூகிளின்","படிமுறைகள்","படிமுறைத் தீர்வு","అల్గారిథం","అల్గారిథం - వికీపీడియా","അൽഗൊരിതം","അൽഗൊരിതങ്ങളിലെ","അൽഗൊരിതങ്ങൾ","ඇල්ගොරිතම - Wikipedia","ඇල්ගොරිතම - විකිප","ඇල්ගොරිතම - විකිපීඩියා, නිදහස් විශ්වකෝෂය","การ คำนวณ algorithmic พล,","การนำขั้นตอนวิธีไปใช้ ไม่จำกัดเฉพาะการเขียนโปรแกรมคอมพิวเตอร์ แต่สามารถใช้กับ ปัญหาอื่น","ขั้นตอนวิธี","ขั้นตอนวิธี - วิกิพีเดีย","ขั้นตอนวิธี - วิกิพีเดี•","นิพนธ์ของ","ลกอริทึม","สื่อประกอบการเรียนรู้ที่ 2 อัลกอริทึม","อัลกอริทึม","อัลกอริทึม - วิกิพีเดีย","อัลกอริธึม","အယ်လ်ဂေါ်ရစ်သမ်","ალგორითმების","ალგორითმი - ვიკიპედია","ალგორითმით","ალგორითმის","ალგორითმს","“(Formalization of algorithms) Termination” section","“Algorithm - Wikipedia, the free encyclopedia”, en.wikipedia.org","“Algorithmus”","“Algorytmy” na pl.wikipedia.org","“Expressing algorithms” section","“algorithm","“algorithms”","„algoritmust”","「アルゴリズム」","「アルゴリズム」についてWikipediaで調査","「アルゴリズム」をWikipediaで調べる","「アルゴリズム」をWikiで調べる","『Algorithmアルゴリズム』","『アルゴリズム』の解説","そのため、多くの「検索エンジン」が、表示順を決定するアルゴリズムを非公開にし、その性能を競っています。","とアルゴリズム","アリゴリズム","アルコリズム","アルゴリズム (algorithm)","アルゴリズム - Wikipedia","アルゴリズム - Wikipedia -","アルゴリズム - Wikipediaja.wikipedia.orgアルゴリズム（英: Algorithm","アルゴリズム - wikipedia","アルゴリズム Algorithm","アルゴリズム – Wikipedia","アルゴリズム からWikipediaを検索","アルゴリズム(解を求めるための方法)","アルゴリズム-パラダイムで設計","アルゴリズム【Wikipedia】","アルゴリズムのWikipedia","アルゴリズムの定式化","アルゴリズムの定義","アルゴリズムの計算、","アルゴリズムの項","アルゴリズムはより良く変化するためのプログラム","アルゴリズム（ウィキペディアより）","ゴリズム","参照・・・・アルゴリズムとは？","大雑把な定義","技术指信息技术部门。每个主要投资银行有内部软件的可观的数量，由为技术支持也负责的技术队创造了。当更多的出售和交易的桌子正在使用电子贸易，技术在最后几年里更加变化了。","最佳的时候記住某事的計算機算法","最佳的時候記住某事的計算機算法","検索エンジンのアルゴリズム","決定的な手続き","演算法","演算法(algorithm)","演算法- 維基百科,自由嘅百科全書","演算法- 維基百科，自由嘅百科全書","演算法- 維基百科，自由的百科全書","演算法Algorithm (Wikipedia)","演算法對不同","演算法（algorithms）","演算法（algorithm）","演算法，Algorithm","算法- 维基百科，自由的百科全书","算法求解数学框架下表出的问题；","算法的五个特性","算法的定义","算法的計算，","算法计算，","維基百科的文章“ 演算法”","維基百科的文章“ 算法”","維基百科～Algorithm","维基百科--算法","维基百科的文章“ 演算法”","维基百科的文章“ 算法”","計算機算法","速演算法，","適切な計算","순차 알고리즘","알고리듬","알고리즘 - 위키백과, 우리 모두의 백과사전","알고리즘 계산,","알고리즘 위키백과, 우리 모두의백과사전","알고리즘!","알고리즘(Algorithm)","알고리즘은","알고리즘을","연산방식","위키 피 디아 문서 Algorithm","위키 피 디아 문서 알고리듬","위키 피 디아 문서 알고리즘","컴퓨터 연산 방식","ﺔﯾﻣزراوﺧ","ｱﾙｺﾞﾘｽﾞﾑ","ｱﾙｺﾞﾘｽﾞﾑ-wikipedia","��š��Է�Á"],"name":"Algorithm","categories":["Algorithms","Articles containing Persian-language text","Articles including recorded pronunciations","Articles with DMOZ links","Articles with example pseudocode","Mathematical logic","Pages using duplicate arguments in template calls","Theoretical computer science","Use mdy dates from June 2013","Wikipedia articles with BNF identifiers","Wikipedia articles with GND identifiers","Wikipedia articles with LCCN identifiers"],"tag_line":"In mathematics and computer science, an algorithm (/ˈælɡərɪðəm/ AL-gə-ri-dhəm) is a self-contained step-by-step set of operations to be performed."}}
,{"_index":"throwtable","_type":"algorithm","_id":"maze-generation-algorithm","_score":0,"_source":{"description":"Maze generation algorithms are automated methods for the creation of mazes.\n\n","alt_names":["maze generation algorithms","-> Read the article about 'Maze generation algorithm'","...more on Wikipedia about Maze generation algorithm","Create a maze","DFS maze generation algorithm","Depth First - Recursive Backtracker","Depth First Algorithm","Depth-first search algorithm","Depth-first search algorithm of maze generation mit","Graph theory based methods","Maze Algorithmen zur Generierung von","Maze Generating Algorithems","Maze Generation","Maze Generation Alggorithma","Maze Generation Algorithm","Maze Generation Algorithm Wikipedia The Free Encyclopedia","Maze Generation Algorithms","Maze Generation algorithm","Maze Generation on Wikipedia","Maze algorithms รุ่น","Maze creation (Wiki)","Maze generation","Maze generation algorithm","Maze generation algorithm - Wikipedia :: The free encyclopedia","Maze generation algorithm - Wikipedia, the free ...","Maze generation algorithm - Wikipedia, the free encyclopedia","Maze generation algorithm Wikipedia the free encyclopedia","Maze generation algorithm – Wikipedia, the free encyclopedia","Maze generation algorithms","Maze поколения алгоритмов","More Maze Algorithms","More generic information","Non-cell-based algorithm","Prim's Algorithm for Maze Generation","Randomized Kruskal's algorithm","Randomized Prim's Algorithm","Randomized Prim's algorithm","Recursive Backtracker Algorithm","Recursive Division","Recursive Division Method","Recursive Subdivision","Recursive division","Recursive division method","See the Wikipedia article here.","Simple algorithms","Small-memory algorithm","These algorithms and more can be found here","Wiki : Maze generation","Wikipedia Maze Generation","Wikipedia article Maze generation","Wikipedia article Maze generation algorithm","Wikipedia article Maze generation algorithms","Wikipedia article on maze generation","Wikipedia entry for Maze generation algorithm","Wikipedia entry on maze generation","Wikipedia's article titled Maze generation algorithm.","Wikipedia: Maze Generation Algorithm","Wikipedia: Maze generation algorithm","a modified version of Kruskal's algorithm","adds significantly to articles","algorithmes de génération de Maze","algorithms for maze construction","algoritma generasi Maze","algoritmi di generazione Maze","algoritmi per generare labirinti","algoritmos de generación de Laberinto","algoritmos de geração Maze","bekende manier","binary tree maze","các thuật toán thế hệ Maze","den Prim Alogorithmus","depth-first maze generation algorithm","depth-first search algorithm","ein Labyrinth","en.wikipedia.org/...Maze_generation_algorithm","en.wikipedia.org/wiki/Maze_generation_algorit hm","en.wikipedia.org/wiki/Maze_generation_algorithm","generating a random maze","generation of a maze","generation of mazes","http://en.wikipedia.org/w...ation_algorithm","http://en.wikipedia.org/wiki/M..._algorithm","http://en.wikipedia.org/wiki/Maze generation algorithm","http://en.wikipedia.org/wiki/Maze_gener ... ion_method","http://en.wikipedia.org/wiki/Maze_genera","http://en.wikipedia.org/wiki/Maze_generation","http://en.wikipedia.org/wiki/Maze_generation_algor. . .","http://en.wikipedia.org/wiki/Maze_generation_algorithm","http://en.wikipedia.org/wiki/Maze_generation_algorithm#Depth-first_search","http://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_Kruskal","http://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_Kruskal.27s_algorithm","http://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_Prim.27s_al","http://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_Prim.27s_algorithm","http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker","http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method","http://en.wikipedia.org/wiki/Maze_generation_algorithm#Simple_algorithms","http://en.wikipedia.org/wiki/Maze_generation_algorithm)","http://en.wikipedia.org/wiki/Maze_genera…","kalituhan algorithm henerasyon","maze algorithms","maze generating","maze generating algorithm","maze generation","maze generation a path finding problem? If that","maze generation algorithm","maze generation on Wikipedia","maze-gen algorithm","nice pseudocode","python implementation in the maze generation article","random maze","random maze generation","random maze generator","random, algorithmically-generated labyrinths","randomized prims algorithm","randomly generated levels","recursive backtracker","recursive division","several good methods","standard depth-first-search algorithm","the Wikipedia entry on maze generation algorithms","wikipedia entry on maze generation algorithms","אלגוריתמים לייצור מבוכים","אלגוריתמים לייצור מבוכים – ויקיפדיה","ויקיפדיה - 'אלגוריתמים לייצור מבוכים'","「Maze Generation Algorithm」","「Maze generation algorithm」","「Non-cell-based algorithm」","迷宫生成算法","迷宮生成算法","迷路生成アルゴリズム","미로 생성 알고리즘"],"name":"Maze generation algorithm","categories":["Algorithms","All articles needing additional references","Articles containing video clips","Articles needing additional references from August 2012","Articles with example Python code","Mazes","Random graphs","Wikipedia articles needing clarification from October 2014"],"tag_line":"Maze generation algorithms are automated methods for the creation of mazes.\n\n"}}
,{"_index":"throwtable","_type":"algorithm","_id":"british-museum-algorithm","_score":0,"_source":{"description":"The British Museum algorithm is a general approach to find a solution by checking all possibilities one by one, beginning with the smallest. The term refers to a conceptual, not a practical, technique where the number of possibilities is enormous.\nFor instance, one may, in theory, find the smallest program that solves a particular problem in the following way: Generate all possible source codes of length one character. Check each one to see if it solves the problem. (Note: the halting problem makes this check troublesome.) If not, generate and check all programs of two characters, three characters, etc. Conceptually, this finds the smallest program, but in practice it tends to take an unacceptable amount of time (more than the lifetime of the universe, in many instances).\nSimilar arguments can be made to show that optimizations, theorem proving, language recognition, etc. are possible or impossible.\nNewell, Shaw, and Simon called this procedure the British Museum algorithm\n\"... since it seemed to them as sensible as placing monkeys in front of typewriters in order to reproduce all the books in the British Museum.\"","alt_names":["...more on Wikipedia about British Museum algorithm","Algorithme du British Museum","British Museum Algorithm","British Museum algorithm","British Museum algorithm - Wikipedia, the free encyclopedia","British Museum algorithm - Wikipedia, the free encyclopedia ...","British Museum algoritme","British Museum-algoritme","British museum algorithm","What are sources of British Museum Algorithm","Wikipedia article Algorithme du British Museum","Wikipedia article British Museum algorithm","Wikipedia article on British Museum algorithm","Wikipedia artikel British Museum algoritme","Wikipedia artikel British Museum-algoritme","Wikipedia entry for British Museum algorithm","Wikipedia sur Algorithme du British Museum","fr:Algorithme du British Museum","http://en.wikipedia.org/wiki/British_Museum_algorithm","http://fr.wikipedia.org/wiki/Algorithme_du_British_Museum","http://nl.wikipedia.org/wiki/British_Museum-algori","http://nl.wikipedia.org/wiki/British_Museum-algoritme","nl:British Museum algoritme","nl:British Museum-algoritme","zh:大英博物館算法"],"name":"British Museum algorithm","categories":["Algorithms","All articles with unsourced statements","Articles with unsourced statements from August 2013","British Museum","Use British English from August 2015","Use dmy dates from August 2015"],"tag_line":"The British Museum algorithm is a general approach to find a solution by checking all possibilities one by one, beginning with the smallest."}}
,{"_index":"throwtable","_type":"algorithm","_id":"holographic-algorithm","_score":0,"_source":{"description":"In computer science, a holographic algorithm is an algorithm that uses a holographic reduction. A holographic reduction is a constant-time reduction that maps solution fragments many-to-many such that the sum of the solution fragments remains unchanged. These concepts were introduced by Leslie Valiant, who called them holographic because \"their effect can be viewed as that of producing interference patterns among the solution fragments\". The algorithms are unrelated to laser holography, except metaphorically. Their power comes from the mutual cancellation of many contributions to a sum, analogous to the interference patterns in a hologram.\nHolographic algorithms have been used to find polynomial-time solutions to problems without such previously known solutions for special cases of satisfiability, vertex cover, and other graph problems. They have received notable coverage due to speculation that they are relevant to the P versus NP problem and their impact on computational complexity theory. Although some of the general problems are #P-hard problems, the special cases solved are not themselves #P-hard, and thus do not prove FP = #P.\nHolographic algorithms have some similarities with quantum computation, but are completely classical.","alt_names":["Holographic Algorithm","Holographic algorithm","Holographic algorithm - Wikipedia, the free encyclopedia","What is research for Holographic algorithm","Wikipedia article Holographic algorithm","Wikipedia entry for Holographic algorithm","holographic algorithm","holographic algorithms","holographic computation","http://en.wikipedia.org/wiki/Holographic_algorithm","more efficient algorithms"],"name":"Holographic algorithm","categories":["Algorithms"],"tag_line":"In computer science, a holographic algorithm is an algorithm that uses a holographic reduction."}}
,{"_index":"throwtable","_type":"algorithm","_id":"adaptive-dimensional-search","_score":0,"_source":{"description":"Adaptive dimensional search algorithms differ from nature-inspired metaheuristic techniques in the sense that they do not use any metaphor as an underlying principle for implementation. Rather, they utilize a simple, performance-oriented methodology based on the update of the search dimensionality ratio (SDR) parameter at each iteration.\nMany robust metaheuristic techniques, such as simulated annealing, evolutionary algorithms, particle swarm optimization, and ant colony optimization, have been introduced by researchers in the last few decades through clearly identifying and formulating similarities between algorithms and the processes they are modeled on. However, over time this trend of developing new search methods has made researchers feel obligated to associate their innovative ideas with some natural event to provide a basis for justification of their thoughts and the originality of their algorithms. As a result, literature has abounded with metaheuristic algorithms that have weak or no similarities to the natural processes which they are purported to derive from.","alt_names":[],"name":"Adaptive dimensional search","categories":["Algorithms","All articles needing expert attention","All articles that are too technical","Articles needing expert attention from October 2015","Computer science","Mathematical optimization","Optimization algorithms and methods","Wikipedia articles that are too technical from October 2015"],"tag_line":"Adaptive dimensional search algorithms differ from nature-inspired metaheuristic techniques in the sense that they do not use any metaphor as an underlying principle for implementation."}}
,{"_index":"throwtable","_type":"algorithm","_id":"flajolet–martin-algorithm","_score":0,"_source":{"description":"The Flajolet–Martin algorithm is an algorithm for approximating the number of distinct elements in a stream with a single pass and space-consumption which is logarithmic in the maximum number of possible distinct elements in the stream. The algorithm was introduced by Philippe Flajolet and G. Nigel Martin in their 1984 paper \"Probabilistic Counting Algorithms for Data Base Applications\". Later it has been refined in the papers \"LogLog counting of large cardinalities\" by Marianne Durand and Philippe Flajolet, and \"HyperLogLog: The analysis of a near-optimal cardinality estimation algorithm\" by Philippe Flajolet et al.\nIn their 2010 paper \"An optimal algorithm for the distinct elements problem\", Daniel M. Kane, Jelani Nelson and David P. Woodruff gives an improved algorithm which uses nearly optimal space, and has optimal O(1) update and reporting times.\n\n","alt_names":[],"name":"Flajolet–Martin algorithm","categories":["Algorithms","All orphaned articles","Orphaned articles from November 2014"],"tag_line":"The Flajolet–Martin algorithm is an algorithm for approximating the number of distinct elements in a stream with a single pass and space-consumption which is logarithmic in the maximum number of possible distinct elements in the stream."}}
,{"_index":"throwtable","_type":"algorithm","_id":"algorithm-engineering","_score":0,"_source":{"description":"Algorithm Engineering focuses on the design, analysis, implementation, optimization, profiling and experimental evaluation of computer algorithms, bridging the gap between algorithm theory and practical applications of algorithms in software engineering. It is a general methodology for algorithmic research.","alt_names":["- Algorithm engineering :","Algorithm Engineering","Algorithm engineering","Algorithm engineering - Wikipedia :: The free encyclopedia","Algorithm engineering - Wikipedia, the free encyclopedia","Algorithm_engineering","Source Wikipedia.org Arcticle - Algorithm engineering","Wikipedia article Algorithm engineering","Wikipedia article Algorithm_engineering","Wikipedia article on Algorithm engineering","Wikipedia entry for Algorithm engineering","algorithm engineering","fa:مهندسی الگوریتم","http://en.wikipedia.org/wiki/Algorithm_engineering","n9:Algorithm_engineering","مهندسی الگوریتم","مهندسی الگوریتم - ویکیپدیا","چیست؟"],"name":"Algorithm engineering","categories":["Algorithms","Theoretical computer science"],"tag_line":"Algorithm Engineering focuses on the design, analysis, implementation, optimization, profiling and experimental evaluation of computer algorithms, bridging the gap between algorithm theory and practical applications of algorithms in software engineering."}}
,{"_index":"throwtable","_type":"algorithm","_id":"label-propagation-algorithm","_score":0,"_source":{"description":"Within complex networks, real networks tend to have community structure. Label propagation is an algorithm  for finding communities. In comparison with other algorithms label propagation has advantage in its running time, amount of a priori information needed about the network structure (no parameter is required to be known beforehand). Disadvantage is that it produces no unique solution, but an aggregate of many solutions.\n\n","alt_names":[],"name":"Label Propagation Algorithm","categories":["Algorithms","All articles needing expert attention","All articles that are too technical","All orphaned articles","Articles needing expert attention from June 2015","Networks","Orphaned articles from June 2015","Wikipedia articles that are too technical from June 2015"],"tag_line":"Within complex networks, real networks tend to have community structure."}}
,{"_index":"throwtable","_type":"algorithm","_id":"kleene's-algorithm","_score":0,"_source":{"description":"In theoretical computer science, in particular in formal language theory, Kleene's algorithm transforms a given deterministic finite automaton (DFA) into a regular expression. Together with other conversion algorithms, it establishes the equivalence of several description formats for regular languages.","alt_names":[],"name":"Kleene's algorithm","categories":["Algorithms","Finite automata","Regular expressions"],"tag_line":"In theoretical computer science, in particular in formal language theory, Kleene's algorithm transforms a given deterministic finite automaton (DFA) into a regular expression."}}
,{"_index":"throwtable","_type":"algorithm","_id":"grey-wolf-optimizer","_score":0,"_source":{"description":"The Grey Wolf Optimizer (GWO) is a recently proposed swarm-based meta-heuristic. This algorithm mimics the social leadership and hunting behaviour of gray wolves in nature. The main phases of hunt in a pack of wolves have been mathematically modeled to solve optimization problems.","alt_names":[],"name":"Grey wolf optimizer","categories":["Algorithms"],"tag_line":"The Grey Wolf Optimizer (GWO) is a recently proposed swarm-based meta-heuristic."}}
,{"_index":"throwtable","_type":"algorithm","_id":"nearest-neighbour-algorithm","_score":0,"_source":{"description":"The nearest neighbour algorithm was one of the first algorithms used to determine a solution to the travelling salesman problem. In it, the salesman starts at a random city and repeatedly visits the nearest city until all have been visited. It quickly yields a short tour, but usually not the optimal one.\nBelow is the application of nearest neighbour algorithm on TSP\nThese are the steps of the algorithm:\nstart on an arbitrary vertex as current vertex.\nfind out the shortest edge connecting current vertex and an unvisited vertex V.\nset current vertex to V.\nmark V as visited.\nif all the vertices in domain are visited, then terminate.\nGo to step 2.\nThe sequence of the visited vertices is the output of the algorithm.\nThe nearest neighbour algorithm is easy to implement and executes quickly, but it can sometimes miss shorter routes which are easily noticed with human insight, due to its \"greedy\" nature. As a general guide, if the last few stages of the tour are comparable in length to the first stages, then the tour is reasonable; if they are much greater, then it is likely that there are much better tours. Another check is to use an algorithm such as the lower bound algorithm to estimate if this tour is good enough.\nIn the worst case, the algorithm results in a tour that is much longer than the optimal tour. To be precise, for every constant r there is an instance of the traveling salesman problem such that the length of the tour computed by the nearest neighbour algorithm is greater than r times the length of the optimal tour. Moreover, for each number of cities there is an assignment of distances between the cities for which the nearest neighbor heuristic produces the unique worst possible tour.\nThe nearest neighbour algorithm may not find a feasible tour at all, even when one exists.","alt_names":["Nearest neighbour","- Nearest neighbour algorithm :","-> Read the article about 'Nearest neighbour algorithm'","...mehr auf Wikipedia über Nearest-Neighbor-Heuristik","...more on Wikipedia about Nearest neighbour algorithm","1NN","Algoritmo do vizinho mais próximo","Algoritmo do vizinho mais próximo (em inglês) - Wikipedia","Algoritmo do vizinho mais próximo – Wikipédia, a enciclopédia","Artimiausio kaimyno algoritmas","Busca do vizinho mais próximo","Nearest Neighbour Algorithm","Nearest Neighbour Algorithm Wikipedia The Free Encyclopedia","Nearest neighbor algorithm","Nearest neighbour algorithm","Nearest neighbour algorithm - Wikipedia :: The free encyclopedia","Nearest neighbour algorithm - Wikipedia, the free encyclopedia","Nearest neighbour algorithm - Wikipedia, the free encyclopedia ...","Nearest neighbour algorithm by Wikipedia","Nearest-Neighbor Methode","Nearest-Neighbor-Heuristik","Nearest-Neighbor-Heuristik - Wikipedia","Nearest-Neighbor-Heuristik ? Wikipedia","Nearest-Neighbor-Heuristik – Wikipedia","Nearest-Neighbour-Heuristik","Nearest-Neighbour-Heuristik - Wikipedia","Nächster-Nachbar-Heuristik","Source Wikipedia.org Arcticle - Nearest neighbour algorithm","Wikipedia (Algoritmo do vizinho mais próximo)","Wikipedia article Algoritmo do vizinho mais próximo","Wikipedia article Nearest neighbour algorithm","Wikipedia article on Nearest neighbor algorithm","Wikipedia article, including psuedocode","Wikipedia-Artikel Heuristik des nächsten Nachbarn","Wikipedia-Artikel Nearest-Neighbor-Heuristik","Wikipedia-Artikel Nearest-Neighbour-Heuristik","Wikipedia-Artikel Nächster-Nachbar-Heuristik","Wikipedia-Seite zu 'Nearest-Neighbor-Heuristik'","Wikipediaで「最近傍法」を調べる","[U]thuật toán","algoritmo do vizinho mais próximo","de:Nearest-Neighbor-Heuristik","giải thuật láng giềng gần nhất","http://de.wikipedia.org/wiki/Nearest-Nei","http://de.wikipedia.org/wiki/Nearest-Neighbor-Heuristik","http://de.wikipedia.org/wiki/Nearest−Neighbor−Heuristik","http://en.wikipedia.org/wiki/Nearest...bour_algorithm","http://en.wikipedia.org/wiki/Nearest_neighbor_algorithm","http://en.wikipedia.org/wiki/Nearest_neighbour_algorithm","ja:最近傍法","nearest neighbor classifier","nearest neighbor tour","nearest neighbour (NN)","nearest neighbour (NN) algorithm","pt:Algoritmo do vizinho mais próximo","ru:Алгоритм ближайшего соседа в задаче коммивояжёра","thuật toán láng giềng gần nhất","vecino más próximo","vi:Thuật toán láng giềng gần nhất","w:Nearest neighbour algorithm","Алгоритм ближайшего соседа","Алгоритм ближайшего соседа в задаче коммивояжёра","Алгоритм ближайшего соседа в задаче коммивояжёра — Википедия","метод ближайшего соседа","最近傍法","最近傍法 - Wikipedia","最近傍法-wikipedia"],"name":"Nearest neighbour algorithm","categories":["Approximation algorithms","Graph algorithms","Heuristic algorithms","Travelling salesman problem"],"tag_line":"The nearest neighbour algorithm was one of the first algorithms used to determine a solution to the travelling salesman problem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rna22","_score":0,"_source":{"description":"Rna22 is a pattern-based algorithm for the discovery of microRNA target sites and the corresponding heteroduplexes.\nThe algorithm is conceptually distinct from other methods for predicting microRNA:mRNA heteroduplexes in that it does not use experimentally validated heteroduplexes for training, instead relying only on the sequences of known mature miRNAs that are found in the public databases. The key idea of rna22 is that the reverse complement of any salient sequence features that one can identify in mature microRNA sequences (using pattern discovery techniques) should allow one to identify candidate microRNA target sites in a sequence of interest: rna22 makes use of the Teiresias algorithm to discover such salient features. Once a candidate microRNA target site has been located, the targeting microRNA can be identified with the help of any of several algorithms able to compute RNA:RNA heteroduplexes. A new version (v2.0) of the algorithm is now available: v2.0-beta adds probability estimates to each prediction, gives users the ability to choose the sensitivity/specificity settings on-the-fly, is significantly faster than the original, and can be accessed through http://cm.jefferson.edu/rna22/Interactive/.\nRna22 neither relies on nor imposes any cross-organism conservation constraints to filter out unlikely candidates; this gives it the ability to discover microRNA binding sites that may not be conserved in phylogenetically proximal organisms. Also, as mentioned above, rna22 can identify putative microRNA binding sites without needing to know the identity of the targeting microRNA. A notable property of rna22 is that it does not require the presence of the exact reverse complement of a microRNA's seed in a putative target permitting bulges and G:U wobbles in the seed region of the heteroduplex. Lastly, the algorithm has been shown to achieve high signal-to-noise ratio.\nUse of rna22 led to the discovery of \"non-canonical\" microRNA targets in the coding regions of the mouse Nanog, Oct4 and Sox2. Most of these targets are not conserved in the human orthologues of these three transcription factors even though they reside in the coding region of the corresponding mRNAs. Moreover, most of these targets contain G:U wobbles, one or more bulges, or both, in the seed region of the heteroduplex. In addition to coding regions, rna22 has helped discover non-canonical targets in 3'UTRs.\nA recent study examined the problem of non-canonical miRNA targets using molecular dynamics simulations of the crystal structure of the Argonaute-miRNA:mRNA ternary complex. The study found that several kinds of modifications, including combinations of multiple G:U wobbles and mismatches in the seed region, are admissible and result in only minor structural fluctuations that do not affect the stability of the ternary complex. The study also showed that the findings of the molecular dynamics simulation are supported by HITS-CLIP (CLIP-seq) data. These results suggest that bona fide miRNA targets transcend the canonical seed-model in turn making target prediction tools like rna22 an ideal choice for exploring the newly augmented spectrum of miRNA targets.","alt_names":[],"name":"RNA22","categories":["Algorithms","MicroRNA","Pattern matching","RNA"],"tag_line":"Rna22 is a pattern-based algorithm for the discovery of microRNA target sites and the corresponding heteroduplexes."}}
,{"_index":"throwtable","_type":"algorithm","_id":"tomasulo-algorithm","_score":0,"_source":{"description":"Tomasulo’s algorithm is a computer architecture hardware algorithm for dynamic scheduling of instructions that allows out-of-order execution, designed to efficiently utilize multiple execution units. It was developed by Robert Tomasulo at IBM in 1967, and first implemented in the IBM System/360 Model 91’s floating point unit.\nThe major innovations of Tomasulo’s algorithm include register renaming in hardware, reservation stations for all execution units, and a common data bus (CDB) on which computed values broadcast to all reservation stations that may need them. These developments allow for improved parallel execution of instructions that would otherwise stall under the use of scoreboarding or other earlier algorithms.\nRobert Tomasulo received the Eckert-Mauchly Award in 1997 for his work on the algorithm.\n\n","alt_names":["Tomasulo","-> Read the article about 'Tomasulo algorithm'","...Wikipedia Algoritmo de Tomasulo","...mehr auf Wikipedia über Tomasulo-Algorithmus","Algorithme de Tomasulo","Algoritmo de Tomasulo","Algoritmo de Tomasulo - Wikipedia, la enciclopedia libre","Algoritmo di Tomasulo","Algoritmo di Tomasulo - Wikipedia","Algoritmo_de_Tomasulo","Implementation Concepts","Instruction Lifecycle","Tomasulo Algorithm","Tomasulo Approach","Tomasulo algorithm","Tomasulo algorithm - Wikipedia, the free encyclopedia","Tomasulo algorithm - Wikipedia, the free encyclopedia wikipedia.org","Tomasulo's","Tomasulo's Algorithm","Tomasulo's Dynamic Scheduling Algorithm","Tomasulo's algorithm","Tomasulo's invention","Tomasulo's method","Tomasulo's scheme","Tomasulo-Algorithmus","Tomasulo-Algorithmus ? Wikipedia","Tomasulo-Algorithmus – Wikipedia","Tomasulo_algorithm","Tomasuloのアルゴリズム","Tomasuloのアルゴリズム - Wikipedia","Tomasuloのｱﾙｺﾞﾘｽﾞﾑ-wikipedia","Tumasulo's Algorithm","Wikipedia article ''Tomasulo algorithm''","Wikipedia article Tomasulo algorithm","Wikipedia article on Tomasulo algorithm","Wikipedia entry for Tomasulo algorithm","Wikipedia-Artikel Tomasulo","Wikipedia-Artikel Tomasulo-Algorithmus","Wikipedia-Seite zu 'Tomasulo-Algorithmus'","Wikipediaで「Tomasuloのアルゴリズム」を調べる","[9] Tomasulo algorithm","algoritmo de Tomasulo","algoritmo de Tomasulo q","algoritmo di Tomasulo","artículo de Wikipedia Algoritmo de Tomasulo","en.wikipedia.org/wiki/Tomasulo_algorithm","http://ca.wikipedia.org/wiki/Algorisme_Tomasulo","http://de.wikipedia.org/wiki/Tomasulo-Al","http://de.wikipedia.org/wiki/Tomasulo-Algorithmus","http://en.wikipedia.org/wiki/Tomasulo_algorithm","http://en.wikipedia.org/wiki/Tomasulo_al…","http://es.wikipedia.org/wiki/Algoritmo_de_Tomasulo","http://fr.wikipedia.org/wiki/Algorithme_de_Tomasulo","http://it.wikipedia.org/wiki/Algoritmo_di_Tomasulo","http://ja.wikipedia.org/wiki/Tomasulo%E3%81","l'algorisme de Tomasulo","the Tomasulo Approach","yago-res:Tomasulo algorithm","Το σκατό στην κάτασπρη κάλτσα.","инженера IBM Tomasulo"],"name":"Tomasulo algorithm","categories":["Algorithms","Instruction processing","Wikipedia articles needing clarification from March 2015"],"tag_line":"Tomasulo’s algorithm is a computer architecture hardware algorithm for dynamic scheduling of instructions that allows out-of-order execution, designed to efficiently utilize multiple execution units."}}
,{"_index":"throwtable","_type":"algorithm","_id":"maze-solving-algorithm","_score":0,"_source":{"description":"There are a number of different maze solving algorithms, that is, automated methods for the solving of mazes. The random mouse, wall follower, Pledge, and Trémaux's algorithms are designed to be used inside the maze by a traveler with no prior knowledge of the maze, whereas the dead-end filling and shortest path algorithms are designed to be used by a person or computer program that can see the whole maze at once.\nMazes containing no loops are known as \"simply connected\", or \"perfect\" mazes, and are equivalent to a tree in graph theory. Thus many maze solving algorithms are closely related to graph theory. Intuitively, if one pulled and stretched out the paths in the maze in the proper way, the result could be made to resemble a tree.","alt_names":["Pledge Algorithm","possible solutions","Tremaux's algorithm","- Maze solving algorithm :","220px-MAZE_solution.png",">>> Maze solving algorithm","Beschreibung des Pledge-Algorithmus (Wikipedia, Englisch)","Dead-end filling","Labyrint-algoritmer","Left-or-Right Hand algorithm","Maze Solving Algorithm","Maze Solving Algorithma","Maze Solving Algorithms","Maze Solving Algorithms on Wikipedia","Maze solving algorithm","Maze solving algorithm - Wikipedia","Maze solving algorithm - Wikipedia :: The free encyclopedia","Maze solving algorithm - Wikipedia, the free ...","Maze solving algorithm - Wikipedia, the free encyclopedia","Maze solving algorithm Wikipedia the free encyclopedia","Maze solving algorithm Wikipedia the free encyclopedia - result","Maze solving algorithm Wikipedia, the ...","Maze solving algorithm from Wikipedia","Maze solving algorithms","Navigation in mazes","Plede's algorithm","Pledge's algorithm","Random mouse algorithm","Right hand algorithm","Tremaux's Theorem","Tremaux-Algorithmus","Trémaux's Algorithm","Trémaux's algorithm","Wall follower","Wikipedia - Resumen de los algoritmos ms conocidos para","Wikipedia Maze Algorithm","Wikipedia Maze Solving","Wikipedia article Maze solving algorithm","Wikipedia entry for Maze solving algorithm","by always turning left","dead end filler algorithm","en.wikipedia.org/...Maze_solving_algorithm","en.wikipedia.org/wik...orithm#Wall_follower","en.wikipedia.org/wiki/Maze_solving_algorithm","follow the wall","http://bit.ly/mLeaNa","http://en.wikipedia....lving_algorithm","http://en.wikipedia.org/wiki/Maze_so...orithm#Tremaux","http://en.wikipedia.org/wiki/Maze_solvin...l_follower","http://en.wikipedia.org/wiki/Maze_solving_...ead-end_filling","http://en.wikipedia.org/wiki/Maze_solving_algorith. . .","http://en.wikipedia.org/wiki/Maze_solving_algorithm","http://en.wikipedia.org/wiki/Maze_solving_algorithm#Pledge_algorithm","http://en.wikipedia.org/wiki/Maze_solving_algorithm#Tr.C3","http://en.wikipedia.org/wiki/Maze_solving_algorithm#Wall_follower","http://en.wikipedia.org/wiki/Maze_solvin…","http://en.wikipedia.org/wiki/Maze_solvin…m#Wall_follower","http://en.wikipedia.org/wiki/Mazesolvingalgorithm#Tremaux","left-hand or right-hand rule","maze solving","navigate through a maze","perfect maze","placing your hand on the wall","pledge algorithm","procedure to get out of a maze","right turns","simply connected mazes","solving the maze","there's a way around it","wall following","“Maze solving algorithm - Wikipedia, the free encyclopedia”, en","迷路解きアルゴリズム(enwiki)"],"name":"Maze solving algorithm","categories":["Algorithms","Mazes"],"tag_line":"There are a number of different maze solving algorithms, that is, automated methods for the solving of mazes."}}
,{"_index":"throwtable","_type":"algorithm","_id":"submodular-set-function","_score":0,"_source":{"description":"In mathematics, a submodular set function (also known as a submodular function) is a set function whose value, informally, has the property that the difference in the incremental value of the function, that a single element makes when added to an input set, decreases as the size of the input set increases. Submodular functions have a natural diminishing returns property which makes them suitable for many applications, including approximation algorithms, game theory (as functions modeling user preferences) and electrical networks. Recently, submodular functions have also found immense utility in several real world problems in machine learning and artificial intelligence, including automatic summarization, multi-document summarization, feature selection, active learning, sensor placement, image collection summarization and many other domains.","alt_names":[],"name":"Submodular set function","categories":["All articles with unsourced statements","Approximation algorithms","Articles with unsourced statements from August 2014","Articles with unsourced statements from November 2013","Combinatorial optimization","Matroid theory"],"tag_line":"In mathematics, a submodular set function (also known as a submodular function) is a set function whose value, informally, has the property that the difference in the incremental value of the function, that a single element makes when added to an input set, decreases as the size of the input set increases."}}
,{"_index":"throwtable","_type":"algorithm","_id":"zassenhaus-algorithm","_score":0,"_source":{"description":"In mathematics, the Zassenhaus algorithm is a method to calculate a basis for the intersection and sum of two subspaces of a vector space.\nIt is named after Hans Zassenhaus, but no publication of this algorithm by him is known. It is used in computer algebra systems.\n^ Luks, Eugene M.; Rákóczi, Ferenc; Wright, Charles R. B. (April 1997), \"Some algorithms for nilpotent permutation groups\", Journal of Symbolic Computation 23 (4): 335–354, doi:10.1006/jsco.1996.0092 .\n^ Fischer, Gerd (2012), Lernbuch Lineare Algebra und Analytische Geometrie (in German), Vieweg+Teubner, pp. 207–210, doi:10.1007/978-3-8348-2379-3, ISBN 978-3-8348-2378-6 \n^ The GAP Group (February 13, 2015), \"24 Matrices\", GAP Reference Manual, Release 4.7, retrieved 2015-06-11","alt_names":[],"name":"Zassenhaus algorithm","categories":["Algorithms","CS1 German-language sources (de)","Linear algebra"],"tag_line":"In mathematics, the Zassenhaus algorithm is a method to calculate a basis for the intersection and sum of two subspaces of a vector space."}}
,{"_index":"throwtable","_type":"algorithm","_id":"xulvi-brunet---sokolov-algorithm","_score":0,"_source":{"description":"Xulvi-Brunet and Sokolov’s algorithm generates networks with chosen degree correlations. This method is based on link rewiring, in which the desired degree is governed by parameter ρ. By varying this single parameter it is possible to generate networks from random (when ρ = 0) to perfectly assortative or disassortative (when ρ = 1). This algorithm allows to keep network’s degree distribution unchanged when changing the value of ρ.","alt_names":[],"name":"Xulvi-Brunet - Sokolov algorithm","categories":["Algorithms","All orphaned articles","Network theory","Orphaned articles from June 2015"],"tag_line":"Xulvi-Brunet and Sokolov’s algorithm generates networks with chosen degree correlations."}}
,{"_index":"throwtable","_type":"algorithm","_id":"randomization-function","_score":0,"_source":{"description":"In computer science, a randomization function or randomizing function is an algorithm or procedure that implements a randomly chosen function between two specific sets, suitable for use in a randomized algorithm.\nRandomizing functions are related to random number generators and hash functions, but have somewhat different requirements and uses, and often need specific algorithms.","alt_names":[],"name":"Randomization function","categories":["Algorithms","All articles lacking sources","All stub articles","Articles lacking sources from April 2009","Computer science stubs"],"tag_line":"In computer science, a randomization function or randomizing function is an algorithm or procedure that implements a randomly chosen function between two specific sets, suitable for use in a randomized algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pointer-jumping","_score":0,"_source":{"description":"Pointer jumping or path doubling is a design technique for parallel algorithms that operate on pointer structures, such as linked lists and directed graphs. It can be used to find the roots of a forest of rooted trees, and can also be applied to parallelize many other graph algorithms including connected components, minimum spanning trees, and biconnected components.","alt_names":["pointer jumping"],"name":"Pointer jumping","categories":["Algorithms","Parallel computing"],"tag_line":"Pointer jumping or path doubling is a design technique for parallel algorithms that operate on pointer structures, such as linked lists and directed graphs."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fitness-proportionate-selection","_score":0,"_source":{"description":"Fitness proportionate selection, also known as roulette wheel selection, is a genetic operator used in genetic algorithms for selecting potentially useful solutions for recombination.\nIn fitness proportionate selection, as in all selection methods, the fitness function assigns a fitness to possible solutions or chromosomes. This fitness level is used to associate a probability of selection with each individual chromosome. If  is the fitness of individual  in the population, its probability of being selected is , where  is the number of individuals in the population.\nThis could be imagined similar to a Roulette wheel in a casino. Usually a proportion of the wheel is assigned to each of the possible selections based on their fitness value. This could be achieved by dividing the fitness of a selection by the total fitness of all the selections, thereby normalizing them to 1. Then a random selection is made similar to how the roulette wheel is rotated.\nWhile candidate solutions with a higher fitness will be less likely to be eliminated, there is still a chance that they may be. Contrast this with a less sophisticated selection algorithm, such as truncation selection, which will eliminate a fixed percentage of the weakest candidates. With fitness proportionate selection there is a chance some weaker solutions may survive the selection process; this is an advantage, as though a solution may be weak, it may include some component which could prove useful following the recombination process.\nThe analogy to a roulette wheel can be envisaged by imagining a roulette wheel in which each candidate solution represents a pocket on the wheel; the size of the pockets are proportionate to the probability of selection of the solution. Selecting N chromosomes from the population is equivalent to playing N games on the roulette wheel, as each candidate is drawn independently.\nOther selection techniques, such as stochastic universal sampling or tournament selection, are often used in practice. This is because they have less stochastic noise, or are fast, easy to implement and have a constant selection pressure [Blickle, 1996].\nThe naive implementation is carried out by first generating the cumulative probability distribution (CDF) over the list of individuals using a probability proportional to the fitness of the individual. A uniform random number from the range [0,1) is chosen and the inverse of the CDF for that number gives an individual. This corresponds to the roulette ball falling in the bin of an individual with a probability proportional to its width. The \"bin\" corresponding to the inverse of the uniform random number can be found most quickly by using a binary search over the elements of the CDF. It takes in the O(log n) time to choose an individual. A faster alternative that generates individuals in O(1) time will be to use the alias method.\nRecently, a very simple O(1) algorithm was introduced that is based on \"stochastic acceptance\". The algorithm randomly selects an individual (say ) and accepts the selection with probability , where  is the maximum fitness in the population. Certain analysis indicates that the stochastic acceptance version has a considerably better performance than versions based on linear or binary search, especially in applications where fitness values might change during the run.","alt_names":["Roulette Wheel Selection","roulette wheel selection","-> Read the article about 'Fitness proportionate selection'","...more on Wikipedia about Fitness proportionate selection","Fitness Proportionate Selection","Fitness proportion","Fitness proportionate selection","Fitness proportionate selection - Wikipedia :: The free encyclopedia","Fitness proportionate selection - Wikipedia, the f...","Fitness proportionate selection - Wikipedia, the free ...","Fitness proportionate selection - Wikipedia, the free encyclopedia","Fitness proportionate selection from Wikipedia","Roulette Wheel Algorithm","Roulette Wheel selection","Roulette wheel selection","Roulette-Rad Auswahl","Roulette-Wheel selection","Roulette-wheel selection","Selecció de la ruleta","Wikipedia article Fitness proportionate selection","Wikipedia article Fitness_proportionate_selection","Wikipedia article on Fitness proportionate selection","Wikipedia article on fitness proportionate selection","Wikipedia entry for Fitness proportionate selection","Wikipedia: Fitness proportionate selection","Wikipedia: Roulette wheel selection","best-fit scheme","biased roulette wheel for a genetic algorithm","ca:Selecció de la ruleta","en:Fitness_proportionate_selection","en:roulette wheel selection","fitness proportionate selection","http://en.wikipedia.org/wiki/Fitness proportionate selection","http://en.wikipedia.org/wiki/Fitness...nate_selection","http://en.wikipedia.org/wiki/Fitness_pr ... _selection","http://en.wikipedia.org/wiki/Fitness_pro","http://en.wikipedia.org/wiki/Fitness_proportionate_selection","http://en.wikipedia.org/wiki/Fitness_pro…","http://en.wikipedia.org/wiki/Roulette_wheel_selection","oulette wheel selection:","p i = f i Σ j = 1 N","roda de roleta de seleção","rolette wheel selection","roulette selection","roulette wiel selectie","roulette-hjulet udvælgelse","roulette-wheel selection","rueda de la ruleta de selección","rulet tekeri seçimi","ruleta-kolo výběru","ruletová selekce","ruota della roulette selezione","system of a down lyrics ho","sélection de la roulette de roue","technical description here.","выбор колесо рулетки","рулетки колесо выбора","ルーレットのホイールの選択の","轮盘赌选择"],"name":"Fitness proportionate selection","categories":["Genetic algorithms"],"tag_line":"Fitness proportionate selection, also known as roulette wheel selection, is a genetic operator used in genetic algorithms for selecting potentially useful solutions for recombination."}}
,{"_index":"throwtable","_type":"algorithm","_id":"genetic-algorithm-scheduling","_score":0,"_source":{"description":"To be competitive, corporations must minimize inefficiencies and maximize productivity. In manufacturing, productivity is inherently linked to how well you can optimize the resources you have, reduce waste and increase efficiency. Finding the best way to maximize efficiency in a manufacturing process can be extremely complex. Even on simple projects, there are multiple inputs, multiple steps, many constraints and limited resources. In general a resource constrained scheduling problem consists of:\nA set of jobs that must be executed\nA finite set of resources that can be used to complete each job\nA set of constraints that must be satisfied\nTemporal Constraints–the time window to complete the task\nProcedural Constraints–the order each task must be completed\nResource Constraints - is the resource available\n\nA set of objectives to evaluate the scheduling performance\nA typical factory floor setting is a good example of this where scheduling which jobs need to be completed on which machines, by which employees in what order and at what time. In very complex problems such as scheduling there is no known way to get to a final answer, so we resort to searching for it trying to find a “good” answer. Scheduling problems most often use heuristic algorithms to search for the optimal solution. Heuristic search methods suffer as the inputs become more complex and varied. This type of problem is known in computer science as an NP-Hard problem. This means that there are no known algorithms for finding an optimal solution in polynomial time.\n\nGenetic algorithms are well suited to solving production scheduling problems, because unlike heuristic methods genetic algorithms operate on a population of solutions rather than a single solution. In production scheduling this population of solutions consists of many answers that may have different sometimes conflicting objectives. For example, in one solution we may be optimizing a production process to be completed in a minimal amount of time. In another solution we may be optimizing for a minimal amount of defects. By cranking up the speed at which we produce we may run into an increase in defects in our final product.\nAs we increase the number of objectives we are trying to achieve we also increase the number of constraints on the problem and similarly increase the complexity. Genetic algorithms are ideal for these types of problems where the search space is large and the number of feasible solutions is small.\n\nTo apply a genetic algorithm to a scheduling problem we must first represent it as a genome. One way to represent a scheduling genome is to define a sequence of tasks and the start times of those tasks relative to one another. Each task and its corresponding start time represents a gene.\nA specific sequence of tasks and start times (genes) represents one genome in our population. To make sure that our genome is a feasible solution we must take care that it obeys our precedence constraints. We generate an initial population using random start times within the precedence constraints. With genetic algorithms we then take this initial population and cross it, combining genomes along with a small amount of randomness (mutation). The offspring of this combination is selected based on a fitness function that includes one or many of our constraints, such as minimizing time and minimizing defects. We let this process continue either for a pre-allotted time or until we find a solution that fits our minimum criteria. Overall each successive generation will have a greater average fitness i.e. taking less time with higher quality than the preceding generations. In scheduling problems, as with other genetic algorithm solutions, we must make sure that we do not select offspring that are infeasible, such as offspring that violate our precedence constraint. We of course may have to add further fitness values such as minimizing costs however each constraint that we add greatly increases the search space and lowers the number of solutions that are good matches.","alt_names":["GA scheduling","Genetic Algorithm Scheduling","Genetic algorithm scheduling","Genetic algorithm scheduling - Wikipedia, the free encyclopedia","Genetic algorithm scheduling Wikipedia the free encyclopedia","Scheduling applications","Wikipedia article Genetic Algorithm Scheduling","Wikipedia article Genetic algorithm scheduling","Wikipedia entry for Genetic algorithm scheduling","applicazioni di programmazione","constraint based scheduling","http://en.wikipedia.org/wiki/Genetic_algorithm_scheduling","schedule optimization"],"name":"Genetic algorithm scheduling","categories":["All articles covered by WikiProject Wikify","All pages needing cleanup","Articles covered by WikiProject Wikify from September 2009","Genetic algorithms","Operations research","Pages missing lead section","Production and manufacturing","Wikipedia introduction cleanup from September 2009"],"tag_line":"To be competitive, corporations must minimize inefficiencies and maximize productivity."}}
,{"_index":"throwtable","_type":"algorithm","_id":"property-testing","_score":0,"_source":{"description":"In computer science, a property testing algorithm for a decision problem is an algorithm whose query complexity to its input is much smaller than the instance size of the problem. Typically property testing algorithms are used to decide if some mathematical object (such as a graph or a boolean function) has a \"global\" property, or is \"far\" from having this property, using only a small number of \"local\" queries to the object.\nFor example, the following promise problem admits an algorithm whose query complexity is independent of the instance size (for an arbitrary constant ε > 0):\n\"Given a graph G on n vertices, decide if G is bipartite, or G cannot be made bipartite even after removing an arbitrary subset of at most  edges of G.\"\nProperty testing algorithms are important in the theory of probabilistically checkable proofs.","alt_names":["- Property testing :","Property Testing","Property testing","Property testing - Wikipedia :: The free encyclopedia","Property testing - Wikipedia, the free encyclopedia","Property testing; it is used under the","Property_testing","Testeur de propriété","Testeur de propriété - Wikipédia","Wikipedia article Property testing","Wikipedia article on Property testing","Wikipedia entry for Property testing","ar:اختبار الخاصية","en.wikipedia.org/wiki/Property_testing","he:בדיקת תכונות מדגמית","http://en.wikipedia.org/wiki/Property_testing","property testing","property testing algorithm","yago-res:Property testing","בדיקת תכונות מדגמית","בדיקת תכונות מדגמית – ויקיפדיה"],"name":"Property testing","categories":["Approximation algorithms","Randomized algorithms","Theoretical computer science"],"tag_line":"In computer science, a property testing algorithm for a decision problem is an algorithm whose query complexity to its input is much smaller than the instance size of the problem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hirschberg's-algorithm","_score":0,"_source":{"description":"In computer science, Hirschberg's algorithm, named after its inventor, Dan Hirschberg, is a dynamic programming algorithm that finds the optimal sequence alignment between two strings. Optimality is measured with the Levenshtein distance, defined to be the sum of the costs of insertions, replacements, deletions, and null actions needed to change one string into the other. Hirschberg's algorithm is simply described as a divide and conquer version of the Needleman–Wunsch algorithm. Hirschberg's algorithm is commonly used in computational biology to find maximal global alignments of DNA and protein sequences.","alt_names":["Hirschberg's algorithm","...mehr auf Wikipedia über Hirschberg-Algorithmus","D.S. Hirschberg","Hirschberg 's algorithm - Wikipedia, the free encyclopedia","Hirschberg Algorithm","Hirschberg's Algorithm (German Version)","Hirschberg's algorithm - Wikipedia :: The free encyclopedia","Hirschberg's algorithm - Wikipedia, the free encyclopedia","Hirschberg-Algorithmus","Hirschberg-Algorithmus - Wikipedia","Hirschbergs algorithm","Learn about Hirschberg's algorithm>>>","Linearspace-Algorithmus","Wikipedia article Hirschberg's algorithm","Wikipedia article Hirschberg's_algorithm","Wikipedia-Artikel Hirschberg-Algorithmus","Wikipedia-Artikel Linearspace-Algorithmus","Wikipedia-Seite zu 'Hirschberg-Algorithmus'","a divide and conquer version of the Needleman","en.wikipedia.org/wiki/Hirschberg's_algorithm","http://de.wikipedia.org/wiki/Hirschberg-","http://de.wikipedia.org/wiki/Hirschberg-Algorithmus","http://en.wikipedia.org/wiki/Hirschberg%27s_al","http://en.wikipedia.org/wiki/Hirschberg%27s_algorithm","http://en.wikipedia.org/wiki/Hirschberg's_algorithm","http://en.wikipedia.org/wiki/Hirschberg_algorithm","http://www.de.wikipedia.org/wiki/Hirschberg-Algorithmus","mehr zu Hirschberg-Algorithmus","алгоритм Хиршберга"],"name":"Hirschberg's algorithm","categories":["Articles with example pseudocode","Bioinformatics algorithms","Dynamic programming","Sequence alignment algorithms"],"tag_line":"In computer science, Hirschberg's algorithm, named after its inventor, Dan Hirschberg, is a dynamic programming algorithm that finds the optimal sequence alignment between two strings."}}
,{"_index":"throwtable","_type":"algorithm","_id":"spades-(software)","_score":0,"_source":{"description":"SPAdes (St. Petersburg genome assembler) is a genome assembly algorithm which was designed for single cell and multi-cells bacterial data sets. However, it might not be suitable for large genomes projects.\nSPAdes works with Ion Torrent, PacBio and Illumina paired-end, mate-pairs and single reads.\nRecently, SPAdes has been integrated into Galaxy pipelines by Guy Lionel and Philip Mabon.\n^ a b c http://spades.bioinf.spbau.ru/release3.0.0/manual.html\n^ Bankevich A, Nurk S, Antipov D, Gurevich AA, Dvorkin M, Kulikov AS, Lesin VM, Nikolenko SI, Pham S, Prjibelski AD, Pyshkin AV, Sirotkin AV, Vyahhi N, Tesler G, Alekseyev MA, Pevzner PA. (2012). \"SPAdes: a new genome assembly algorithm and its applications to single-cell sequencing\" (PDF). Journal of Computational Biology 19: 455–477. doi:10.1089/cmb.2012.0021. PMC 3342519. PMID 22506599. \n^ Galaxy tool shed","alt_names":[],"name":"SPAdes (software)","categories":["Bioinformatics algorithms","Bioinformatics software","DNA sequencing","Metagenomics software","Pages with duplicate reference names","Pages with reference errors","Use mdy dates from October 2013"],"tag_line":"SPAdes (St. Petersburg genome assembler) is a genome assembly algorithm which was designed for single cell and multi-cells bacterial data sets."}}
,{"_index":"throwtable","_type":"algorithm","_id":"kabsch-algorithm","_score":0,"_source":{"description":"The Kabsch algorithm, named after Wolfgang Kabsch, is a method for calculating the optimal rotation matrix that minimizes the RMSD (root mean squared deviation) between two paired sets of points. It is useful in graphics, cheminformatics to compare molecular structures, and also bioinformatics for comparing protein structures (in particular, see root-mean-square deviation (bioinformatics)).\nThe algorithm only computes the rotation matrix, but it also requires the computation of a translation vector. When both the translation and rotation are actually performed, the algorithm is sometimes called partial Procrustes superimposition (see also orthogonal Procrustes problem).","alt_names":["- Kabsch algorithm :","Kabsch","Kabsch Algorithmus","Kabsch algorithm","Kabsch algorithm - Wikipedia :: The free encyclopedia","Kabsch algorithm - Wikipedia, the free encyclopedia","Kabsch algorithm to calculate RMSD","Kabsch algorithm; it is used under the","Kabsch algoritme","Kabsch alignment","Kabschのアルゴリズム","Kabschアルゴリズム","Kabsch算法","Wikipedia article Kabsch algorithm","Wikipedia article Kabsch_algorithm","Wikipedia entry for Kabsch algorithm","algorithme de Kabsch","algoritmo Kabsch","algoritmo de Kabsch","en.wikipedia.org/wiki/Kabsch_algorithm","http://en.wikipedia.org/wiki/Kabsch_algo","http://en.wikipedia.org/wiki/Kabsch_algorithm","kabsch","yago-res:Kabsch algorithm","алгоритм Kabsch"],"name":"Kabsch algorithm","categories":["Bioinformatics algorithms"],"tag_line":"The Kabsch algorithm, named after Wolfgang Kabsch, is a method for calculating the optimal rotation matrix that minimizes the RMSD (root mean squared deviation) between two paired sets of points."}}
,{"_index":"throwtable","_type":"algorithm","_id":"needleman–wunsch-algorithm","_score":0,"_source":{"description":"The Needleman–Wunsch algorithm is an algorithm used in bioinformatics to align protein or nucleotide sequences. It was one of the first applications of dynamic programming to compare biological sequences. The algorithm was developed by Saul B. Needleman and Christian D. Wunsch and published in 1970. The algorithm essentially divides a large problem (e.g. the full sequence) into a series of smaller problems and uses the solutions to the smaller problems to reconstruct a solution to the larger problem. It is also sometimes referred to as the optimal matching algorithm and the global alignment technique. The Needleman–Wunsch algorithm is still widely used for optimal global alignment, particularly when the quality of the global alignment is of the utmost importance.","alt_names":[],"name":"Needleman–Wunsch algorithm","categories":["All articles needing expert attention","All articles that are too technical","Articles needing expert attention from September 2013","Articles with example pseudocode","Bioinformatics algorithms","CS1 errors: external links","Computational phylogenetics","Dynamic programming","Pages using citations with accessdate and no URL","Pages using web citations with no URL","Sequence alignment algorithms","Wikipedia articles that are too technical from September 2013"],"tag_line":"The Needleman–Wunsch algorithm is an algorithm used in bioinformatics to align protein or nucleotide sequences."}}
,{"_index":"throwtable","_type":"algorithm","_id":"blast2go","_score":0,"_source":{"description":"Blast2GO, first published in 2005, is a bioinformatics software tool for the automatic, high-throughput functional annotation of novel sequence data (genes proteins). It makes use of the BLAST algorithm to identify similar sequences to then transfers existing functional annotation from yet characterised sequences to the novel one. The functional information is represented via the Gene Ontology (GO), a controlled vocabulary of functional attributes. The Gene Ontology, or GO, is a major bioinformatics initiative to unify the representation of gene and gene product attributes across all species.","alt_names":[],"name":"Blast2GO","categories":["All stub articles","Bioinformatics algorithms","Bioinformatics software","Bioinformatics stubs","Genomics","Laboratory software","Official website different in Wikidata and Wikipedia","Omics","Public domain software"],"tag_line":"Blast2GO, first published in 2005, is a bioinformatics software tool for the automatic, high-throughput functional annotation of novel sequence data (genes proteins)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"baum–welch-algorithm","_score":0,"_source":{"description":"In electrical engineering, computer science, statistical computing and bioinformatics, the Baum–Welch algorithm is used to find the unknown parameters of a hidden Markov model (HMM). It makes use of the forward-backward algorithm and is named for Leonard E. Baum and Lloyd R. Welch.","alt_names":[],"name":"Baum–Welch algorithm","categories":["Bioinformatics algorithms","Markov models","Pages using citations with accessdate and no URL","Statistical algorithms"],"tag_line":"In electrical engineering, computer science, statistical computing and bioinformatics, the Baum–Welch algorithm is used to find the unknown parameters of a hidden Markov model (HMM)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"checksum","_score":0,"_source":{"description":"A checksum or hash sum is a small-size datum from a block of digital data for the purpose of detecting errors which may have been introduced during its transmission or storage. It is usually applied to an installation file after it is received from the download server. By themselves checksums are often used to verify data integrity, but should not be relied upon to also verify data authenticity.\nThe actual procedure which yields the checksum, given a data input is called a checksum function or checksum algorithm. Depending on its design goals, a good checksum algorithm will usually output a significantly different value, even for small changes made to the input. This is especially true of cryptographic hash functions, which may be used to detect many data corruption errors and verify overall data integrity; if the computed checksum for the current data input matches the stored value of a previously computed checksum, there is a very high probability the data has not been accidentally altered or corrupted.\nChecksum functions are related to hash functions, fingerprints, randomization functions, and cryptographic hash functions. However, each of those concepts has different applications and therefore different design goals. Checksums are used as cryptographic primitives in larger authentication algorithms. For cryptographic systems with these two specific design goals, see HMAC.\nCheck digits and parity bits are special cases of checksums, appropriate for small blocks of data (such as Social Security numbers, bank account numbers, computer words, single bytes, etc.). Some error-correcting codes are based on special checksums which not only detect common errors but also allow the original data to be recovered in certain cases.","alt_names":["las sumas de comprobación","kontrolního součtu","check-sum","校驗","Что такое MD5","checksums","http://ru.wikipedia.org/wiki/Контрольная...","контрольную сумму","校验","контрольная сумма","sumę kontrolną","controlecijfer","контрольными суммами","prüfsumme","Checksum","checksum","체크섬","Контрольная сумма","Checksums","チェックサム","Prüfsummen","kontrolní součet","контрольных сумм","Prüfsumme","'checksum'","- Check sum :","- Checksum :","- Checksums :","- Integrity check value :","-> Read the article about 'Checksum'","... czytaj więcej o Suma kontrolna na pl.wikipedia","...Wikipedia Bit de parité","...Wikipedia Checksumma","...Wikipedia Cyfra kontrolna","...Wikipedia Suma de verificación","...Wikipedia Suma kontrolna","...mehr auf Wikipedia über Prüfsumme","...more on Wikipedia about Checksum",".Контрольные суммы","1 Checksum algorithms","1.1 Parity byte or parity word","1.2 Modular sum","1.3 Position-dependent checksums","1.4 General considerations","2 Checksum tools","5 Checksum","8 bits de parité",">>читать на WiKi",">checksum","A checksum or hash sum is a fixed","Approche intuitive","Bearbeiten Komplexere Verfahren. Der Begriff Prüfsumme wird auch","Bit de parité","Bit_de_parité","CHECKSUM","CHECKSUMsuma de verificacion","CMOS Checksum Error","CRC [MD5, SHA]","Cecksun","Check Sum","Check sum","Check sum; it is used under the","Check-sum","CheckSum","Check_sum","Checksommen","Checksum ( Checksum, tradotto letteralmente significa somma di controllo","Checksum (From Wikipedia)","Checksum (Wikipedia)","Checksum (wikipedia)","Checksum -","Checksum - Simple English Wikipedia, the free encyclopedia","Checksum - Viquipèdia","Checksum - Wikipedia","Checksum - Wikipedia, the free encyclopedia","Checksum Wiki","Checksum Wikipedia the free encyclopedia","Checksum algorithims","Checksum algorithms","Checksum algorithms-wikipedia","Checksum and hash sum are the same","Checksum article on wikipedia","Checksum de Wikipedia","Checksum en Wikipedia","Checksum from Wikipedia","Checksum on Wikipedia","Checksum on wikipedia.org","Checksum tools","Checksum |","Checksum – Wikipedia, the free encyclopedia","Checksum'd","Checksum's","Checksum; it is used under the","Checksum@Wikipedia","Checksumme","Checksummen","Checksummenprüfung","Checksums; it is used under the","Controlecijfer","Controlecijfer - Wikipedia","Controlecijfers","Definición de Suma de verificación más completo","Définition d'une somme de contrôle","Effect of a typical checksum function (the Unix","Effect of a typical checksum function the Unix","Ellenőrzőösszeg","Ellenőrzőösszeg - Wikipédia","File checksum","Giá trị tổng kiểm - Wikipedia tiếng Việt","Hash (Prüfsumme)","Hashdatein","How to apply for Integrity check value?","In der Informatik ist eine Prüfsumme (engl.: checksum","Integrity check value","Integrity_check_value","Kontrolesom","Kontrolesom - Wikipedia","Kontrollsumma","Kontrolní součet","Kontrolní součet - Wikipedie","Kontrolný súčet","Kontrolsum","Kontrolsum - Wikipedia, den frie encyklo...","Kontrolsum - Wikipedia, den frie encyklopædi","La somme de contrôle","Learn about Checksum>>>","MD5-tarkistussummalla","Métodos de suma de comprobación","PRÜFSUMME ]","Pesquisar checksum na Wikipedia Portugal","Pr fsumme Wikipedia","Pruefsummen","Prufsummen","Prófsumma","Prüfsumme (Checksum)","Prüfsumme - Wikipedia","Prüfsumme ? Wikipedia","Prüfsumme Wikipedia","Prüfsumme stimmt nicht überein","Prüfsumme – Wikipedia","Prüfsummenalgorithmus","Prüfsummenprogramm","Prüfsummenunterstützung","Prüfsummenvergleich","Prüfsümme","Prüfwerts","Read more about Checksum at Wikipedia","SHA-1 checksum","Search for Checksum on Wikipedia!","Search for Checksums on Wikipedia!","Search info on Checksum at Wikipedia","Sjekksum","Soma de verificação – Wikipédia, a enciclopédia livre","Somme de contr?le - Wikip?dia","Somme de contrôle","Somme de contrôle - Wikipédia","Somme_de_contrôle","Soomy qoNtRoLnE","Source Wikipedia.org Arcticle - Checksum","Suma de control","Suma de verificaci?n - Wikipedia, la enciclopedia libre","Suma de verificacion (checksum)","Suma de verificación","Suma de verificación (Checksum)","Suma de verificación - Wikipedia, la enciclopedia libre","Suma de verificación según la Wikipedia","Suma kontrolna â�“ Wikipedia, wolna encyklopedia","Suma kontrolna – Wikipedia, wolna encyklopedia","Suma_kontrolna","Suma_kontrolna - hasło w polskiej Wikipedii","Sumy kontrolne","Tarkistussumma ? Wikipedia","Tarkistussumma-artikkeli Wikipediassa","Verificar su integridad","WIKIPEDIA checksum","Was ist eine Prüfsumme?","What is a checksum?","Wiki on checksum","Wikipedia (Checksum)","Wikipedia - Checksumme","Wikipedia : チェックサム","Wikipedia Checksum article","Wikipedia Suma de verificación","Wikipedia article Check sum","Wikipedia article Checksum","Wikipedia article Checksums","Wikipedia article Controlecijfer","Wikipedia article Giá trị tổng kiểm","Wikipedia article Integrity check value","Wikipedia article Kontrolesom","Wikipedia article Kontrollsumma","Wikipedia article Kontrolný súčet","Wikipedia article Kontrolsum","Wikipedia article Soma de verificação","Wikipedia article Somme de contrôle","Wikipedia article Suma de verificación","Wikipedia article about Checksum","Wikipedia article on Check sum","Wikipedia article on Checksum","Wikipedia article on Checksums","Wikipedia article on Suma de verificación","Wikipedia article Контролна сума","Wikipedia article Контрольная сумма","Wikipedia article סיכום ביקורת","Wikipedia artikel Checksum","Wikipedia artikel Controlecijfer","Wikipedia artikel Controlegetal","Wikipedia di sobre checksums","Wikipedia entry for Checksum","Wikipedia kaže o checksumova","Wikipedia l'articolo Checksum","Wikipedia sagt über Prüfsummen","Wikipedia saka par kontrolsummas","Wikipedia says about checksums","Wikipedia sağlama diyor","Wikipedia spune despre sumele de control","Wikipedia sur Bit de parité","Wikipedia sur Vérification de somme","Wikipedia zegt over checksums","Wikipedia ütleb kontrollimisel","Wikipedia λέει για checksums","Wikipedia(DE): Pr%C3%BCfsumme","Wikipedia(EN): Checksum","Wikipedia-Artikel Checksum","Wikipedia-Artikel Checksumme","Wikipedia-Artikel Prüfsumme","Wikipedia-Artikel Prüfsummenverfahren","Wikipedia-Prüfsumme Verweis","Wikipedia-Seite zu 'Checksum'","Wikipedia-Seite zu 'Checksumme'","Wikipedia-Seite zu 'Prüfsumme'","Wikipedia-Seite zu 'Prüfsummenverfahren'","Wikipedia.org/wiki/Checksum","Wikipedia: Checksum","Wikipedia: Prüfsumme","Wikipedia: Prüfsumme (Checksumme)","Wikipedia:Sjekksum","Wikipedia:チェックサム","Wikipedia（チェックサム）","Wikipédia - Checksum","Wikipédia : Somme de contrôle","Wikipédia artigo Checksum","[2] Fletcher's checksum","a checksu","a checksum","af:Kontrolesom","algorithme de checksum","algoritma checksum","algoritmo de checksum","algoritmo di checksum","an article on the topic","ar:تدقيق مجموع","article Checksum","artículo de Wikipedia Checksum","artículo de Wikipedia Suma de verificación","autovérification par chiffre de contrôle","bg:Контролна сума","bit de parité","bit de parité (wikipedia)","bits de parité","ca:Checksum","check sum","check-summed","checksum - Wikipedia, the free encyclopedia","checksum algorithm","checksum algorithms","checksum e","checksum is","checksum o","checksum o suma de verificación","checksum of the file","checksum program","checksum simple english wikipedia the encyclopedia","checksum tramite una funzione di hash crittografico(MD5","checksum w","checksum wikipedia the free encyclopedia","checksum y","checksum yang","checksum के","checksum's","checksum,","checksum, d","checksum.","checksum;","checksumbytes","checksumcontrole o","checksumman","checksummed","checksumming","checksumprogramma","checksums,","checksumy","cheksum","ckecksum","confirms the validity","controlecijfers","controlegetal","controlenummer","cryptographic hash sum","cs:Kontrolní součet","cyfra kontrolna","cyfry kontrolne","cyfrykontrolne","cyfrą kontrolną","cyfrę kontrolną","código detector de erros","da:Kontrolsum","de référence de contrôle Wikipédia","de.wikipedia.org/wiki/Checksum","de.wikipedia.org/wiki/Prüfsumme","de.wikipedia.org: Prüfsumme","de:Prüfsumme","dice Wikipedia sobre las sumas de comprobación","diferentes chechsums y hashes","diu la Viquipèdia sobre les sumes de comprovació","dokumenta nospieduma","e check summed","e checksum","e somme de contrôle","ellenőrzőösszeg","ellenőrzőösszeg (hash)","ellenőrzőösszeget","ellenőrzőösszeggel","en.wikipedia.org/ wiki/","en.wikipedia.org/Checksum","en.wikipedia.org/wiki/Checksum","en.wikipedia.org/wiki/Checksums","en:Checksum","en:Integrity check value","erro de soma","es.wikipedia.org/wiki/Checksum","es:Suma de verificación","este artículo en Wikipedia que esta en castellano","et:Kontrollsumma","f checksum","f checksums","fa:چکسام","fi:Tarkistussumma","foutcontrole","foutdetecterende code","fr:Somme de contrôle","g checksums","generazione di un checksum","giá trị tổng kiểm","hash string","hashelve","have 7","he:סיכום ביקורת","hecksum","hovorí Wikipedia o kontrolné súčty","http://af.wikipedia.org/wiki/Kontrolesom","http://cs.wikipedia.org/wiki/Kontroln%C3%AD_sou","http://de.wikipedia..../Pr%C3%BCfsumme","http://de.wikipedia.org/wiki/Checksum","http://de.wikipedia.org/wiki/Checksumme","http://de.wikipedia.org/wiki/Pr %C3%BCfsumme","http://de.wikipedia.org/wiki/Pr%C3%BCfsumme","http://de.wikipedia.org/wiki/Pr%C3%BCfsummenverfahren","http://de.wikipedia.org/wiki/Prüfsumme","http://en.wikipedia.org/wiki/Check_sum","http://en.wikipedia.org/wiki/Checks","http://en.wikipedia.org/wiki/Checksu...or_parity_word","http://en.wikipedia.org/wiki/Checksum","http://en.wikipedia.org/wiki/Checksum#P ... arity_word","http://en.wikipedia.org/wiki/Checksum#Parity_byte_or_parity_word","http://en.wikipedia.org/wiki/Checksum#Parity_byte_or_parity_word...","http://en.wikipedia.org/wiki/Checksum#Pa…","http://en.wikipedia.org/wiki/Checksum)","http://en.wikipedia.org/wiki/Checksum]","http://en.wikipedia.org/wiki/Checksums","http://en.wikipedia.org/wiki/Integrity_check_value","http://es.wikipedia.org/wiki/Checksum","http://es.wikipedia.org/wiki/Checksum.","http://es.wikipedia.org/wiki/Suma_de_verificaci%C3%B3n","http://es.wikipedia.org/wiki/Suma_de_verificación","http://et.wikipedia.org/wiki/Kontrollsumma","http://fi.wikipedia.org/wiki/Tarkistussumma","http://fr.wikipedia.org/wiki/Bit_de_...de_parit.C3","http://fr.wikipedia.org/wiki/Bit_de_parit%C3%A9","http://fr.wikipedia.org/wiki/Checksu..._cryptographie","http://fr.wikipedia.org/wiki/Checksum","http://fr.wikipedia.org/wiki/Somme [...] tilisation","http://fr.wikipedia.org/wiki/Somme_de_contr%C3%B4le","http://fr.wikipedia.org/wiki/Somme_de_contrôle","http://hu.wikipedia.org/wiki/Ellenőrzőösszeg","http://it.wikipedia.org/wiki/Checksum","http://ja.wikipedia.org/wiki/チェックサム","http://nl.wikipedia.org/wiki/Checksum","http://nl.wikipedia.org/wiki/Controlecijfer","http://no.wikipedia.org/wiki/Sjekksum","http://pl.wikipedi...ki/Suma_kontrolna","http://pl.wikipedia..../wiki/Suma_kontrolna","http://pl.wikipedia.org/wiki/Cyfra_kontrolna","http://pl.wikipedia.org/wiki/Suma_kontrolna","http://pt.wikipedia.org/wiki/Checksum","http://pt.wikipedia.org/wiki/Soma_de...a%C3","http://pt.wikipedia.org/wiki/Soma_de_verifica%C3%A7","http://ru.wikipedia....нтрольная_сумма","http://ru.wikipedia.org/wiki/Контрольная_сумма","http://sk.wikipedia.org/wiki/Kontroln%C3%BD_s","http://sv.wikipedia.org/wiki/Checksumma","http://sv.wikipedia.org/wiki/Kontrollsumma","http://sv.wikipedia.org/wiki/Kontrollsummor","http://tinyurl.com/2pngwq","hu:Ellenőrzőösszeg","ihrer Prüfsumme und","integridad del archivo consiste a calcular una","integrity checks","is checked with a very long string of","is:Prófsumma","it:Checksum","ja:チェックサム","kata Wikipedia tentang checksum","kiểm tra tổng","ko:체크섬","kontrola integrity spracovaných","kontrollsumma","kontrollsummor","kontrolno vsoto","kontrolného súčtu","kontrolní","kontrolních součtů","kontrolný súčet","kontrolnými súčtami","kontrolsum","l'article de Wikipédia Checksum","l'article de Wikipédia Somme de contrôle","le contrôle d'erreurs appelé bit de parité","liczby kontrolnej","mond ellenőrző Wikipedia","n checksum;","nl:Controlecijfer","no:Sjekksum","page on checksums","periodic file integrity checks using checksums(aka Scrubbing","pl.wikipedia.org/wiki/Cyfra_kontrolna","pl:Suma kontrolna","please see this Wiki document about checksums","position-dependent checksum","programma di controllo delle somme,","pt:Soma de verificação","re checksummed","redundante informatie","referência checksum wikipedia","ru.wikipedia.org/wiki/Контрольная_сумма","ru:Контрольная сумма","sağlama toplamı","simple checksum algorithms","simple:Checksum","sjekksum","sjekksummer","sk:Kontrolný súčet","soma de verificação","soma para checagem de erros","somas de verificação","somme ce contrôle","somme de contr´#le <3>","somme di controllo","sommes de","sommes de contrôle","sommes de contrôles","spune Wikipedia despre sumele de control","sum kontrolnych","suma de","suma de verificacion","suma de verificación","suma de verificación (leer más)","suma kontrolna","sumas de verificación","sumas de verificación (checksum)","sumy kontrolnej","sv:Kontrollsumma","tarkistussummat","testi di controllo","the current one on Wikipedia","this Wikipedia entry on checksums","thuật toán checksum","traduction proposée sur Wikipédia","tổng kiểm","tổng kiểm tra","uk:Контрольна сума","un checksum","valid checksums","verificador de sumas","verificar a integridade de dados","vi:Giá trị tổng kiểm","vérification de somme","whats a programs checksum?","wiki:Контрольная_сумма","wikipedia checksum","wikipedia checksum di riferimento","wikipedia checksum reference","wikipedia checksum referensi","wikipedia checksum tham khảo","wikipedia de referencia de control","wikipedia.org: Checksum","wikipedia:Checksum","wikipedia:チェックサム","zh:校验和","«Контрольна сума»","«контрольная сумма»","ВикипедиЯ - Контрольная сумма","Википедии статью Контрольная сумма","Контольная сумма описание","Контролна сума","Контрольна сума","Контрольная сумма — Википедия","Контрольная сумма.","Контрольной","Контрольные суммы","Контрольные суммы образа","Контрольные суммы:","Ответ описан здесь","Педивикия/Checksum","Хэш сумма","контролна сума","контрольная ссылка Википедии","контрольная хэш сумма","контрольная_сумма","контрольних сум","контрольной","контрольной суммой","контрольную алгоритма","контрольным суммам","рулит...","что за контрольные суммы[/post],","וויקפדיה אנגלית","ויקיפדיה - 'סיכום ביקורת'","ויקיפדיה אומרת על בדיקות סיכום","להמשך הקריאה על סיכום ביקורת – קרדיט לויקיפדיה","סיכום ביקורת","סיכום ביקורת – ויקיפדיה","تدقيق مجموع","تدقيق مجموع - ويكيبيديا، الموسوعة الحرة","وللاستزآدة","يتحقق من المجاميع","چکسام","چکسام - ویکیپدیا","विकिपीडिया चेकसमों बारे में कहते हैं","চেকসাম","การตรวจสอบ","วิธีการตรวจสอบ","อ้างอิงการตรวจสอบวิกิพีเดีย","“Checksum - Wikipedia, the free encyclopedia”, en.wikipedia.org","„Prüfsumme“","„Weblinks“","※チェックサム通信などで使われる誤り検出の手法","「チェックサム」をWikipediaで調べる","『チェックサム』の解説","の代わりに（","ウィキペディアのチェックサムを参照","ウィキペディアの記事 チェックサム","ウィキペディアはチェックサムについて語ります","チェックサム (wikipediaへのリンク)","チェックサム - Wikipedia","チェックサムとは","チェックサムを","チェックサムエラー","チェックサム（check sum）とは、簡易な誤り検出に用いられるアルゴリズムのこと","校驗和","校驗和算法","校验值","校验和","校验和算法","検査数字","的校驗","的校验","維基百科校驗參考","維基百科的文章“ 校验和”","維基百科說，大約校驗","維基說關於校驗","维基百科校验参考","维基百科的文章“ 校验和”","说，关于维基百科校验","디스크의","위키백 체크섬에 대해 말합니다","위키백과 (Wikipedia)가 체크섬에 대해 말합니다","위키백과 체크섬 참조","체크섬 - 위키백과, 우리 모두의 백과사전","체크섬 알고리즘을","체크섬을","ﾁｪｯｸｻﾑ-wikipedia"],"name":"Checksum","categories":["All articles needing additional references","Articles needing additional references from August 2012","Checksum algorithms"],"tag_line":"A checksum or hash sum is a small-size datum from a block of digital data for the purpose of detecting errors which may have been introduced during its transmission or storage."}}
,{"_index":"throwtable","_type":"algorithm","_id":"luhn-algorithm","_score":0,"_source":{"description":"The Luhn algorithm or Luhn formula, also known as the \"modulus 10\" or \"mod 10\" algorithm, is a simple checksum formula used to validate a variety of identification numbers, such as credit card numbers, IMEI numbers, National Provider Identifier numbers in the US, and Canadian Social Insurance Numbers. It was created by IBM scientist Hans Peter Luhn and described in U.S. Patent No. 2,950,048, filed on January 6, 1954, and granted on August 23, 1960.\nThe algorithm is in the public domain and is in wide use today. It is specified in ISO/IEC 7812-1. It is not intended to be a cryptographically secure hash function; it was designed to protect against accidental errors, not malicious attacks. Most credit cards and many government identification numbers use the algorithm as a simple method of distinguishing valid numbers from mistyped or otherwise incorrect numbers.","alt_names":["the examples","mod 10","Luhn","Luhn Algorithm","'Luhn Check' algorithm","(http://en.wikipedia.org/wiki/Luhn_algor ithm).","- Luhn algorithm :","...Wikipedia Algorytm Luhna","...Wikipedia Formula di Luhn","...Wikipedia Formule de Luhn","...mehr auf Wikipedia über Luhn-Algorithmus","...more on Wikipedia about Luhn algorithm",".Wikipedia.org","1 Dane podstawowe","1 Informal explanation","1.1 Przykład","2 Implementacja","5 Other implementations",": http://en.wikipedia.org/wiki/Luhn_algorithm, an","Algoritma Luhn","Algoritma Luhn dijelaskan di Wikipedia","Algoritmo Luhn","Algoritmo de Luhn","Algoritmul de validare Luhn","Algoritmus Luhn","Algorytm Luhn","Algorytm Luhna","Algorytm Luhna – Wikipedia, wolna…","Beispielimplementierungen","Check it and see","Chiffre Luhn","Double-Add-Double-Methode","Entrada da Wikipedia sobre o algoritmo Luhn","FileMaker Funcions personalitzades","Formula di Luhn","Formule de Luhn","Formule de Luhn - Wikipédia","Informelle Erläuterung","Internal Verification System","Its calculation (by the Luhn algorithm) is described","Kontrolní Luhn","L'algorithme de Luhn","L'algorithme de Luhn ou la formule de","L'entrée de Wikipédia sur l'algorithme Luhn","LUHN","LUHN Algorithm","LUHN For","LUHN Formula","LUHN algorithm","LUHN algorithm or formula","LUHN algorithm.","LUHN algoritme","LUHN algoritmo","LUHN check","LUHN ellenőrző szám","LUHN verification","LUHN алгоритъм","LUHN 알고리즘을","LUHN-10","LUHN-10 checksum","LUHN/MOD10 check","LUHN10","LUHN式（モジュラス10チェック）","La entrada de Wikipedia sobre el algoritmo de","La formula di Luhn","Learn about Luhn algorithm>>>","Lhun-Checker","Lonh Algorithm","Luhn (mod 10) checksum","Luhn (mod10)","Luhn Algorith – click here","Luhn Algorithm (aka Mod 10 Algorithm)","Luhn Algorithm - Wikipedia","Luhn Algorithm - first pass Credit Card Number Validation","Luhn Algorithm Wikipeda Entry","Luhn Algorithm at Wikipedia","Luhn Algorithm described on Wikipedia","Luhn Algorithm.","Luhn Algorithms Informal Explanation","Luhn Algorithmus","Luhn Algorithmus auf Wiki","Luhn Algorithum","Luhn Algoritması","Luhn Algoritme","Luhn Check","Luhn Check Digit Algorithm","Luhn CheckSum","Luhn Checking Algorithm","Luhn Formel (Modul 10 Check)","Luhn Formula","Luhn Mod-10","Luhn Modulus 10 Algorithmus","Luhn Number","Luhn Prüfsumme","Luhn Thuật toán được mô tả trên Wikipedia","Luhn agorithm","Luhn algorithim","Luhn algorithm","Luhn algorithm (Wikipedia)","Luhn algorithm - Credit Card Validation","Luhn algorithm - Modulus 10","Luhn algorithm - Wikipedia","Luhn algorithm - Wikipedia :: The free encyclopedia","Luhn algorithm - Wikipedia, the free encyclop...","Luhn algorithm - Wikipedia, the free encyclopedia","Luhn algorithm - Wikipedia,...","Luhn algorithm @ Wikipedia","Luhn algorithm Click to visit","Luhn algorithm Wikipedia the free encyclopedia","Luhn algorithm at Wikipedia","Luhn algorithm – Wikipedia, the free encyclopedia","Luhn algorithm.","Luhn algorithm: Strengths and weaknesses","Luhn algorithme","Luhn algorithme décrit sur Wikipedia","Luhn algoritma","Luhn algoritme","Luhn algoritmen","Luhn algoritmo","Luhn algoritmo descrito en Wikipedia","Luhn algoritmo descrito na Wikipedia","Luhn algoritmo descritto su Wikipedia","Luhn algoritmu","Luhn algoritmus","Luhn algorytm","Luhn check","Luhn check Algorithm","Luhn check digit","Luhn check digit”","Luhn checksum","Luhn checksum algorithm","Luhn checksums","Luhn fail","Luhn formel (Modulus 10 check)","Luhn formel (Modulus 10 kontroll)","Luhn formel (modulus 10 check)","Luhn formelen (Modulus 10 kontroller)","Luhn formelen (Modulus 10 sjekk)","Luhn formula","Luhn formula (Modulus 10 check)","Luhn formula (Modulus 10 tseke)","Luhn formula (Modulus 10 tseke).","Luhn formulas (modulis 10 pārbaude)","Luhn formule (Modulus 10 check)","Luhn formuli (modul 10 provjera)","Luhn formulu (modulis 10 pārbaude)","Luhn formulu (modulis 10 pārbaude).","Luhn formúlu (stuðull 10 stöðva)","Luhn formülü (Mod 10 kontrol)","Luhn formülü (Modulus 10 kontrol)","Luhn kaavan (moduuli 10 check)","Luhn kontrolü","Luhn képlet (modulus 10 ellenőrzés)","Luhn képlettel","Luhn mod 10 algorithm","Luhn mod-10 checksum","Luhn or Mod-10 algorithm","Luhn test","Luhn thuật toán","Luhn valem (Taivutusvetolujuus 10 kontroll)","Luhn valemit (Moodul 10 sündmused).","Luhn validation","Luhn validity","Luhn vzorca (Modul 10 check)","Luhn vzorce (Modul 10 check)","Luhn wzoru (Moduł 10 check)","Luhn Алгоритм","Luhn алгоритму, описанному в Википедии","Luhn एल्गोरिथ्म","Luhn फार्मूला (Modulus 10 की जांच)","Luhn सूत्र (मापांक 10) की जाँच करें","Luhn ขั้น ตอน วิธี ที่ อธิบาย ไว้ ใน","Luhn 수식 (계수 10 수표)","Luhn 알고리즘","Luhn 알고리즘과","Luhn 알고리즘에 대한 위키 피 디아의 항목은","Luhn 알고리즘을","Luhn 위키 피 디아에서 설명한 알고리즘","Luhn'o formulė","Luhn's","Luhn's Algm for validation of credit card numbers","Luhn's Algorithm","Luhn's Algrothim","Luhn's algorithm","Luhn's algoritm","Luhn's formula","Luhn, sau modulo 10","Luhn-Algorithmus","Luhn-Algorithmus - Wikipedia","Luhn-Algorithmus Wikipedia","Luhn-Algorithmus auf Wiki","Luhn-Algorithmus beschrieben auf Wikipedia","Luhn-Algorithmus – Wikipedia","Luhn-Algorithmus.","Luhn-Formel (Modulo 10) überprüfen","Luhn-Formel - Wikipedia","Luhn-Prüfzahl","Luhn-algoritmen","Luhn-formula","Luhn/Mod-10","Luhn/mod10 algorithm","Luhn10","Luhn_algorithm","Luhnalgorithm","Luhnin algoritmi","Luhnovim","Luhnproef","Luhnův algoritmus","Luhnův algoritmus - Wikipedie","Luhnのアルゴリズム","Luhnアルゴリズム","Luhnアルゴリズム - Wikipedia","Luhnアルゴリズム - Wikipedia »","Luhnアルゴリズムに関するWikipediaのエントリ","Luhnアルゴリズム項目説明","Luhn算法","Luhnｱﾙｺﾞﾘｽﾞﾑ-wikipedia","Lunh algorithm","Lunh's Algorithm","MOD 10","MOD 10 = Luhn","MOD10","MOD10 - Wikipedia","MOD10 Prüfsumme","MOD10 checksum","MOD10 de contrôle","MOD10-algoritmen","Mod 10","Mod 10 algorithm","Mod 10 rule (Luhn alogirthm)","Mod 10+5 Variant","Suggested: luhn algorithm","The Luhn Algorithm","The Luhn Mod-10 Method","The Luhn algorithm","The Luhn hash","This was a problem solved at IBM back","Voce di Wikipedia sulla algoritmo Luhn","Wiki Formule de Luhn","Wiki article on Luhn Algorithm which is a","Wikipedia (Luhn algorithm)","Wikipedia - Luhn","Wikipedia - MOD10","Wikipedia Eintrag auf der Luhn-Algorithmus","Wikipedia about the Luhn algorithm","Wikipedia article Luhn","Wikipedia article Luhn algorithm","Wikipedia article Luhn formula","Wikipedia article Luhn-Algorithmus","Wikipedia article MOD10","Wikipedia article on Luhn","Wikipedia article on the Luhn algorithm","Wikipedia entri pada algoritma Luhn","Wikipedia entry for Luhn algorithm","Wikipedia explanation of the Luhn formula","Wikipedia indtræden på Luhn algoritme","Wikipedia intrede op de Luhn algoritme","Wikipedia je vstup na algoritmus Luhn","Wikipedia tiếng Việt nhập cảnh trên thuật toán","Wikipedia's entry on the Luhn algorithm","Wikipedia-Artikel Luhn-Algorithmus","Wikipedia-Artikel Luhn-Formel","Wikipedia-Eintrag über die Luhn-Algorithmus","Wikipedia-Seite zu 'Luhn-Algorithmus'","Wikipedia:MOD10","Wikipediaで「Luhnアルゴリズム」を調べる","Wikipedie - Luhn algorithm","[14] (2008) Luhnov algoritem. Dostopno na: h","[Luhn Algorithm Implementation]","[Wikipedia] Luhn algorithm","a Luhn code","a very simple algorithm","a “mod 10″ check","algorithme Luhn","algorithme de Luhn","algoritma LUHN.","algoritma Luhn","algoritma Luhn.","algoritmo LUHN","algoritmo LUHN.","algoritmo Luhn","algoritmo Luhn.","algoritmo de LUHN","algoritmo de Luhn","algoritmo de Luhn.","algoritmo di Luhn","algoritmo di luhn (wikipedia)","algoritmo mod10 o Luhn","algoritmu LUHN","algoritmul Luhn","algoritmus szerint kiszámított","algorytm Luhn","algorytm Luhna","algorytmu Luhn","algorytmu Luhna","algorítimo de Luhn","also known as a Luhn","as required by the algorithm","check-digit","checksum Luhn","checksum mod10","clé de Luhn","condition de validité","create valid credit card numbers","cs:Luhnův algoritmus","công thức Luhn (Modulus 10 kiểm tra)","công thức Luhn (Mô-đun 10 kiểm tra","de control Luhn","de:Luhn-Algorithmus","del resto de dividir por 10","deze controle","dodatkowym wariancie","el algoritmo de Luhn","en.wikipedia.org/...Luhn_algorithm","en.wikipedia.org/wiki/Luhn","en.wikipedia.org/wiki/Luhn_algorithm","fi:Luhnin algoritmi","foirmle Luhn (modulus 10 seiceáil)","folmula di Luhn","formola Luhn (Modulus 10 verifika)","formula Luhn (Modul 10 Ora de check)","formula Luhn (Modulo 10 di controllo).","formula Luhn (modulul 10 Ora de check)","formula di Luhn","formula di Luhn (Modulo 10 di controllo)","formule de Luhn (coefficient 10)","formulën Luhn (Modulus 10 kontrolloni)","formulën Luhn (Modulus 10 kontrolloni).","fr.wikipedia.org/wiki/Formule_de_Luhn","fr:Formule de Luhn","fórmula Luhn (Mòdul 10 de verificació)","fórmula Luhn (Módulo 10 check)","fórmula Luhn (Módulo 10 de verificación)","fórmula Luhn (Módulo 10) testemuña.","fórmula Luhn (Módulo de comprobar 10)","fórmula Luhn (mòdul 10 de verificació)","fórmula Luhn (módulo 10 de verificación)","fórmula Luhn (módulo de selección 10)","fórmula Luhn (módulo de seleção 10)","fórmula de Luhn (Mòdul 10 de verificació).","generic credit card check sum","giải thuật Luhn","how the algorithm works","http://alturl.com/j9bi","http://bit.ly/9510El","http://cs.wikipedia.org/wiki/Luhn%C5%AFv_algoritmus","http://de.wikipedia.org/wiki/Luhn-Algori","http://de.wikipedia.org/wiki/Luhn-Algorithmus","http://de.wikipedia.org/wiki/Luhn-Algorithmus#PHP","http://de.wikipedia.org/wiki/Luhn-Formel","http://en.wikipedi... Luhn algorithm - Wikipedia, the free","http://en.wikipedia..../Luhn_algorithm","http://en.wikipedia....mal_explanation","http://en.wikipedia.org/wiki/Luh...","http://en.wikipedia.org/wiki/Luhn","http://en.wikipedia.org/wiki/Luhn algorithm","http://en.wikipedia.org/wiki/Luhn% 5Falgorithm","http://en.wikipedia.org/wiki/Luhn%5Falgorithm","http://en.wikipedia.org/wiki/Luhn_algori","http://en.wikipedia.org/wiki/Luhn_algori...","http://en.wikipedia.org/wiki/Luhn_algorith","http://en.wikipedia.org/wiki/Luhn_algorithm","http://en.wikipedia.org/wiki/Luhn_algorithm#Implementation_of_standard_Mod_10","http://en.wikipedia.org/wiki/Luhn_algorithm).","http://en.wikipedia.org/wiki/Luhn_algorithm.","http://en.wikipedia.org/wiki/Luhn_algorithm>","http://en.wikipedia.org/wiki/Luhn_algori…","http://en.wikipedia.org/wiki/Luhn_formula","http://en.wikipedia.org/wiki/Luhn_formul…","http://fr.wikipedia....Formule_de_Luhn","http://fr.wikipedia.org/wiki/Formule_de_Luhn","http://fr.wikipedia.org/wiki/Luhn","http://it.wikipedia.org/wiki/Formula_di_Luhn","http://j.mp/gqKNcb","http://ja.wikipedia.org/wiki/Luhn%E3%82","http://no.wikipedia.org/wiki/MOD10","http://pl.wikipedia.org/wiki/Algorytm_Luhna","http://r.sm3.jp/2hb0","http://ru.wikipedia.org/wiki/Алгоритм_Луна","http://sv.wikipedia....Luhn-algoritmen","http://sv.wikipedia.org/wiki/Luhn-algoritmen","http://sv.wikipedia.org/wiki/Luhn-algoritmen#Groovy","http://sv.wikipedia.org/wiki/Luhn-algoritmen#VBA","hu:Luhn-formula","informal explanation of the algorithm","invented by Hans Luhn","it:Formula di Luhn","ja:Luhnアルゴリズム","kontrollsiffra","kontrolna Luhn","l'algo de luhn","l'algorithme Lühn.","l'algorithme de Luhn","l'algorithme de Luhn (module 10)","l'algorithme de Luhn.","l'algoritmo Luhn","l'algoritmo Luhn.","l'article de Wikipédia Luhn","la entrada de Wikipedia sobre el algoritmo de","la formule de Luhn","learned how the checksum works","les explications de wikipédia","lgoritmo de Luhn","lt:Luhn'o formulė","luhn","luhn algorithm","luhn check","luhn checksum algorithm","mod 10 algorithm","mod 10 checksum","mod-10","mod10","mod10 Checksum","mod10 Prüfsumme","mod10 checksum","mod10 control","mod10 di controllo","mod10 kiểm tra","mod10 suma de comprobación","mod10 체크섬","mod10-Prüfsumme","mod10チェックサム","mod10校驗","mod10校验","modulus 10","mogen för det","no:MOD10","pl:Algorytm Luhna","poměrně jednoduchém číselném algorytmu","popularny algorytm matematyczny","ru.wikipedia.org: Алгоритм Луна","ru:Алгоритм Луна","rumus Luhn (Modulus 10 cek)","single check digit","sv:Luhn-algoritmen","the Luhn algorithm","the Luhn algorithm used to validate credit card","the Wikipedia on Luhn","the algorithm listed on this Wiki page","the credit-card-number validation algorithm","this is how you can check that it's","this is what freaky is talking about?","thuật toán LUHN.","thuật toán Luhn","thuật toán Luhn.","ttp://en.wikipedia.org/wiki/Luhn_algorithm","using the Luhn checksum algorithm","valid credit car number","verify the credit card using Luhn","vzorca Luhn (Modul 10 check)","vzorce Luhn (Modul 10 check)","vzorci Luhn (Modul 10 check)","w:Formule de Luhn","wikipedia's explanation of the Luhn algorithm","wpis w Wikipedii algorytm Luhn","wzorem Luhn (moduł 10 kontroli)","wzorem Luhna (Moduł 10 Zameldowanie)","» l'algorithme de Luhn (module 10)","Ð Ð»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼ Ð›ÑƒÐ½Ð","è voce di Wikipedia su l'algoritmo Luhn","αλγόριθμο Luhn","αλγόριθμος του Luhn","τύπο Luhn (Μέτρο 10 έλεγχος)","Алгоритм Лун","Алгоритм Луна","Алгоритм Луна - проверка контрольного разряда БПК и др","Алгоритм Луна вЂ” Википедия","Алгоритм Луна — Википедия","Алгоритму Луна","Википедии - Луна","Лун алгоритм","Лухн формулу (Модул 10 проверити)","Лухн формулу (модул 10 чек)","Статью Википедии по алгоритму Luhn","алгоритм Luhn'a","алгоритм Луна","алгоритм проверки корректности числа Луна (Luhn)","алгоритма Luhn.","алгоритма Лун","алгоритмом Luhn","алгоритмом Луна","алгоритму Luhn","алгоритму Луна","алгоритму Параселена","контрольную Лун","простому алгоритму","формула Luhn","формула Luhn (модул 10 провериш)","формула Luhn (модул 10 проверка)","формулата Luhn (Модул 10 проверка)","формулата Luhn (модул 10 проверка)","формуле Лун (Модуль 10 праверкі)","формуле Лун (Модуль 10 проверки)","формуле Лун (модуль 10 праверка)","формуле Лун (модуль 10 праверкі)","формуле Лун (модуль 10 проверки)","формулі Лун (модуль 10 перевірки)","הנוסחה Luhn (מודולוס 10 לבדוק)","صيغة Luhn (10 معامل الاختيار)","فرمول Luhn (مدول 10 بررسی)","මෙතනින් ලබාගන්න","ขั้น ตอน วิธี LUHN.","ขั้น ตอน วิธี Luhn","ขั้น ตอน วิธี Luhn.","รายการ วิ กิ พี เดีย ใน ขั้น ตอน","วิกิ -- Luhn","สูตร Luhn (โมดูลัส 10 การตรวจสอบ)","สูตร Luhn (โมดูลัส 10 ตรวจสอบ)","“Luhn algorithm - Wikipedia, the free encyclopedia”, en.wikipedia","、Luhnアルゴリズム","ウィキペディア-ルーンを","チェックデジットの計算くらい","ルーンの","ルーンのアルゴリズムは、","ルーンアルゴリズムを","ルーン式（モジュラス10チェック）","割ったあまりのチェックサムを","割ったあまりアルゴリズム","卢恩公式（模数10个检查）","卢恩在维基百科中描述的算法","卢恩算法","式（係数10チェック） 。","盧恩公式（模數10個檢查）","盧恩公式（模數10入住）","盧恩在維基百科中描述的算法","盧恩算法","維基百科-盧恩","維基百科條目的Luhn算法","维基百科-卢恩","维基百科对Luhn算法进入","维基百科的项目就卢恩算法","상세계산방법","수식 (10 계수 검사) .","위키백과 - Luhn을"],"name":"Luhn algorithm","categories":["Articles with example Python code","Checksum algorithms","Error detection and correction","Modular arithmetic"],"tag_line":"The Luhn algorithm or Luhn formula, also known as the \"modulus 10\" or \"mod 10\" algorithm, is a simple checksum formula used to validate a variety of identification numbers, such as credit card numbers, IMEI numbers, National Provider Identifier numbers in the US, and Canadian Social Insurance Numbers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"adler-32","_score":0,"_source":{"description":"Adler-32 is a checksum algorithm which was invented by Mark Adler in 1995, and is a modification of the Fletcher checksum. Compared to a cyclic redundancy check of the same length, it trades reliability for speed (preferring the latter). Adler-32 is more reliable than Fletcher-16, and slightly less reliable than Fletcher-32.","alt_names":["http://ja.wikipedia.org/wiki/Adler-32","- Adler-32 :","-> Read more about Adler-32","...mehr auf Wikipedia über Adler-32","...more on Wikipedia about Adler-32","ADLER-32 algorithm","ADLER32","Adler - 32","Adler 32","Adler 32 checksum algorithm","Adler checksum","Adler or Adler32","Adler-32","Adler-32 - Wikipedia","Adler-32 - Wikipedia :: The free encyclopedia","Adler-32 - Wikipedia, the free encyclopedia","Adler-32 Wikipedia article","Adler-32 bei der wikipedia","Adler-32 checksum","Adler-32 checksumming","Adler-32 on wikipedia.org","Adler-32 wiki","Adler-32 |","Adler-32 – Wikipedia","Adler-32 – Wikipedia, the free encyclopedia","Adler-32 – Wikipedia, wolna encyklopedia","Adler-32 — Википедия","Adler32","Adler32 algorythim","Adler32 checksum","Adler32 dans la Wikipedia","Adler32 di Wikipedia","Adler32 en la Wikipedia","Adler32 in Wikipedia","Adler32 in der Wikipedia","Adler32 in the Wikipedia","Adler32 na Wikipédia","Adler32 trong Wikipedia tiếng Việt","Adler32 в Википедии","Adler32 ใน วิ กิ พี เดีย","Adler32 위키백과에","Adler32.","Adler32は、","Adler32ウィキペディア内の","Adler32在維基百科","Adler32在维基百科","Adler32는","Adler32를","Algoritmen på engelska wikipedia","Beispiel-Implementierung in der Wikipedia","Comparison with the Fletcher checksum","What is the history of Adler-32","Wikipedia article Adler checksum","Wikipedia article Adler-32","Wikipedia article Adler32","Wikipedia article about Adler-32","Wikipedia entry for Adler-32","Wikipedia-Artikel Adler-32","Wikipedia-Artikel Adler32","Wikipedia-Seite zu 'Adler-32'","Wikipedia: ADLER-32","Wikipediaで「Adler-32」を調べる","Wikipedia文章中的示例实现","[1] Adler-32","adler-32","adler32","adler32 checksum","adler32のは、","adler32のを","article Adler-32","attuazione esempio l'articolo di Wikipedia","de:Adler-32","eksempel implementering i Wikipedia-artiklen","en.wikipedia.org/Adler-32","en.wikipedia.org/wiki/Adler-32","example implementation in the Wikipedia article","fr:Adler-32","http://de.wikipedia.org/wiki/Adler-32","http://de.wikipedia.org/wiki/Adler32","http://en.wikipedia.org/wiki/Adler%2D32","http://en.wikipedia.org/wiki/Adler-3...implementation","http://en.wikipedia.org/wiki/Adler-32","http://en.wikipedia.org/wiki/Adler-32#Ex","http://en.wikipedia.org/wiki/Adler-32#Example_implementation","http://en.wikipedia.org/wiki/Adler-32#The_Algorithm","http://en.wikipedia.org/wiki/Adler32","http://en.wikipedia.org/wiki/Adler32#Example_implementation","http://en.wikipedia.org/wiki/Adler−32","http://en.wikipedia.org/wikiAdler-32","http://fr.wikipedia.org/wiki/Adler-32","http://pl.wikipedia.org/wiki/Adler-32","http://ru.wikipedia.org/wiki/Adler-32","http://sv.wikipedia.org/wiki/Adler-32","implementación de ejemplo en el artículo de la","invented by Mark Adler","ja:Adler-32","mis au point par Mark Adler","pl:Adler-32","příkladu provedení v článku Wikipedie","rolling Adler checksum","ru:Adler-32","sv:Adler-32","uitvoering in bijvoorbeeld het Wikipedia-artikel","weaker than CRC","wikipedia page for Adler-32","wykonania np. w Wikipedii","АДЛЕР32","Википедии статью Adler-32","пример реализации в статье Википедии","विकिपीडिया लेख उदाहरण कार्यान्वयन में","のAdler - 32","ウィキペディアの記事 Adler-32","ウィキペディアの記事の例の実装では","フレッチャーの ...","链接标记http://en.wikipedia.org/wiki/Adler-32","阿德勒- 32","애들러 - 32"],"name":"Adler-32","categories":["Checksum algorithms"],"tag_line":"Adler-32 is a checksum algorithm which was invented by Mark Adler in 1995, and is a modification of the Fletcher checksum."}}
,{"_index":"throwtable","_type":"algorithm","_id":"zeller's-congruence","_score":0,"_source":{"description":"Zeller's congruence is an algorithm devised by Christian Zeller to calculate the day of the week for any Julian or Gregorian calendar date. It can be considered to be based on the conversion between Julian day and the calendar date.","alt_names":["Zellers_Kongruenz","Zeller's congruence","Zeller's Congruence","- Zeller's Congruence :","- Zeller's congruence :","-> Read more about Zeller's congruence","-> Zellers Kongruenz","...mehr auf Wikipedia über Zellers Kongruenz","...more on Wikipedia about Zeller's congruence","30f35f4958a6c63f63cf13e6ad9a ...",": http://en.wikipedia.org/wiki/Zeller%27s congruence",": http://en.wikipedia.org/wiki/Zeller's congruence",": http://en.wikipedia.org/wiki/Zeller's_congruence","Congruencia de Zeller","Congruencia de Zeller - Wikipedia, la enciclopedia libre","Congruenza (o Algoritmo) di Zeller","Congruenza di Zeller","Congruência de Zeller","DNEH V TEDNU","Formula Tsellera","Implementation in software","Look for Fi:Zellerin sääntö","Milyen napra esett egy adott dátum?","Persamaan Zeller","What is analysis of Zeller congruence","What is analysis of Zeller congruence?","What is formula of Zeller's algorithm?","WikiPedia.ja:ツェラーの公式","Wikipedia - ツェラーの公式","Wikipedia -Zellers_Kongruenz","Wikipedia article Congruência de Zeller","Wikipedia article Zeller congruence","Wikipedia article Zeller's Congruence","Wikipedia article Zeller's algorithm","Wikipedia article Zeller's congruence","Wikipedia article Zellers Kongruenz","Wikipedia article on Congruencia de Zeller","Wikipedia erläutert ausführlich","Wikipedia ツェラーの公式","Wikipedia-Artikel Zellers Kongruenz","Wikipedia-Artikel zu Zellers Kongruenz","Wikipedia-Seite zu 'Zellers Kongruenz'","Wikipediaで「ツェラーの公式」を調べる","Wikipedia：ツェラーの公式","Wikipédia artigo Congruência de Zeller","ZELLER'S CONGRUENCE","Zeller Congruence","Zeller Kongruenz","Zeller の公式","Zeller%27s_congruence","Zeller's Algorithm","Zeller's Congruence @ wikipedia","Zeller's Congruence Algorithm","Zeller's Congruence.","Zeller's algorithm","Zeller's cgruence","Zeller's congruence - Wikipedia","Zeller's congruence - Wikipedia, the free ...","Zeller's congruence - Wikipedia, the free encyclopedia","Zeller's congruence – Wikipedia","Zeller-Algorithmus","Zellers Algorithm","Zellers Congruence","Zellers Kongruenz","Zellers Kongruenz ? Wikipedia","Zellers Kongruenz in","Zellers Kongruenz – Wikipedia","Zellers algorithm","Zellers_Kongruenz bei der wikipedia","Zellerの公式","artículo de Wikipedia Congruencia de Zeller","congruencia de Zeller","en.wikipedia.org/wiki/Zeller%27s_congruence","en.wikipedia.org/wiki/Zeller's_congruence","es.wikipedia.org/wiki/Congruencia_de_Zeller","excessively technical Wikipedia article","h = q + ( m + 1 ) 26 10 + K + K","http://de.wikipedia.org/wiki/Ze llers_Kongruenz","http://de.wikipedia.org/wiki/Zellers_Kon","http://de.wikipedia.org/wiki/Zellers_Kongruenz","http://de.wikipedia.org/wiki/Zellers_Kongruenz. . .","http://en.wikipedia....%27s_congruence","http://en.wikipedia.org/wiki/Zeller%27s_Congruence","http://en.wikipedia.org/wiki/Zeller%27s_Congruence>","http://en.wikipedia.org/wiki/Zeller%27s_congr...","http://en.wikipedia.org/wiki/Zeller%27s_congruence","http://en.wikipedia.org/wiki/Zeller%27s_…","http://en.wikipedia.org/wiki/Zeller&...on_in_software","http://en.wikipedia.org/wiki/Zeller's congruence","http://en.wikipedia.org/wiki/Zeller's_co","http://en.wikipedia.org/wiki/Zeller's_congruence","http://en.wikipedia.org/wiki/Zeller's_congruence?","http://en.wikipedia.org/wiki/Zeller's_co…","http://en.wikipedia.org/wiki/Zeller_congruence","http://es.wikipedia.org/wiki/Congruencia_de_Zeller","http://fi.wikipedia.org/wiki/Zellerin_s ... A4nt%C3","http://goo.gl/mdg5","http://ja.wikipedia.org/wiki/ツェラーの公式","n http://en.wikipedia.org/wiki/Zeller%27s","wikipedia:ツェラーの公式","wp:Zeller's_congruence","zeller の公式 - wikipedia","zellerの公式","Статья о формуле Зеллера в Википедии","Формула Целлера","「ツェラーの公式」","「ツェラーの公式」をWikipediaで調べる","ツェラー (Zeller) の公式","ツェラーの公式","ツェラーの公式 - Wikipedia","ツェラーの公式 - [Wikipedia]","ツェラーの公式 - wikipedia","ツェラーの公式 -Wikipedia","ツェラーの公式 – Wikipedia","ツェラーの公式(Zeller's congruence)","ツェラーの公式(ウィキペディア)","ツェラーの公式（Wikipedia）","ツェラーの公式：Wikipedia","日付から曜日を計算","維基百科的文章“ 蔡勒公式”","维基百科的文章“ 蔡勒公式”","蔡勒公式","蔡勒公式- Wikipedia","蔡勒公式- 维基百科，自由的百科全书","記算日期蔡勒公式","Ｗｉｋｉｐａｄｉａ ： ツェラーの公式","ﾂｪﾗｰの公式(Zeller's congruence)","ﾂｪﾗｰの公式-wikipedia"],"name":"Zeller's congruence","categories":["CS1 German-language sources (de)","CS1 Latin-language sources (la)","Calendar algorithms","Gregorian calendar","Julian calendar","Modular arithmetic"],"tag_line":"Zeller's congruence is an algorithm devised by Christian Zeller to calculate the day of the week for any Julian or Gregorian calendar date."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bees-algorithm","_score":0,"_source":{"description":"In computer science and operations research, the Bees Algorithm is a population-based search algorithm which was developed in 2005. It mimics the food foraging behaviour of honey bee colonies. In its basic version the algorithm performs a kind of neighbourhood search combined with global search, and can be used for both combinatorial optimization and continuous optimization. The only condition for the application of the Bees Algorithm is that some measure of topological distance between the solutions is defined. The effectiveness and specific abilities of the Bees Algorithm have been proven in a number of studies.\n\n","alt_names":["- Bees algorithm :","A colony of honey bees can extend itself","AnswerQuestions article on Bees algorithm","Bee's Algorithm","Bees Algorithm","Bees Algorithm Wikipedia The Free Encyclopedia","Bees algorithm","Bees algorithm - Wikipedia :: The free encyclopedia","Bees algorithm - Wikipedia, the free encyclopedia","Bees algorithm Wikipedia the free encyclopedia","Bees algorithm; it is used under the","Bees_algorithm","Definition Bees algo ... /span>","Definition Bees algorithm","Definition “Bees algorithm”","The Bees Algorithm","The foraging process in nature","Wikipedia article Bees algorithm","Wikipedia entry for Bees algorithm","bees algorithm","bees algorithm wikipedia the free encyclopedia","bees, who utilise a sophisticated method of information","en.wikipedia.org/...Bees_algorithm","en.wikipedia.org/wiki/Bees_algorithm","foraging behaviour of bees","http://en.wikiped...lgorithm","http://en.wikipedia.org/wiki/Bees_algori","http://en.wikipedia.org/wiki/Bees_algorithm","http://en.wikipedia.org/wiki/Bees_algori…","the bees algorithm","yago-res:Bees algorithm","صفحه الگوریتم زنبور عسل در ویکیپدیای انگلیسی","蜂群演算法"],"name":"Bees algorithm","categories":["Artificial intelligence","Bees","Collective intelligence","Combinatorial algorithms","Optimization algorithms and methods"],"tag_line":"In computer science and operations research, the Bees Algorithm is a population-based search algorithm which was developed in 2005."}}
,{"_index":"throwtable","_type":"algorithm","_id":"speciation-(genetic-algorithm)","_score":0,"_source":{"description":"Speciation is a process that occurs naturally in evolution and is modeled explicitly in some genetic algorithms.\nSpeciation in nature occurs when two similar reproducing beings evolve to become too dissimilar to share genetic information effectively or correctly. In the case of living organisms, they are incapable of mating to produce offspring. Interesting special cases of different species being able to breed exist, such as a horse and a donkey mating to produce a mule. However in this case the Mule is usually infertile, and so the genetic isolation of the two parent species is maintained.\nIn implementations of genetic search algorithms, the event of speciation is defined by some mathematical function that describes the similarity between two candidate solutions (usually described as individuals) in the population. If the result of the similarity is too low, the crossover operator is disallowed between those individuals.","alt_names":["Speciation (Genetic Algorithm)","Speciation (genetic algorithm)","Speciation (genetic algorithm) - Wikipedia :: The free encyclopedia","Speciation (genetic algorithm) - Wikipedia, the free encyclopedia","Speciation genetic algorithm","Speciation genetic algorithm Wikipedia the free encyclopedia","Wikipedia entry for Speciation (genetic algorithm)","http://en.wikipedia.org/wiki/Speciation_%28genetic_algorithm%29","http://en.wikipedia.org/wiki/Speciation_(genetic_algorithm)","yago-res:Speciation_(genetic_algorithm)"],"name":"Speciation (genetic algorithm)","categories":["All articles lacking sources","Articles lacking sources from December 2007","Evolutionary algorithms","Genetic algorithms"],"tag_line":"Speciation is a process that occurs naturally in evolution and is modeled explicitly in some genetic algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"top-nodes-algorithm","_score":0,"_source":{"description":"The top-nodes algorithm is an algorithm for managing a resource reservation calendar.\nIt is used when a resource is shared among lots of users (for example bandwidth in a telecommunication link, or disk capacity in a large data center).\nThe algorithm allows\nto check if an amount of resource is available during a specific period of time,\nto reserve an amount of resource for a specific period of time,\nto delete a previous reservation,\nto move the calendar forward (the calendar covers a defined duration, and it must be moved forward as time goes by).","alt_names":[],"name":"Top-nodes algorithm","categories":["All articles covered by WikiProject Wikify","All articles with too few wikilinks","Articles covered by WikiProject Wikify from December 2012","Articles with French-language external links","Articles with too few wikilinks from December 2012","Calendar algorithms","Scheduling algorithms"],"tag_line":"The top-nodes algorithm is an algorithm for managing a resource reservation calendar."}}
,{"_index":"throwtable","_type":"algorithm","_id":"list-of-genetic-algorithm-applications","_score":0,"_source":{"description":"This is a list of Genetic Algorithm (GA) applications","alt_names":["List of genetic algorithm applications","List of genetic algorithm applications - Wikipedia, the free","List of genetic algorithm applications Wikipedia the free","http://en.wikipedia....hm_applications","http://en.wikipedia.org/w(...)gorithm_applications","http://en.wikipedia.org/wiki/List_of_genetic_algorithm_applic...","http://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications","list of genetic algorithm applications","list of genetic algorithms applications","used anywhere optimization has a place","wide range of problems"],"name":"List of genetic algorithm applications","categories":["All articles with dead external links","All articles with unsourced statements","Articles with dead external links from December 2014","Articles with dead external links from October 2015","Articles with unsourced statements from November 2008","Genetic algorithms","Mathematics-related lists"],"tag_line":"This is a list of Genetic Algorithm (GA) applications"}}
,{"_index":"throwtable","_type":"algorithm","_id":"reward-based-selection","_score":0,"_source":{"description":"Reward-based selection is a technique used in evolutionary algorithms for selecting potentially useful solutions for recombination. The probability of being selected for an individual is proportional to the cumulative reward, obtained by the individual. The cumulative reward can be computed as a sum of the individual reward and the reward, inherited from parents.","alt_names":[],"name":"Reward-based selection","categories":["Articles created via the Article Wizard","Evolutionary algorithms","Genetic algorithms"],"tag_line":"Reward-based selection is a technique used in evolutionary algorithms for selecting potentially useful solutions for recombination."}}
,{"_index":"throwtable","_type":"algorithm","_id":"gaussian-elimination","_score":0,"_source":{"description":"In linear algebra, Gaussian elimination (also known as row reduction) is an algorithm for solving systems of linear equations. It is usually understood as a sequence of operations performed on the associated matrix of coefficients. This method can also be used to find the rank of a matrix, to calculate the determinant of a matrix, and to calculate the inverse of an invertible square matrix. The method is named after Carl Friedrich Gauss (1777–1855), although it was known to Chinese mathematicians as early as 179 CE (see History section).\nTo perform row reduction on a matrix, one uses a sequence of elementary row operations to modify the matrix until the lower left-hand corner of the matrix is filled with zeros, as much as possible. There are three types of elementary row operations: 1) Swapping two rows, 2) Multiplying a row by a non-zero number, 3) Adding a multiple of one row to another row. Using these operations, a matrix can always be transformed into an upper triangular matrix, and in fact one that is in row echelon form. Once all of the leading coefficients (the left-most non-zero entry in each row) are 1, and in every column containing a leading coefficient has zeros elsewhere, the matrix is said to be in reduced row echelon form. This final form is unique; in other words, it is independent of the sequence of row operations used. For example, in the following sequence of row operations (where multiple elementary operations might be done at each step), the third and fourth matrices are the ones in row echelon form, and the final matrix is the unique reduced row echelon form.\n\nUsing row operations to convert a matrix into reduced row echelon form is sometimes called Gauss–Jordan elimination. Some authors use the term Gaussian elimination to refer to the process until it has reached its upper triangular, or (non-reduced) row echelon form. For computational reasons, when solving systems of linear equations, it is sometimes preferable to stop row operations before the matrix is completely reduced.","alt_names":["Algoritmo di Gauss","Gauss' algorithm","http://es.wikipedia.org/wiki/Eliminación…","LU-Zerlegung","http://ru.wikipedia.org/wiki/Метод_Гаусс...","Gauß-Algorithmus","Gauss-Algorithmus","http://it.wikipedia.org/wiki/Metodo_di_e…","Метод Гаусса","http://es.wikipedia.org/wiki/Eliminaci%C…","http://de.wikipedia.org/wiki/Gau%C3%9Fsc","http://ru.wikipedia.org/wiki/Метод_Гаусса","Gaussian elimination - Wikipedia, the free encyclopedia","'élimination de Gauss-Jordan","(Wiki) Gaussian Elimination","**GAUSS**","- Gaussian elimination :","-> Read the article about 'Gaussian elimination'","...Wikipedia Algoritmo di Gauss-Jordan","...Wikipedia Gausselimination","...Wikipedia Metoda Gaussa","...Wikipedia Élimination de Gauss-Jordan","...mehr auf Wikipedia über Gaußsches Eliminationsverfahren","...mehr auf Wikipedia über LR-Zerlegung","...more on Wikipedia about Gaussian elimination","2 Phân tích thuật toán","2 x + y - z = 8","3 其他应用","3 其他應用","3.1 找出逆矩阵","3.1 找出逆矩陣","3.2 計出秩的基本算法","3.2 计出秩的基本算法","4.1 Finding the inverse of a matrix","4.2 General algorithm to compute ranks and bases","5 伪代码","5 偽代碼","5.1 Higher order tensors","86631e1a3e32d16f1caf3b98889f ...","<U>Gaussian elimination</U>","?limination de Gauss-Jordan - Wikip?dia","Algoritmo di Gauss-Jordan","Algoritmo di Gauss-Jordan - Wikipedia","Calcul de l'inverse d'une matrice carrée","Complexa explicació de l'eliminació de Gauss de","Dies mal lesen","El Algoritmo de Gaussian Eliminación.","Elimina??o de Gauss ? Wikip?dia, a enciclop","Eliminaci?n de Gauss-Jordan - Wikipedia, la enciclopedia","EliminaciÃ³n de Gauss-Jordan - Wikipedia, la enciclopedia libre","Eliminación Gaussiana","Eliminación Gaussiana o Eliminación de Gauss-Jordan","Eliminación de Gauss","Eliminación de Gauss- Jordan","Eliminación de Gauss-Jordan","Eliminación de Gauss-Jordan - Wikipedia, la enciclopedia libre","Eliminación de gaussianos","Eliminación gaussiana","Eliminacja Gaussa","Eliminasi Gaussian","Elimination de Gauss","Eliminationsverfahren","Eliminationsverfahren nach Gauß","Eliminationsverfahren von Gauss","Eliminationsverfahren von Gauß","Eliminationsverfahrens","Eliminazione gaussiana","Eliminazione à la Gauss","Eliminação Gaussiana","Eliminação de Gauss","Eliminação de Gauss – Wikipédia, a enciclopédia livre","Eliminação gaussiana","GAUSS JORDAN","Gau?sches Eliminationsverfahren ? Wikipedia","Gausa izslēgšanas metode","Gausian Elimination","Gausova metoda","Gauss Elimination","Gauss eliminacio","Gauss eliminatie","Gauss elimination","Gauss elimination algorithm with partial (column) pivoting","Gauss elimination method","Gauss method","Gauss'sche Eliminationsverfahren","Gauss'schen Eliminationsverfahren","Gauss(ガウス)法","Gauss-Elimination","Gauss-Jordan algoritmo","Gauss-Jordan il massacratore","Gauss-elimin?ci? - Wikip?dia","Gauss-eliminatie","Gauss-eliminatie - Wikipedia","Gauss-elimination","Gauss-elimináció","Gauss-elimináció - Wikipédia","Gauss-eliminációhoz","Gauss-eliminációnak","Gauss-eliminációról","Gauss-eliminációval","Gaussalgorithmus","Gausselimination","Gausselimination - Wikipedia","Gaussian Elimination","Gaussian Elimination (wikipedia), to know more","Gaussian Elimination - Wikipedia, The Free Encyclopedia","Gaussian Elimination Algorithm","Gaussian Elimination Method","Gaussian Elimination Solver","Gaussian Elimination on Wikipedia","Gaussian Xoá bỏ","Gaussian elemination","Gaussian eliminace","Gaussian eliminati","Gaussian elimination","Gaussian elimination - Wikipedia, the free en","Gaussian elimination @ Wikipedia","Gaussian elimination Wikipedia the free encyclopedia","Gaussian elimination Wikipedia the free encyclopedia - result","Gaussian elimination algorithm","Gaussian elimination method","Gaussian elimination: Analysis","Gaussian elimination: Example","Gaussian elimination: Pseudocode","Gaussian elimination;","Gaussian elimination; it is used under the","Gaussian eliminering","Gaussian reduction","Gaussian ликвидации","Gaussian-Jordan elimination","Gaussian-aalis","Gaussian_elimination","Gaussian_elimination#Analysis","Gaussianelimination","Gaussin algoritmi","Gaussin algoritmi – Wikipedia","Gaussin algoritmilla","Gaussion elimination","Gaussische eliminatie","Gaussova eliminace","Gaussova eliminacija","Gaussova eliminacijska metoda","Gaussova eliminacní metoda - Wikipedie","Gaussova eliminační metoda","Gaussova eliminační metoda - Wikipedie","Gaussova eliminační metoda - Wikipedie, otevřená encyklopedie","Gaussove eliminacije","Gaussovi eliminace","Gaussovim postopkom","Gaussovo eliminacijo","Gaussovom eleminacijom","Gaussovu eliminaci","Gaussovu eliminační metodu","Gaussovy eliminace","Gaussovy eliminační metody","Gaussschen Eliminationsverfahren","Gaussverfahren","Gauß Algorithmus","Gauß Elimination","Gauß Verfahren","Gauß'sche Eliminationsverfahren","Gauß'schem Eliminationsverfahren","Gauß'schen Eliminationsverfahren","Gauß-Algo.","Gauß-Elimination","Gauß-Methode","Gauß-Verfahren","Gauß-eyðing","Gauß-eyðingu","Gaußen Eliminationsverfahren","Gaußsche Elimination","Gaußsche Eliminationsverfahren","Gaußsche Verfahren","Gaußschen Algorithmus","Gaußschen Elimination","Gaußschen Eliminationsverfahren","Gaußschen Eliminationsverfahren (auch bekannt als Gauß-Verfahren)","Gaußschen Eliminationsverfahrens","Gaußsches Eliminationsverfahren","Gaußsches Eliminationsverfahren - Wikipedia","Gaußsches Eliminationsverfahren ? Wikipedia","Gaußsches Eliminationsverfahren – ...","Gaußsches Eliminationsverfahren – Wikipedia","Gaußsches Eliminationsverfahren.","Gaußsches_Eliminationsverfahren","Gaußverfahren","Guassian elimination","Inverse par la méthode de Gauss","Iterative_Refinement bei der wikipedia","LR Zerlegung","LR-Zerlegung","LR-Zerlegung - Wikipedia","LU-Faktorisierung","Learn about Gaussian elimination>>>","METODI DI JORDAN","Methode von Gauss,","Metoda Gaussa","Metoda Gaussa ? Wikipedia, wolna encyklopedia","Metoda Gaussa – Wikipedia, wolna encyklopedia","Metoda eliminacji Gaussa","Metodo di Gauss","Metodo di eliminazione di Gauss","Metodo di eliminazione di Gauss - Wikipedia","Metodo di eliminazione gaussiana","Metody Eliminacji Gaussa","Metodą Gaussa","Mtode de reducci de Gauss Viquipdia","MÃ¨tode de reducciÃ³ de Gauss","MÉTODO DE GAUSS","Mètode de reducció de Gauss","Mètode de reducció de Gauss - Viquipèdia","Méthode d'élimination de Gauss","Méthode du pivot de Gauss","Mí¨tode de reducció de Gauss","O(n^3) time","Online Example","Phép khử Gauss","Phép khử Gauss - Wikipedia tiếng Việt","Phép khử Gauss – Wikipedia tiếng Việt","Phép khử Gaussian","Pivot de gauss","Poczytaj TUTAJ","Pseudocode/programming algorithm for gaussian elimination (wiki)","Row reduction","Row reduction; it is used under the","Row reductions","Row row row reduce Madly down the page","See if this helps you out at all","See: Gaussian elimination Pseudocode -- From Wikipedia","Tady je postup","This echelon matrix T contains","This snippet works","Vorwärts- und Rückwärtseinsetzen","What is Gauss elimination method's example?","What is Naive Gaussian elimination's example?","What is the example of Gauss elimination method","Wiki zum Gauß'schen Eliminationsverfahren","Wikipedia Article on GE","Wikipedia Eliminación de Gauss-Jordan","Wikipedia article Eliminación de Gauss-Jordan","Wikipedia article Eliminação de Gauss","Wikipedia article Gauss elimination","Wikipedia article Gauss-elimináció","Wikipedia article Gaussian elimination","Wikipedia article Gaussian reduction","Wikipedia article Gaussin algoritmi","Wikipedia article Gauß-eyðing","Wikipedia article Gaußsches Eliminationsverfahren","Wikipedia article Gaŭsa eliminado","Wikipedia article Metoda Gaussa","Wikipedia article Mètode de reducció de Gauss","Wikipedia article Phép khử Gauss","Wikipedia article Row reduction","Wikipedia article on Eliminación de Gauss-Jordan","Wikipedia article on Eliminación gaussiana","Wikipedia article on Gaussian elimination","Wikipedia article Élimination de Gauss-Jordan","Wikipedia article Метод Гауса","Wikipedia article Метод Гаусса","Wikipedia article דירוג מטריצות","Wikipedia article حذف گاوسی","Wikipedia article گاسین اخراج","Wikipedia article ගවුසීය බැහැරීම","Wikipedia article 가우스 소거법","Wikipedia artikel Gauss-Jordan-eliminatie","Wikipedia artikel Gauss-eliminatie","Wikipedia entry for Gaussian elimination","Wikipedia l'articolo Algoritmo di Gauss","Wikipedia l'articolo Algoritmo di Gauss-Jordan","Wikipedia on Gaussian Elimination","Wikipedia sur Pivot de Gauss","Wikipedia zum Gaußschen Eliminationsverfahren","Wikipedia ガウスの消去法","Wikipedia-Artikel Gaußsches Eliminationsverfahren","Wikipedia-Artikel Iterative Refinement","Wikipedia-Artikel LR-Zerlegung","Wikipedia-Artikel LU-Zerlegung","Wikipedia-Seite zu 'Gaußsches Eliminationsverfahren'","Wikipedia-Seite zu 'LR-Zerlegung'","Wikipedia-Seite zu 'LU-Zerlegung'","Wikipedia: Gaussian Elimination","Wikipedia: Gaussian elimination","Wikipedia: Gaußsches Eliminationsverfahren","Wikipedia:Algoritmo_di_Gauss","Wikipedia:Gaussian elimination","Wikipedia:Metodo_di_eliminazione_di_Gauss-Jordan","Wikipedia:Metodo_di_eliminazione_gaussiana","Wikipediaで「掃き出し法」を調べる","Wikipedie: Gaussova eliminační metoda","Wikipédia artigo Eliminação de Gauss","Wikipédia artigo Eliminação de gauss","Wikipédia artigo Eliminação gaussiana","[25] Gaussian elimination method","[4] Gaussian elimination","[gaussian elimination]","a eliminación gaussian","a76ed7160550051605fbf6ae1e1bf0 ...","algorithme de Gauss-Jordan","algoritmo de Gauss-Jordan","algoritmo di Gauss","algoritmo di Gauss-Jordan","algoritmul lui Gauss","als:Gaußsches Eliminationsverfahren","ar:حذف غاوسي","artículo de Wikipedia Eliminación de Gauss","artículo de Wikipedia Eliminación de Gauss-Jordan","artículo de Wikipedia Eliminación gaussiana","b4b664a044d06a025a263ca4c11c ...","begin{bmatrix} 1 & * & 0 & 0","ca:Mètode de reducció de Gauss","can be computed efficiently","cs:Gaussova eliminační metoda","das Gaußsche Eliminationsverfahren","de Gauss redução","de.wikipedia.org/wiki/Gau%C3%9Fsches_Eliminationsverfahren","de.wikipedia.org/wiki/Gau%C3%9Fsches_Eliminationsverfahren#Beispiel","de.wikipedia.org​/wiki​/Gau%C3%9Fsches_Eliminationsv...","de:Gaußsches Eliminationsverfahren","de:Gaußsches Eliminationsverfahren#LR-Zerlegung","een wikipedia-pagina","eliminaciones por Gauss-Jordan","eliminación Gaussiana","eliminación de Gauss","eliminación de Gauss-Jordan","eliminación de Gauss-Jordan,","eliminación gaussiana","eliminacji Gaussa","eliminację Gaussa","eliminasi Gauss","eliminazione di Gauss","eliminazione di Gauss-Jordan","eliminazione gaussiana","eliminação de Gauss","eliminação gaussiana","en.wikipedia.org/wiki/Gaussian_elimination","en.wikipedia.org/wiki/Row_reduction","en:Gaussian elimination","eo:Gaŭsa eliminado","es:Eliminación de Gauss-Jordan","eu:Gauss-Jordan algoritmo","fa:حذف گاوسی","fi:Gaussin algoritmi","forma escalonada reducida a una matriz","fr:Élimination de Gauss-Jordan","free column","gausovy eliminace","gauss-algorithmus","gausseliminerat","gaussian algorithm","gaussian elimination","gaussian elimination wikipedia the free encyclopedia","gauß","gaußsche Eliminationsverfahren","gaußschen Eliminationsverfahren","gaußsches Eliminationsverfahren","he:דירוג מטריצות","here, for help from wikipedia","hier gibts noch ein paar infos","http//de.wikipedia.org/wiki/Gau%C3%9Fsches_Eliminationsverfahren","http://cs.wikipedia.org/wiki/Gaussova_e … %AD_metoda","http://cs.wikipedia.org/wiki/Gaussova_elimina%C4","http://cs.wikipedia.org/wiki/Gaussova_elimina%C4%","http://cs.wikipedia.org/wiki/Gaussova_elimina%C4%8Dn","http://de.wikipedia.org/wiki/Ga ußsches_Eliminationsverfahren","http://de.wikipedia.org/wiki/Gau%C3%...ahren","http://de.wikipedia.org/wiki/Gau%C3%...herplatzbedarf","http://de.wikipedia.org/wiki/Gau%C3%...tionsverfahren","http://de.wikipedia.org/wiki/Gau%C3%9Fsche","http://de.wikipedia.org/wiki/Gau%C3%9Fsches_Elimin","http://de.wikipedia.org/wiki/Gau%C3%9Fsches_Eliminat","http://de.wikipedia.org/wiki/Gau%C3%9Fsches_Eliminationsverfahren","http://de.wikipedia.org/wiki/Gaußsch...tionsverfahren","http://de.wikipedia.org/wiki/Gaußsches_Eliminationsv...","http://de.wikipedia.org/wiki/Gaußsches_Eliminationsverfahren","http://de.wikipedia.org/wiki/Gaußsches_Eliminationsverfahren#Pivotisierung","http://de.wikipedia.org/wiki/Gaußsches_E…","http://de.wikipedia.org/wiki/Iterative_Refinement","http://de.wikipedia.org/wiki/LR-Zerlegung","http://de.wikipedia.org/wiki/LR-Zerlegung#LR","http://de.wikipedia.org/wiki/LU-Zerlegung","http://en.wikipedia....ian_elimination","http://en.wikipedia.org/wiki/G aussian_elimination","http://en.wikipedia.org/wiki/Gauss_elimi...Pseudocode","http://en.wikipedia.org/wiki/Gauss_elimination","http://en.wikipedia.org/wiki/Gauss_elimination#Pseudocode","http://en.wikipedia.org/wiki/Gauss_elimi…","http://en.wikipedia.org/wiki/Gaussia...ion#Pseudocode","http://en.wikipedia.org/wiki/Gaussia...nation#Example","http://en.wikipedia.org/wiki/Gaussia...rithm_overview","http://en.wikipedia.org/wiki/Gaussia...se_of_a_matrix","http://en.wikipedia.org/wiki/Gaussian elimination","http://en.wikipedia.org/wiki/Gaussian_e ... n#Analysis","http://en.wikipedia.org/wiki/Gaussian_el","http://en.wikipedia.org/wiki/Gaussian_elimination","http://en.wikipedia.org/wiki/Gaussian_elimination#Analysis","http://en.wikipedia.org/wiki/Gaussian_elimination#Example","http://en.wikipedia.org/wiki/Gaussian_elimination#Finding_the_inverse_of_a_matrix","http://en.wikipedia.org/wiki/Gaussian_elimination#Pseudocode","http://en.wikipedia.org/wiki/Gaussian_el​imination#Example","http://en.wikipedia.org/wiki/Gaussian_el…","http://en.wikipedia.org/wiki/Gaussian_reduction","http://en.wikipedia.org/wiki/Row_reduction","http://en.wikipedia.org/wiki/Row_reducti…","http://eo.wikipedia.org/wiki/Ga%C5%ADsa_elimina_maniero","http://eo.wikipedia.org/wiki/Ga%C5%ADsa_eliminado","http://eo.wikipedia.org/wiki/Metodo_de_Gauss","http://es.wikipedia.org/wiki/Elimin..._de_Gauss-Jordan","http://es.wikipedia.org/wiki/Elimina...e_Gauss-Jordan","http://es.wikipedia.org/wiki/Eliminaci% ... uss-Jordan","http://es.wikipedia.org/wiki/Eliminaci%C3%B3n_de_Gauss","http://fi.wikipedia.org/wiki/Gaussin_algoritmi","http://fr.wikipedia.org/wiki/%C3%8 [...] an","http://fr.wikipedia.org/wiki/%C3%8 [...] uss","http://fr.wikipedia.org/wiki/%C3%89..._num","http://fr.wikipedia.org/wiki/%C3%89...de_Gauss","http://fr.wikipedia.org/wiki/%C3%89l...e_Gauss","http://fr.wikipedia.org/wiki/%C3%89limi ... uss","http://fr.wikipedia.org/wiki/%C3%89liminat","http://fr.wikipedia.org/wiki/%C3%89liminat...de_Gauss","http://fr.wikipedia.org/wiki/%C3%89limination_de_Gauss-Jordan","http://fr.wikipedia.org/wiki/Méthode_du_pivot_de_Gauss","http://fr.wikipedia.org/wiki/Pivot_de_Gauss","http://fr.wikipedia.org/wiki/Pivot_de_gauss","http://fr.wikipedia.org/wiki/Pivot_de_gauss#Exemple","http://he.wikipedia.org/wiki/דירוג_מטריצות","http://hu.wikipedia.org/wiki/Gauss-elimin%C3","http://it.wikipedia.org/wiki/Algorit...di_una_matrice","http://it.wikipedia.org/wiki/Algoritmo di Gauss","http://it.wikipedia.org/wiki/Algoritmo_di_Gauss","http://it.wikipedia.org/wiki/Algoritmo_di_Gauss-Jordan","http://it.wikipedia.org/wiki/Algoritmo_di_Gauss-Jordan#Inversa_di_una_matrice","http://it.wikipedia.org/wiki/Metodo...di_Gauss-Jordan","http://it.wikipedia.org/wiki/Metodo_di_ ... e_di_Gauss","http://it.wikipedia.org/wiki/Metodo_di_ ... na_matrice","http://it.wikipedia.org/wiki/Metodo_di_eliminazione_di_Gauss","http://it.wikipedia.org/wiki/Metodo_di_eliminazione_di_Gauss#Algoritmo_di_Gauss-Jordan","http://it.wikipedia.org/wiki/Metodo_di_eliminazione_di_Gauss#Inversa_di_una_matrice","http://it.wikipedia.org/wiki/Metodo_di_eliminazione_gaussiana","http://ja.wikipedia.org/wiki/ガウスの消去法","http://nl.wikipedia.org/wiki/Gauss-eliminatie","http://pl.wikipedia....i/Metoda_Gaussa","http://pl.wikipedia.org/wiki/Metoda_Gau ... _liniowych","http://pl.wikipedia.org/wiki/Metoda_Gau ... u_macierzy","http://pl.wikipedia.org/wiki/Metoda_Gaussa","http://pl.wikipedia.org/wiki/Metoda_Gaussa#Obliczanie_macierzy_odwrotnej","http://pl.wikipedia.org/wiki/Metoda_Gaussa#Obliczanie_rz.C4","http://pl.wikipedia.org/wiki/Metoda_eliminacji_Gaussa","http://sv.wikipedia.org/wiki/Gauss%E2%80","http://sv.wikipedia.org/wiki/Gausselimination","http://sv.wikipedia.org/wiki/Gausseliminering","http://ur.wikipedia.org/wiki/Gaussian_elimination","http://vi.wikipedia.org/wiki/Ph%C3%A9p_k","http://vi.wikipedia.org/wiki/Ph%C3%A9p_kh","http://zh.wikipedia.org/wiki/高斯消去法","hu:Gauss-elimináció","is:Gauß-eyðing","it:Algoritmo di Gauss-Jordan","it:Metodo di eliminazione di Gauss","ja:ガウスの消去法","ko:가우스 소거법","l'algorithme de Gauss Jordan","l'algorithme de Gauss-Jordan","l'algorithme de réduction de matrice de Gauss","l'article de Wikipédia Pivot de Gauss","l'article de Wikipédia Élimination de Gauss-Jordan","l'eliminazione di Gauss","l'eliminazione gaussiana","l'élimination de Gauss","la eliminación de Gauss","la forme réduite de Gauss-Jordan","la teoria che c'è dietro","link zum Wiki-Artikel","loại bỏ Gaussian","many procedures","matrix te vegen","method of Gauss,","methode van Gauss","metoda eliminacji Gaussa","metoda gaussa","metoda lui Gauss","metodo di eliminazione di Gauss","metody eliminacji Gaussa","metodą eliminacji Gaussa-Jordana","mÃ©todo de Gauss","mètode de reducció","mètode de reducció de Gauss","mètode del pivot","méthode de Gauss","méthode de Gauss,","méthode du pivot de Gauss","método de Gaus","método de Gauss","método de Gauss p","método de Gauss-Jordan","método de eliminación de Gauss","n, http://en.wikipedia.org/wiki/Gaussian_elimination","nach WP","nl:Gauss-eliminatie","of Gaussian eliminatio","phép khử Gauss","pivot columns","pivot de Gauss","pivotelement","pl.wikipedia.org/wiki/Metoda_Gaussa","pl:Metoda Gaussa","procedimento di eliminazione di Gauss","procédé d'élimination de Gauss","pt:Eliminação de Gauss","row reduce","row reduction","row-reduction","ru.wikipedia.org/wiki/Метод_Гаусса","ru:Метод Гаусса","sh:Gaussova eliminacijska metoda","si:ගවුසීය බැහැරීම","sl:Gaussova eliminacijska metoda","sv:Gausselimination","thuật toán diện biến số của Gauss","uk:Метод Гауса","ur:گاسین اخراج","vi:Phép khử Gauss","w:Gaußsches Eliminationsverfahren","w:Метод Гаусса","w:ガウス消去法","wiki » Gaußsches Eliminationsverfahren","wikipedia einen sehr ausführlichen Artikel","worked out example can be found here, along","zh:高斯消去法","Élimination de Gauss","Élimination de Gauss-Jordan","Élimination de Gauss-Jordan - Wikipédia","Élimination_de_Gauss-Jordan","Íme, bár kissé könnyelmű pedagógus lennék ennyivel, de","élimination de Gauss","élimination de Gauss-Jordan","élimination gaussienne","ê°€ìš°ìŠ¤ ì†Œê±°ë²•","Вики: Алгоритм Гаусса","Матрицы методом Гаусса","Метод Гауса","Метод Гаусса - пример","Метод Гаусса на Википедии","Метод Гаусса — Википедия","Метод Гаусса.","Метод гаусса","Метод_Гаусса","Методом Гаусса","Мтoдe дe peдукчи дe Gaусс","гаусова елиминация","именем Гаусса","исключения Гаусса","классическом методе Гаусса","метод Gauss,","метод Гауса","метод Гаусса","метод гауса","метод гаусса","метода Гаусса","методами Гаусса","методом Гаусса","методом Гаусса.","методу Гауса","объяснения самого алгоритма","одноимённым методом","подробное описание метода Гаусса","דירוג מטריצות","דירוג מטריצות – ויקיפדיה","ויקיפדיה - 'דירוג מטריצות'","ליכסון עפי גאוס","حذف گاوسی","حذف گاوسی - ویکیپدیا","حذف گوسی","گاسین اخراج","گاسین اخراج - وکیپیڈیا","ගවුසීය බැහැරීම -","ගවුසීය බැහැරීම - විකිපීඩියා, නිදහස් විශ්වකෝෂය","ගවුසීය බැහැරීම - �·","การกำจัดแบบเกาส์","การแก้สมการ linear ด้วย Guassian Elimination","กำจัด Gaussian","ขจัด Gaussian","「ガウスの消去法」についてWikipediaで調査","「掃き出し法」についてWikipediaで調査","『ガウスの消去法』の解説","ウィキペディアの記事 ガウスの消去法","ウィキペディアの記事 掃き出し法","ガウスの消去","ガウスの消去法","ガウスの消去法 - Wikipedia","ガウスの消去法 - wikipedia","ガウスの消去法は","ガウス撤廃","ガウス法","ガウス消去","ガウス消去法","ガウス消去法 - Wikipedia","ガウス（・ジョルダン）消去法","維基百科的文章“ 高斯消去法”","维基百科的文章“ 高斯消去法”","行列でこの","高斯消元法","高斯消元法 - 维基百科，自由的百科全书","高斯消元法- 维基百科，自由的百科全书","高斯消去","高斯消去法","高斯消去法- 維基百科，自由的百科全書","高斯消除","가우스 소거","가우스 소거법","가우스 소거법 - 위키백과, 우리 모두의 백과사전","가우스 소거법 [ 가감법 ]","가우스 소거법을","위키 피 디아 문서 가감법","위키 피 디아 문서 가우스 소거법","ｶﾞｳｽの消去法-wikipedia"],"name":"Gaussian elimination","categories":["All articles to be merged","All articles with specifically marked weasel-worded phrases","Articles to be merged from March 2013","Articles with example pseudocode","Articles with specifically marked weasel-worded phrases from January 2014","CS1 errors: external links","Exchange algorithms","Numerical linear algebra","Pages using citations with accessdate and no URL","Pages using web citations with no URL"],"tag_line":"In linear algebra, Gaussian elimination (also known as row reduction) is an algorithm for solving systems of linear equations."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cycle-detection","_score":0,"_source":{"description":"In computer science, cycle detection is the algorithmic problem of finding a cycle in a sequence of iterated function values.\nFor any function ƒ that maps a finite set S to itself, and any initial value x0 in S, the sequence of iterated function values\n\nmust eventually use the same value twice: there must be some i ≠ j such that xi = xj. Once this happens, the sequence must continue periodically, by repeating the same sequence of values from xi to xj−1. Cycle detection is the problem of finding i and j, given ƒ and x0.","alt_names":["tortoise and hare","Brent's algorithm","Cycle detection","Floyd's cycle-finding algorithm","(Read More) Robert W (Bob) Floyd (June 8","- Cycle detection :","-> Read more about Cycle detection","...more on Wikipedia about Floyd's cycle-finding algorithm","@isis: Hase-Igel-Algorithmus","Algorithme de Floyd ou algorithme du lièvre et","Algorithme du lièvre et de la tortue","Algorithme du lièvre et de la tortue - Wikipédia","Algoritma pencari-siklus Floyd","Algoritma pencari-siklus Floyd - Wikipedia bahasa Indonesia ...","Algoritma pencari-siklus Floyd :: Wikipedia Bahasa Indonesia","Algoritmo Busca-Cíclica de Floyd","Algoritmo busca-ciclos de Floyd","Algoritmo busca-ciclos de Floyd – Wikipédia, a enciclopédia","Brent's Algorithm","Brent's cycle finding method","Brent's research","Brents Algorithmus mit Python Beispiel","Brents algorithm with Python example","Brents algoritme met Python bijvoorbeeld","Ciclo de detección","Ciclo de detecção","Ciclo di rilevamento","Cycle Detection","Cycle Detection (2011). Wikipedia.org","Cycle Detection - Wikipedia, the free encyclopedia","Cycle Finding","Cycle afsløring","Cycle de détection","Cycle detecti","Cycle detectie","Cycle detection - Wikipedia, the free encyclopedia","Cycle detection Wikipedia the free encyclopedia","Cycle detection Wikipedia the free encyclopedia - result","Cycle detection, wikipedia","Cycle detection- , the free encyclopedia","Cycle detection.","Cycle detection; it is used under the","Cycle-Erkennung","Cycle_detection","Cyclus detectie","Cykl wykrywania","Detección de ciclos (explicación en ingles)","Floyd cycle algorithm.","Floyd 判圈法","Floyd&#8217;s &#8220;tortoise and the","Floyd's Cycle Finding Algorithm","Floyd's Cycle-Finding Algorithm","Floyd's algorithm for cycle detection","Floyd's algorthm","Floyd's cycle detect algorithm, also called the tortoise","Floyd's cycle detection algorithm","Floyd's cycle finding","Floyd's cycle finding algorithm","Floyd's cycle-finding","Floyd's cycle-finding algorith","Floyd's cycle-finding algorithm (Wikipedia)","Floyd's cycle-finding algorithm - Wikipedia, the free encyclopedia","Floyd's cycle-finding algorithm:","Floyd's hare and tortoise algorithm.","Floyd's “tortoise and the hare” cycle-finding algorithm","Floyd-Zyklus-Algorithmus.","Hase-Igel-Algorithmus","Hase-Igel-Algorithmus Wikipedia","Hase-Igel-Algorithmus in","Hase-Igel-Algorithmus – Wikipedia","Here is something to tide you over","How to apply for Floyd cycle-finding algorithm","Kura-kura dan Hare","La tortuga y la liebre","Pythonの例とブレンツアルゴリズム","Rùa và Hare","Schildkröte und Hase","Schildkröte und Hase Algorithmus","Schildkröte und dem Hasen","Tartaruga e Hare","Tortoise and Hare algorithm","Tortoise and Hare cycle detection algorithm","Tortoise and Hare, 즉 토끼와 거북이 알고리즘","Tortoise and hare Algorithm","Tortoise and hare cycle-finding algorithm","Tortoise and hare cycle-finding algorithm.","Tortoise and the hare algorithm (Floyd's cycle-finding","What are applications of Cycle detection","What are the definitions of Cycle detection?","Wikipedia article Algoritmo busca-ciclos de Floyd","Wikipedia article Cycle detection","Wikipedia article Floyd's cycle-finding algorithm","Wikipedia article about Floyd's cycle-finding algorithm","Wikipedia article on Cycle Detection","Wikipedia article on Cycle detection","Wikipedia entry for Cycle detection","Wikipedia entry on Floyd's algorithm","Wikipedia has a little","Wikipedia on Cycle Detection","Wikipedia sur Algorithme du lièvre et de la","Wikipedia-Artikel Hase-Igel-Algorithmus","Wikipedia-Seite zu 'Hase-Igel-Algorithmus'","Wikipédia artigo Algoritmo busca-cíclica de floyd","Wikpedia overview of cycle finding algorithms","Zyklus-Erkennung","a previously-solved problem","algoritmo Brents con el ejemplo de Python","algoritmo ciclo Floyd.","algoritmo de Floyd ciclo.","algoritmo de la tortuga y la liebre","algorytm cyklu Floyd.","artigo da Wikipédia Algoritmo Busca-Cíclica de Floyd","check this linked list on loops","ciclo de detección","ciclo di rilevamento","con algoritmo Brents esempio Python","cycle detection","cycle detection algorithm","cycle detection algorithms","cykl wykrywania","cyklu wykrywania","cyklus Floyd algoritmus.","de:Hase-Igel-Algorithmus","detect cycles in a linked data structure","e Floyd's cycle-finding algorith","en.wikipedia.org/...Cycle_detection","en.wikipedia.org/wiki/Cycle_detection","en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare","en.wikipedia.org/wiki/Floyd's_cycle-finding_algorithm","en:Cycle detection","en:Floyd's cycle-finding algorithm","fr:Algorithme du lièvre et de la tortue","http://de.wikipedia.org/wiki/Hase-Igel-A","http://de.wikipedia.org/wiki/Hase-Igel-Algorithmus","http://en.wikipedia....Cycle_detection","http://en.wikipedia.org/wiki/Cycle% 5Fdetection # Tortoise","http://en.wikipedia.org/wiki/Cycle% 5Fdetection # Tortuga","http://en.wikipedia.org/wiki/Cycle% 5Fdetection # želva","http://en.wikipedia.org/wiki/Cycle% 5Fdetection # Черепаха","http://en.wikipedia.org/wiki/Cycle%5Fdetection#Tortoise","http://en.wikipedia.org/wiki/Cycle_dete ... _algorithm","http://en.wikipedia.org/wiki/Cycle_detec","http://en.wikipedia.org/wiki/Cycle_detection","http://en.wikipedia.org/wiki/Cycle_detection#Algorithms","http://en.wikipedia.org/wiki/Cycle_detection#Brent.27s_algor","http://en.wikipedia.org/wiki/Cycle_detection#Brent.27s_algorithm","http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare","http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare)","http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare...","http://en.wikipedia.org/wiki/Cycle_detection#cite_note-0","http://en.wikipedia.org/wiki/Cycle_detection.","http://en.wikipedia.org/wiki/Cycle_detec…","http://en.wikipedia.org/wiki/Cycle％5Fdetection＃龟","http://en.wikipedia.org/wiki/Cycle％の5Fdetection","http://en.wikipedia.org/wiki/Floyd%...nding_algorithm","http://en.wikipedia.org/wiki/Floyd%2...ding_algorithm","http://en.wikipedia.org/wiki/Floyd%27s_cyc...nding_algorithm","http://en.wikipedia.org/wiki/Floyd%27s_cycle-finding_algor","http://en.wikipedia.org/wiki/Floyd%27s_cycle-finding_algorit","http://en.wikipedia.org/wiki/Floyd%27s_cycle-finding_algorithm","http://en.wikipedia.org/wiki/Floyd&#39...nding_algorithm","http://en.wikipedia.org/wiki/Floyd's_cy ... Algorithms","http://en.wikipedia.org/wiki/Floyd's_cy ... _algorithm","http://en.wikipedia.org/wiki/Floyd's_cycle-finding_algorithm","http://en.wikipedia.org/wiki/Floyd_cycle-finding_algorithm","http://fr.wikipedia.org/wiki/Algorit...ue#Pseudo","http://id.wikipedia.org/wiki/Algoritma_pencari-siklus_Floyd","id:Algoritma pencari-siklus Floyd","it's a simple idea","ja:フロイドの循環検出法","l) Brents algorithm","lepre e la tartaruga algoritmo","loop detection","np. algorytm Brents z Pythona","pt:Algoritmo Busca-Cíclica de Floyd","pt:Algoritmo busca-ciclos de Floyd","schildpad en de haas","schildpad en haas","schildpad en haas algoritme","schildpad en haas-algoritme","skildpadde og hare","skildpadde og hare algoritme","skildpadde og harer algoritme","standard graph algorithms","t http://en.wikipedia.org/wiki/Cycle_detection","tartaruga e la lepre","tartaruga e la lepre algoritmo","tartaruga ea lebre","thttp://en.wikipedia.org/wiki/Cycle_detection","tortoise and hare algorithm","tortue et le lièvre","tortuga y la liebre","tortuga y la liebre algoritmo","wikipedia page about cycle detection","x 0 , x 1 = f ( x 0 ) , x","Żółw i zając","żółw i zając","Želva a zajíc algoritmus","želva a zajíc","želva a zajíc algoritmus","Цикл обнаружения","Черепаха и заяц","Черепаха и заяц алгоритм","цикла алгоритма Флойда.","черепаха и заяц","черепаха и заяц алгоритма","फ्लोयड चक्र एल्गोरिथ्म.","เต่า และ กระต่าย","『フロイドの循環検出法』の解説","ウサギとカメのアルゴリズムは","カメとウサギ","カメとウサギのアルゴリズム","サイクルの検出","サイクル検出","フロイドの循環検出法","フロイドの循環検出法 - Wikipedia","乌龟和兔子","乌龟和兔子算法","乌龟和野兔","亀とウサギ","周期检测","布伦茨例如算法的Python","時間計算量、空間計算量は同じだけれど、Brent's algorithm は「うさぎと亀」よりも(平均的に","烏龜和野兔","空間計算量を犠牲にすれば、さらなる高速化も可能","算法乌龟和兔子","龟兔","거북이와 헤어","ﾌﾛｲﾄﾞの循環検出法-wikipedia"],"name":"Cycle detection","categories":["Articles with example Python code","Combinatorial algorithms","Fixed points (mathematics)"],"tag_line":"In computer science, cycle detection is the algorithmic problem of finding a cycle in a sequence of iterated function values."}}
,{"_index":"throwtable","_type":"algorithm","_id":"smawk-algorithm","_score":0,"_source":{"description":"The SMAWK algorithm is an algorithm for finding the minimum value in each row of an implicitly-defined totally monotone matrix. It is named after the initials of its five inventors, Peter Shor, Shlomo Moran, Alok Aggarwal, Robert Wilber, and Maria Klawe.\nFor the purposes of this algorithm, a matrix is defined to be monotone if each row's minimum value occurs in a column which is equal to or greater than the column of the previous row's minimum. It is totally monotone if the same property is true for every submatrix (defined by an arbitrary subset of the rows and columns of the given matrix). Equivalently, a matrix is totally monotone if there does not exist a 2×2 submatrix whose row minima are in the top right and bottom left corners. Every Monge array is totally monotone, but not necessarily vice versa.\nFor the SMAWK algorithm, the matrix to be searched should be defined as a function, and this function is given as input to the algorithm (together with the dimensions of the matrix). The algorithm then evaluates the function whenever it needs to know the value of a particular matrix cell. If this evaluation takes O(1), then, for a matrix with r rows and c columns, the running time and number of function evaluations are both O(c(1 + log(r/c))). This is much faster than the O(rc) time of a naive algorithm that evaluates all matrix cells.\nThe main applications of this method presented in the original paper by Aggarwal et al. were in computational geometry, in finding the farthest point from each point of a convex polygon, and in finding optimal enclosing polygons. Subsequent research found applications of the same algorithm in breaking paragraphs into lines, RNA secondary structure prediction, DNA and protein sequence alignment, the construction of prefix codes, and image thresholding, among others.\n^ Aggarwal, Alok; Klawe, Maria M.; Moran, Shlomo; Shor, Peter; Wilber, Robert (1987), \"Geometric applications of a matrix-searching algorithm\", Algorithmica 2 (2): 195–208, doi:10.1007/BF01840359, MR 895444 .\n^ Wilber, Robert (1988), \"The concave least-weight subsequence problem revisited\", Journal of Algorithms 9 (3): 418–425, doi:10.1016/0196-6774(88)90032-6, MR 955150 \n^ Larmore, Lawrence L.; Schieber, Baruch (1991), \"On-line dynamic programming with applications to the prediction of RNA secondary structure\", Journal of Algorithms 12 (3): 490–515, doi:10.1016/0196-6774(91)90016-R, MR 1114923 .\n^ Russo, Luís M. S. (2012), \"Monge properties of sequence alignment\", Theoretical Computer Science 423: 30–49, doi:10.1016/j.tcs.2011.12.068, MR 2887979 .\n^ Crochemore, Maxime; Landau, Gad M.; Ziv-Ukelson, Michal (2003), \"A subquadratic sequence alignment algorithm for unrestricted scoring matrices\", SIAM Journal on Computing 32 (6): 1654–1673 (electronic), doi:10.1137/S0097539702402007, MR 2034254 .\n^ Bradford, Phil; Golin, Mordecai J.; Larmore, Lawrence L.; Rytter, Wojciech (2002), \"Optimal prefix-free codes for unequal letter costs: dynamic programming with the Monge property\", Journal of Algorithms 42 (2): 277–303, doi:10.1006/jagm.2002.1213, MR 1895977 .\n^ Luessi, M.; Eichmann, M.; Schuster, G.M.; Katsaggelos, A.K. (2006), \"New results on efficient optimal multilevel image thresholding\", IEEE International Conference on Image Processing, pp. 773–776, doi:10.1109/ICIP.2006.312426 .","alt_names":[],"name":"SMAWK algorithm","categories":["Algorithms and data structures stubs","All stub articles","Combinatorial algorithms","Computer science stubs","Matrix theory"],"tag_line":"The SMAWK algorithm is an algorithm for finding the minimum value in each row of an implicitly-defined totally monotone matrix."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pivot-element","_score":0,"_source":{"description":"The pivot or pivot element is the element of a matrix, or an array, which is selected first by an algorithm (e.g. Gaussian elimination, simplex algorithm, etc.), to do certain calculations. In the case of matrix algorithms, a pivot entry is usually required to be at least distinct from zero, and often distant from it; in this case finding this element is called pivoting. Pivoting may be followed by an interchange of rows or columns to bring the pivot to a fixed position and allow the algorithm to proceed successfully, and possibly to reduce round-off error. It is often used for verifying row echelon form\nPivoting might be thought of as swapping or sorting rows or columns in a matrix, and thus it can be represented as multiplication by permutation matrices. However, algorithms rarely move the matrix elements because this would cost too much time; instead, they just keep track of the permutations.\nOverall, pivoting adds more operations to the computational cost of an algorithm. These additional operations are sometimes necessary for the algorithm to work at all. Other times these additional operations are worthwhile because they add numerical stability to the final result.","alt_names":["Pivot element - Wikipedia, the free encyclopedia","partial pivoting","''pivot''","...mehr auf Wikipedia über Pivotelement","Cerca pivoting in Wikipedia Italia","Learn about Pivot element>>>","Partial pivoting","Pivot (matematica)","Pivot (matematica) - Wikipedia","Pivot Element","Pivot Element: The value isnt 0 in this","Pivot eleman","Pivot eleman - Vikipedi","Pivot element","Pivot element Wikipedia the free encyclopedia","Pivot element Wikipedia the free encyclopedia - result","Pivot element on wikipedia.org","Pivot seçimi gerektiren sistem örnekleri","Pivot-Element","Pivot-Wert","Pivot_element","Pivotelement","Pivotelement - Wikipedia","Pivotelement in","Pivotelement – Wikipedia","Pivotelements","Pivotisierung","Wikipedia article Pivot eleman","Wikipedia article Pivot element","Wikipedia article on Pivot element","Wikipedia entry for Pivot element","Wikipedia l'articolo Pivot (matematica)","Wikipedia-Artikel Pivot-Element","Wikipedia-Artikel Pivotelement","Wikipedia-Artikel Pivotisierung","Wikipedia-Seite zu 'Pivotelement'","Wikipedia-Seite zu 'Pivotisierung'","Wikipedia:Pivot_(matematica)","cf15e1268def04a9f69255afbb6c8b ...","complete pivoting","de.wikipedia.org/wiki/Pivotelement","en.wikipedia.org/wiki/Pivot_element","http://de.wikipedia.org/wiki/Pivotelemen","http://de.wikipedia.org/wiki/Pivotelement","http://de.wikipedia.org/wiki/Pivotisierung","http://en.wikipedia.org/wiki/Pivot element","http://en.wikipedia.org/wiki/Pivot_e...caled_pivoting","http://en.wikipedia.org/wiki/Pivot_eleme","http://en.wikipedia.org/wiki/Pivot_element","http://en.wikipedia.org/wiki/Pivot_element#Partial_and_complete_pivoting","http://en.wikipedia.org/wiki/Pivot_eleme…","ivot,","l'elemento pivot","matrix pivoting","pivot element","pivot element wikipedia the free encyclopedia","pivot-element","pivotes","with pivoting","“Pivot element - Wikipedia, the free encyclopedia”, en.wikipedia","主元","維基百科的文章“ 主元”"],"name":"Pivot element","categories":["Exchange algorithms","Numerical linear algebra","Pages using duplicate arguments in template calls","Wikipedia articles incorporating text from PlanetMath"],"tag_line":"The pivot or pivot element is the element of a matrix, or an array, which is selected first by an algorithm (e.g."}}
,{"_index":"throwtable","_type":"algorithm","_id":"criss-cross-algorithm","_score":0,"_source":{"description":"In mathematical optimization, the criss-cross algorithm denotes a family of algorithms for linear programming. Variants of the criss-cross algorithm also solve more general problems with linear inequality constraints and nonlinear objective functions; there are criss-cross algorithms for linear-fractional programming problems, quadratic-programming problems, and linear complementarity problems.\nLike the simplex algorithm of George B. Dantzig, the criss-cross algorithm is not a polynomial-time algorithm for linear programming. Both algorithms visit all 2D corners of a (perturbed) cube in dimension D, the Klee–Minty cube (after Victor Klee and George J. Minty), in the worst case. However, when it is started at a random corner, the criss-cross algorithm on average visits only D additional corners. Thus, for the three-dimensional cube, the algorithm visits all 8 corners in the worst case and exactly 3 additional corners on average.","alt_names":[],"name":"Criss-cross algorithm","categories":["All articles to be expanded","Articles to be expanded from April 2011","Combinatorial algorithms","Combinatorial optimization","Exchange algorithms","Geometric algorithms","Linear programming","Optimization algorithms and methods","Oriented matroids","Use dmy dates from December 2013"],"tag_line":"In mathematical optimization, the criss-cross algorithm denotes a family of algorithms for linear programming."}}
,{"_index":"throwtable","_type":"algorithm","_id":"steinhaus–johnson–trotter-algorithm","_score":0,"_source":{"description":"The Steinhaus–Johnson–Trotter algorithm or Johnson–Trotter algorithm, also called plain changes, is an algorithm named after Hugo Steinhaus, Selmer M. Johnson and Hale F. Trotter that generates all of the permutations of n elements. Each permutation in the sequence that it generates differs from the previous permutation by swapping two adjacent elements of the sequence. Equivalently, this algorithm finds a Hamiltonian path in the permutohedron.\nThis method was known already to 17th-century English change ringers, and Sedgewick (1977) calls it \"perhaps the most prominent permutation enumeration algorithm\". As well as being simple and computationally efficient, it has the advantage that subsequent computations on the permutations that it generates may be sped up because these permutations are so similar to each other.","alt_names":[],"name":"Steinhaus–Johnson–Trotter algorithm","categories":["Combinatorial algorithms","Permutations"],"tag_line":"The Steinhaus–Johnson–Trotter algorithm or Johnson–Trotter algorithm, also called plain changes, is an algorithm named after Hugo Steinhaus, Selmer M. Johnson and Hale F. Trotter that generates all of the permutations of n elements."}}
,{"_index":"throwtable","_type":"algorithm","_id":"barabási–albert-model","_score":0,"_source":{"description":"The Barabási–Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. Scale-free networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. The algorithm is named for its inventors Albert-László Barabási and Réka Albert.","alt_names":[],"name":"Barabási–Albert model","categories":["Graph algorithms","Pages containing links to subscription-only content","Random graphs","Social networks"],"tag_line":"The Barabási–Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism."}}
,{"_index":"throwtable","_type":"algorithm","_id":"b*","_score":0,"_source":{"description":"In computer science, B* (pronounced \"B star\") is a best-first graph search algorithm that finds the least-cost path from a given initial node to any goal node (out of one or more possible goals). First published by Hans Berliner in 1979, it is related to the A* search algorithm.","alt_names":[],"name":"B*","categories":["Combinatorial optimization","Game artificial intelligence","Graph algorithms","Routing algorithms","Search algorithms"],"tag_line":"In computer science, B* (pronounced \"B star\") is a best-first graph search algorithm that finds the least-cost path from a given initial node to any goal node (out of one or more possible goals)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lemke–howson-algorithm","_score":0,"_source":{"description":"The Lemke–Howson algorithm  is an algorithm that computes a Nash equilibrium of a bimatrix game, named after its inventors, Carlton E. Lemke and J. T. Howson. It is said to be “the best known among the combinatorial algorithms for finding a Nash equilibrium”.","alt_names":[],"name":"Lemke–Howson algorithm","categories":["Combinatorial algorithms","Game theory","Non-cooperative games"],"tag_line":"The Lemke–Howson algorithm  is an algorithm that computes a Nash equilibrium of a bimatrix game, named after its inventors, Carlton E. Lemke and J. T. Howson."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fringe-search","_score":0,"_source":{"description":"In computer science, fringe search is a recent graph search algorithm that finds the least-cost path from a given initial node to one goal node.\nIn essence, fringe search is a middle ground between A* and the iterative deepening A* variant (IDA*).\nIf g(x) is the cost of the search path from the first node to the current, and h(x) is the heuristic estimate of the cost from the current node to the goal, then ƒ(x) = g(x) + h(x), and h* is the actual path cost to the goal. Consider IDA*, which does a recursive left-to-right depth-first search from the root node, stopping the recursion once the goal has been found or the nodes have reached a maximum value ƒ. If no goal is found in the first threshold ƒ, the threshold is then increased and the algorithm searches again. I.E. It iterates on the threshold.\nThere are three major inefficiencies with IDA*. First, IDA* will repeat states when there are multiple (sometimes non-optimal) paths to a goal node - this is often solved by keeping a cache of visited states. IDA* thus altered is denoted as memory-enhanced IDA* (ME-IDA*), since it uses some storage. Furthermore, IDA* repeats all previous operations in a search when it iterates in a new threshold, which is necessary to operate with no storage. By storing the leaf nodes of a previous iteration and using them as the starting position of the next, IDA*'s efficiency is significantly improved (otherwise, in the last iteration it would always have to visit every node in the tree).\nFringe search implements these improvements on IDA* by making use of a data structure that is more or less two lists to iterate over the frontier or fringe of the search tree. One list now, stores the current iteration, and the other list later stores the immediate next iteration. So from the root node of the search tree, now will be the root and later will be empty. Then the algorithm takes one of two actions: If ƒ(head) is greater than the current threshold, remove head from now and append it to the end of later; i.e. save head for the next iteration. Otherwise, if ƒ(head) is less than or equal to the threshold, expand head and discard head, consider its children, adding them to the beginning of now. At the end of an iteration, the threshold is increased, the later list becomes the now list, and later is emptied.\nAn important difference here between fringe and A* is that the contents of the lists in fringe do not necessarily have to be sorted - a significant gain over A*, which requires the often expensive maintenance of order in its open list. Unlike A*, however, fringe will have to visit the same nodes repeatedly, but the cost for each such visit is constant compared to the worst-case logarithmic time of sorting the list in A*.","alt_names":["Fringe Search","Fringe search","Fringe search - Wikipedia, the free encyclopedia","Fringe search by Wikipedia","Fringe_search","Wikipedia article Fringe search","http://en.wikipedia.org/wiki/Fringe_search","yago-res:Fringe search"],"name":"Fringe search","categories":["All articles lacking in-text citations","Articles lacking in-text citations from June 2013","Graph algorithms"],"tag_line":"In computer science, fringe search is a recent graph search algorithm that finds the least-cost path from a given initial node to one goal node."}}
,{"_index":"throwtable","_type":"algorithm","_id":"belief-propagation","_score":0,"_source":{"description":"Belief propagation, also known as sum-product message passing, is a message passing algorithm for performing inference on graphical models, such as Bayesian networks and Markov random fields. It calculates the marginal distribution for each unobserved node, conditional on any observed nodes. Belief propagation is commonly used in artificial intelligence and information theory and has demonstrated empirical success in numerous applications including low-density parity-check codes, turbo codes, free energy approximation, and satisfiability.\nThe algorithm was first proposed by Judea Pearl in 1982, who formulated this algorithm on trees, and was later extended to polytrees. It has since been shown to be a useful approximate algorithm on general graphs.\nIf X={Xi} is a set of discrete random variables with a joint mass function p, the marginal distribution of a single Xi is simply the summation of p over all other variables:\n\nHowever, this quickly becomes computationally prohibitive: if there are 100 binary variables, then one needs to sum over 299 ≈ 6.338 × 1029 possible values. By exploiting the polytree structure, belief propagation allows the marginals to be computed much more efficiently.","alt_names":["- Belief propagation :","- Generalized belief propagation :","-> Read more about Belief propagation","Approximate algorithm for general graphs","Bayesian belief propagation","Belief Propagation","Belief propagation","Belief propagation - Wikipedia :: The free encyclopedia","Belief propagation - Wikipedia, the free encyclopedia","Belief propagation Wikipedia the free encyclopedia","Belief propagation Wikipedia, the ...","Belief propagation by Wikipedia","Belief propagation; it is used under the","Belief_propagation","Description of the sum-product algorithm","Exact algorithm for trees","Gaussian Belief Propagation","Gaussian belief propagation","Gaussian belief propagation (GaBP)","Generalized belief propagation","Generalized belief propagation (GBP)","Judea Pearl in the late 80's","Learn about Belief propagation>>>","Loopy Belief Propagation","Loopy belief propagation","Related algorithm and complexity issues","Relation to free energy","Sum-Product Algorithm","Sum-product algorithm","The wikipedia article and related references","Wikipedia article Belief propagation","Wikipedia article Loopy belief propagation","Wikipedia article on Belief propagation","Wikipedia article on Sum-product algorithm","Wikipedia entry for Belief propagation","algorithme belief-propagation","belief propagation","belief propagation algorithm","belief propagation at Wikipedia","belief propagation.","belief-propagation","en.wikipedia.org/...Belief_propagation","en.wikipedia.org/wiki/Belief_propagation","en:Belief propagation","generalized belief propagation","hierarchical reasoning","http://en.wikipedia.org/wiki/Belief propagation","http://en.wikipedia.org/wiki/Belief_prop","http://en.wikipedia.org/wiki/Belief_propaga tion","http://en.wikipedia.org/wiki/Belief_propagation","http://en.wikipedia.org/wiki/Loopy_belief_propagation","http://en.wikipedia.org/wiki/Sum-product_algorithm","loopy BP","loopy belief propagation","message passing scheme","propagate Bayesian beliefs","sum of products algorithm","sum-product","sum-product algorithm","sum-product belief propagation algorithm","| The wikipedia article and related references","Статья в Википедии про алгоритм Belief Propagation","انتشار یک عقیده"],"name":"Belief propagation","categories":["All articles lacking in-text citations","Articles lacking in-text citations from April 2009","Coding theory","Graph algorithms","Graphical models","Probability theory","Use dmy dates from June 2013"],"tag_line":"Belief propagation, also known as sum-product message passing, is a message passing algorithm for performing inference on graphical models, such as Bayesian networks and Markov random fields."}}
,{"_index":"throwtable","_type":"algorithm","_id":"floyd–warshall-algorithm","_score":0,"_source":{"description":"In computer science, the Floyd–Warshall algorithm is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights (but with no negative cycles). A single execution of the algorithm will find the lengths (summed weights) of the shortest paths between all pairs of vertices, though it does not return details of the paths themselves.\nVersions of the algorithm can also be used for finding the transitive closure of a relation , or (in connection with the Schulze voting system) widest paths between all pairs of vertices in a weighted graph.\n^ Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L. (1990). Introduction to Algorithms (1st ed.). MIT Press and McGraw-Hill. ISBN 0-262-03141-8.  See in particular Section 26.2, \"The Floyd–Warshall algorithm\", pp. 558–565 and Section 26.4, \"A general framework for solving path problems in directed graphs\", pp. 570–576.\n^ Kenneth H. Rosen (2003). Discrete Mathematics and Its Applications, 5th Edition. Addison Wesley. ISBN 0-07-119881-4.","alt_names":[],"name":"Floyd–Warshall algorithm","categories":["Articles with example pseudocode","Commons category without a link on Wikidata","Dynamic programming","Graph algorithms","Polynomial-time problems","Routing algorithms"],"tag_line":"In computer science, the Floyd–Warshall algorithm is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights (but with no negative cycles)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bellman–ford-algorithm","_score":0,"_source":{"description":"The Bellman–Ford algorithm is an algorithm that computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph. It is slower than Dijkstra's algorithm for the same problem, but more versatile, as it is capable of handling graphs in which some of the edge weights are negative numbers. The algorithm is named after two of its developers, Richard Bellman and Lester Ford, Jr., who published it in 1958 and 1956, respectively; however, Edward F. Moore also published the same algorithm in 1957, and for this reason it is also sometimes called the Bellman–Ford–Moore algorithm.\nNegative edge weights are found in various applications of graphs, hence the usefulness of this algorithm. If a graph contains a \"negative cycle\" (i.e. a cycle whose edges sum to a negative value) that is reachable from the source, then there is no cheapest path: any path can be made cheaper by one more walk around the negative cycle. In such a case, the Bellman–Ford algorithm can detect negative cycles and report their existence. \n\n","alt_names":[],"name":"Bellman–Ford algorithm","categories":["Articles with example C code","Articles with example pseudocode","Dynamic programming","Graph algorithms","Polynomial-time problems"],"tag_line":"The Bellman–Ford algorithm is an algorithm that computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cuthill–mckee-algorithm","_score":0,"_source":{"description":"In the mathematical subfield of matrix theory, the Cuthill–McKee algorithm (CM), named for Elizabeth Cuthill and J. McKee , is an algorithm to permute a sparse matrix that has a symmetric sparsity pattern into a band matrix form with a small bandwidth. The reverse Cuthill–McKee algorithm (RCM) due to Alan George is the same algorithm but with the resulting index numbers reversed. In practice this generally results in less fill-in than the CM ordering when Gaussian elimination is applied.\nThe Cuthill McKee algorithm is a variant of the standard breadth-first search algorithm used in graph algorithms. It starts with a peripheral node and then generates levels  for  until all nodes are exhausted. The set  is created from set  by listing all vertices adjacent to all nodes in . These nodes are listed in increasing degree. This last detail is the only difference with the breadth-first search algorithm.","alt_names":[],"name":"Cuthill–McKee algorithm","categories":["Graph algorithms","Matrix theory","Sparse matrices"],"tag_line":"In the mathematical subfield of matrix theory, the Cuthill–McKee algorithm (CM), named for Elizabeth Cuthill and J. McKee , is an algorithm to permute a sparse matrix that has a symmetric sparsity pattern into a band matrix form with a small bandwidth."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ford–fulkerson-algorithm","_score":0,"_source":{"description":"The Ford–Fulkerson method or Ford–Fulkerson algorithm (FFA) is an algorithm that computes the maximum flow in a flow network. It is called a \"method\" instead of an \"algorithm\" as the approach to finding augmenting paths in a residual graph is not fully specified or it is specified in several implementations with different running times. It was published in 1956 by L. R. Ford, Jr. and D. R. Fulkerson. The name \"Ford–Fulkerson\" is often also used for the Edmonds–Karp algorithm, which is a specialization of Ford–Fulkerson.\nThe idea behind the algorithm is as follows: as long as there is a path from the source (start node) to the sink (end node), with available capacity on all edges in the path, we send flow along one of the paths. Then we find another path, and so on. A path with available capacity is called an augmenting path.","alt_names":[],"name":"Ford–Fulkerson algorithm","categories":["Articles with example pseudocode","Graph algorithms","Network flow"],"tag_line":"The Ford–Fulkerson method or Ford–Fulkerson algorithm (FFA) is an algorithm that computes the maximum flow in a flow network."}}
,{"_index":"throwtable","_type":"algorithm","_id":"disparity-filter-algorithm-of-weighted-network","_score":0,"_source":{"description":"Disparity filter is a network reduction algorithm to extract the backbone structure of undirected weighted network. Many real world networks such as citation networks, food web, airport networks display heavy tailed statistical distribution of nodes' weight and strength. Disparity filter can sufficiently reduce the network without destroying the multi-scale nature of the network. The algorithm is developed by M. Angeles Serrano, Marian Boguna and Alessandro Vespignani.\n^ Serrano, M.Angeles; Boguna, Marian; Vespignani, Alessandro (2009), \"Extracting the multiscale backbone of complex weighted networks\", Proceedings of the National Academy of Sciences 106 (16): 6483–6488, arXiv:0904.2389, Bibcode:2009PNAS..106.6483S, doi:10.1073/pnas.0808904106 .","alt_names":[],"name":"Disparity filter algorithm of weighted network","categories":["Graph algorithms"],"tag_line":"Disparity filter is a network reduction algorithm to extract the backbone structure of undirected weighted network."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fkt-algorithm","_score":0,"_source":{"description":"The FKT algorithm, named after Fisher, Kasteleyn, and Temperley, counts the number of perfect matchings in a planar graph in polynomial time. This same task is #P-complete for general graphs. Counting the number of matchings, even for planar graphs, is also #P-complete. The key idea is to convert the problem into a Pfaffian computation of a skew-symmetric matrix derived from a planar embedding of the graph. The Pfaffian of this matrix is then computed efficiently using standard determinant algorithms.","alt_names":["FKT algorithm","FKT algorithm - Wikipedia :: The free encyclopedia","FKT algorithm - Wikipedia, the free encyclopedia","FKT algorithm by Wikipedia","Fisher-Kastelyen-Temperley algorithm","Wikipedia article on FKT algorithm","en.wikipedia.org/wiki/FKT_algorithm","en:FKT algorithm","http://en.wikipedia.org/wiki/FKT_algorithm"],"name":"FKT algorithm","categories":["Graph algorithms","Planar graphs"],"tag_line":"The FKT algorithm, named after Fisher, Kasteleyn, and Temperley, counts the number of perfect matchings in a planar graph in polynomial time."}}
,{"_index":"throwtable","_type":"algorithm","_id":"girvan–newman-algorithm","_score":0,"_source":{"description":"The Girvan–Newman algorithm (named after Michelle Girvan and Mark Newman) is a hierarchical method used to detect communities in complex systems.\n\n","alt_names":[],"name":"Girvan–Newman algorithm","categories":["Graph algorithms","Network analysis","Networks"],"tag_line":"The Girvan–Newman algorithm (named after Michelle Girvan and Mark Newman) is a hierarchical method used to detect communities in complex systems.\n\n"}}
,{"_index":"throwtable","_type":"algorithm","_id":"kruskal's-algorithm","_score":0,"_source":{"description":"Kruskal's algorithm is a minimum-spanning-tree algorithm which finds an edge of the least possible weight that connects any two trees in the forest. It is a greedy algorithm in graph theory as it finds a minimum spanning tree for a connected weighted graph adding increasing cost arcs at each step. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. If the graph is not connected, then it finds a minimum spanning forest (a minimum spanning tree for each connected component).\nThis algorithm first appeared in Proceedings of the American Mathematical Society, pp. 48–50 in 1956, and was written by Joseph Kruskal.\nOther algorithms for this problem include Prim's algorithm, Reverse-delete algorithm, and Borůvka's algorithm.","alt_names":["http://en.wikipedia.org/wiki/Kruskal%27s…","Kruskals algoritme","Kruskal's Algorithm","http://en.wikipedia.org/wiki/Kruskal's_algorithm","Kruskal's algorithm","อัลกอริทึมของครูสกัล","Kruskal algorithm","Kruskal's algorithm - Wikipedia, the free encyclopedia","(http://de.wikipedia.org/wiki/Algorithmus von Kruskal","*Algoritmo de *Kruskal","- Kruskal's algorithm :","-> Read the article about 'Kruskal's algorithm'","...Wikipedia Algorithme de Kruskal","...Wikipedia Algoritmo de Kruskal","...Wikipedia Algorytm Kruskala","...Wikipedia Kruskals algoritm","...mehr auf Wikipedia über Algorithmus von Kruskal","...more on Wikipedia about Kruskal's algorithm","1 步骤","27s_algorithm http://en.wikipedia.org/wiki/Kruskal%","3.1 Spanning tree","3.2 Minimality","4 算法","7.2 Kruskal's algorithm","Algo de información...","Algorithme de Kruskal","Algorithme de Kruskal - Wikip?dia","Algorithme de Kruskal - Wikipédia","Algorithmus von Kruskal","Algorithmus von Kruskal - Wikipedia","Algorithmus von Kruskal ? Wikipedia","Algorithmus von Kruskal bei Wikipedia","Algorithmus von Kruskal – Wikipedia","Algorithmus_von_Kruskal","Algoritmo de Kruskal","Algoritmo de Kruskal - Wikip?dia, a enciclop?dia","Algoritmo de Kruskal - Wikipedia, la enciclopedia libre","Algoritmo de Kruskal - Wikipédia, a enciclopédia livre","Algoritmo de Kruskal – Wikipédia, a enciclopédia livre","Algoritmo di Kruskal","Algoritmo di Kruskal - Wikipedia","Algoritmul lui Kruskal","Algoritmul lui Kruskal - Wikipedia","Algorytm Kruskala","Algorytm Kruskala ? Wikipedia, wolna encyklopedia","Algorytm Kruskala – Wikipedia, wolna encyklopedia","KRUSKAL","Kruscal's","Kruskal Algorithm","Kruskal S Algorithm Wikipedia The Free Encyclopedia","Kruskal Wiki","Kruskal algorithm in wikipedia","Kruskal algoritme","Kruskal algoritmus","Kruskal er","Kruskal のアルゴリズム","Kruskal's","Kruskal's Alg","Kruskal's Algorithm - Wikipedia","Kruskal's Algorithm.","Kruskal's Algorithmus","Kruskal's MST","Kruskal's MST algorithm","Kruskal's algorithm - Wikipedia :: The free encyclopedia","Kruskal's algorithm - Wikipedia, the free ...","Kruskal's algorithm @ Wikipedia","Kruskal's algorithm by Wikipedia","Kruskal's algorithm,","Kruskal's algorithm.","Kruskal's algoritme","Kruskal's minimal spanning tree algorithm","Kruskal's minimum spanning tree algorithm","Kruskal's performance","Kruskal's_algorithm","Kruskal-Algorithmus","Kruskal-algoritme","Kruskal-algoritmus","Kruskal?v algoritmus","Kruskala","Kruskala jest","Kruskalalgorithmus","Kruskalin","Kruskalin algoritmi","Kruskalov algoritmus","Kruskalova algoritmu","Kruskalovom algoritme.","Kruskals Algorithm.","Kruskals Algorithmus","Kruskals algorithm","Kruskals algoritm","Kruskals algoritme is een","Kruskal´s algorithm","Kruskalův algoritmus","Kruskalův algoritmus - Wikipedie","Kruskalův algortimus","Kruskalの","Kruskalのアルゴリズム","Kruskal演算法","Kruskal的树问题","Kruskal的樹問題","Kruskal算法","Kruskal의 Minimum Spanning Tree 알고리즘","Krustal","Kurskal algoritmas","Kuskal's algorithm","Learn about Kruskal's algorithm>>>","Nach Abschluss des Algorithmus bilden die ausgewählten Kanten","Source Wikipedia.org Arcticle - Kruskal's algorithm","W: Kruskal's algorithm","What is Kruskal algorithm's performance?","What is Kruskals algorithm's performance?","Wiki : 克魯斯克爾演算法","Wikipedia (Algoritmo de Kruskal).","Wikipedia : Kruskal's algorithm","Wikipedia Article on Kruskal's algorithm","Wikipedia article Algorithme de Kruskal","Wikipedia article Algoritmo de Kruskal","Wikipedia article Algorytm Kruskala","Wikipedia article Kruskal algorithm","Wikipedia article Kruskal's algorithm","Wikipedia article Kruskal's_algorithm","Wikipedia article Kruskal-algoritmus","Wikipedia article about Kruskal's algorithm","Wikipedia article on Algoritmo de Kruskal","Wikipedia artikel Algoritme van Kruskal","Wikipedia explanation of Kruskal's greedy algorithm to find","Wikipedia-Artikel Algorithmus von Kruskal","Wikipedia-Artikel Algorithmus_von_Kruskal","Wikipedia-Artikel Kruskal-Algorithmus","Wikipedia-Seite zu 'Algorithmus von Kruskal'","Wikipedia.org Algoritmo de Kruskal","Wikipedia: Algorithmus von Kruskal","Wikipedia: Kruskal","Wikipedia: Kruskal's algorithm","Wikipedia: Kruskal-Algorithmus","Wikipedia::Kruskal_algorithm","Wikipedia:Kruskal's_algorithm","Y 1 ∪ e","[ teorie Kruskal ]","algorithme de Kruskal","algoritma kruskal","algoritme van Kruskal","algoritmo de Kruskal","algoritmo de Kruskal,","algoritmo di Kruskal","algoritmo en wikipedia","algoritmo voraz para el cálculo del árbol de","algoritmus Kruskalův","algoritmą.","algorytm Kruskala","algôhitme van Kruskal","artigo da Wikipédia Algoritmo de Kruskal","artículo de Wikipedia Algoritmo de Kruskal","de Kruskal","de.wikipedia.org/...Algorithmus_von_Kruskal","de.wikipedia.org/wiki/Algorithmus_von_Kruskal","en.wikipedia.org/wiki/Kruskal%27s_algorithm","en.wikipedia.org/wiki/Kruskal's_algorithm","en:Kruskal's_algorithm","es un algoritmo","fa:الگوریتم کروسکال","following solution","het algoritme van Kruskal","hladového algoritmu","http://cs.wikipedia.org/wiki/Kruskal%C5%AFv_algoritmus","http://cs.wikipedia.org/wiki/Kruskalův_algoritmus","http://de.wikipedia.org/wiki/Algorithmus_von_Kruskal","http://de.wikipedia.org/wiki/Kruskal-Algorithmus","http://en.wikipedia.org/wiki/K[…]kal%27s_algorithm","http://en.wikipedia.org/wiki/Kruskal 27s_algorithm%","http://en.wikipedia.org/wiki/Kruskal% 27s_algorithm","http://en.wikipedia.org/wiki/Kruskal%27 ... Pseudocode","http://en.wikipedia.org/wiki/Kruskal%27s_algorithm","http://en.wikipedia.org/wiki/Kruskal%27s_algorithm#Example","http://en.wikipedia.org/wiki/Kruskal's algorithm","http://en.wikipedia.org/wiki/Kruskal's_a…","http://en.wikipedia.org/wiki/Kruskal_algorithm","http://en2.wikipedia.org/wiki/Kruskal%27s_algorithm","http://es.wikipedia.org/wiki/Algoritmo_de_Kruskal","http://fa.wikipedia.org/wiki/الگوریتم کروسکال/","http://fr.wikipedia.org/wiki/Algorithme_de_Kruskal","http://it.wikipedia.org/wiki/Algoritmo_di_Kruskal","http://nl.wikipedia.org/wiki/Kruskals_algoritme","http://pl.wikipedia.org/wiki/Algorytm_Kruskala","http://pt.wikipedia.org/wiki/Algoritmo_de_","http://pt.wikipedia.org/wiki/Algoritmo_de_Kruskal","http://ru.wikipedia.org/wiki/Алгоритм_Краскала","hu:Kruskal-algoritmus","ja:クラスカル法","je Kruskalův","kruskal's algorithm","kruskals algorithm","l'algorithme de Kruskal","l'algoritmo di Kruskal","m Wikipedia::Kruskal_algorithm","mañosos algoritmos","nl:Kruskals algoritme","pl.wikipedia.org/wiki/Algorytm_Kruskala","proof that Kruskal's alogorithm works.","ro:Algoritmul lui Kruskal","ru:Алгоритм Крускала","ruskal","simple analysis of Kruskal's Algorithm","sk:Kruskalov algoritmus","sr:Крускалов алгоритам","uk:Алгоритм Краскала","uk:Алгоритм Крускала","w:Kruskal's algorithm","wiki) строит каркас — минимальное остовное дерево данного графа","wikipedia algorytm Kruskala","wikipedia: Kruskal's algorithm","wikiの例","zh:克鲁斯克尔演算法","Алгоритм Краскала","Алгоритм Крускала","Википедии статью Алгоритм Краскала","Крускал","Крускала","Крускалов алгоритам","алгоритм Краскала","алгоритм Крускала","альгрытм Краскала","אלגוריתם KRUSKAL","האלגוריתם של קרוסקל","האלגוריתם של קרוסקל מתוך ויקיפדיה","האלגוריתם של קרוסקל – ויקיפדיה","הערך בוויקי האנגלית","והאלגוריתם של קרוסקל","الگوریتم کروسکال","الگوریتم کروسکال - ویکیپدیا","کروسکال","ウィキペディアの記事 クラスカル法","クラスカル法","クラスカル法 - Wikipedia","クラスカル法 -wikipedia","克鲁斯克尔演算法","克鲁斯卡尔","克鲁斯卡尔的","克鲁斯卡尔算法","維基百科的文章“ Kruskal演算法”","維基百科的文章“ 克鲁斯克尔演算法”","维基百科的文章“ Kruskal演算法”","维基百科的文章“ 克鲁斯克尔演算法”","위키 피 디아 문서 크루스칼 알고리즘","최소신장트리","쿠르스칼","크루스칼 알고리즘","ﺍﻟﮕﻮﺭﯾﺘﻢ ﮐﺮﻭﺳﮑﺎﻝ","ｸﾗｽｶﾙ法-wikipedia"],"name":"Kruskal's algorithm","categories":["All articles lacking in-text citations","Articles containing proofs","Articles lacking in-text citations from June 2013","Articles with example pseudocode","Graph algorithms","Spanning tree"],"tag_line":"Kruskal's algorithm is a minimum-spanning-tree algorithm which finds an edge of the least possible weight that connects any two trees in the forest."}}
,{"_index":"throwtable","_type":"algorithm","_id":"proof-number-search","_score":0,"_source":{"description":"Proof-number search (short: PN search) is a game tree search algorithm invented by Victor Allis, with applications mostly in endgame solvers, but also for sub-goals during games.\nUsing a binary goal (e.g. first player wins the game), game trees of two-person perfect-information games can be mapped to an and–or tree. Maximizing nodes become OR-nodes, minimizing nodes are mapped to AND-nodes. For all nodes proof and disproof numbers are stored, and updated during the search.\nTo each node of the partially expanded game tree the proof number and disproof number are associated. A proof number represents the minimum number of leaf nodes which have to be proved in order to prove the node. Analogously, a disproof number represents the minimum number of leaves which have to be disproved in order to disprove the node. Because the goal of the tree is to prove a forced win, winning nodes are regarded as proved. Therefore, they have proof number 0 and disproof number ∞. Lost or drawn nodes are regarded as disproved. They have proof number ∞ and disproof number 0. Unknown leaf nodes have a proof and disproof number of unity. The proof number of an internal AND node is equal to the sum of its childrens’ proof numbers, since to prove an AND node all the children have to be proved. The disproof number of an AND node is equal to the minimum of its childrens’ disproof numbers. The disproof number of an internal OR node is equal to the sum of its childrens’ disproof numbers, since to disprove an OR node all the children have to be disproved. Its proof number is equal to the minimum of its childrens’ proof numbers.\nThe procedure of selecting the most-proving node to expand is the following. We start at the root. Then, at each OR node the child with the lowest proof number is selected as successor, and at each AND node the child with the lowest disproof number is selected as successor. Finally, when a leaf node is reached, it is expanded and its children are evaluated.\nThe proof and disproof numbers represent lower bounds on the number of nodes to be evaluated to prove (or disprove) certain nodes. By always selecting the most proving (disproving) node to expand, an efficient search is generated.\nSome variants of proof number search like dfPN, PN2, PDS-PN have been developed to address the quite big memory requirements of the algorithm.","alt_names":["- Proof-number search :","Proof-Number Search","Proof-Number-Suche","Proof-Number-Suche - Wikipedia","Proof-number search","Proof-number search - Wikipedia :: The free encyclopedia","Proof-number search - Wikipedia, the free encyclopedia","Proof-number search - Wikipedia, the free encyclopedia ...","Proof-number search by Wikipedia","Proof-number_search","View Proof-number search on Wikipedia","Wikipedia article Proof-number search","Wikipedia article on Proof-number search","http://de.wikipedia.org/wiki/Proof-Number-Suche","http://en.Liarpedia.org/wiki/Proof-number_search","http://en.wikipedia.org/wiki/Proof-number_search","proof-number search","“Proof-number search - Wikipedia, the free encyclopedia”, en"],"name":"Proof-number search","categories":["Game artificial intelligence","Graph algorithms","Search algorithms"],"tag_line":"Proof-number search (short: PN search) is a game tree search algorithm invented by Victor Allis, with applications mostly in endgame solvers, but also for sub-goals during games."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bead-sort","_score":0,"_source":{"description":"Bead sort, also called gravity sort is a natural sorting algorithm, developed by Joshua J. Arulanandham, Cristian S. Calude and Michael J. Dinneen in 2002, and published in The Bulletin of the European Association for Theoretical Computer Science. Both digital and analog hardware implementations of bead sort can achieve a sorting time of O(n); however, the implementation of this algorithm tends to be significantly slower in software and can only be used to sort lists of positive integers. Also, it would seem that even in the best case, the algorithm requires O(n2) space.","alt_names":["(http://en.wikipedia.org/wiki/Bead_sort)","(http://en.wikipedia.org/wiki/Bead_sort),","- Bead sort :","-> Read more about Bead sort","-> Read the article about 'Bead sort'","...more on Wikipedia about Bead sort","Abacus (Bead) Sort","Algorithm Overview","Art Bälle","Bead Sort","Bead Sort Algorithm","Bead Sort на википедии","Bead sort","Bead sort - Wikipedia, the free encyclopedia","Bead sort Wikipedia the free encyclopedia","Bead sort – Wikipedia, the free encyclopedia","Bead sort: faster than O(N log N","Bead sort; it is used under the","Bead sort?","Bead-sort","BeadSort","Bead_sort","Ordenación por gotas","Whoa, that's a pretty hot algorithm","Wikipedia (Bead sort)","Wikipedia article Bead Sort","Wikipedia article Bead sort","Wikipedia article on Bead sort","Wikipedia entry for Bead sort","bead sort","bolas de sorte","boules tri","en.wikipedia.org/Bead_sort","en.wikipedia.org/wiki/Bead_sort","en:Bead_sort","http://en.wikipedia.org/wiki/Bead_Sort","http://en.wikipedia.org/wiki/Bead_sort","le palle sorta","ordenar bolas","soort ballen","вид шаров","مهره ای","“珠排序”","”（http://en.wikipedia.org/wiki/Bead_sort），","ソートのボール","珠排序","那种球","정렬(http://en.wikipedia.org/wiki/Bead_sort),","（http://en.wikipedia.org/wiki/Bead_sort）"],"name":"Bead sort","categories":["Sorting algorithms"],"tag_line":"Bead sort, also called gravity sort is a natural sorting algorithm, developed by Joshua J. Arulanandham, Cristian S. Calude and Michael J. Dinneen in 2002, and published in The Bulletin of the European Association for Theoretical Computer Science."}}
,{"_index":"throwtable","_type":"algorithm","_id":"graph-kernel","_score":0,"_source":{"description":"In structure mining, a domain of learning on structured data objects in machine learning, a graph kernel is a kernel function that computes an inner product on graphs. Graph kernels can be intuitively understood as functions measuring the similarity of pairs of graphs. They allow kernelized learning algorithms such as support vector machines to work directly on graphs, without having to do feature extraction to transform them to fixed-length, real-valued feature vectors. They find applications in bioinformatics, in chemoinformatics (as a type of molecule kernels), and in social network analysis.\nGraph kernels were first described in 2002 by R. I. Kondor and John Lafferty as kernels on graphs, i.e. similarity functions between the nodes of a single graph, with the World Wide Web hyperlink graph as a suggested application. Vishwanathan et al. instead defined kernels between graphs.\nAn example of a kernel between graphs is the random walk kernel, which conceptually performs random walks on two graphs simultaneously, then counts the number of paths that were produced by both walks. This is equivalent to doing random walks on the direct product of the pair of graphs, and from this, a kernel can be derived that can be efficiently computed.","alt_names":["graph kernel"],"name":"Graph kernel","categories":["All stub articles","Computer science stubs","Graph algorithms","Kernel methods for machine learning"],"tag_line":"In structure mining, a domain of learning on structured data objects in machine learning, a graph kernel is a kernel function that computes an inner product on graphs."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hopcroft–karp-algorithm","_score":0,"_source":{"description":"In computer science, the Hopcroft–Karp algorithm is an algorithm that takes as input a bipartite graph and produces as output a maximum cardinality matching – a set of as many edges as possible with the property that no two edges share an endpoint. It runs in  time in the worst case, where  is set of edges in the graph, and  is set of vertices of the graph. In the case of dense graphs the time bound becomes , and for random graphs it runs in near-linear time.\nThe algorithm was found by John Hopcroft and Richard Karp (1973). As in previous methods for matching such as the Hungarian algorithm and the work of Edmonds (1965), the Hopcroft–Karp algorithm repeatedly increases the size of a partial matching by finding augmenting paths. However, instead of finding just a single augmenting path per iteration, the algorithm finds a maximal set of shortest augmenting paths. As a result, only  iterations are needed. The same principle has also been used to develop more complicated algorithms for non-bipartite matching with the same asymptotic running time as the Hopcroft–Karp algorithm.","alt_names":[],"name":"Hopcroft–Karp algorithm","categories":["Graph algorithms","Matching"],"tag_line":"In computer science, the Hopcroft–Karp algorithm is an algorithm that takes as input a bipartite graph and produces as output a maximum cardinality matching – a set of as many edges as possible with the property that no two edges share an endpoint."}}
,{"_index":"throwtable","_type":"algorithm","_id":"network-simplex-algorithm","_score":0,"_source":{"description":"In mathematical optimization, the network simplex algorithm is a graph theoretic specialization of the simplex algorithm. The algorithm is usually formulated in terms of a standard problem, minimum-cost flow problem and can be efficiently solved in polynomial time. The network simplex method works very well in practice, typically 200 to 300 times faster than the simplex method applied to general linear program of same dimensions.","alt_names":[],"name":"Network simplex algorithm","categories":["All articles with unsourced statements","Articles with unsourced statements from May 2015","Computational problems in graph theory","Graph algorithms","Linear programming","Mathematical problems","Network flow","Network theory","Operations research","Optimization algorithms and methods","Polynomial-time problems"],"tag_line":"In mathematical optimization, the network simplex algorithm is a graph theoretic specialization of the simplex algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"journal-of-graph-algorithms-and-applications","_score":0,"_source":{"description":"The Journal of Graph Algorithms and Applications is an open access peer-reviewed scientific journal covering the subject of graph algorithms and graph drawing. The journal was established in 1997 and the editor-in-chief is Giuseppe Liotta (University of Perugia). It is abstracted and indexed by Scopus and MathSciNet.","alt_names":["Journal of Graph Algorithms and Applications","Journal of Graph Algorithms and Applications; it is","http://en.wikipedia.org/wiki/Journal_of_Graph_Algorithms_and_Applications"],"name":"Journal of Graph Algorithms and Applications","categories":["Computer science journals","English-language journals","Graph algorithms","Graph drawing","Mathematics journals","Publications established in 1997"],"tag_line":"The Journal of Graph Algorithms and Applications is an open access peer-reviewed scientific journal covering the subject of graph algorithms and graph drawing."}}
,{"_index":"throwtable","_type":"algorithm","_id":"block-sort","_score":0,"_source":{"description":"Block sort, or block merge sort, is a sorting algorithm combining at least two merge operations with an insertion sort to arrive at O(n log n) in-place stable sorting. It gets its name from the observation that merging two sorted lists, A and B, is equivalent to breaking A into evenly sized blocks, inserting each A block into B under special rules, and merging AB pairs.\nOne practical algorithm for block sort was proposed by Pok-Son Kim and Arne Kutzner in 2008.","alt_names":[],"name":"Block sort","categories":["Articles with example pseudocode","Comparison sorts","Sorting algorithms","Stable sorts"],"tag_line":"Block sort, or block merge sort, is a sorting algorithm combining at least two merge operations with an insertion sort to arrive at O(n log n) in-place stable sorting."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sethi–ullman-algorithm","_score":0,"_source":{"description":"In computer science, the Sethi–Ullman algorithm is an algorithm named after Ravi Sethi and Jeffrey D. Ullman, its inventors, for translating abstract syntax trees into machine code that uses as few registers as possible.\n\n","alt_names":[],"name":"Sethi–Ullman algorithm","categories":["Compiler construction","Graph algorithms"],"tag_line":"In computer science, the Sethi–Ullman algorithm is an algorithm named after Ravi Sethi and Jeffrey D. Ullman, its inventors, for translating abstract syntax trees into machine code that uses as few registers as possible.\n\n"}}
,{"_index":"throwtable","_type":"algorithm","_id":"bubble-sort","_score":0,"_source":{"description":"Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm, which is a comparison sort, is named for the way smaller elements \"bubble\" to the top of the list. Although the algorithm is simple, it is too slow and impractical for most problems even when compared to insertion sort. It can be practical if the input is usually in sort order but may occasionally have some out-of-order elements nearly in position.\n\n","alt_names":["مرتبسازی حبابی","bubble-sort","bubble sort","Bubble Sort","Bubble sort","% http://en.wikipedia.org/wiki/Bubble 5Fsort","'BubbleSort'","(Source:http://en.wikipedia.org/wiki/Bubble_sort)","* it under the terms of the GNU General","- Bubble sort :","...Wikipedia Bubble sort","...Wikipedia Ordenamiento de burbuja","...Wikipedia Sortowanie bąbelkowe","...Wikipedia Tri à bulles","...d_even_sort_animation.gif","...mehr auf Wikipedia über Bubblesort","...more on Wikipedia about Bubble sort","1 Dowód matematyczny","1. Bubble sort - Wikipedia, the free encyclopedia","1.2 Rabbits and turtles","1.3 Step-by-step example","10. Bubble sort - Wikipedia, the free encyclopedia","2 Złożoność obliczeniowa","2. Bubble sort - Wikipedia, the free encyclopedia","2.1 Modyfikacje powodujące ulepszenie czasu","2.1 Pseudocode implementation","2.1 Rendimiento en casos óptimos","2.2 Conejos y Tortugas (Yo-yos) (?)","2.2 Optimizing bubble sort","3 En la práctica","3 Przykład działania","4 Pseudokod","5 Implementacja","8. Bubble sort - Wikipedia, the free encyclopedia","?a????µ?s? f?sa??da? - ????pa?de","?a????ĩ?s? f?sa??da? - ????pa?de","AUTOMA DI BUBBLE SORT","Algorisme de bombolla","Algoritmo Burbuja","Algoritmo de Ordenamiento Burbuja","Algoritmo de Ordenamiento de Burburja (Bubblesort)","Algoritmo de intercambio directo","Algoritmo de la Burbuja","Algoritmo di ordinamento: Bubble Sort","Amazon.com: Squinkies Bubble Pack - Series Five: Toys","Aqui tiene sal repsuesta.. has click aqui","Art Blase","BUBBLE SORT","BUBLE SORT","BURBUJA","Bei Wikipedia gibt es genug dazu","Blubblesort","Boblesortering - Wikipedia, den frie enc...","Boblesortering - Wikipedia, den frie encyklopædi","Bubbel Sort","Bubbelsortering","Bubbelsortering - Wikipedia","Bubble Pagsunud-sunurin ayon","Bubble Sort - A horrible O(n 2 ) algorithm","Bubble Sort - Erklärung","Bubble Sort - Wikipedia","Bubble Sort Description","Bubble Sort algorithm","Bubble Sort algoritme","Bubble Sort from Wikipedia","Bubble Sort on Wikipedia","Bubble Sort sur Wikipedia","Bubble Sort)","Bubble Sort,","Bubble Sort, Sumber: Wikipedia","Bubble Sort.","Bubble Sorte","Bubble Sorter","Bubble Sorting","Bubble Sorting Algorithm","Bubble druh","Bubble slags","Bubble sort (Wikipedia)","Bubble sort (wikipedia)","Bubble sort - Wikipedia","Bubble sort - Wikipedia, th...","Bubble sort - Wikipedia, the free encyclopedia","Bubble sort - Wikipedia, the free encyclopedia Bubble sort","Bubble sort - Wikipédia, a enciclopédia livre","Bubble sort - wiki","Bubble sort ? Wikip?dia, a enciclop?dia livre","Bubble sort From Wikipedia, the free encyclopedia","Bubble sort Wikipdia, a enciclopdia livre","Bubble sort Wikipedia the free encyclopedia","Bubble sort Wikipedia the free encyclopedia - result","Bubble sort algorithm","Bubble sort from Wikipedia","Bubble sort in Wikipedia","Bubble sort na Wikipédia","Bubble sort or Sinking sort graphical representation","Bubble sort – Wikipedia, the free encyclopedia","Bubble sort – Wikipédia, a enciclopédia livre","Bubble sort!","Bubble sort(Wikipedia)","Bubble sort.","Bubble sort:","Bubble sort: Rabbits and turtles","Bubble sort; it is used under the","Bubble sorta","Bubble sortere","Bubble sorting","Bubble sortowania","Bubble sortu","Bubble třídit","Bubble Сортировать","Bubble Сортировка.","Bubble рода","Bubble рода!","Bubble-","Bubble-Sort","Bubble-Sort Algorithmus","Bubble-Sort Funktion","Bubble-Sort.","Bubble-Sortieralgorithmus","Bubble-sort","BubbleSort","BubbleSort Algo","BubbleSort Algorithmus","BubbleSort at Wikipedia (DE)","BubbleSort at Wikipedia (EN)","BubbleSort bei Wikipedia (DE)","BubbleSort bei Wikipedia (EN)","BubbleSort-Algorithmus","BubbleSort-Algorithmus,","BubbleSorter","Bubble_Sort","Bubble_Sort bei der wikipedia","Bubble_sort","Bubble_sort [Wikipedia]","Bubble_sort_animation","Bubble_sort_animation.gif","Bubblesort","Bubblesort (Wikipedia)","Bubblesort - Wikipedia","Bubblesort ? Wikipedia","Bubblesort Wikipedia","Bubblesort algorithm","Bubblesort bei der wikipedia","Bubblesort bei wikipedia.de","Bubblesort in","Bubblesort page","Bubblesort prinzip","Bubblesort â€“ Wikipedia","Bubblesort – Wikipedia","Bubblesort-Algorithmus","Bubblesort-Sortieralgorithmus","Bubblesort:","Bubblesortalgorithmus","Bubblesorts","Buble sort","Bublinkové triedenie","Bublinkové triedenie - Wikipédia - Wikipedia","Bublinkové řazení","Bublinkové řazení - Wikipedie","Buborék rendező algoritmus","Buborékrendezés","Buborékrendezés - Wikipédia","Burbuja!!!","Burbulo","Burbulo rikiavimo algoritmas","Bóluröðun","CONTROLLARE PER CREDERE!!!","Click here. (IMG:","Cортировка пузырьком","Definiciones y Uso","Definición de Ordenamiento de burbuja más completo","Donald Knuth, in his famous The Art of","Due to its simplicity, the bubble sort is","Ejemplo de Ordenamiento tipo Bubble Sort","Encyclopedia: Bubble sort","Exchange sort","Fuente texto original","Gelembung semacam","Genaue Erklärung zu Bubblesort bei Wikipedia... (sehr gut","In informatica il Bubble sort o bubblesort (letteralmente","Is anyone else pretty impressed by the images","Kabarcık Sıralaması","Kabarcık sıralaması","Kabarcık sıralaması - Vikipedi","Klassiker Bubble-Sort-Algorithmus","Kliknij po więcej.","Kuplalajittelu","Kuplalajittelu – Wikipedia","Mehurčno urejanje","Metodo Burbuja","Mullisortimine","Mullsortimine","Método de la Burbuja","Método de la burbuja","Método de la burbuja.","Nie za bardzo nadaje się on do czegokolwiek","No more bubble-sort","O(N * N)","Obama knows how to sort things out!","Ordenamiento Burbuja","Ordenamiento de burbuja","Ordenamiento de burbuja - Wikipedia, la enciclopedia libre","Ordenamiento de burbuja!","Ordenamiento por burbuja","Ordenamiento tipo Burbuja","Ordinamento a bolle.","Ordinamento bubble sort","Phân loại Bubble.","Phân loại bong bóng","Please pick me","Read More bubble sort wikipedia the free encyclopedia","Read this to understand what your code is","Rêzkerdişê çimokan","See more about Bubble Sort...","So, like me, you're probably wondering what","Sort Algorithm","Sort Burbuja","Sortowanie bąbelkowe","Sortowanie bąbelkowe - Wikipedia, wolna encyklopedia","Sortowanie bąbelkowe – Wikipedia, wolna encyklopedia","Sortowanie bąbelkowe:","Sắp xếp nổi bọt","Sắp xếp nổi bọt – Wikipedia tiếng Việt","Sắp xếp nổi bọt!","The Bubble Sort","The Bubblesort Algorithm","Tri bulles pdia","Tri par bulles","Tri à bulles","Tri à bulles (C/C++/Java)","Tri à bulles - Wikipédia","Tri à bulles sur Wikipedia","Tri à bulles!","URL >>Здесь","Urejanje z mehurčki","Visulisation of a bubble sort","Víxlunarröðun","Víxlunarröðun - Wikipedia, frjálsa alfræðiritið","Was ist die Komplexität dieses Algorithmu","What are variations of Bubble sort/C?","What is implementation of Bubble sort algorithm?","Wiki: Sortowanie bąbelkowe","WikiPeja:バブルソート","Wikipedia (Bubble sort)","Wikipedia - Bubble Sort","Wikipedia - Bubble sort","Wikipedia - Bubblesort","Wikipedia -> Bubble Sort","Wikipedia : バブルソート","Wikipedia Bubble Sort","Wikipedia Bubblesort-Artikel","Wikipedia Ordenamiento de burbuja","Wikipedia article Boblesortering","Wikipedia article Bubble Sort","Wikipedia article Bubble sort","Wikipedia article Bubblesort","Wikipedia article Ordenamiento de burbuja","Wikipedia article Rêzkerdişê çimokan","Wikipedia article on Bubble Sort","Wikipedia article on Bubble sort","Wikipedia article on Bubblesort","Wikipedia article on Ordenamiento de burbuja","Wikipedia article Көпіршіктік сүрыптау (көпіршік әдісімен сүрыптау)","Wikipedia article מיון בועות","Wikipedia article مرتبسازی حبابی","Wikipedia article ബബിൾ സോർട്ട്","Wikipedia article การเรียงลำดับแบบฟอง","Wikipedia article 거품 정렬","Wikipedia artikel Bubblesort","Wikipedia entry for Bubble sort","Wikipedia l'articolo Bubblesort","Wikipedia on Bubble Sort","Wikipedia page for Bubblesort","Wikipedia provides two pseudocode implementations of the bubble","Wikipedia viene un ejemplo en Java","Wikipedia バブルソート","Wikipedia's Bubble sort page","Wikipedia-Artikel Bubble Sort","Wikipedia-Artikel Bubblesort","Wikipedia-Artikel zu Bubblesort","Wikipedia-MetodoBurbuja","Wikipedia-Seite zu 'Bubble Sort'","Wikipedia-Seite zu 'Bubblesort'","Wikipedia: Bubble Sort","Wikipedia: Bubble sort","Wikipediaで「基本交換法」を調べる","Wikipediaで「隣接交換法」を調べる","Wikipédia artigo Bubble sort","Wikipédia artigo Bubblesort","Wikipédia artigo Classificação Bolha","Wikipédia artigo Classificação bolha","[10] Bubble sort","a particularly inefficient sorting algorithm","a really cool sorting","algorithm description","algorithm presented here","algoritmo burbuja","algoritmo de la burbuja","algorytm sortowania bąbelkowego","algorítmo da bolha","aquí tienes el link","artigo da Wikipédia Bubble sort","artículo de Wikipedia Algoritmo de intercambio directo","beispielhaften Pseudocode bei Wikipedia","belajar bubble sort","boble slags","boble sorterer","bubble sor","bubble sort algorithm","bubble sort program","bubble sort pseudo code","bubble sort subroutine","bubble sort wikipedia the free encyclopedia","bubble sort.","bubble sorting","bubble sorting machines","bubble sortowania","bubble sorts","bubble-sorting algorithm","bubble_sort","bubblesort","bubblesort routine","bubblesort.","bubblesortanimation.gif","bubblesorting","bublina řazení","bublinkove triedenie","bublinkové triedenie","bublinkové třídění","bubliny řazení","bublině řazení","bublle sort","buborék rendezést","buborékrendezés","buborékrendezésnek","buborékrendezést","buddle sort","burbulo metodas","bąbelkowa","bąbelkowe","bąbelkowe na wiki","classic bubble sort algorithm","classico algoritmo bubble sort","classificação de bolhas.","comparatively inefficient in practice","continue reading http://en.wikipedia.org/wiki/Bubble_sort","cs:Bublinkové řazení","de.wikipedia.org/wik...Formaler_Algorithmus","de.wikipedia.org/wiki/Bubble_Sort","de.wikipedia.org/wiki/Bubblesort","de.wikipedia.org/wiki/Bubblesort#Java","de:Bubblesort","denn artikel auf wikipedia","des programmes","di ordinamento Bubble","druh bubliny","einen bekannten Sortieralgorithmus","el algoritmo de ordenamiento de la burbuja","el de la burbuja","el método de la burbuja","en.wikipedia.org/Bubble_sort","en.wikipedia.org/wik...tive_implementations","en.wikipedia.org/wiki/Bubble_sort","en.wikipedia.org/wiki/Bubble_sort#Alternative_implementations","en.wikipedia.org/wiki/Bubble_sort#Pseudocode_implementation","en.wikipedia.org/wiki/Bubblesort","en:Bubble_sort","especie de burbuja","especie de burbuja.","espécie de bolha.","et:Mullisortimine","et:Mullsortimine","exchange sort","explanation of the bubble sort","f bubble so","fa:مرتبسازی حبابی","fertigen Bubblesort","formalen Algorithmus","good description of bubble sort","hier mal reinsehen","http://cs.wikipedia.org/wiki/Bubble_sort","http://cs.wikipedia.org/wiki/Bublinkov% ... azen%C3","http://cs.wikipedia.org/wiki/Bublinkov%C3%A9_","http://da.wikipedia.org/wiki/Boblesortering","http://de.wikipedia.org/wiki/Bu bblesort","http://de.wikipedia.org/wiki/Bubble_Sort","http://de.wikipedia.org/wiki/Bubbles...nstigster_Fall","http://de.wikipedia.org/wiki/Bubblesort","http://de.wikipedia.org/wiki/Bubblesort#C.2B","http://de.wikipedia.org/wiki/Bubblesort#Delphi","http://de.wikipedia.org/wiki/Bubblesort#Formaler_Algorithmus","http://de.wikipedia.org/wiki/Bubblesort#PHP","http://de.wikipedia.org/wiki/Bubblesort#Prinzip","http://de.wikipedia.org/wiki/Bubblesort#Visual_Basic","http://de.wikipedia.org/wiki/Bubblesort#cite_note-0","http://de.wikipedia.org/wiki/Bubblesort]Programm[/url","http://el.wikipedia.org/wiki/Ταξινόμηση_φυσαλίδας","http://en.wikiped...ubble_sort","http://en.wikipedia....by-step_example","http://en.wikipedia....iki/Bubble_sort","http://en.wikipedia....wiki/Bubblesort","http://en.wikipedia.org/wiki/Bubble sort","http://en.wikipedia.org/wiki/Bubble% 5Fsort","http://en.wikipedia.org/wiki/Bubble%5Fsort","http://en.wikipedia.org/wiki/Bubble_...implementation","http://en.wikipedia.org/wiki/Bubble_...y-step_example","http://en.wikipedia.org/wiki/Bubble_Sort","http://en.wikipedia.org/wiki/Bubble_Sort#Performance","http://en.wikipedia.org/wiki/Bubble_sor ... ementation","http://en.wikipedia.org/wiki/Bubble_sort","http://en.wikipedia.org/wiki/Bubble_sort [C","http://en.wikipedia.org/wiki/Bubble_sort#Alternative_implementations","http://en.wikipedia.org/wiki/Bubble_sort#Implementation","http://en.wikipedia.org/wiki/Bubble_sort#In_practice","http://en.wikipedia.org/wiki/Bubble_sort#Performance","http://en.wikipedia.org/wiki/Bubble_sort#Pseudocode_implementation","http://en.wikipedia.org/wiki/Bubble_sort#Step-by","http://en.wikipedia.org/wiki/Bubble_sort)","http://en.wikipedia.org/wiki/Bubble_sort.","http://en.wikipedia.org/wiki/Bubble_sort…","http://en.wikipedia.org/wiki/Bubblesort","http://en.wikipedia.org/wiki/Bubblesort#Optimizing_bubble_sort","http://en.wikipedia.org/wiki/Bubblesort#Pseudocode_implementation","http://en.wikipedia.org/wiki/Bubble％5Fsort","http://es.wikipedia.org/wiki/Bubblesort","http://es.wikipedia.org/wiki/Bubblesort#…","http://es.wikipedia.org/wiki/M%C3%A9todo_de_la_burbuja","http://es.wikipedia.org/wiki/Ordenamiento_de_burbuja","http://es.wikipedia.org/wiki/Ordenamiento_de_burbuja#Descripci.C3","http://es.wikipedia.org/wiki/Ordenamiento_de_burbuja#Implementaci.C3","http://es.wikipedia.org/wiki/O​rdenamiento_de_burbuja","http://et.wikipedia.org/wiki/Mullisortimine","http://et.wikipedia.org/wiki/Mullsortimine","http://fr.wikipedia.org/wiki/Tri_%C3%A0_","http://fr.wikipedia.org/wiki/Tri_%C3%A0_bulles","http://fr.wikipedia.org/wiki/Tri_à","http://fr.wikipedia.org/wiki/Tri_à_bulle","http://fr.wikipedia.org/wiki/Tri_à_bulles","http://he.wikipedia.org/wiki/%D7%9E...2","http://he.wikipedia.org/wiki/מיון_בועות","http://hu.wikipedia.org/wiki/Bubor%C3%A9krendez","http://hu.wikipedia.org/wiki/Buborékrendezés","http://is.wikipedia.org/wiki/B%C3%B3lur","http://is.wikipedia.org/wiki/V%C3%ADxlunarr","http://it.wikipedia.org/wiki/Bubble_sor ... e_astratta","http://it.wikipedia.org/wiki/Bubble_sort","http://it.wikipedia.org/wiki/Bubble_sort#Lisp","http://it.wikipedia.org/wiki/Bubble_sort#Pseudocodice","http://it.wikipedia.org/wiki/Bubble_sort…","http://it.wikipedia.org/wiki/Bubblesort","http://ja.wikipedia.org/wiki/バブルソート","http://ko.wikipedia.org/wiki/거품_정렬","http://lt.wikipedia....vimo_algoritmas","http://lt.wikipedia.org/wiki/Burbuliuko_metodas","http://lt.wikipedia.org/wiki/Burbulo_r%C5%AB","http://lt.wikipedia.org/wiki/Burbulo_ri ... algoritmas","http://lt.wikipedia.org/wiki/Burbulo_ri … algoritmas","http://lt.wikipedia.org/wiki/Burbulo_rikiavimo_algoritmas","http://nl.wikipedia.org/wiki/Bubblesort","http://pl.wikiped...%85belkowe","http://pl.wikipedia...._b%C4%85belkowe","http://pl.wikipedia...._b&#261;belkowe","http://pl.wikipedia....owanie_bbelkowe","http://pl.wikipedia....wanie_bąbelkowe","http://pl.wikipedia.org/w..._b%C4%85belkowe","http://pl.wikipedia.org/w...zyk.C5.82ad_w_C","http://pl.wikipedia.org/wiki/Sortowanie ... .C5.82ania","http://pl.wikipedia.org/wiki/Sortowanie_b%C4%85be","http://pl.wikipedia.org/wiki/Sortowanie_b%C4%85belkowe","http://pl.wikipedia.org/wiki/Sortowanie_bąbelkowe","http://pt.wikipedia....iki/Bubble_sort","http://pt.wikipedia.org/wiki/Bubble_...mulador_Online","http://pt.wikipedia.org/wiki/Bubble_sort","http://pt.wikipedia.org/wiki/Bubble_sort#Assembly","http://pt.wikipedia.org/wiki/Bubble_sort#C","http://pt.wikipedia.org/wiki/Bubble_sort#C.2B","http://pt.wikipedia.org/wiki/Bubble_sort#JAVA","http://pt.wikipedia.org/wiki/Bubble_sort#Java","http://pt.wikipedia.org/wiki/Bubble_sort#Pascal","http://pt.wikipedia.org/wiki/Bubble_sort#Shell_script","http://pt.wikipedia.org/wiki/Bubble_sort…","http://pt.wikipedia.org/wiki/Bubblesort#C","http://ru.wikipedia.org/wiki/Пузырьковая_сортировка","http://ru.wikipedia.org/wiki/Сортиро...зырьком#Pascal","http://ru.wikipedia.org/wiki/Сортировка_методом_пузырька","http://ru.wikipedia.org/wiki/Сортировка_пузырьком","http://ru.wikipedia.org/wiki/Сортировка_пузырьком#C","http://sk.wikipedia.org/wiki/Bubble_sort","http://sk.wikipedia.org/wiki/Bublinkové_triedenie","http://sl.wikipedia.org/wiki/Mehur%C4%8Dno_urejanje","http://sv.wikipedia.org/wiki/Bubbelsortering","http://tr.wikipedia.org/wiki/Kabarc%...1ralamas%C4","http://tr.wikipedia.org/wiki/Kabarc%C4%B1k_s","http://zh.wikipedia.org/wiki/冒泡排序","http://zh.wikipedia.org/zh-tw/% E5% 86","http://zh.wikipedia.org/zh-tw/冒泡排序","hu:Buborékrendezés","is:Víxlunarröðun","j http://pl.wikipe","jest na wikipedii","kk:Көпіршіктік сүрыптау (көпіршік әдісімен сүрыптау)","klasickou bublinu algoritmus druhu","klassiske boblen slags algoritme","klasyczny algorytm sortowania bąbelkowego","kuplalajittelu","kuplalajittelulla","kuplalajittelun","l'article de Wikipédia Bubble Sort","l'article de Wikipédia Bubblesort","la clase de burbuja","la ordenación de burbuja.","le tri bulle","lezen over het","like on the side of this wiki article","little better","loại bong bóng.","mais sobre bubble sort","metodo burbuja","metodo de la burbuja","metodą bąbelkową","ml:ബബിള് സോര്ട്ട്","ml:ബബിൾ സോർട്ട്","możliwe są inne implementacje","mullsorteerimist","mullsortimine","mullsortimist","método Burbuja","método de la burbuja","método de la burbuja o bubble sort","método de ordenacion de la burbuja","najgorszy i średnia złożoność zarówno О (n2)","ng på http://en.wikipe","o Bubble Sort","optimised version","ordenació de bombolla","ordenación de burbuja","ordenamiento burbuja","ordenamiento de burbuja","ordenamiento de la burbuja.","ordenamiento por burbuja","ordenar burbuja de","ordenação por bolha","pl.wikipedia.org/wiki/Sortowanie_bąbelkowe","przeczytać na jej temat","pseudocode on wikipedia here","qui per esempio","re http://en.wikipedia.org/wiki/Bubble_sort.","ru.wikipedia.org/wiki/Сортировка_пузырьком","semacam gelembung.","sencillo pero el menos eficiente","simple:Bubble sort","sinking sort","sort things","sorting by a vial","sortowania bąbelkowego","sortowanie babelkowe","sortowanie bąbelkowe","state-of-the-art matching algorithm","step-by-step example","sv:Bubbelsortering","sắp xếp Bubble","telle que celle donnée dans Wikipedia","th:การเรียงลำดับแบบฟอง","the pass through the list is repeated until","tiga: bubble sort","tiga: バブルソート - Wikipedia ランダム配列数のバブルソートの例","tiga: バブルソート - Wikipedia ランダム配列数のバブルソートの例バブルソートは基本情報技術者の試験勉強で知ってるけど、これがなにかわからない。","tipo Bubble","tipo bolha.","tipo burbuja","tp://en.wikipedia.org/wiki/Bubblesort","tri bulle","tri à bulle","tri à bulles","tri à bulles.","ttp://en.wikipedia.org/wiki/Bubble_sort","ubble sort","urejanje z mehurčki","w:Сортировка пузырьком","wikipedia docet again","wikipedia:バブルソート","worst-case and average complexity both ?(n2)","worst-case and average complexity both О(n2","worst-case en de gemiddelde complexiteit zowel О","z. B. http://de.wikipedia","zu Punkt 3","¿ Que Es ?","Ταξινόμηση Φυσαλίδας","Ταξινόμηση φυσαλίδας","Ταξινόμηση φυσαλίδας - Βικιπαίδεια","Алгоритм в википедии.","Алгоритм сортировки пузырьком","Ваша палата тут, сэр","Википедии статью Пузырьковая сортировка","Код смотреть тут","Көпіршіктік сүрыптау (көпіршік әдісімен сүрыптау)","Метод на мехурчето","Метод на мехурчето — Уикипедия","Пирамидальная сортировка на Википедии","Пример работы алгоритма","Пузырьковая сортировка","Пузырьковая сортировка на Википедии","Пузырьком","Сортиране по метода на мехурчето","Сортировка Пузырьком","Сортировка пузырьком","Сортировка пузырьком - Википедия","Сортировка пузырьком на ru.wikipedia.org","Сортировка пузырьком — Википедия","Сортировка_пузырьком","Сортування бульбашкою","Так что дерзай","Читай тут про сортировку пузырьком и смотри реализацию","алгоритма сортировки пузырьком","вид пузыря","должен знать каждый","классический алгоритм сортировки пузырь","метода на мехурчето","методом пузырька","мехурчето","наихудшим и средней сложности как О (п2)","описание сортировки пузырьком","простым обменом","пузырь Сортировка.","пузырькoвую coртирoвку","пузырьковая сортировка","пузырьковой","пузырьковой сортировки","пузырьковой сортировки.","пузырьковую сортировку","пузырьковую сортировку (wikipedia)","пузырьком","сортиране по метода на мехурчето","сортировка простыми обменами","сортировка пузырьком","сортировки пузырьком","сортировку пузырьком","сортування бульбашкою","сортування обміном","сортування стандартним обміном","ויקיפדיה - 'מיון בועות'","מיון בועות","מיון בועות – ויקיפדיה","ראה גם ב wiki","ترتيب الفقاعات","توضیحات مرتبط با روش حبابی در ویکیپدیا فارسی","حبابی","مرتب سازی حبابی","مرتبسازی حبابی - ویکیپدیا","مرتبسازی_حبابی/bubble sort","क्लासिक बुलबुला तरह एल्गोरिथ्म","ബബിൾ സോർട്ട്","විස්තර මෙන්න.","การเรียงลำดับแบบฟอง","จัด เรียง ข้อความ","จัด เรียง ข้อความ.","เรียง ข้อความ.","เรียง ลำดับ ข้อความ!","“泡沫排序”","→ Статья «Сортировка пузырьком»","、バブルソート","「バブルソート」についてWikipediaで調査","「バブルソート」をWikipediaで調べる","「バブルソート」をWikiで調べる","「基本交換法」をWikiで調べる","「隣接交換法」をWikiで調べる","ウィキペディア(バブルソート)","ウィキペディアの記事 基本交換法","バブル ソート","バブルソート","バブルソート - Wikipedia","バブルソート - Wikipedia ランダム配列数のバブルソートの例","バブルソート(Wikipedia)","バブルソートの","バブルソートは、","バブルソートを","典型的泡沫排序算法","冒泡排序","冒泡排序- 維基百科，自由的百科全書","冒泡排序- 维基百科，自由的百科全书","冒泡排序，自由的百科全书- 维基百科","古典的なバブルソートアルゴリズムを","基本交換法","念起来就可以了","最坏情况和平均复杂度都О（N2）","气泡排序","氣泡排序","氣泡排序法","氣泡排序法(bubble sort)","氣泡排序法（bubble sort）","泡沫排序： Bubble Sort","泡泡排序法","看到這個我才知道為什麼要叫bubble sort...","維基百科的文章“ 冒泡排序”","維基百科的文章“ 氣泡排序”","維基百科～Bubble_sort","起泡排序","거품 정렬","거품 정렬 - 위키백과, 우리 모두의 백과사전","거품 정렬 위키백과, 우리 모두의백과사전","거품 정렬을","거품 정렬을위한","버블 정렬!","버블 정렬로","버블 정렬을","버블 정렬이","위키 피 디아 문서 거품 정렬","위키백과-버블 정렬","ﾊﾞﾌﾞﾙｿｰﾄ-wikipedia"],"name":"Bubble sort","categories":["All articles with unsourced statements","Articles with example pseudocode","Articles with specifically marked weasel-worded phrases from November 2015","Articles with unsourced statements from August 2015","Commons category with local link same as on Wikidata","Comparison sorts","Pages with syntax highlighting errors","Sorting algorithms","Stable sorts","Wikipedia articles needing clarification from October 2014"],"tag_line":"Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order."}}
,{"_index":"throwtable","_type":"algorithm","_id":"merge-sort","_score":0,"_source":{"description":"In computer science, merge sort (also commonly spelled mergesort) is an efficient, general-purpose, comparison-based sorting algorithm. Most implementations produce a stable sort, which means that the implementation preserves the input order of equal elements in the sorted output. Mergesort is a divide and conquer algorithm that was invented by John von Neumann in 1945. A detailed description and analysis of bottom-up mergesort appeared in a report by Goldstine and Neumann as early as 1948.\n\n","alt_names":["Sortowanie przez scalanie","Merge-sort","mergesort","MergeSort","Merge sort","merge sort","(In-place) マージソート","(http://de.wikipedia.org/wiki/Mergesort)","- Merge sort :","- Mergesort :","-> Leggi tutto l'articolo su 'Merge sort'","-> Read the article about 'Merge sort'","... of random dots class sorting algorithm data structure","...Wikipedia Merge sort","...Wikipedia Mergesort","...Wikipedia Ordenamiento por mezcla","...Wikipedia Sortowanie przez łączenie proste","...Wikipedia Tri fusion","...mehr auf Wikipedia über Mergesort","...more on Wikipedia about Merge sort","1. Merge sort - Wikipedia, the free encyclopedia","1.1 Merge Sort Algorithm","3 Merge sorting tape drives","4 Optimizing merge sort","5 Comparison with other sort algorithms","6 Utility in online sorting","<b>Merge b> sort - Wikipedia, the free encyclopedia","@ 병합 정렬(위키피디아)","Algorisme per mescla","Art zusammenführen","Art. s.v. Mergesort in Wikipedia","Balanced merge sort","Birle?tirmeli s?ralama - Vikipedi","Birleştirme sıralaması","Birleştirme sıralamasının optimizasyonu","Birleştirmeli Sıralama","Birleştirmeli sıralama","Combinar Ordenar","Comparison with other sort algorithms","Da Mergesort die Startliste sowie alle Zwischenlisten sequenziell","Die sortierten kleinen Listen werden dann im Reißverschlussverfahren","Encyclopedia: Merge sort","Example of merge sort sorting a list of","Flet Sort","Flet Sortér","Flet slags","Just spent several hours alphabetizing 563 name slips","Katajainen, Pasanen & Teuhola 1996","Kronrod (1969)","Kunfanda ordigo","Kunfanda ordigo - Vikipedio","LaMarca & Ladner 1997","Learn about Merge sort>>>","Lomituslajittelu","Lomituslajittelu – Wikipedia","Look into merge sort","MERGE SORT","Merg-sort.png","Merge Phân loại","Merge Sort","Merge Sort - Another O(n lg(n)) algorithm","Merge Sort - Wikipedia","Merge Sort Algorithm on wiki","Merge Sort Wikipedia The Free Encyclopedia","Merge Sort algorithm","Merge Sort.","Merge Sorting","Merge Sorts","Merge sort - Wikipedia","Merge sort - Wikipedia bahasa Indonesia, ensiklopedia bebas","Merge sort - Wikipedia, the free encyclopedia","Merge sort - Wikipedia, the free encyclopedia http://en","Merge sort - Wikipedia, the free encyclopedia »","Merge sort - Wikipedia, the free encyclopedia — shared on","Merge sort - Wikipedie","Merge sort - Wikipédia","Merge sort - Wikipédia, a enciclopédia livre","Merge sort :: Wikipedia Bahasa Indonesia","Merge sort Wikipedia page","Merge sort Wikipedia the free encyclopedia","Merge sort analysis","Merge sort in Wikipedia","Merge sort is an O(n log n","Merge sort – Wikipédia, a enciclopédia livre","Merge sort,","Merge sort:","Merge sort: Comparison with other sort algorithms","Merge sort: Wikipedia article on merge sort","Merge sort:n","Merge sort; it is used under the","Merge sorting","Merge sorting tape drives","Merge – Sort","Merge-Sort","Merge-Sort Algorithmus","MergeSort - Wikipedia","MergeSort Algorithm","MergeSort algorithm","MergeSort at Wikipedia (DE)","MergeSort at Wikipedia (EN)","MergeSort bei Wikipedia (DE)","MergeSort bei Wikipedia (EN)","MergeSort in Action","MergeSort-Algorithmus","MergeSorter","Merge_Sort","Merge_sort","Merge_sort_animation2.gif","Mergesort","Mergesort (Wikipedia)","Mergesort - Wikipedia","Mergesort ? Wikipedia","Mergesort Algorithmus","Mergesort Wikipediaartikel","Mergesort bei Wikipedia","Mergesort – Wikipedia","Mergesort,","Mergesort-Algorithmus","Mergesort-Algorithmus,","Mergesort.","Mergesort; it is used under the","Mergesort를","Mergesort을","Mestimissortimine","Natural Mergesort","Optimizing merge sort","Ordenamiento por Mezcla","Ordenamiento por mezcla","Ordenamiento por mezcla - Wikipedia, la enciclopedia libre","Pascal-Variante","Phân loại hợp nhất","Read More merge sort wikipedia the free encyclopedia","Sameiningarröðun","See Wiki for details)","Sloučit Seřadit","Sortowanie przez scalanie - Wikipedia, wolna encyklopedia","Sortowanie przez scalanie ? Wikipedia, wolna encyklopedia","Sortowanie przez scalanie – Wikipedia, wolna encyklopedia","Sumanib Pagsunud-sunurin ayon","Sąlajos","Sąlajos rikiavimo algoritmas – Vikipedija","Sắp xếp trộn","The Merge Sort","Tri fusion","Tri fusion (C)","Tri fusion - Wikip?dia","Tri fusion - Wikipédia","Tri par fusion","Triedenie zlučovaním","Triedenie zlučovaním - Wikipédia","Urejanje z zlivanjem","View Merge sort on Wikipedia","What is algorithm of Merge Sort?","What is algorithm of MergeSort?","What is analysis of Balanced k-way merge","Wiki: Merge Sort","WikiPedia entri","WikiPedia nhập","WikiPedia въезд","WikiPedia：归并排序（Merge Sort，台灣譯作：合併排序）","Wikipedia - Merge Sort","Wikipedia - Merge sort","Wikipedia - Mergesort","Wikipedia Merge Sort","Wikipedia Merge sort","Wikipedia Mergesort page","Wikipedia article Kunfanda ordigo","Wikipedia article Merge Sort","Wikipedia article Merge sort","Wikipedia article Merge_sort","Wikipedia article Mergesort","Wikipedia article Sameiningarröðun","Wikipedia article on Merge Sort","Wikipedia article on Merge sort","Wikipedia article on Mergesort","Wikipedia article on Ordenamiento por mezcla","Wikipedia article on merge sort","Wikipedia article Тоғыстыру арқылы сүрыптау","Wikipedia article Միաձուլման տեսակավորում","Wikipedia article ترتيب دمجي","Wikipedia article تصنيف دمجي","Wikipedia article മെർജ് സോർട്ട്","Wikipedia artikel Merge sort","Wikipedia artikel Mergesort","Wikipedia discussion of Mergesort","Wikipedia entry for Merge sort","Wikipedia entry for mergesort","Wikipedia merge sort","Wikipedia on merge sort","Wikipedia page on Merge Sort","Wikipedia page on Mergesort","Wikipedia über Mergesort","Wikipedia's implementation of Mergesort in C","Wikipedia's version of Mergesort","Wikipedia-Artikel Merge Sort","Wikipedia-Artikel Mergesort","Wikipedia-Artikel Natural Mergesort","Wikipedia-Seite zu 'Mergesort'","Wikipedia/Mergesort","Wikipedia: Merge sort","Wikipedia: Mergesort","Wikipedia:Merge Sort","Wikipedia:Mergesort","Wikipedia:マージソート","Wikipedii o seryjnej sortowania","Wikipédia artigo Merge sort","Wikipédia artigo Mergesort","Xem cái này","[Merge sort]","a merge sort","a merge sort algorithm","algoritmoX","array merging","article Mergesort","artigo da Wikipédia Merge sort","artiklen i Wikipedia om fusionere sortere","artículo de Wikipedia Merge sort","artículo de Wikipedia Mergesort","artículo de Wikipedia Ordenamiento por mezcla","balanced k-way merge sort","balanced merge sort","basic merge sort","code pseudo de Wikipédia","combinación algoritmo de ordenación,","combinación de clase","combinar-tipo","código pseudo da Wikipédia","código pseudo de Wikipedia","de combinación tipo","de fusion algorithme de tri,","de mezcla tipo","de.wikipedia.org/wiki/Mergesort","disk based merge sort","druh sloučit","en.wikipedia.org/.../Mergesort","en.wikipedia.org/Merge_sort","en.wikipedia.org/wiki/Merge...","en.wikipedia.org/wiki/Merge_sort","en.wikipedia.org/wiki/Merge_sort#Analysis","en.wikipedia.org/wiki/Merge_sort#Utility_in_online_sorting","en.wikipedia.org/wiki/Mergesort","en.wikipedia.org/wiki/Mergesort#Analysis","erge sort","ergesort","es.wikipedia.org/wiki/Ordenamiento_por_mezcla","especie de combinación","especie de mezcla","et:Mestimissortimine","f1e2b72e76550b357d437bc95e9a ...","flette slags","flette sortere","fusionar tipo","fusionere slags","fusionere sortere","fusión especie","fusión tipo","fusão algoritmo de classificação,","fusão espécie","gabungan semacam","gregbrown: Just spent several hours alphabetizing 563 name","http://cs.wikipedia.org/wiki/Merge_sort","http://de.wikipedia.org/wiki/Me rgesort","http://de.wikipedia.org/wiki/Me rgesort#Komplexit","http://de.wikipedia.org/wiki/Merge_Sort","http://de.wikipedia.org/wiki/Mergesort","http://de.wikipedia.org/wiki/Mergesort#Implementierung","http://de.wikipedia.org/wiki/Mergesort#Pascal","http://de.wikipedia.org/wiki/Mergesort#Veranschaulichung_der_Funktionsweise","http://en.wikipedia....wiki/Merge_sort","http://en.wikipedia.org/wiki/Balanced_merge_sort","http://en.wikipedia.org/wiki/Merge_...ing_tape_drives","http://en.wikipedia.org/wiki/Merge_Sort","http://en.wikipedia.org/wiki/Merge_Sort#…","http://en.wikipedia.org/wiki/Merge_s...ng_tape_drives","http://en.wikipedia.org/wiki/Merge_s...ort_algorithms","http://en.wikipedia.org/wiki/Merge_sort","http://en.wikipedia.org/wiki/Merge_sort # Merge_sorting_tape_drives","http://en.wikipedia.org/wiki/Merge_sort ... algorithms","http://en.wikipedia.org/wiki/Merge_sort Merge sort","http://en.wikipedia.org/wiki/Merge_sort#Algorithm","http://en.wikipedia.org/wiki/Merge_sort#Analysis","http://en.wikipedia.org/wiki/Merge_sort#CITEREFKatajainenPasanenTeuhola1996","http://en.wikipedia.org/wiki/Merge_sort#Comparison_with_othe[..]","http://en.wikipedia.org/wiki/Merge_sort#Comparison_with_other_sort_algorith","http://en.wikipedia.org/wiki/Merge_sort#Comparison_with_other_sort_algorith=","http://en.wikipedia.org/wiki/Merge_sort#Comparison_with_other_sort_algorithms","http://en.wikipedia.org/wiki/Merge_sort#Merge_sort_using_tape_drives","http://en.wikipedia.org/wiki/Merge_sort#Merge_sorting_tape_d...","http://en.wikipedia.org/wiki/Merge_sort#Merge_sorting_tape_drives","http://en.wikipedia.org/wiki/Merge_sort#Use_with_tape_drives","http://en.wikipedia.org/wiki/Merge_sort#…","http://en.wikipedia.org/wiki/Merge_sort)","http://en.wikipedia.org/wiki/Merge_sort.","http://en.wikipedia.org/wiki/Merge_sort>","http://en.wikipedia.org/wiki/Merge_sort＃Merge_sorting_tape_drives","http://en.wikipedia.org/wiki/Mergesort","http://en.wikipedia.org/wiki/Mergesort#Algorithm","http://en.wikipedia.org/wiki/Mergesort#Compar...","http://en.wikipedia.org/wiki/Mergesort#Comparison_with_other_sort_algorithms","http://en.wikipedia.org/wiki/Mergesort#Merge_sorting_tape_drives","http://en.wikipedia.org/wiki/Mergesort#Python","http://es.wikipedia.org/wiki/Merge_sort","http://es.wikipedia.org/wiki/Mergesort","http://es.wikipedia.org/wiki/Ordenamiento_por...","http://es.wikipedia.org/wiki/Ordenamiento_por_m...","http://es.wikipedia.org/wiki/Ordenamiento_por_mezcla","http://et.wikipedia.org/wiki/Mestimissortimine","http://fi.wikipedia.org/wiki/Lomituslajittelu","http://fr.wikipedia.org/wiki/Tri_fusion","http://id.wikipedia.org/wiki/Merge_sort","http://id.wikipedia.org/wi​ki/Merge_sort","http://is.wikipedia.org/wiki/Sameiningarr%C3%B6","http://it.wikipedia....ki/Merge_sort#C","http://it.wikipedia.org/wiki/Merge_sort","http://it.wikipedia.org/wiki/Merge_sort#C.2B","http://ko.wikipedia.org/wiki/합병_정렬","http://nl.wikipedia.org/wiki/Mergesort","http://pl.wikipedia.org/wiki/Mergesort","http://pl.wikipedia.org/wiki/Sortowanie_przez_scalanie","http://pl.wikipedia.org/wiki/Sortowanie_przez_scalanie#Z.C5","http://pl.wikipedia.org/wiki/Sortowanie_pżez_scalanie","http://pt.wikipedia....wiki/Merge_sort","http://pt.wikipedia.org/wiki/Merge_sort","http://pt.wikipedia.org/wiki/Merge_sort#Java","http://pt.wikipedia.org/wiki/Merge_sort#…","http://pt.wikipedia.org/wiki/Mergesort","http://pt.wikipedia.org/wiki/Mergesort#C","http://ro.wikipedia.org/wiki/Merge_sort","http://ru.wikipedia.org/wiki/Mergesort","http://ru.wikipedia.org/wiki/Mergesort#C.2B","http://ru.wikipedia.org/wiki/Сортировка_слиянием","http://sk.wikipedia.org/wiki/Mergesort","http://sk.wikipedia.org/wiki/Triedenie_zlu%C4%8Dovan","http://tr.wikipedia.org/wiki/Birle%C5%9Ftirmeli_s","http://zh.wikipedia.org/zh-cn/% E5% BD","http://zh.wikipedia.org/zh-tw/% E5% 90","http://zh.wikipedia.org/zh-tw/归并排序","hy:Միաձուլման տեսակավորում","hợp nhất sắp xếp","hợp thuật toán sắp xếp,","id:Merge sort","kk:Тоғыстыру арқылы сүрыптау","kode pseudo dari Wikipedia","korespondence řazení","kết hợp sắp xếp","le tri fusion","le tri par fusion","loại sáp nhập","menggabungkan jenis","merge Sort on WikiPedia","merge sort algorithm","merge sort algoritma","merge sort and quick sort","merge sort,","merge sort-algoritme","merge sort...","merge sorting","merge sorting algorithm","merge sortrest","merge-sort","merge-sort algoritam","merge-sort algorithm","merge-sorted","merge-sortin","mergersort","mergesort algorithm","mergesort page","mergesort rules the roost","mergesort super dargestellt","mergesort-programm","mergesort.","mesclar tipo","mã giả từ Wikipedia","ordenación por fusión","ordenamiento por mezcla","pl.wikipedia.org/wiki/Sortowanie_przez_scalanie","połączenie sortowania","primeru iz wikipedije","przez scalanie","przez scalenie na wiki","pseudo codice nella pagina di wikipedia","samenvoegen soort","semacam menggabungkan","semacam penggabungan","semacam penggabungan algoritma,","sequential merge sort","seryjnej rodzaju","seryjnej sortowania","seryjnej sortowanie","siste steg","sloučení řazení","sloučit algoritmus druhu","sloučit druh","sloučit-sort","slučování Seřadit","sorte de fusion,","sorting routines","sortowania korespondencji seryjnej","sortowania przez scalanie","sortowanie przez scalanie","sortowaniu przez scalanie","stable iterative mergesort","sumanib-uri-uriin","sumanib-uri-uriin algorithm,","sắp xếp Merge,","sắp xếp hợp nhất","sắp xếp trộn","the Merge Sort wikipedia article","the Wikipedia article on merge sort.","tiled merge sort","tipo Merge,","tipo de combinación","tipo de mesclagem","tipo de mezcla","tipo de mezcla,","tri fusion","tri par fusion","tri-fusion","ttp://en.wikipedia.org/wiki/Merge_sort","urejanje z zlivanjem","verschmelzen Art,","von Wikipedia Pseudo-Code","w:Сортировка слиянием","wiki page Merge Sort","wiki. mergesort","wikipedia - merge sort","wikipedia article about merge sort","wikipedia artikel over merge sort","wikipedia のマージソート","wikipedia/Сортировка_слиянием","wikipedia:マージソート","wp:Merge sort","zlievanie","összefésüléses rendezés","řazení sloučení","α = - 1 + ∑ k = 0 ∞ 1 2 k + 1","Википедии статью Mergesort","Слияние Сортировать","Слиянием","Сортиране чрез сливане","Сортировка слиянием","Сортировка слиянием на Википедии","Сортировка слиянием — Википедия","Сортировка слиянием,","Сортировка_слиянием","Сортировки слиянием","Сортування злиттям","алгоримом слияния","алгоритм сортировки слиянием","классическая сортировка слиянием","ответу","псевдокод из Википедии","рода слияния","сартавання зліццём","слияние рода","слиянием","слиянии рода,","слияния алгоритм сортировки,","слияния-рода","слияния.","сортиране със сливане","сортиране чрез сливане","сортировка слиянием","сортировки слиянием","сортировку слиянием","сортування злиттям","статью Википедии о сортировки слиянием","Միաձուլման ...","Միաձուլման տեսակավորում","ויקיפדיה - 'מיון מיזוג'","מיון איחוד","מיון מיזוג","מיון מיזוג – ויקיפדיה","מיון-מיזוג","ادغامی","الگوریتم مرتبسازی ادغامی","ترتيب دمجي","مرتبسازی ادغامی","مرتبسازی ادغامی - ویکیپدیا","मर्ज के आधार पर क्रमबद्ध","लिए मिलता","মার্জ সর্ট","മെർജ് സോർട്ട്","ตัด ขั้น ตอน วิธี จัด เรียง","ตัด จัด เรียง","ตัด เรียง","ตัด เรียง ลำดับ","ประเภท รวม","ผสานเรียง","รวมเรียงลำดับ","รหัสเทียมจากวิกิพีเดีย","เรียง ผสาน","“Merge sort - Wikipedia, the free encyclopedia”, en.wikipedia","→ Статья «Сортировка слиянием»","「マージソート」をWikipediaで調べる","こうゆう原理","のコードを擬似。","ウィキペディアの記事 マージソート","ソートはマージ","ソートアルゴリズムマージ","マージしないと","マージソート","マージソート - Wikipedia","マージソート(wikipedia)","マージソートについて書かれたWikipediaの記事を","マージソートは","マージソートは、","マージソートを","マージソートアルゴリズムを","マージ・ソート","一篇关于合并排序百科","参考下","合併排序","合併排序法(mergesort)","合併排序法（mergesort）","合併排序算法","合并排序","合并排序算法","大家咋用","归并","归并排序","归并排序- 维基百科，自由的百科全书","排序合併","歸並排序","歸併","歸併排序","歸併排序- 維基百科，自由的百科全書","維基百科的偽代碼","維基百科的文章“ 合併排序”","維基百科的文章“ 归并排序”","維基百科～Merge_sort","维基百科上面先学习一下归并排序","维基百科的伪代码","维基百科的文章“ 合併排序”","维基百科的文章“ 归并排序”","谈合并","병합 정렬","병합 정렬,","병합정렬(Merge sort)","병합합니다 .","부터 위키백과 코드를 가짜의","위키 피 디아 문서 합병 정렬","일종의 병합","일종의 병합을","일종의 편지 병합 기능들을","정렬 알고리즘에 병합에서","정렬과","합병 정렬","ﾏｰｼﾞｿｰﾄ-wikipedia"],"name":"Merge sort","categories":["All articles with dead external links","All articles with unsourced statements","Articles with dead external links from June 2013","Articles with example pseudocode","Articles with inconsistent citation formats","Articles with unsourced statements from April 2014","Articles with unsourced statements from June 2008","Articles with unsourced statements from March 2014","Comparison sorts","Sorting algorithms","Stable sorts"],"tag_line":"In computer science, merge sort (also commonly spelled mergesort) is an efficient, general-purpose, comparison-based sorting algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bucket-sort","_score":0,"_source":{"description":"Bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm. It is a distribution sort, and is a cousin of radix sort in the most to least significant digit flavour. Bucket sort is a generalization of pigeonhole sort. Bucket sort can be implemented with comparisons and therefore can also be considered a comparison sort algorithm. The computational complexity estimates involve the number of buckets.\nBucket sort works as follows:\nSet up an array of initially empty \"buckets\".\nScatter: Go over the original array, putting each object in its bucket.\nSort each non-empty bucket.\nGather: Visit the buckets in order and put all elements back into the original array.","alt_names":["Comparison with other sorting algorithms","вот такой статьи","Bucket sort","bucket sort","- Bucket sort :","-> Read the article about 'Bucket sort'","...Wikipedia Sortowanie kubełkowe","...mehr auf Wikipedia über Bucketsort","...more on Wikipedia about Bucket sort","/ bin /","1 Pseudocode","3.1 Generic bucket sort","3.2 Proxmap sort","3.3 Histogram sort","3.4 Postman's sort","3.5 Shuffle sort","4 Comparison with other sorting algorithms","Algoritmo del cartero","BIN / ведро","Benna tipo?","Bin sort","Bucket Phân loại","Bucket Phân loại.","Bucket Sort","Bucket Sort - Sorting in O(n) time","Bucket Sort!","Bucket Sort.","Bucket Sort. Wikipedia.","Bucket Sorted","Bucket Sorteer","Bucket Sorter","Bucket Sortér","Bucket Trier","Bucket Urut.","Bucket Urutkan","Bucket sort (a.k.a. bin sort)","Bucket sort - Wikipedia","Bucket sort - Wikipedia, the free encyclopedia","Bucket sort - Wikipédia, a enciclopédia livre","Bucket sort Wikipedia","Bucket sort Wikipedia the free encyclopedia","Bucket sort Wikipedia the free encyclopedia - result","Bucket sort algorithm","Bucket sort can be seen as a generalization","Bucket sort – Wikipédia, a enciclopédia livre","Bucket sort; it is used under the","Bucket sort?","Bucket sorting","BucketSort","BucketSorter","Bucket_sort","Bucketsort","Bucketsort - Wikipedia","Bucketsort ? Wikipedia","Bucketsort bei der wikipedia","Bucketsort – Wikipedia","Cubo Ordenar","Definición de Ordenamiento por casilleros más completo","Eimer sortieren","Eimer zu sortieren?","Ember Urutkan","Emmer Sorteren","Emmer sorteren?","Encyclopedia: Bucket sort","Fächer-Sortierung","Hier vll noch die Beschreibung zum Bucketsort","Kbelík třídit?","Kova sıralaması","Learn about Bucket sort>>>","Look for De:Bucketsort","Ordenamiento por casilleros","Ordenamiento por casilleros - Wikipedia, la enciclopedia libre","Ordenamiento por casilleros.","Ordenar Cubo","Ordenar cazo","Ordenar cubo","Ordenar cubo!","Ordina Bucket","Ordina benna.","Pagsunud-sunurin ayon bucket.","Phân loại Bucket","Postman sort","Postman's sort","Příhrádkové třídění","Sorteren emmer!","Sortowanie kubełkowe","Sortowanie kubełkowe – Wikipedia, wolna encyklopedia","Sortuj Wiaderko!","Spand Sort!","Spand slags?","Tipo cubo puede ser visto como una generalización","Tri Bucket.","Tri par paquets","Tri par paquets - Wikipédia","Trier Bucket","Urut Bucket.","Urutkan Bucket","Vödrös rendezés","WP: Buckets","What variants of Bucket sort are there","What variants of Bucket sort are there?","Wiaderko Sortuj","Wiki: Блочная сортировка","Wikipedia (Bucket sort)","Wikipedia : バケットソート","Wikipedia article Bin sort","Wikipedia article Bucket sort","Wikipedia article Bucketsort","Wikipedia article Postman sort","Wikipedia article on Bucket sort","Wikipedia article Բլոկային դասակարգում","Wikipedia article مرتبسازی سطلی","Wikipedia entry for Bucket sort","Wikipedia sur Tri par paquets","Wikipedia バケットソート","Wikipedia-Artikel Bucketsort","Wikipedia-Seite zu 'Bucketsort'","Wikipedia/Bucket sort","Wikipediaで「バケットソート」を調べる","a related computer science definition","artigo da Wikipédia Bucket sort","artículo de Wikipedia Algoritmo del cartero","artículo de Wikipedia Bin sort","artículo de Wikipedia Ordenamiento por casilleros","balde de triagem","balde tipo","benna Ordina","bin /","bin / Eimer","bin / bucket-uri-uriin","bin / ember","bin / thùng","bin sort","bin sorting","bin/bucket","bucket Pagsunud-sunurin ayon","bucket Pagsunud-sunurin ayon.","bucket array","bucket pag-aayos","bucket sort algorithm","bucket sort wikipedia the encyclopedia","bucket sorting","bucket sorting algorithm","bucketsort","cucharón Ordenar","de.wikipedia.org/wiki/Bucketsort","del cubo Ordenar","du godet de tri","ember sortasi","emmer soort","en.wikipedia.org/wiki/Bucke...","en.wikipedia.org/wiki/Bucket_sort","en:Bucket sort","espécie de balde","fa:مرتبسازی سطلی","fr:Tri par paquets","histogram sort","http://de.wikipedia.org/wiki/Bucketsort","http://de.wikipedia.org/wiki/Bucketsort#Java","http://en.wikipedia.org/wiki/Bucket_","http://en.wikipedia.org/wiki/Bucket_sort","http://en.wikipedia.org/wiki/Bucket_sort#Comparison_with_other_sorting_algorithms","http://en.wikipedia.org/wiki/Bucket_sort#Postman.27s_Sort","http://en.wikipedia.org/wiki/Bucket_sort#Pseudocode","http://en.wikipedia.org/wiki/Bucket_sort.","http://es.wikipedia.org/wiki/Bucket_sort","http://es.wikipedia.org/wiki/Ordenamiento_por_casilleros","http://fr.wikipedia.org/wiki/Tri_par_paquets","http://it.wikipedia.org/wiki/Bucket_sort","http://ja.wikipedia.org/wiki/バケットソート","http://pl.wikipedia....wanie_kubełkowe","http://pl.wikipedia.org/wiki/Sortowanie_kube%C5%82kowe","http://pl.wikipedia.org/wiki/Sortowanie_kubełkowe","http://ru.wikipedia.org/wiki/Блочная_сортировка","http://zh.wikipedia.org/zh-tw/% E6% A1","kbelíku druhu","kbelíku řazení","kubełkowe","la clasificación cubo","lopaty druhu","loại xô","lžíce Seřadit","mente, dass sie","perfect_bucket_sort","postman's sort","postman's sort / postal sort","range sort","secchio di smistamento","secchio sorta","semacam ember","sorta secchio","sorte seau","sortowania wiadro","sortowanie kubełkowe","sortowanie łyżki?","spand slags","spand sort","spand sortere","t. http://en.wikipedia.org/wiki/Bucket_sort.","thùng phân loại","tipo benna","tipo cubo","tri en casiers (bucket sort)","ucket sort","w:Bucket sort","wiadro rodzaju","wikipediaにサンプルがあった","wp:Bucket sort","zh:桶排序","| Bucket sort Wikipedia","Řadit lopaty!","Блочная","Блочная сортировка","Блочная сортировка (вики)","Википедии статью Блочная сортировка","Карманная сортировка","Ковш Сортировать!","Ковш рода?","Ковшовая сортировка","Обоснование асимптотики","Сортировать ковша","Сортировать ковша.","Сортування комірками","ведро рода","ведро сортировки","ковша Сортировать","ковша Сортировка","ковша рода","сортування комірками","ומיון דלי","מיון סלים","מיון סלים – ויקיפדיה","سطلی","مرتبسازی سطلی","مرتبسازی سطلی - ویکیپدیا","बाल्टी क्रमबद्ध करें","बाल्टी क्रमबद्ध करें!","बाल्टी सॉर्ट?","จัด เรียง ถัง","ถัง เรียง ลำดับ","ถังเรียง","ประเภทถัง","เรียง ถัง","เรียง ถัง.","เรียงถัง","「バケットソート」をWikiで調べる","ソート。","バケットの並べ替え","バケットソート","バケットソート - Wikipedia","バケットソートを","バケットソート！","バケットソート？","バケット並べ替え","バケツの並べ替え","バケツソート","バケツ整列","バケツ整列を利用した","ビン(バケット)ソート","ビン/バケット","分布数えソート","分布数えｿｰﾄ-wikipedia","本/桶","桶排序","桶排序 - 維基百科,自由的百科全書","桶排序 - 维基百科,自由的百科全书","桶排序- 维基百科，自由的百科全书","桶排序！","桶排序？","維基百科的文章“ 桶排序”","维基百科的文章“ 桶排序”","버켓 정렬을","버켓 정렬하십시오.","버킷 정렬","빈 / 양동이에","식당 검색 결과 정렬 방식은","식당 정렬","양동이에 정렬을","ﾊﾞｹｯﾄｿｰﾄ-wikipedia"],"name":"Bucket sort","categories":["All articles needing expert attention","Articles needing expert attention from November 2008","Articles needing expert attention with no reason or talk parameter","Articles with example pseudocode","Computer science articles needing expert attention","Sorting algorithms","Stable sorts"],"tag_line":"Bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of an array into a number of buckets."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cocktail-sort","_score":0,"_source":{"description":"Cocktail sort, also known as bidirectional bubble sort, cocktail shaker sort, shaker sort (which can also refer to a variant of selection sort), ripple sort, shuffle sort, or shuttle sort, is a variation of bubble sort that is both a stable sorting algorithm and a comparison sort. The algorithm differs from a bubble sort in that it sorts in both directions on each pass through the list. This sorting algorithm is only marginally more difficult to implement than a bubble sort, and solves the problem of turtles in bubble sorts. It provides only marginal performance improvements, and does not improve asymptotic performance; like the bubble sort, it is not of practical interest (insertion sort is preferred for simple sorts), though it finds some use in education.","alt_names":["- Cocktail sort :","-> Read the article about 'Cocktail sort'","...Wikipedia Shaker sort","...more on Wikipedia about Cocktail sort","Bidirectional Bubble sort","Bidirectional bubble sort","Cocktail Sort","Cocktail Sort (Shaker)","Cocktail Sort ,","Cocktail shaker sort","Cocktail sort","Cocktail sort - Wikipedia, the free encyclopedia","Cocktail sort – Wikipédia, a enciclopédia livre","Cocktail sort: Complexity","Cocktail sort; it is used under the","Cocktail-Sortieralgorithmus","CocktailSort","CocktailSort - wikipedia.org","CocktailSorter","Cocktail_sort","Cocktailsort","Cocktailsort bei der wikipedia","Cocktailsort:","Coctail sort","Definición de Ordenamiento de burbuja bidireccional más completo","Differences from bubble sort","Diğer sıralama algoritmaları","Kokteyl Sıralaması","Kokteyl sıralaması","Koktélrendezés","Learn about Cocktail sort>>>","Ordenamiento de Burbuja Bidireccional","Ordenamiento de burbuja bidireccional","Ordenamiento de burbuja bidireccional - Wikipedia, la enciclopedia ...","Ordenamiento por sacudida","Shaker sort","Shaker sort - Wikipedia","Shaker-Sort","ShakerSort","ShakerSorter","Shakersort","Shakersort Wikipedia","Shakersort – Wikipedia","Sortowanie koktajlowe","Sortowanie koktajlowe â�“ Wikipedia, wolna encyklopedia","Sortowanie koktajlowe – Wikipedia, wolna encyklopedia","Wikipedia (Cocktail sort)","Wikipedia - Cocktail sort","Wikipedia - Shakersort","Wikipedia : シェーカーソート","Wikipedia article Cocktail shaker sort","Wikipedia article Cocktail sort","Wikipedia article on Cocktail sort","Wikipedia article Կոկտեյլային տեսակավորում","Wikipedia entry for Cocktail sort","Wikipedia l'articolo Shakersort","Wikipedia on cocktail sort","Wikipedia-Artikel Cocktailsort","Wikipedia-Artikel Shakersort","Wikipedia-Artikel zu Cocktailsort","Wikipedia-Seite zu 'Cocktailsort'","Wikipedia-Seite zu 'Shakersort'","Wikipedia:Shakersort","Wikipediaで「シェーカーソート」を調べる","[Wikipedia 鸡尾酒排序]","artículo de Wikipedia Cocktail sort","artículo de Wikipedia Ordenamiento de burbuja bidireccional","bidirectional bubble sort","bidirectional or cocktail sort","bidirectional variant of bubble sort","cocktail shaker sort","cocktail slags","cocktail sort","cocktail sorteren","double-direction bubble sort","en.wikipedia.org/wiki/Cocktail_sort","http://de.wikipedia.org/wiki/Shakersort","http://en.wikipedia....i/Cocktail_sort","http://en.wikipedia.org/wiki/Cocktail_so","http://en.wikipedia.org/wiki/Cocktail_sort","http://en.wikipedia.org/wiki/Cocktail_sort#Pseudocode","http://en.wikipedia.org/wiki/Cocktail_so…","http://en.wikipedia.org/wiki/Shaker_sort","http://es.wikipedia.org/wiki/Cocktail_sort","http://es.wikipedia.org/wiki/Cocktail_so…","http://es.wikipedia.org/wiki/Ordenamiento_de_burbuja_bidireccional","http://it.wikipedia.org/wiki/Shaker_sort","http://ja.wikipedia.org/wiki/シェーカーソート","http://ko.wikipedia.org/wiki/%EC%B9%B5","http://pl.wikipedia.org/wiki/Sortowanie_koktajlowe","http://pt.wikipedia.org/wiki/Cocktail_so…","http://ru.wikipedia.org/wiki/Сортиро...ремешиванием#C","http://ru.wikipedia.org/wiki/Сортировка_перемешиванием","http://ru.wikipedia.org/wiki/Шейкерная_сортировка","http://zh.wikipedia.org/zh-tw/% E9% B8","koktejl řazení","může znamenat","ocktail sort","shaker sort","shakersort","sorta cocktail","sortowanie koktajl","tipo de cócteles","uk:Сортування змішуванням","Перемешиванием","Сортировка перемешиванием","Сортування змішуванням","коктейль рода","сортировкой перемешиванием","шейкерная сортировка","Կոկտեյլային ...","Կոկտեյլային տեսակավորում","نوشابه ای","→ Статья «Сортировка перемешиванием»","カクテルの並べ替えを","シェーカーソート","シェーカーソート - Wikipedia","一个鸡尾酒","維基百科的文章“ 鸡尾酒排序”","這篇：雞尾酒排序","雞尾酒排序","鸡尾酒排序","위키 피 디아 문서 칵테일 정렬","칵테일 정렬","ｼｪｰｶｰｿｰﾄ","ｼｪｰｶｰｿｰﾄ-wikipedia"],"name":"Cocktail sort","categories":["Articles with example pseudocode","Comparison sorts","Sorting algorithms","Stable sorts"],"tag_line":"Cocktail sort, also known as bidirectional bubble sort, cocktail shaker sort, shaker sort (which can also refer to a variant of selection sort), ripple sort, shuffle sort, or shuttle sort, is a variation of bubble sort that is both a stable sorting algorithm and a comparison sort."}}
,{"_index":"throwtable","_type":"algorithm","_id":"comb-sort","_score":0,"_source":{"description":"Comb sort is a relatively simple sorting algorithm originally designed by Włodzimierz Dobosiewicz in 1980. Later it was rediscovered by Stephen Lacey and Richard Box in 1991. Comb sort improves on bubble sort.\n\n","alt_names":["Combsort","Comb sort","- Comb sort :","-> Read the article about 'Comb sort'","...Wikipedia Sortowanie grzebieniowe","...mehr auf Wikipedia über Combsort","...more on Wikipedia about Comb sort","1 / 1 - 1 e φ &approx; 1 . 247330950103979","1 Shrink factor","2 Combsort11","3 Pseudocode example of combsort11","But I don't have any hair!","Comb Phân loại.","Comb Sort","Comb Sort - Just As Good As Quick Sort","Comb Trier.","Comb Urut.","Comb sort - Wikipedia","Comb sort - Wikipedia, la enciclopedia libre","Comb sort - Wikipedia, the f...","Comb sort - Wikipedia, the free encyclopedia","Comb sort - almost as good as Quicksort","Comb sort 11","Comb sort Wikipedia the free encyclopedia","Comb sort – Wikipédia, a enciclopédia livre","Comb sortieren.","CombSort","CombSort - wikipedia.org","CombSorter","Comb_sort","Combsort 11","Combsort in","Combsort – Wikipedia","Combsort11","Combsort:","Ejemplo en pseudocódigo del algoritmo combsort11","Fésűs rendezés","Fésűs rendezés - Wikipédia","Hacker News: Comb Sort - Just As Good As","Ordenar Comb.","Ordina Comb.","Pseudocode example of combsort11","Shrink factor","Sortowanie grzebieniowe","Sortowanie grzebieniowe – Wikipedia, wolna encyklopedia","Tarak Sıralaması","Tarak sıralaması","Tarak sıralaması - Vikipedi","What are implementations of Comb sort","Wikipedia Comb sort","Wikipedia article Comb sort","Wikipedia article Combsort","Wikipedia article on Comb sort","Wikipedia article Սանրաձև տեսակավորում","Wikipedia entry for Comb sort","Wikipedia on Comb sort","Wikipedia-Artikel Combsort","Wikipedia-Seite zu 'Combsort'","Wikipedia: Sortieren mit Combsort","WikipediaのComb sort","artículo de Wikipedia Comb sort","comb sort","comb-sort","combsort","combsort page at Wikipedia","en.wikipedia.org/wiki/Comb_sort","es.wikipedia.org/wiki/Comb_sort","http://de.wikipedia.org/wiki/Combsort","http://en.wikipedia.org/wiki/Comb_sort","http://en.wikipedia.org/wiki/Comb_sort#C.2B","http://en.wikipedia.org/wiki/Combsort","http://es.wikipedia.org/wiki/Comb_sort","http://it.wikipedia.org/wiki/Comb_sort","http://ja.wikipedia.org/wiki/コムソート","http://pl.wikipedia.org/wiki/Sortowanie_grzebieniowe","http://pl.wikipedia.org/wiki/Sortowanie_gżebieniowe","http://pt.wikipedia.org/wiki/Comb_sort","ordenamiento por combinación","pt.wikipedia.org/wiki/Comb_sort","sortowanie grzebieniowe","ttp://en.wikipedia.org/wiki/Comb_sort","w:Comb sort","Расчёской","Сортировка расческой","Сортировка расческой.","Сортировка расчёской","Сортування гребінцем","Սանրաձև տեսակավորում","شانه ای","مرتبسازی شانهای - ویکیپدیا","จัด เรียง หวี.","「コムソート」をWikipediaで調べる","「コムソート」をWikiで調べる","の巣の並べ替え","コムソート","コムソート - Wikipedia","コムソート11","バブルソートの改良版","梳排序","빗 정렬.","ｺﾑｿｰﾄ-wikipedia"],"name":"Comb sort","categories":["All articles needing additional references","Articles needing additional references from March 2011","Articles with example pseudocode","Comparison sorts","Sorting algorithms"],"tag_line":"Comb sort is a relatively simple sorting algorithm originally designed by Włodzimierz Dobosiewicz in 1980."}}
,{"_index":"throwtable","_type":"algorithm","_id":"timsort","_score":0,"_source":{"description":"Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data. It was invented by Tim Peters in 2002 for use in the Python programming language. The algorithm finds subsets of the data that are already ordered, and uses that knowledge to sort the remainder more efficiently. This is done by merging an identified subset, called a run, with existing runs until certain criteria are fulfilled. Timsort has been Python's standard sorting algorithm since version 2.3. It is also used to sort arrays of non-primitive type in Java SE 7, on the Android platform, and in GNU Octave.\n\n","alt_names":["this craziness","tiny Wikipedia article","Timsort","(timsort)","- Timsort :","Python's timsort","Tim Art","Tim Sort","Tim espécie","Tim slags","Tim soort","Tim sort","Tim sắp xếp","TimSort","TimSort.","Timesort","Timsort -","Timsort - Wikipedia","Timsort - Wikipedia, the free encyclopedia","Timsort algorithm","Timsort – Wikipedia","Timsort – Wikipédia, a enciclopédia livre","Timsort!","Timsort; it is used under the","Timsortin","Wikipedia article Timsort","Wikipedia article about Timsort","Wikipedia article on Timsort","articolo piccolo Wikipedia","en.wikipedia.org/Timsort","en.wikipedia.org/wiki/Timsort","http://de.wikipedia.org/wiki/Timsort","http://en.wikipedia.org/wiki/Timsort","http://en.wikipedia.org/wiki/Timsort>","http://it.wikipedia.org/wiki/Timsort","kleine Wikipedia-artikel","l'algorithme de tri « <span class=italique>timsort","l'algorithme de tri « timsort »","małe Wikipedii","pequeño artículo de Wikipedia","pt:Timsort","python built-in sort","semacam Tim","sort · I","sorte Tim","sorting algo","sortowania Tim","the aforementioned Timsort","timsort","tipo Tim","wp:Timsort","řazení Tim","Тим рода","छोटे से विकिपीडिया लेख","จัด Tim","の並べ替えのPython","ティムソート","小さなWikipediaの記事","小百科文章","添排序","要件を","팀 정렬"],"name":"Timsort","categories":["All articles with dead external links","Articles with dead external links from June 2013","Comparison sorts","Sorting algorithms","Stable sorts"],"tag_line":"Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dutch-national-flag-problem","_score":0,"_source":{"description":"The Dutch national flag problem (DNF) is a computer science programming problem proposed by Edsger Dijkstra. The flag of the Netherlands consists of three colours: red, white and blue. Given balls of these three colours arranged randomly in a line (the actual number of balls does not matter), the task is to arrange them such that all balls of the same colour are together and their collective colour groups are in the correct order.\nThe solution to this problem is of interest for designing sorting algorithms. In particular, variants of the quicksort algorithm that must be robust to repeated elements need a three-way partitioning function that groups items less than a given key (red), equal to the key (white) and greater than the key (blue). Several solutions exist that have varying performance characteristics, tailored to sorting arrays with either small or large numbers of repeated elements.","alt_names":["Dutch National Flag Problem","Dutch National Flag problem","Dutch flag sort","Dutch national flag problem","Dutch national flag problem - Wikipedia, the free encyclopedia","What is a Dutch national flag problem","What is a Dutch national flag?","Wikipedia article Dutch national flag","Wikipedia article Dutch national flag problem","Wikipedia entry for Dutch national flag problem","a Bandera Nacional Holandesa.","en.wikipedia.org/wiki/Dutch_national_flag_problem","http://en.wikipedia.org/wiki/Dutch_national_flag","http://en.wikipedia.org/wiki/Dutch_national_flag_problem","w:en:Dutch_national_flag_problem"],"name":"Dutch national flag problem","categories":["All articles needing additional references","Articles needing additional references from July 2014","Computational problems","Sorting algorithms"],"tag_line":"The Dutch national flag problem (DNF) is a computer science programming problem proposed by Edsger Dijkstra."}}
,{"_index":"throwtable","_type":"algorithm","_id":"median-cut","_score":0,"_source":{"description":"Median cut is an algorithm to sort data of an arbitrary number of dimensions into series of sets by recursively cutting each set of data at the median point along the longest dimension. Median cut is typically used for color quantization. For example, to reduce a 64k-colour image to 256 colours, median cut is used to find 256 colours that match the original data well.","alt_names":["Median Cut","Median cut","Median cut - Wikipedia, the free encyclopedia","Median cut; it is used under the","Median_Cut","Median_cut","Wikipedia article Median cut","Wikipedia article on Median cut","Wikipedia-Artikel Median Cut","Wikipedia-Seite zu 'Median Cut'","Wikipedia: Median Cut","http://de.wikipedia.org/wiki/Median_Cut","http://en.wikipedia.org/wiki/Median Cut","http://en.wikipedia.org/wiki/Median_cut","median cut","median-cut based colour selection"],"name":"Median cut","categories":["Sorting algorithms"],"tag_line":"Median cut is an algorithm to sort data of an arbitrary number of dimensions into series of sets by recursively cutting each set of data at the median point along the longest dimension."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cubesort","_score":0,"_source":{"description":"Cubesort is a parallel sorting algorithm that builds a self-balancing multi-dimensional array from the keys to be sorted. As the axes are of similar length the structure resembles a cube. After each key is inserted the cube can be rapidly converted to an array.\nA cubesort implementation written in C was published in 2014.\n\n","alt_names":[],"name":"Cubesort","categories":["Algorithms and data structures stubs","All articles lacking reliable references","All articles with topics of unclear notability","All stub articles","Articles lacking reliable references from September 2014","Articles with topics of unclear notability from September 2014","Comparison sorts","Computer science stubs","Online sorts","Sorting algorithms","Stable sorts"],"tag_line":"Cubesort is a parallel sorting algorithm that builds a self-balancing multi-dimensional array from the keys to be sorted."}}
,{"_index":"throwtable","_type":"algorithm","_id":"deflate","_score":0,"_source":{"description":"In computing, deflate is a data compression algorithm and associated file format that uses a combination of the LZ77 algorithm and Huffman coding. It was originally defined by Phil Katz for version 2 of his PKZIP archiving tool. The file format was later specified in RFC 1951.\nThe original algorithm as designed by Katz was patented as U.S. Patent 5,051,745 and assigned to PKWARE, Inc. As stated in the RFC document, an algorithm producing DEFLATE files is widely thought to be implementable in a manner not covered by patents. This has led to its widespread use, for example in gzip compressed files, PNG image files and the .ZIP file format for which Katz originally designed it.","alt_names":["Deflate-Algorithmus","ยุบ","http://ja.wikipedia.org/wiki/Deflate","deflate","Deflate","DEFLATE","(http://en.wikipedia.org/wiki/DEFLATE)","(http://en.wikipedia.org/wiki/DEFLATE).","- DEFLATE (algorithm) :","- DEFLATE :","- Deflate :","-> Leggi tutto l'articolo su 'Deflate'","-> Read the article about 'DEFLATE'","...Wikipedia Deflación (algoritmo)","...Wikipedia Deflate","...mehr auf Wikipedia über Deflate","...more on Wikipedia about DEFLATE (algorithm)","1 Stream format","1.1 Duplicate string elimination","1.2 Bit reduction","2 Encoder/compressor","2.1 Deflate64/Enhanced Deflate","3 Using Deflate in new software","3.1 Encoder implementations","3.2 Hardware encoders","4 Decoder/decompressor","4.1 Inflate-only implementations","4.2 Hardware decoders","A DEFLATE stream consists of a series of","Algorithme deflate, paramètres standard","DEFLATE (","DEFLATE (English Wikipedia)","DEFLATE (algorithm)","DEFLATE (algorithm) - Wikipedia, the free encyclopedia","DEFLATE - Wikipedia, the free ...","DEFLATE - Wikipedia, the free encyclopedia","DEFLATE - 維基百科,自由的百科全書","DEFLATE - 維基百科，自由的百科全書","DEFLATE - 维基百科,自由的百科全书","DEFLATE - 维基百科，自由的百科全书","DEFLATE - 위키백과, 우리 모두의 백과사전","DEFLATE Wikipedia the free encyclopedia","DEFLATE algorithm","DEFLATE compression algorithm","DEFLATE on wikipedia.org","DEFLATE |","DEFLATE – Wikipédia, a enciclopédia livre","DEFLATE,","DEFLATE-algorithm","DEFLATE_(algorithm)","DEFLATEは","DEFLATE的","DEFLATE算法","Deflación ( algoritmo )","Deflación (algoritmo)","Deflación (algoritmo) - Wikipedia, a enciclopedia libre","Deflación (algoritmo) - Wikipedia, la enciclopedia libre","Deflate - Wikipedia","Deflate - Wikipédia","Deflate ? Wikipedia","Deflate algorithm","Deflate algorithm.","Deflate compression method","Deflate in","Deflate â€“ Wikipedia","Deflate алгоритма","Deflate – Wikipedia","Deflate – Wikipedia, wolna e...","Deflate — Википедия","Deflate,","Deflate-wikipedia","Deflate/Inflate","Deflate64","Deflateとは？ (Wikipediaへのリンク)","Deflateのを","Deflateアルゴリズム","Deflate을","Desinfle","Dreamhost Wiki","GZIP1","Inflate / Deflate","Je ne pense pas qu'il y ait","Pesquisar deflate na Wikipedia Portugal","Read More deflate wikipedia the free encyclopedia","Search for Deflate on Wikipedia!","Sgonfiare","Stream format","Using Deflate in new software","Wikipedia - Deflate","Wikipedia : Deflate","Wikipedia Deflación (algoritmo)","Wikipedia about Deflate","Wikipedia article DEFLATE","Wikipedia article Deflate","Wikipedia article about DEFLATE","Wikipedia article on Algoritmo Deflate","Wikipedia article on DEFLATE","Wikipedia article on Deflación (algoritmo)","Wikipedia article on Deflate","Wikipedia artikel Deflate","Wikipedia entry for DEFLATE","Wikipedia entry: deflate","Wikipedia l'articolo Deflate","Wikipedia-Artikel Deflate","Wikipedia-Seite zu 'Deflate'","Wikipedia: DEFLATE","Wikipedia: a DEFLATE algoritmus","Wikipediaで「Deflate」を調べる","Wikipedia日本語版 - Deflate","Wikipedia英語版 - Deflate","Wikipédia artigo DEFLATE","Wikipédia artigo Deflate","Zip Deflate","a combination of LZ77 and Huffman encoding","algorisme de deflació","algorithme de compression deflate","algoritma deflate","algoritmo Deflate","algoritmo de deflación","algoritmo deflate","algorytmem DEFLATE","article DEFLATE","artículo de Wikipedia Algoritmo Deflate","artículo de Wikipedia Deflación (algoritmo)","artículo de Wikipedia Deflate","ca:Algorisme de deflació","compression levels from 1-9","compression non destructif","de:Deflate","deflacin","deflacionar,","deflactar","deflate Effectuer une recherche sur wikipédia","deflate algorithm","deflate compressed","deflate compression","deflate compression algorithm","deflate in Wikipedia suchen","deflate level","deflate search in Wikipedia","deflate wikipedia the free encyclopedia","deflate_module","deflatere komprimeringsalgoritme","deflateアルゴリズム","deflate圧縮","desinflan","desinflar","desinfle","dégonfler","dégonfler algorithme","el algorimo deflate","eliminating duplicate strings","en.wikipedia.org/DEFLATE","en.wikipedia.org/wiki/DEFLATE","en:DEFLATE","enhanced compression algorithm","entsprechenden Algorithmen","es:Deflación (algoritmo)","esvaziar","fi:Deflate","fr:Deflate","gl:Deflación (algoritmo)","gzip is DEFLATE","http://ca.wikipedia.org/wiki/Algorisme_de_deflaci%C3%B3","http://de.wikipedia.org/wiki/Deflate","http://en.wikipedia....%28algorithm%29","http://en.wikipedia....ATE_(algorithm)","http://en.wikipedia.org/wiki/DEFLAT","http://en.wikipedia.org/wiki/DEFLATE","http://en.wikipedia.org/wiki/DEFLATE#","http://en.wikipedia.org/wiki/DEFLATE#Deflate64.2FEnhanced_Deflate","http://en.wikipedia.org/wiki/DEFLATE#Duplicate%5Fstring","http://en.wikipedia.org/wiki/DEFLATE#Encoder_implementations","http://en.wikipedia.org/wiki/DEFLATE#Inflate-only_implementations","http://en.wikipedia.org/wiki/DEFLATE#Stream_format","http://en.wikipedia.org/wiki/DEFLATE_%28algorithm%29","http://en.wikipedia.org/wiki/DEFLATE_(algorithm)","http://en.wikipedia.org/wiki/Deflate","http://es.wikipedia.org/wiki/Algoritmo_Deflate","http://es.wikipedia.org/wiki/Deflaci...28algoritmo%29","http://fr.wikipedia.org/wiki/Deflate","http://it.wikipedia.org/wiki/Deflate","http://ko.wikipedia.org/wiki/DEFLATE","http://nl.wikipedia.org/wiki/Deflate","http://pl.wikipedia.org/wiki/Deflate","http://pt.wikipedia.org/wiki/DEFLATE","http://ru.wikipedia.org/wiki/DEFLATE","http://sv.wikipedia.org/wiki/DEFLATE","http://www.de.wikipedia.org/wiki/Deflate","http://zh.wikipedia.org/wiki/DEFLATE","http://zh.wikipedia.org/zh-cn/DEFLATE","inflate/deflate","it:Deflate","ja:Deflate","ko:DEFLATE","l'algorithme nommé deflate","l'algorithme « _deflate_ »","l'algorithme « deflate »","l'algoritmo DEFLATE","l'algoritmo di sgonfiare","l'article de Wikipédia Deflate","la deflación,","mengempis","menurunkan","most common compression idea","nl:Deflate","pl:Deflate","pt:DEFLATE","ru:DEFLATE","ru:Deflate","same algoritihm is used for .ZIP, .gzip and","sgonfiare","sl:DEFLATE","static decompression rate","sv:DEFLATE","the DEFLATE algorithm","the files","thuật toán thâu bớt","ttp://ja.wikipedia.org/wiki/Deflate","uncompressed/stored","zh:DEFLATE","zib (deflate compression) uses Huffman compression combined with","zip は Lempel-Ziv + 動的ハフマンなのに対し、gzip の方は Lempel","αλγόριθμου DEFLATE","Википедии статью DEFLATE","По сути","выкачивать","снижаться","डिफ्लेट","ขั้น ตอน วิธี ยุบ","“DEFLATE - Wikipedia, the free encyclopedia”, en.wikipedia.org","∙ Deflate - Wikipédia","「deflate」","「deflate」をWikiで調べる","ウィキペディアの記事 Deflate","エルゼットセヴンティセブン","デフレートは","フィル・カッツが開発した圧縮ツールPKZIPのバージョン2で使われているデータ圧縮アルゴリズム。","减缩","意気消沈させる","減縮","紧缩","維基百科的文章“ DEFLATE ”","维基百科的文章“ DEFLATE ”","수축과","알고리즘을 빼다","위키 피 디아 문서 DEFLATE","위키백과 Deflate","폐의","（http://en.wikipedia.org/wiki/DEFLATE）","（http://en.wikipedia.org/wiki/DEFLATE）。","，deflate壓縮算法"],"name":"DEFLATE","categories":["All articles needing additional references","Articles needing additional references from January 2009","Lossless compression algorithms"],"tag_line":"In computing, deflate is a data compression algorithm and associated file format that uses a combination of the LZ77 algorithm and Huffman coding."}}
,{"_index":"throwtable","_type":"algorithm","_id":"canonical-huffman-code","_score":0,"_source":{"description":"A canonical Huffman code is a particular type of Huffman code with unique properties which allow it to be described in a very compact manner.\nData compressors generally work in one of two ways. Either the decompressor can infer what codebook the compressor has used from previous context, or the compressor must tell the decompressor what the codebook is. Since a canonical Huffman codebook can be stored especially efficiently, most compressors start by generating a \"normal\" Huffman codebook, and then convert it to canonical Huffman before using it.\nIn order for a symbol code scheme such as the Huffman code to be decompressed, the same model that the encoding algorithm used to compress the source data must be provided to the decoding algorithm so that it can use it to decompress the encoded data. In standard Huffman coding this model takes the form of a tree of variable-length codes, with the most frequent symbols located at the top of the structure and being represented by the fewest number of bits.\nHowever, this code tree introduces two critical inefficiencies into an implementation of the coding scheme. Firstly, each node of the tree must store either references to its child nodes or the symbol that it represents. This is expensive in memory usage and if there is a high proportion of unique symbols in the source data then the size of the code tree can account for a significant amount of the overall encoded data. Secondly, traversing the tree is computationally costly, since it requires the algorithm to jump randomly through the structure in memory as each bit in the encoded data is read in.\nCanonical Huffman codes address these two issues by generating the codes in a clear standardized format; all the codes for a given length are assigned their values sequentially. This means that instead of storing the structure of the code tree for decompression only the lengths of the codes are required, reducing the size of the encoded data. Additionally, because the codes are sequential, the decoding algorithm can be dramatically simplified so that it is computationally efficient.","alt_names":["canonical ones","Canonical Huffman","Canonical Huffman Code","Canonical Huffman code","Canonical Huffman code - Wikipedia :: The free encyclopedia","Canonical Huffman code - Wikipedia, the free ...","Canonical Huffman code - Wikipedia, the free encyclopedia","Canonical Huffman codes","Canonical_Huffman_code","Cdigo cannico de Huffman la enciclopedia libre","Codi canònic de Huffman","Código canónico de Huffman","Código canónico de Huffman - Wikipedia, la enciclopedia libre","What is algorithm of Canonical Huffman coding?","Wikipedia article Canonical Huffman code","Wikipedia article about Canonical Huffman code","Wikipedia article on Código canónico de Huffman","Wikipedia entry for Canonical Huffman code","artículo de Wikipedia Código canónico de Huffman","canonical Huffman code","canonical Huffman codes","canonical Huffman encoding","codi canònic de Huffman","código canónico de Huffman","http://en.wikipedia.org/wiki/Canonical_H","http://en.wikipedia.org/wiki/Canonical_Huffma...","http://en.wikipedia.org/wiki/Canonical_Huffman_code","http://es.wikipedia.org/wiki/C%C3%B3digo_can","pæn","yago-res:Canonical Huffman code"],"name":"Canonical Huffman code","categories":["All Wikipedia articles needing context","All articles lacking in-text citations","All articles needing expert attention","All articles that are too technical","All pages needing cleanup","Articles lacking in-text citations from March 2014","Articles needing expert attention from June 2011","Coding theory","Lossless compression algorithms","Wikipedia articles needing context from June 2011","Wikipedia articles that are too technical from June 2011","Wikipedia introduction cleanup from June 2011"],"tag_line":"A canonical Huffman code is a particular type of Huffman code with unique properties which allow it to be described in a very compact manner."}}
,{"_index":"throwtable","_type":"algorithm","_id":"move-to-front-transform","_score":0,"_source":{"description":"The move-to-front (MTF) transform is an encoding of data (typically a stream of bytes) designed to improve the performance of entropy encoding techniques of compression. When efficiently implemented, it is fast enough that its benefits usually justify including it as an extra step in data compression algorithms.","alt_names":["- Move-to-front transform :","...Wikipedia Move To Front","...more on Wikipedia about Move-to-front transform","1 The transform","3 Use in practical data compression algorithms","Haal-naar-vorencodering","Haal-naar-vorencodering (Wikipedia)","MTF (Move to Front)","MTF (Move-To-Front) 法","MTF algorithm","MTF encoding","MTF transzformáció","MTF(move-to-front) Transform","MovccQmm@qkissrlWenZdh_","Move -to-front transform - Wikipedia, the free encyclopedia","Move To Front","Move To Front - Wikipedia","Move To Front Transform","Move To Front – Wikipedia, wolna encyklopedia","Move To Front(先頭移動法、MTF)","Move To Frontとは？ (Wikipediaへのリンク)","Move to Front","Move to front","Move to front englisch Nach vorne verschieben , auch","Move to front in","Move to front transform","Move-To-Front","Move-To-Front Transform","Move-to-Front","Move-to-Front-Transformation","Move-to-front","Move-to-front transform","Move-to-front transform - Wikipedia, the free encyclopedia","Move-to-front transform, the free encyclopedia - Wikipedia","Move-to-front transformace","Move-to-front_transform","MoveToFront","Move_To_Front","Move_to_front","Read More movetofront transform wikipedia the free encyclopedia","The transform","Use in practical data compression algorithms","What is implementation of Move-to-front transform","Wikipedia article on Move to front","Wikipedia article on Move-to-front transform","Wikipedia artikel Haal-naar-voren codering","Wikipedia artikel Haal-naar-vorencodering","Wikipedia entry for Move-to-front transform","Wikipedia sur Move-To-Front","Wikipedia-Artikel Move To Front","Wikipedia-Artikel Move to front","Wikipedia-Artikel Move-to-Front","Wikipedia-Seite zu 'Move to front'","algorytm Move To Front","cs:Move-to-front transformace","de:Move to front","en.wikipedia.org/wiki/Move-to-front_t...","fr:Move-To-Front","haal-naar-voren codering","haal-naar-vorencodering","http://cs.wikipedia.org/wiki/Move-to-front_transformace","http://de.wikipedia.org/wiki/Move_to_fro","http://de.wikipedia.org/wiki/Move_to_front","http://en.wikipedia....front_transform","http://en.wikipedia.org/wiki/Move-to-fro","http://en.wikipedia.org/wiki/Move-to-front_transform","http://en.wikipedia.org/wiki/Move_t","http://fr.wikipedia.org/wiki/Move-To-Front","http://ja.wikipedia.org/wiki/Move_To_Front","http://ja.wikipedia.org/wiki/Move_To_Frontのthumbnail","http://nl.wikipedia.org/wiki/Haal-naar-vorencoderi","http://nl.wikipedia.org/wiki/Haal-naar-vorencodering","http://pl.wikipedia.org/wiki/Move_To_Front","http://ru.wikipedia.org/wiki/Move-To-Front","ja:Move To Front","move to front","move to front coder","move-to-front (or MTF) transform.","move-to-front transform","move-to-前線","naar voren","nl:Haal-naar-vorencodering","pl:Move To Front","přesunout do přední","ru:Move-To-Front","ruch do przodu","se mueven hacia adelante","the Wikipedia article on move-to-front transforms","the move-to-front transform","wp:Move-to-front transform","Википедии статью Move-To-Front","Википедии статью Move-to-front heuristic","перейти к передней","ウィキペディアの記事 Move To Front","前面に移動"],"name":"Move-to-front transform","categories":["All Wikipedia articles needing clarification","All articles lacking in-text citations","All articles needing additional references","Articles lacking in-text citations from May 2011","Articles needing additional references from May 2011","Data compression","Lossless compression algorithms","Transforms","Wikipedia articles needing clarification from February 2011","Wikipedia articles needing clarification from February 2012","Wikipedia articles needing clarification from July 2015"],"tag_line":"The move-to-front (MTF) transform is an encoding of data (typically a stream of bytes) designed to improve the performance of entropy encoding techniques of compression."}}
,{"_index":"throwtable","_type":"algorithm","_id":"byte-pair-encoding","_score":0,"_source":{"description":"Byte pair encoding or digram coding is a simple form of data compression in which the most common pair of consecutive bytes of data is replaced with a byte that does not occur within that data. A table of the replacements is required to rebuild the original data. The algorithm was first described publicly by Philip Gage in a February 1994 article \"A New Algorithm for Data Compression\"\nin the C Users Journal.\n^ Philip Gage, A New Algorithm for Data Compression. \"Dr Dobbs Journal\". \n^ Ian H. Witten, Alistair Moffat, and Timothy C. Bell. Managing Gigabytes. New York: Van Nostrand Reinhold, 1994. ISBN 978-0-442-01863-4.\n^ \"Byte Pair Encoding\".","alt_names":["http://ja.wikipedia.org/wiki/BPE","- Byte pair encoding :","BPE (disambiguation)","BPE - Wikipedia","BPE - Wikipedia, the free encyclopedia","BPE can stand for: .500 Black Powder Express","BPE on Wikipedia","BPE – Wikipedia","BPE-wikipedia","BPEとは？ (Wikipediaへのリンク)","BPE圧縮","Banco Popular Español, banking group in Spain. Barclays","Byte pair compression","Byte pair encoding","Byte pair encoding - Wikipedia, the free encyclopedia","Byte pair encoding; it is used under the","Byte-pair-Codierung (BPE)","Byte_pair_encoding","Wikipedia (Byte pair encoding)","Wikipedia article BPE","Wikipedia article Byte pair encoding","Wikipedia article on Byte pair encoding","Wikipedia entry for Byte pair encoding","Wikipedia l'articolo BPE","Wikipedia-Artikel BPE","Wikipediaで「BPE」を調べる","byte pair compression","byte pair encoding","byte-pair encoding","byte-pair encoding (BPE)","byte-pair kódování (BPE)","byte-pair-codering (BPE)","byte-par-kodning (BPE)","coppia di byte di codifica (BPE)","http://de.wikipedia.org/wiki/BPE","http://en.wikipedia....e_pair_encoding","http://en.wikipedia.org/wiki/BPE","http://en.wikipedia.org/wiki/Byte_pair_e","http://en.wikipedia.org/wiki/Byte_pair_encoding","http://en.wikipedia.org/wiki/Byte_pair_encoding#","ja:BPE","par-codificación de bytes (BPE)","pary kodowania bajt (BPE)","yago-res:Byte pair encoding","байт-пары кодирования (BPE)","ترميز زوجين من البايت","ウィキペディアの記事 BPE","バイトペアのエンコード（BPE）を","字节对编码","字节对编码- 维基百科，自由的百科全书","字节对编码（BPE等）","維基百科的文章“ 字节对编码”","维基百科的文章“ 字节对编码”"],"name":"Byte pair encoding","categories":["Lossless compression algorithms"],"tag_line":"Byte pair encoding or digram coding is a simple form of data compression in which the most common pair of consecutive bytes of data is replaced with a byte that does not occur within that data."}}
,{"_index":"throwtable","_type":"algorithm","_id":"tree-sort","_score":0,"_source":{"description":"A tree sort is a sort algorithm that builds a binary search tree from the keys to be sorted, and then traverses the tree (in-order) so that the keys come out in sorted order. Its typical use is sorting elements adaptively: after each insertion, the set of elements seen so far is available in sorted order.","alt_names":["Деревом","binary tree sort","Binary tree sort","- Binary tree sort :","- Tree sort :","...Wikipedia Tri arborescent","@ 트리 정렬(위키피디아)","Ağaç sıralaması","BST sort","Balanced tree sort","Binary Tree Sort","Binary Tree is...","Binary tree sort from Wikipedia","Ordenamiento con árbol binario","Tree Sort","Tree sort","Tree sort - Wikipedia, the free encyclopedia","Tree sort page","Tree_sort","Tri arborescent","Tri arborescent - Wikipédia","What is Binary tree sort's efficiency?","What is the example of Binary tree sort","What is the example of Treesort?","Wikipedia article Binary tree sort","Wikipedia article Tree sort","Wikipedia article on Tree sort","Wikipedia entry for Tree sort","artículo de Wikipedia Binary tree sort","artículo de Wikipedia Ordenamiento con arbol binario","artículo de Wikipedia Ordenamiento con árbol binario","en.wikipedia.org/wiki/Tree_sort","es:Ordenamiento con árbol binario","fa:مرتبسازی درختی","http://en.wikipedia. org/wiki/Binary_t","http://en.wikipedia. org/wiki/Binary_tree_sort","http://en.wikipedia.org/wiki/Binary_tree_sort","http://en.wikipedia.org/wiki/Tree_sort","http://es.wikipedia.org/wiki/Ordenamiento_con_%C3%A1rbol_binario","http://fr.wikipedia.org/wiki/Tri_arborescent","http://ru.wikipedia.org/wiki/Сортиро...оичного_дерева","http://ru.wikipedia.org/wiki/Сортировка_с_помощью_двоичного_дерева","ru:Сортировка с помощью двоичного дерева","sorted trees","tr:Ağaç sıralaması","tree sort","treesort","tri en arbre","wikipedia.org/wiki/Tree_sort","İkili arama ağacı","Сортировка деревом","Сортировка с помощью двоичного дерева","درخت دو دویی","مرتبسازی درختی","مرتبسازی درختی - ویکیپدیا","“Tree sort - Wikipedia, the free encyclopedia”, en.wikipedia"],"name":"Tree sort","categories":["All articles lacking sources","All articles with unsourced statements","Articles lacking sources from September 2014","Articles with unsourced statements from September 2014","Sorting algorithms"],"tag_line":"A tree sort is a sort algorithm that builds a binary search tree from the keys to be sorted, and then traverses the tree (in-order) so that the keys come out in sorted order."}}
,{"_index":"throwtable","_type":"algorithm","_id":"brotli","_score":0,"_source":{"description":"Brotli is an open source data compression library developed by Jyrki Alakuijala and Zoltán Szabadka. Brotli is based on a modern variant of the LZ77 algorithm, Huffman coding and 2nd order context modeling. Replacing deflate with brotli typically gives an increase of 20% in compression density for text files, while compression and decompression speeds are roughly unchanged.\nThe first release of brotli in 2013 was built for off-line compression of web fonts. The version of brotli released in September 2015 has been extended to perform competitively in generic lossless data compression, with particular emphasis on use for HTTP compression. The encoder has been partly rewritten, the compression ratio improved, both the encoder and the decoder have been sped up, the streaming API was improved, more compression quality levels have been added, performance has been improved across platforms, decoding memory use has been reduced, and more use cases are taken into account.\nBrotli uses a pre-defined static dictionary of more than 13,000 strings to \"warm up\" its internal state. The dictionary contains common words, phrases and other substrings derived from a large corpus of text and HTML documents.\nStreams compressed with Brotli have the proposed content encoding type \"br\".\nLike zopfli, another compression algorithm from Google, brotli is named after a Swiss bakery product, brötli.\n\n","alt_names":[],"name":"Brotli","categories":["Algorithms and data structures stubs","All articles lacking reliable references","All stub articles","Articles lacking reliable references from September 2015","Computer science stubs","Free computer libraries","Lossless compression algorithms"],"tag_line":"Brotli is an open source data compression library developed by Jyrki Alakuijala and Zoltán Szabadka."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lempel–ziv–markov-chain-algorithm","_score":0,"_source":{"description":"The Lempel–Ziv–Markov chain algorithm (LZMA) is an algorithm used to perform lossless data compression. It has been under development either since 1996 or 1998 and was first used in the 7z format of the 7-Zip archiver. This algorithm uses a dictionary compression scheme somewhat similar to the LZ77 algorithm published by Abraham Lempel and Jacob Ziv in 1977 and features a high compression ratio (generally higher than bzip2)) and a variable compression-dictionary size (up to 4 GB), while still maintaining decompression speed similar to other commonly used compression algorithms.\nLZMA2 is a simple container format that can include both uncompressed data and LZMA data, possibly with multiple different LZMA encoding parameters. LZMA2 supports arbitrarily scalable multithreaded compression and decompression and efficient compression of data which is partially incompressible.\n\n","alt_names":[],"name":"Lempel–Ziv–Markov chain algorithm","categories":["All articles covered by WikiProject Wikify","All articles needing additional references","All articles needing style editing","All articles that may contain original research","All articles with unsourced statements","All pages needing cleanup","Articles covered by WikiProject Wikify from July 2014","Articles needing additional references from July 2010","Articles that may contain original research from April 2012","Articles with unsourced statements from June 2013","Lossless compression algorithms","Wikipedia articles needing style editing from July 2014","Wikipedia introduction cleanup from July 2014"],"tag_line":"The Lempel–Ziv–Markov chain algorithm (LZMA) is an algorithm used to perform lossless data compression."}}
,{"_index":"throwtable","_type":"algorithm","_id":"incompressible-string","_score":0,"_source":{"description":"An incompressible string is one that cannot be compressed because it lacks sufficient repeating sequences. Whether a string is compressible will often depend on the algorithm being used. Some strings are incompressible by any algorithm — see Kolmogorov complexity.","alt_names":["Incompressible string","Incompressible string - Wikipedia, the free encyclopedia","Wikipedia article Incompressible string","Wikipedia entry for Incompressible string","http://en.wikipedia.org/wiki/Incompressible_string","incompressible string","incompressible strings","yago-res:Incompressible string"],"name":"Incompressible string","categories":["All articles lacking sources","Articles lacking sources from December 2009","Lossless compression algorithms","String (computer science)"],"tag_line":"An incompressible string is one that cannot be compressed because it lacks sufficient repeating sequences."}}
,{"_index":"throwtable","_type":"algorithm","_id":"prediction-by-partial-matching","_score":0,"_source":{"description":"Prediction by partial matching (PPM) is an adaptive statistical data compression technique based on context modeling and prediction. PPM models use a set of previous symbols in the uncompressed symbol stream to predict the next symbol in the stream. PPM algorithms can also be used to cluster data into predicted groupings in cluster analysis.","alt_names":[],"name":"Prediction by partial matching","categories":["All articles lacking in-text citations","Articles lacking in-text citations from November 2015","Articles with Russian-language external links","Lossless compression algorithms","Wikipedia external links cleanup from November 2015","Wikipedia spam cleanup from November 2015"],"tag_line":"Prediction by partial matching (PPM) is an adaptive statistical data compression technique based on context modeling and prediction."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bloom-filter","_score":0,"_source":{"description":"A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not, thus a Bloom filter has a 100% recall rate. In other words, a query returns either \"possibly in set\" or \"definitely not in set\". Elements can be added to the set, but not removed (though this can be addressed with a \"counting\" filter). The more elements that are added to the set, the larger the probability of false positives.\nBloom proposed the technique for applications where the amount of source data would require an impractically large amount of memory if \"conventional\" error-free hashing techniques were applied. He gave the example of a hyphenation algorithm for a dictionary of 500,000 words, out of which 90% follow simple hyphenation rules, but the remaining 10% require expensive disk accesses to retrieve specific hyphenation patterns. With sufficient core memory, an error-free hash could be used to eliminate all unnecessary disk accesses; on the other hand, with limited core memory, Bloom's technique uses a smaller hash area but still eliminates most unnecessary accesses. For example, a hash area only 15% of the size needed by an ideal error-free hash still eliminates 85% of the disk accesses, an 85–15 form of the Pareto principle (Bloom (1970)).\nMore generally, fewer than 10 bits per element are required for a 1% false positive probability, independent of the size or number of elements in the set (Bonomi et al. (2006)).\n\n","alt_names":["bloom filter","(http://en.wikipedia.org/wiki/Bloom_filter",", http://en.wikipedia.org/wiki/Bloom_filter","-> Read more about Bloom filter","...more on Wikipedia about Bloom filter","1 - 1 m .","10.1 Implementations","2 Space and time advantages","3 Probability of false positives","4 Interesting properties","4. http://en.wikipedia.","5 Counting filters","6 Bloomier filters","617899adf560c7809a67125b312903 ...","7 Compact approximators","7 Extensions and applications","7.1 Counting filters","7.2 Data synchronization","7.3 Bloomier filters","7.4 Compact approximators","7.5 Stable Bloom filters","7.6 Scalable Bloom filters","8 Generalized Bloom Filters","A bloom filter","Agarwal & Trachtenberg (2006)","Basic theory behind Bloom filters at Wikepedia","Bloom Bộ lọc","Bloom Filter","Bloom Filter (aka Bloom Hash)","Bloom Filter @ Wikipedia","Bloom Filter Wikipedia The Free Encyclopedia","Bloom Filter article","Bloom Filter data structure and by tolerating a","Bloom Filter on Wikipedia","Bloom Filter)","Bloom Filters","Bloom Filters on Wikipedia","Bloom Filterを","Bloom Filter的","Bloom Filtr","Bloom Filtros","Bloom Filtry","Bloom bộ lọc","Bloom filter","Bloom filter (Wikipedia)","Bloom filter (bloom filters)","Bloom filter - Wikipedia :: The free encyclopedia","Bloom filter - Wikipedia, the free encyclopedia","Bloom filter - Wikipedia, the free encyclopedia:","Bloom filter Wikipedia the free encyclopedia","Bloom filter Wikipedia the free encyclopedia - result","Bloom filter в wikipedia","Bloom filter – Wikipedia, the free encyclopedia","Bloom filter;","Bloom filter; it is used under the","Bloom filter@wikipedia","Bloom filteret","Bloom filtering","Bloom filters","Bloom filters in Wikipedia","Bloom filtert","Bloom filtr","Bloom filtra","Bloom filtre","Bloom filtres","Bloom filtri","Bloom filtro","Bloom filtros","Bloom filtru","Bloom filtry","Bloom lọc","Bloom map","Bloom กรอง","Bloom-Filter","Bloom-Filter)","Bloom-Filter,","Bloom-filter","Bloom-filter - Wikipedia","Bloom-suodatinta","BloomFilter","Bloom_filter","Bloomfilter","Bloomfilter – Wikipedia","Bloomfilter: an O(1) probabilistic data structure that's","Bloomfilters.","Bloomier Filter","Bloomier filters","Bloomier filters - Wikipedia, the free encyclopedia","Bloomier filtre","Bloomier filtros","Bloomier filtry","Bloomierフィルタ","Bloomov filter","Bloomovho filtra","Bloomův filtr","Bloom过滤器","Blüte Filter","Blüte Filter,","Boldi & Vigna (2005)","Bonomi et al. (2006)","Burton H. Bloom","Byers et al. (2004)","Can we use Bloom filters","Chang et al. (Wallach)","Charles & Chellapilla (2008)","Chazelle et al. (2004)","Counting Bloom Filter","Counting filter","Definition of Bloom filter by wikipedia","Dietzfelbinger & Pagh (2008)","Dillinger & Manolios (2004a)","Dillinger & Manolios (2004b)","Fan et al. (1998)","Filter Bloom","Filter Bloom)","Filtr Blooma","Filtre de Bloom","Filtre de Bloom - Wikipédia","Filtri Bloomier","Filtro de flor - Wikipedia, la enciclopedia libre(gratis","Goel & Gupta (2010)","I just came across an unreferenced mention of","Karteek: Bloom filter - Wikipedia, the free encyclopedia","Kirsch & Mitzenmacher (2006)","Mortensen, Pagh & Pătraşcu (2005)","Pagh, Pagh & Rao 2005","Porat (2008)","Probability of false positives","Putze, Sanders & Singler (2007)","Read More bloom filter wikipedia the free encyclopedia","Space and time advantages","Starobinski, Trachtenberg & Agarwal (2003)","Stern & Dill (1996)","The Bloom Filter, a space-efficient probabilistic data","The Bloom filter","The Wikipedia page on Bloom Filters","WikiPedia:ブルームフィルタ","Wikipedia (Bloom filter)","Wikipedia Bloom Filter","Wikipedia article Bloom filter","Wikipedia article Bloom filters","Wikipedia article Bloom map","Wikipedia article Bloomfilter","Wikipedia article Bloomov filter","Wikipedia article on Bloom filter","Wikipedia entry for Bloom Filters","Wikipedia has a nice description of the Bloom","Wikipedia on Bloom Filters","Wikipedia-Artikel Bloom-filter","Wikipedia-Artikel Bloomfilter","Wikipedia: Bloom Filter","Wikipedia: Bloom filter (and variants)","Wikipediaで「ブルームフィルタ」を調べる","[BLOOM-FILTER] Bloom Filter","an element is a member of a set","bloei filter","bloei-filter","bloom filter provides quicker resolution for key value","bloom filter wikipedia","bloom filter wikipedia the free encyclopedia","bloom filter.","bloom filtering","bloom filters","bloom filter的wiki","bloom-filter","bloom-filters","bloomfil","bloomfilter","bloomfilters","bloomier filter","blühen Filter","bộ lọc Bloom","bộ lọc Bloom;","bộ lọc nở","bộ lọc nở,","calculate the number of bits we should be","counting Bloom filter","counting Bloom filters","counting bloom filter","cs:Bloomův filtr","de:Bloomfilter","des filtres de Bloom","drzewa filtr","drzewa filtrów","e http://en.wikipedia.org/wiki/Bloom_filter","en.wikipedia.org/...Bloom_filter","en.wikipedia.org/wiki/Bloom_filter","en.wikipedia.org/wiki/Bloom_filter#CITEREFAgarwalTrachtenberg2006","en.wikipedia.org/wiki/Bloom_filter#Example","en.wikipedia.org/wiki/Bloomfilter","en:Bloom_filter","excellent (and extremely readable) mathematical analysis","excellently chosen name","explanation of the math behind Bloom Filters","filter Bloom","filter bloei","filter mekar","filtr Bloom","filtr Blooma","filtra Bloom'a","filtration Bloom","filtre bloom","filtre bloom,","filtre de Bloom","filtre de Bloom)","filtre de la floraison","filtres de Bloom","filtri di Bloom","filtri di Bloom,","filtro Bloom","filtro Bloom)","filtro Bloom,","filtro de Bloom","filtro de Bloom)","filtro de Bloom,","filtro de flor","filtro de la floración","filtro di Bloom","filtro di Bloom)","filtro di Bloom,","filtros Bloom","filtros Bloom,","filtros de Bloom,","filtru Bloom","filtry Bloom","fiore filtro","fiore filtro di","fioritura filtro","fioritura filtro di","flor filter","flor filtro de","fr:Filtre de Bloom","generalized bloom filter","great introduction in Wikipedia","he:פילטר בלום","his favorite data structure","http://de.wikipedia.org/wiki/Bloomfilter","http://de.wikipedia.org/wiki/Bloomfilter]Bloomfilter[/url","http://en.wikipedia.org/wiki/Bloom filter","http://en.wikipedia.org/wiki/Bloom_filte","http://en.wikipedia.org/wiki/Bloom_filter","http://en.wikipedia.org/wiki/Bloom_filter#Algorithm_description","http://en.wikipedia.org/wiki/Bloom_filter#Cou...","http://en.wikipedia.org/wiki/Bloom_filter#Counting_filters","http://en.wikipedia.org/wiki/Bloom_filter#Pro...","http://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives","http://en.wikipedia.org/wiki/Bloom_filter#Space_and_time_advantages","http://en.wikipedia.org/wiki/Bloom_filter#Stable_Bloom_Filters","http://en.wikipedia.org/wiki/Bloom_filter)","http://en.wikipedia.org/wiki/Bloom_filter.","http://en.wikipedia.org/wiki/Bloom_filters","http://en.wikipedia.org/wiki/Bloom_map","http://en.wikipedia.org/wiki/Bloomfilter","http://fr.wikipedia.org/wiki/Filtre_de_Bloom","http://ja.wikipedia.org/wiki/ブルームフィルタ","i filtri Bloom","i filtri Bloom,","is something else.","ja:ブルームフィルタ","ko:블룸 필터","květ filtr","kwitną filtr","l'encyclopédie Wikipédia,","l: http://en.wikipedia.org/wiki/Bloom_filter.","les filtres de Bloom,","los filtros Bloom","map (bloom filter)","mekar filter,","mekar penyaring","mga filter ng pamumulaklak;","optimal number of hash functions","org/wiki/Bloom_filter fo","page on Bloom filters","penyaring mekar","pretty handy data structures","ru.wikipedia.org/...%D0%91%D0%BB%D1","ru:Фильтр Блума","sk:Bloomov filter","some math and probability calculation","standard filter","the data-membership one","w:Bloom filter","wikipedia--bloom filter","wikipedia:jp:ブルームフィルタ","zh:布隆过滤器","Блум Фильтр","Блум Фильтры","Блум фильтр","Блум фильтра","Блум фильтров,","Блум фильтры","Блум-фильтры","Фильтр Блума","Фильтр Блума — Википедия","Фильтр_Блума","Фильтра Блума","вероятностные поисковые индексы","фильтр Блума","фильтр блюма","фильтр цвету","фильтра Блума","фильтра Блума)","фильтрах Блума","фильтрацию Блюма","фильтров Блюма (Bloom-filter)","фильтру Блума","фильтры Блума","фильтры Блюма","цвета фильтра,","цветение фильтра","цвету фильтра","эффективный по памяти способ организации фильтров","פילטר בלום","פילטר בלום – ויקיפדיה","نور مرشحة - [ويكيبديا], الموسوعة حرّة:","खिल फिल्टर","ब्लूम फ़िल्टर","กรอง Bloom","กรอง บ ลู","กรอง บาน","กรอง บาน,","กรองบาน","ตัว กรอง บ ลู;","บ ลู Filter)","บลูมกรอง","“Bloom filter - Wikipedia, the free encyclopedia”, en.wikipedia","フィルタの代わりに","フィルタを咲かせる","フィルタ（","ブルームはフィルタ","ブルームフィルタ","ブルームフィルタ - Wikipedia","ブルームフィルタ – Wikipedia","ブルームフィルタ 、カウンティングフィルタ","ブルームフィルタが","ブルームフィルタを","ブルームフィルター","咲いてフィルタ","定义的Bloom","布卢姆过滤器","布盧姆過濾器","布隆过滤器","布隆过滤器（bloom filters）","布隆過濾器","布魯姆過濾器","布鲁姆过滤器","満開のフィルタ","満開フィルタ","盛开筛选","盛开过滤器","盛開篩選","盛開過濾器","維基百科的文章“ 布隆过滤器”","维基百科的文章“ 布隆过滤器”","꽃 필터는","꽃 필터를","꽃 필터의","꽃을 필터인가요?","블룸 필터","블룸 필터)의","블룸 필터;","블룸 필터는","위키 피 디아 문서 블룸 필터","（http://en.wikipedia.org/wiki/Bloom_filter","，Bloom过滤器","，Bloom過濾器","ﾌﾞﾙｰﾑﾌｨﾙﾀ","ﾌﾞﾙｰﾑﾌｨﾙﾀ - Wikipedia","ﾌﾞﾙｰﾑﾌｨﾙﾀ-wikipedia"],"name":"Bloom filter","categories":["All articles lacking in-text citations","All articles with dead external links","Articles lacking in-text citations from November 2009","Articles with dead external links from June 2010","Commons category with local link same as on Wikidata","Hashing","Lossy compression algorithms","Probabilistic data structures"],"tag_line":"A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fractal-compression","_score":0,"_source":{"description":"Fractal compression is a lossy compression method for digital images, based on fractals. The method is best suited for textures and natural images, relying on the fact that parts of an image often resemble other parts of the same image. Fractal algorithms convert these parts into mathematical data called \"fractal codes\" which are used to recreate the encoded image.","alt_names":["fractal compression","Fraktale_Bildkompression","wikipediaによれば、","*fractal *image *compression","-> Read the article about 'Fractal compression'","...Wikipedia Kompresja fraktalna","...mehr auf Wikipedia über Fraktale Bildkompression","...more on Wikipedia about Fractal compression","1 Iterated Function Systems","1.1 For Binary Images","1.2 Extension to Grayscale","1.3 Encoding","2.1 Resolution independence and fractal scaling","2.2 Fractal interpolation","Compresión fractal","Compression fractale","Compression fractale - Wikipédia","Compressione frattale","Compressione frattale - Wikipedia","Compressione frattale - Wikipedia- /w/opensearch_desc.php title= Wikipedia","Fractal Compression","Fractal compression","Fractal compression - Wikipedia, the free encyclopedia","Fractal compression Wikipedia the free encyclopedia","Fractal compression – Wikipedia, the free encyclopedia","Fractal compression; it is used under the","Fractal image compression","Fractal pression Wikipedia the free encyclopedia","Fractal_compression","Fractal_image_compression","Fraktale Bildkompression","Fraktale Bildkompression - Wikipedia","Fraktale Bildkompression bei Wikipedia","Fraktale Bildkompression ist ein Verfahren zur verlustbehafteten Kompression","Fraktale Bildkompression – Wikipedia","Fraktale Kompression","Fraktale Kompression - Wikipedia","Fraktale Kompression bei Wikipedia","Fraktale_Bildkompression bei der wikipedia","Fraktale_Kompression","Fraktale_Kompression bei der wikipedia","Here's Wikipedia's article an fractal compression","Iimage Compression","Kompresja fraktalna","Kompresja fraktalna ? Wikipedia, wolna encyklopedia","Kompresja fraktalna – Wikipedia, wolna encyklopedia","Learn about Fractal compression>>>","Overview of Fractal compression","View Fractal compression on Wikipedia","What are the features of Fractal image compression","What is the history of Fractal compression?","What is the history of Fractal image compression","Wikipedia article Fractal image compression","Wikipedia article Kompresja fraktalna","Wikipedia article on Compresión fractal","Wikipedia entry for Fractal compression","Wikipedia entry: Fractal Compression","Wikipedia l'articolo Compressione frattale","Wikipedia on fractal compression","Wikipedia's article on fractal compression","Wikipedia-Artikel Fraktale Bildkompression","Wikipedia-Artikel Fraktale Kompression","Wikipedia-Seite zu 'Fraktale Bildkompression'","Wikipedia-Seite zu 'Fraktale Kompression'","Wikipedia: Fraktale Bildkompression","Wikipedia:Compressione_frattale","Wikipedia:Fractal_compression","Wikipediaで「フラクタル圧縮」を調べる","algorithme adéquat","billede komprimering","coding and compression","compresión fractal","compressing images through fractals","compression d'image fractale","compression fractale","comprimir imágenes","de compresión de imágenes","de compression d'image","de compressão de imagem","de.wikipedia.org/wiki/Fraktale_Bildkompression","de:Fraktale Bildkompression","di compressione delle immagini","en.wikipedia.org/wiki/Fractal_compres...","en:Fractal compression","en:fractal compression","fr:Compression fractale","fractal compression - Wikipedia, the free encyclopedia","fractal compression?","fractal decompression","fractal image compression","fractal image compression.","fractal information compression","fractal pression wikipedia the free encyclopedia","fractal_compression","fractale compressie","fractals have been used for image compression","fraktaalipakkausalgoritmin","fraktal komprimering","fraktal komprimiertes Format","fraktalen Bildkompression","fraktalen Kompression","fraktaler Bildkompression","fraktaler Kompression","google to wikipedia","http://de.wikipedia.org/wiki/Fraktale_Bi","http://de.wikipedia.org/wiki/Fraktale_Bildkompression","http://de.wikipedia.org/wiki/Fraktale_Kompression","http://en.wikipedia....tal_compression","http://en.wikipedia.org/w...ion#Fractal_interpolation","http://en.wikipedia.org/wiki/Fracta...","http://en.wikipedia.org/wiki/Fractal_Compression","http://en.wikipedia.org/wiki/Fractal_com","http://en.wikipedia.org/wiki/Fractal_com...","http://en.wikipedia.org/wiki/Fractal_compress...","http://en.wikipedia.org/wiki/Fractal_compression","http://en.wikipedia.org/wiki/Fractal_compression#","http://en.wikipedia.org/wiki/Fractal_compression#History","http://en.wikipedia.org/wiki/Fractal_compression#Open_Source","http://en.wikipedia.org/wiki/Fractal_compression#Patents","http://en.wikipedia.org/wiki/Fractal_compression#Resolution_independence_and_fractal_scaling","http://en.wikipedia.org/wiki/Fractal_com…","http://en.wikipedia.org/wiki/Fractal_image_compression","http://es.wikipedia.org/wiki/Compresi%C3%B3n_fractal","http://fr.wikipedia.org/wiki/Compression_fractale","http://it.wikipedia.org/wiki/Compressione_frattale","http://pl.wikipedia.org/wiki/Kompresja_fraktalna","http://ru.wikipedia.org/wiki/Фрактальное_сжатие","it:Compressione frattale","ja:フラクタル圧縮","komprese obrazu","kompresja fraktalna","kompresji obrazów","lost the race","pl:Kompresja fraktalna","pl:Kompresja_fraktalna","ru:Алгоритм фрактального сжатия","Алгоритм фрактального сжатия","Алгоритм фрактального сжатия (Википедия)","Википедии статью Алгоритм фрактального сжатия","Википедии статью Фрактальное сжатие","Фрактальний стиск","Фрактальный","алгоритм фрактального сжатия","алгоритмы для сжатия изображения с помощью фракталов","сжатие изображений","фрактального сжатия","фрактальное сжатие","фрактальном сжатии изображений","фрактальному сжатию","सामान भग्न","ფრაქტალური შეკუმშვის ალგორითმი","フラクタル圧縮","フラクタル圧縮 - Wikipedia","ﾌﾗｸﾀﾙ圧縮-wikipedia"],"name":"Fractal compression","categories":["All articles with unsourced statements","Articles with unsourced statements from August 2009","Articles with unsourced statements from March 2008","Fractals","Image compression","Lossy compression algorithms","Pages containing cite templates with deprecated parameters"],"tag_line":"Fractal compression is a lossy compression method for digital images, based on fractals."}}
,{"_index":"throwtable","_type":"algorithm","_id":"double-dabble","_score":0,"_source":{"description":"In computer science, the double dabble algorithm is used to convert binary numbers into binary-coded decimal (BCD) notation. It is also known as the shift and add 3 algorithm, and can be implemented using a small number of gates in computer hardware, but at the expense of high latency. The algorithm operates as follows:\nSuppose the original number to be converted is stored in a register that is n bits wide. Reserve a scratch space wide enough to hold both the original number and its BCD representation; 4×ceil(n/3) bits will be enough. It takes a maximum of 4 bits in binary to store each decimal digit.\nThen partition the scratch space into BCD digits (on the left) and the original register (on the right). For example, if the original number to be converted is eight bits wide, the scratch space would be partitioned as follows:\n\n100s Tens Ones   Original\n0010 0100 0011   11110011\n\nThe diagram above shows the binary representation of 24310 in the original register, and the BCD representation of 243 on the left.\nThe scratch space is initialized to all zeros, and then the value to be converted is copied into the \"original register\" space on the right.\n\n0000 0000 0000   11110011\n\nThe algorithm then iterates n times. On each iteration, the entire scratch space is left-shifted one bit. However, before the left-shift is done, any BCD digit which is greater than 4 is incremented by 3. The increment ensures that a value of 5, incremented and left-shifted, becomes 16, thus correctly \"carrying\" into the next BCD digit.\nThe double-dabble algorithm, performed on the value 24310, looks like this:\n\n0000 0000 0000   11110011   Initialization\n0000 0000 0001   11100110   Shift\n0000 0000 0011   11001100   Shift\n0000 0000 0111   10011000   Shift\n0000 0000 1010   10011000   Add 3 to ONES, since it was 7\n0000 0001 0101   00110000   Shift\n0000 0001 1000   00110000   Add 3 to ONES, since it was 5\n0000 0011 0000   01100000   Shift\n0000 0110 0000   11000000   Shift\n0000 1001 0000   11000000   Add 3 to TENS, since it was 6\n0001 0010 0001   10000000   Shift\n0010 0100 0011   00000000   Shift\n   2    4    3\n       BCD\n\nNow eight shifts have been performed, so the algorithm terminates. The BCD digits to the left of the \"original register\" space display the BCD encoding of the original value 243.\nAnother example for the double dabble algorithm - value 6524410.\n\n 104  103  102   101  100    Original binary\n0000 0000 0000 0000 0000   1111111011011100   Initialization\n0000 0000 0000 0000 0001   1111110110111000   Shift left (1st)\n0000 0000 0000 0000 0011   1111101101110000   Shift left (2nd)\n0000 0000 0000 0000 0111   1111011011100000   Shift left (3rd)\n0000 0000 0000 0000 1010   1111011011100000   Add 3 to 100, since it was 7\n0000 0000 0000 0001 0101   1110110111000000   Shift left (4th)\n0000 0000 0000 0001 1000   1110110111000000   Add 3 to 100, since it was 5\n0000 0000 0000 0011 0001   1101101110000000   Shift left (5th)\n0000 0000 0000 0110 0011   1011011100000000   Shift left (6th)\n0000 0000 0000 1001 0011   1011011100000000   Add 3 to 101, since it was 6\n0000 0000 0001 0010 0111   0110111000000000   Shift left (7th)\n0000 0000 0001 0010 1010   0110111000000000   Add 3 to 100, since it was 7\n0000 0000 0010 0101 0100   1101110000000000   Shift left (8th)\n0000 0000 0010 1000 0100   1101110000000000   Add 3 to 101, since it was 5\n0000 0000 0101 0000 1001   1011100000000000   Shift left (9th)\n0000 0000 1000 0000 1001   1011100000000000   Add 3 to 102, since it was 5\n0000 0000 1000 0000 1100   1011100000000000   Add 3 to 100, since it was 9\n0000 0001 0000 0001 1001   0111000000000000   Shift left (10th)\n0000 0001 0000 0001 1100   0111000000000000   Add 3 to 100, since it was 9\n0000 0010 0000 0011 1000   1110000000000000   Shift left (11th)\n0000 0010 0000 0011 1011   1110000000000000   Add 3 to 100, since it was 8\n0000 0100 0000 0111 0111   1100000000000000   Shift left (12th)\n0000 0100 0000 1010 0111   1100000000000000   Add 3 to 101, since it was 7\n0000 0100 0000 1010 1010   1100000000000000   Add 3 to 100, since it was 7\n0000 1000 0001 0101 0101   1000000000000000   Shift left (13th)\n0000 1011 0001 0101 0101   1000000000000000   Add 3 to 103, since it was 8\n0000 1011 0001 1000 0101   1000000000000000   Add 3 to 101, since it was 5\n0000 1011 0001 1000 1000   1000000000000000   Add 3 to 100, since it was 5\n0001 0110 0011 0001 0001   0000000000000000   Shift left (14th)\n0001 1001 0011 0001 0001   0000000000000000   Add 3 to 103, since it was 6\n0011 0010 0110 0010 0010   0000000000000000   Shift left (15th)\n0011 0010 1001 0010 0010   0000000000000000   Add 3 to 102, since it was 6\n0110 0101 0010 0100 0100   0000000000000000   Shift left (16th)\n   6    5    2    4    4\n            BCD\n\nSixteen shifts have been performed, so the algorithm terminates. The BCD digits is: 6*104 + 5*103 + 2*102 + 4*101 + 4*100 = 65244.","alt_names":["Double Dabble - Wikipedia, The Free Encyclopedia","Double dabble","Double dabble - Wikipedia, the free encyclopedia","Double dabble - Wikipédia","Double dabble on wikipedia.org","Double-Dabble Algorithm","Double-Dabble-Algorithmus","Double_dabble","Quick conversions","Wikipedia article Double dabble","Wikipedia article about Double dabble","Wikipedia entry for Double dabble","double dabble","double dabble method","en.wikipedia.org/wiki/Double_dabble","http://en.wikipedia.org/wiki/Double_dabb","http://en.wikipedia.org/wiki/Double_dabble","http://ur1.ca/111br","shift add 3","wikipedia: double dabble"],"name":"Double dabble","categories":["Articles with example C code","Binary arithmetic","Computer arithmetic algorithms"],"tag_line":"In computer science, the double dabble algorithm is used to convert binary numbers into binary-coded decimal (BCD) notation."}}
,{"_index":"throwtable","_type":"algorithm","_id":"addition-chain-exponentiation","_score":0,"_source":{"description":"In mathematics and computer science, optimal addition-chain exponentiation is a method of exponentiation by positive integer powers that requires a minimal number of multiplications. It works by creating the shortest addition chain that generates the desired exponent. Each exponentiation in the chain can be evaluated by multiplying two of the earlier exponentiation results. More generally, addition-chain exponentiation may also refer to exponentiation by non-minimal addition chains constructed by a variety of algorithms (since a shortest addition chain is very difficult to find).\nThe shortest addition-chain algorithm requires no more multiplications than binary exponentiation and usually less. The first example of where it does better is for a15, where the binary method needs six multiplications but a shortest addition chain requires only five:\n (binary, 6 multiplications)\n (shortest addition chain, 5 multiplications).\nOn the other hand, the determination of a shortest addition chain is hard: no efficient optimal methods are currently known for arbitrary exponents, and the related problem of finding a shortest addition chain for a given set of exponents has been proven NP-complete. Even given a shortest chain, addition-chain exponentiation requires more memory than the binary method, because it must potentially store many previous exponents from the chain. So in practice, shortest addition-chain exponentiation is primarily used for small fixed exponents for which a shortest chain can be precomputed and is not too large.\nThere are also several methods to approximate a shortest addition chain, and which often require fewer multiplications than binary exponentiation; binary exponentiation itself is a suboptimal addition-chain algorithm. The optimal algorithm choice depends on the context (such as the relative cost of the multiplication and the number of times a given exponent is re-used).\nThe problem of finding the shortest addition chain cannot be solved by dynamic programming, because it does not satisfy the assumption of optimal substructure. That is, it is not sufficient to decompose the power into smaller powers, each of which is computed minimally, since the addition chains for the smaller powers may be related (to share computations). For example, in the shortest addition chain for a15 above, the subproblem for a6 must be computed as (a3)2 since a3 is re-used (as opposed to, say, a6 = a2(a2)2, which also requires three multiplies).","alt_names":["(minimal) vector addition chains","...more on Wikipedia about Addition chain exponentiation","Addition chain exponentiation","Addition chain exponentiation Wikipedia the free encyclopedia","Addition-chain exponentiation","Addition-chain exponentiation - Wikipedia, the free encyclopedia","Addition-chain exponentiation - Wikipedia, the free encyclopedia ...","Wikipedia article Addition chain exponentiation","Wikipedia article Addition-chain exponentiation","Wikipedia entry for Addition-chain exponentiation","a 15 = a × ( a × [ a × a 2 ] 2","addition-chain exponentiation","ddition-chain exponentiation","en.wikipedia.org/wiki/Addition-chain_exponentiation","en.wikipedia.org/wiki/Addition-chain_exponentiation).","http://en.wikipedia.org/wiki/Additio...exponentiation","http://en.wikipedia.org/wiki/Addition-c ... nentiation","http://en.wikipedia.org/wiki/Addition-ch","http://en.wikipedia.org/wiki/Addition-chain exponentiation","http://en.wikipedia.org/wiki/Addition-chain_exponentiation","http://en.wikipedia.org/wiki/Addition-chain_exponentiation.","http://en.wikipedia.org/wiki/Addition-ch…","http://en.wikipedia.org/wiki/Addition_chain_exponentiation","http://en.wikipedia.org/wiki/Addition−chain_exponentiation"],"name":"Addition-chain exponentiation","categories":["Addition chains","Computer arithmetic algorithms","Exponentials"],"tag_line":"In mathematics and computer science, optimal addition-chain exponentiation is a method of exponentiation by positive integer powers that requires a minimal number of multiplications."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fürer's-algorithm","_score":0,"_source":{"description":"Fürer's algorithm is an integer multiplication algorithm for very large numbers possessing a very low asymptotic complexity. It was created in 2007 by Swiss mathematician Martin Fürer of Pennsylvania State University as an asymptotically faster (when analysed on a multitape Turing machine) algorithm than its predecessor, the Schönhage–Strassen algorithm published in 1971.\nThe predecessor to the Fürer algorithm, the Schönhage–Strassen algorithm, used fast Fourier transforms to compute integer products in time  (in big O notation) and its authors, Arnold Schönhage and Volker Strassen, also conjectured a lower bound for the problem of . Here,  denotes the total number of bits in the two input numbers. Fürer's algorithm reduces the gap between these two bounds: it can be used to multiply binary integers of length  in time  (or by a circuit with that many logic gates), where log*n represents the iterated logarithm operation. However, the difference between the  and  factors in the time bounds of the Schönhage–Strassen algorithm and the Fürer algorithm for realistic values of  is very small.\nIn 2008, Anindya De, Chandan Saha, Piyush Kurur and Ramprasad Saptharishi gave a similar algorithm that relies on modular arithmetic instead of complex arithmetic to achieve the same running time.\nIn 2014, David Harvey, Joris van der Hoeven, and Grégoire Lecerf showed that an optimized version of Fürer's algorithm achieves a running time of , making the implied constant in the  exponent explicit. They also gave a modification to Fürer's algorithm that achieves \nIn 2015 Svyatoslav Covanov and Emmanuel Thomé provided another modifications that achieves same running time. Yet, as all the other implementation, it's still not practical.\n^ a b Fürer, M. (2007). \"Faster Integer Multiplication\" in Proceedings of the thirty-ninth annual ACM symposium on Theory of computing, June 11–13, 2007, San Diego, California, USA\n^ A. Schönhage and V. Strassen, \"Schnelle Multiplikation großer Zahlen\", Computing 7 (1971), pp. 281–292.\n^ Anindya De, Piyush P Kurur, Chandan Saha, Ramprasad Saptharishi. Fast Integer Multiplication Using Modular Arithmetic. Symposium on Theory of Computation (STOC) 2008. arXiv:0801.1416\n^ David Harvey, Joris van der Hoeven, and Grégoire Lecerf, \"Even faster integer multiplication\", 2014, arXiv:1407.3360\n^ Svyatoslav Covanov and Emmanuel Thomé, \"Fast arithmetic for faster integer multiplication\", 2015 arXiv:1502.02800","alt_names":[],"name":"Fürer's algorithm","categories":["Algorithms and data structures stubs","All articles with unsourced statements","All stub articles","Articles with unsourced statements from June 2015","Computer arithmetic algorithms","Computer science stubs"],"tag_line":"Fürer's algorithm is an integer multiplication algorithm for very large numbers possessing a very low asymptotic complexity."}}
,{"_index":"throwtable","_type":"algorithm","_id":"binary-splitting","_score":0,"_source":{"description":"In mathematics, binary splitting is a technique for speeding up numerical evaluation of many types of series with rational terms. In particular, it can be used to evaluate hypergeometric series at rational points. Given a series\n\nwhere pn and qn are integers, the goal of binary splitting is to compute integers P(a, b) and Q(a, b) such that\n\nThe splitting consists of setting m = [(a + b)/2] and recursively computing P(a, b) and Q(a, b) from P(a, m), P(m, b), Q(a, m), and Q(m, b). When a and b are sufficiently close, P(a, b) and Q(a, b) can be computed directly from pa...pb and qa...qb.\nBinary splitting requires more memory than direct term-by-term summation, but is asymptotically faster since the sizes of all occurring subproducts are reduced. Additionally, whereas the most naive evaluation scheme for a rational series uses a full-precision division for each term in the series, binary splitting requires only one final division at the target precision; this is not only faster, but conveniently eliminates rounding errors. To take full advantage of the scheme, fast multiplication algorithms such as Toom–Cook and Schönhage–Strassen must be used; with ordinary O(n2) multiplication, binary splitting may render no speedup at all or be slower.\nSince all subdivisions of the series can be computed independently of each other, binary splitting lends well to parallelization and checkpointing.\nIn a less specific sense, binary splitting may also refer to any divide and conquer algorithm that always divides the problem in two halves.","alt_names":["Binary splitting","Binary splitting - Wikipedia, the free encyclopedia","Binary splitting algorithm","Dichotomy principle","S ( a , b ) = ∑ n = a b p n","Scindage binaire - Wikipédia","Wikipedia article Binary splitting","Wikipedia article Dichotomy principle","Wikipedia article تفرع ثنائي","Wikipedia entry for Binary splitting","ar:تفرع ثنائي","binary splitting","binary splitting algorithm","binary splitting article","dichotomy principle","http://en.wikipedia.org/wiki/Binary_spli","http://en.wikipedia.org/wiki/Binary_splitting","http://fr.wikipedia.org/wiki/Scindage_binaire","تفرع ثنائي"],"name":"Binary splitting","categories":["Computer arithmetic algorithms"],"tag_line":"In mathematics, binary splitting is a technique for speeding up numerical evaluation of many types of series with rational terms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sequitur-algorithm","_score":0,"_source":{"description":"Sequitur (or Nevill-Manning algorithm) is a recursive algorithm developed by Craig Nevill-Manning and Ian H. Witten in 1997 that infers a hierarchical structure (context-free grammar) from a sequence of discrete symbols. The algorithm operates in linear space and time. It can be used in data compression software applications.\n^ Nevill-Manning, C.G.; Witten, I.H. (1997). \"Identifying Hierarchical Structure in Sequences: A linear-time algorithm\". arXiv:cs/9709102. \n^ Nevill-Manning, C.G.; Witten, I.H. (1997). \"Linear-Time, Incremental Hierarchy Inference for Compression\". doi:10.1109/DCC.1997.581951.","alt_names":["Sequitur","- Sequitur algorithm :","-> Read more about Sequitur algorithm","-> Read the article about 'Sequitur algorithm'","Funkt10n5w3153 d35 Sequitur-Algorithmus","Funktionsweise des Sequitur-Algorithmus","How the Sequitur algorithm works","Learn about Sequitur algorithm>>>","SEQUITUR","SEQUITUR algorithm","SEQUITUR algorithm - Wikipedia, the free encyclopedia","Sequitor","Sequitur - Wikipedia","Sequitur algorithm","Sequitur algorithm - Wikipedia :: The free encyclopedia","Sequitur algorithm - Wikipedia, the free encyclopedia","Sequitur â�“ Wikipedia, wolna encyklopedia","Sequitur – Wikipedia","Sequitur-algoritmi","Sequitur-algoritmi – Wikipedia","Wikipedia article Nevill-Manning algorithm","Wikipedia article Sequitur","Wikipedia article Sequitur algorithm","Wikipedia article on SEQUITUR algorithm","Wikipedia entry for Sequitur algorithm","Wikipedia-Artikel Sequitur","Wikipedia-Seite zu 'Sequitur'","Wikipediaドイツ版 - Sequitur","Zasada działania algorytmu Sequitur","de.wikipedia.org/wiki/Sequitur","http://de.wikipedia.org/wiki/Sequitur","http://de.wikipedia.org/wiki/Sequitur#Beispiel","http://en.wikipedia.org/wiki/SEQUITUR_al","http://en.wikipedia.org/wiki/SEQUITUR_algorithm","http://en.wikipedia.org/wiki/Sequitur_algorithm","http://pl.wikipedia.org/wiki/Sequitur"],"name":"Sequitur algorithm","categories":["Lossless compression algorithms"],"tag_line":"Sequitur (or Nevill-Manning algorithm) is a recursive algorithm developed by Craig Nevill-Manning and Ian H. Witten in 1997 that infers a hierarchical structure (context-free grammar) from a sequence of discrete symbols."}}
,{"_index":"throwtable","_type":"algorithm","_id":"s2tc","_score":0,"_source":{"description":"S2TC (short for Super Simple Texture Compression) is a texture compression algorithm designed to be compatible with existing patented S3TC decompressors while avoiding any need for patent licensing fees. According to the authors, compressed textures produced by a good S2TC implementation are similar in quality to compressed textures produced by a bad S3TC implementation. The S2TC reference implementation is also capable of decompressing S3TC compressed textures, but instead of implementing the patented aspects of the algorithm, the S2TC decompressor picks colors at random. S2TC was created to provide an alternative to S3TC for open source OpenGL implementations which are legally constrained from implementing patented algorithms.\n\n","alt_names":[],"name":"S2TC","categories":["Lossy compression algorithms","Texture compression"],"tag_line":"S2TC (short for Super Simple Texture Compression) is a texture compression algorithm designed to be compatible with existing patented S3TC decompressors while avoiding any need for patent licensing fees."}}
,{"_index":"throwtable","_type":"algorithm","_id":"adaptive-scalable-texture-compression","_score":0,"_source":{"description":"Adaptive Scalable Texture Compression (ASTC) is a lossy block-based texture compression algorithm developed by Jørn Nystad et al. of ARM Ltd. and AMD.\nFull details of ASTC were first presented publicly at the High Performance Graphics 2012 conference, in a paper by Olson et al. entitled \"Adaptive Scalable Texture Compression\"\nASTC was adopted as an official extension for both OpenGL and OpenGL ES by the Khronos Group on 6 August 2012. It's also a part of Direct3D 11.3 and Direct3D 12.\n\n","alt_names":[],"name":"Adaptive Scalable Texture Compression","categories":["All articles with unsourced statements","Articles with unsourced statements from December 2015","Lossy compression algorithms","Texture compression"],"tag_line":"Adaptive Scalable Texture Compression (ASTC) is a lossy block-based texture compression algorithm developed by Jørn Nystad et al."}}
,{"_index":"throwtable","_type":"algorithm","_id":"spinlock","_score":0,"_source":{"description":"In software engineering, a spinlock is a lock which causes a thread trying to acquire it to simply wait in a loop (\"spin\") while repeatedly checking if the lock is available. Since the thread remains active but is not performing a useful task, the use of such a lock is a kind of busy waiting. Once acquired, spinlocks will usually be held until they are explicitly released, although in some implementations they may be automatically released if the thread being waited on (that which holds the lock) blocks, or \"goes to sleep\".\nBecause they avoid overhead from operating system process rescheduling or context switching, spinlocks are efficient if threads are likely to be blocked for only short periods. For this reason, operating-system kernels often use spinlocks. However, spinlocks become wasteful if held for longer durations, as they may prevent other threads from running and require rescheduling. The longer a thread holds a lock, the greater the risk that the thread will be interrupted by the OS scheduler while holding the lock. If this happens, other threads will be left \"spinning\" (repeatedly trying to acquire the lock), while the thread holding the lock is not making progress towards releasing it. The result is an indefinite postponement until the thread holding the lock can finish and release it. This is especially true on a single-processor system, where each waiting thread of the same priority is likely to waste its quantum (allocated time where a thread can run) spinning until the thread that holds the lock is finally finished.\nImplementing spin locks correctly offers challenges because programmers must take into account the possibility of simultaneous access to the lock, which could cause race conditions. Generally, such implementation is possible only with special assembly-language instructions, such as atomic test-and-set operations, and cannot be easily implemented in programming languages not supporting truly atomic operations. On architectures without such operations, or if high-level language implementation is required, a non-atomic locking algorithm may be used, e.g. Peterson's algorithm. But note that such an implementation may require more memory than a spinlock, be slower to allow progress after unlocking, and may not be implementable in a high-level language if out-of-order execution is allowed.\n\n","alt_names":["- Spin lock :","- Spinlock :","...Wikipedia Spinlock","...mehr auf Wikipedia über Spinlock","...more on Wikipedia about Spinlock","Busy waiting (Wikipedia)","Entrada en la Wikipedia EN","OM NOM NOM NOM Wikipedia for you","Read More spinlock wikipedia the free encyclopedia","Search info on Spinlock at Wikipedia","Significant optimizations","Spin Lock","Spin Locks.","Spin lock","Spin locking","Spin locks","Spin-Lock","Spin-Lock.","Spin-lock","SpinLocking","Spinlock","Spinlock (Wikipedia)","Spinlock (en)","Spinlock - SMP Synchronization","Spinlock - Wikipedia","Spinlock - Wikipedia, the fr...","Spinlock - Wikipedia, the free encyclopedia","Spinlock - Wikipédia","Spinlock Wikipedia The Free Encyclopedia","Spinlock from Wikipedia","Spinlock loop from Wikipedia","Spinlock on Wikipedia","Spinlock – Wikipedia","Spinlock — Википедия","Spinlocks","Suktukinis rakinimas","Suktukinis_rakinimas","Wikipedia (Spinlock)","Wikipedia Spinlock","Wikipedia article Spin lock","Wikipedia article Spinlock","Wikipedia article about spinlock","Wikipedia article about spinlocks","Wikipedia article on Spinlock","Wikipedia entry for Spinlock","Wikipedia l'articolo Spinlock","Wikipedia spinlock page","Wikipedia-Artikel Spinlock","Wikipedia-Seite zu 'Spinlock'","Wikipedia:Spinlock","WikipediaJにて","Wikipediaで「スピンロック」を調べる","Wirująca blokada","adalah spinlock","article Spinlock","article about spinlock alternatives","artículo de Wikipedia Spinlock","c'est un spinlock","en.wikipedia.org/wiki/Spinlock","er en Spinlock","es un spinlock","http://cs.wikipedia.org/wiki/Spinlock","http://de.wikipedia.org/wiki/Spinlock","http://en.Liarpedia.org/wiki/Freesurfer","http://en.wikipedia.org/wiki/Spin_lock","http://en.wikipedia.org/wiki/Spin_locking","http://en.wikipedia.org/wiki/Spinlock","http://en.wikipedia.org/wiki/Spinlock#Example_implementation","http://en.wikipedia.org/wiki/Spinlock(...)","http://es.wikipedia.org/wiki/Spinlock","http://fr.wikipedia.org/wiki/Spinlock","http://it.wikipedia.org/wiki/Spinlock","http://ja.wikipedia.org/wiki/スピンロック","http://ja.wikipedia.org/wiki/スピンロック#.E6.9C","http://nl.wikipedia.org/wiki/Busy_waiting","http://pl.wikipedia.org/wiki/Spinlock","http://ru.wikipedia.org/wiki/Spinlock","is a spinlock","is een spinlock","ist ein Spinlock","ja:スピンロック","je spinlock","jest spinlock","lt:Suktukinis rakinimas","là một spinlock","pl:Spinlock","ru:Spinlock","spin lock","spin locking","spin locks","spin loop","spin-lock","spin-lock.","spin-locks","spinlock","spinlock है","spinlocking","spinlockokat","spinlocks","spinlocków","spinlock는","wikipedia:スピンロック","è un spinlock","é um spinlock","Википедии статью Spinlock","блокировки","на сайте http://ru.wikipedia.org/wiki/Spinlock","спилок-блокировок","спин-блокировки","спин-блокировку.","спинлок-блокировок","спинлока","спинлоков с очередями","является блокировка","является блокировкой","หมุน-ล็อค.","เป็น spinlock","このようになる","ウィキペディア-スピンロック","ウィキペディアの記事 Spinlock","スピンロック","スピンロック - Wikipedia","スピンロックです","スピンロックは、","是自旋鎖","是自旋锁","自旋鎖","自旋锁","스핀 잠금을","）是一个自旋","ｽﾋﾟﾝﾛｯｸ-wikipedia"],"name":"Spinlock","categories":["All articles needing additional references","Articles needing additional references from October 2012","Concurrency control algorithms","Programming constructs"],"tag_line":"In software engineering, a spinlock is a lock which causes a thread trying to acquire it to simply wait in a loop (\"spin\") while repeatedly checking if the lock is available."}}
,{"_index":"throwtable","_type":"algorithm","_id":"spigot-algorithm","_score":0,"_source":{"description":"A spigot algorithm is an algorithm for computing the value of a mathematical constant such as π or e which generates output digits left to right, with limited intermediate storage.\nThe name comes from a \"spigot\", meaning a tap or valve controlling the flow of a liquid.\nInterest in such algorithms was spurred in the early days of computational mathematics by extreme constraints on memory, and an algorithm for calculating the digits of e appears in a paper by Sale in 1968. The name \"Spigot algorithm\" appears to have been coined by Stanley Rabinowitz and Stan Wagon, whose algorithm for calculating the digits of π is sometimes referred to as \"the spigot algorithm for π\".\nThe spigot algorithm of Rabinowitz and Wagon is bounded, in the sense that the number of required digits must be specified in advance. Jeremy Gibbons (2004)\nuses the term \"streaming algorithm\" to mean one which can be run indefinitely, without a prior bound. A further refinement is an algorithm which can compute a single arbitrary digit, without first computing the preceding digits: an example is the Bailey-Borwein-Plouffe formula, a digit extraction algorithm for π which produces hexadecimal digits.\n^ Sale, AHJ (1968). \"The calculation of e to many significant digits\". The Computer Journal 11 (2): 229–230. doi:10.1093/comjnl/11.2.229. Retrieved 8 May 2013. \n^ Rabinowitz, Stanley; Wagon, Stan (1995). \"A Spigot Algorithm for the Digits of Pi\" (PDF). American Mathematical Monthly 102 (3): 195–203. doi:10.2307/2975006. Retrieved 8 May 2013. \n^ Gibbons, Jeremy (24 May 2004). \"Unbounded Spigot Algorithms for the Digits of Pi\" (PDF).","alt_names":["-> Read the article about 'Spigot algorithm'","5e67f574a5563a23b0070a161987e5 ...","Spigot Algorithm","Spigot Algorithms","Spigot algorithm","Spigot algorithm - Wikipedia :: The free encyclopedia","Spigot algorithm - Wikipedia, the free encyclopedia","Spigot algorithm Wikipedia the free encyclopedia - result","Spigot algorithm: Example","Spigot 알고리즘","What is the example of Spigot Algorithms","Wikipedia article Spigot Algorithms","Wikipedia article Spigot algorithm","Wikipedia entry for Spigot algorithm","en.wikipedia.org/wiki/Spigot_algorithm","http://en.wikipedia.org/wiki/Spigot_algo","http://en.wikipedia.org/wiki/Spigot_algorithm","http://en.wikipedia.org/wiki/Spigot_algo…","ln ( 2 ) = ∑ k = 1 ∞ 1 k 2 k","spigot algorithm","spigot algorithms","spigot-algorithms","“spigot” algorithms","스피곳 알고리즘"],"name":"Spigot algorithm","categories":["Computer arithmetic algorithms"],"tag_line":"A spigot algorithm is an algorithm for computing the value of a mathematical constant such as π or e which generates output digits left to right, with limited intermediate storage."}}
,{"_index":"throwtable","_type":"algorithm","_id":"non-blocking-algorithm","_score":0,"_source":{"description":"In computer science, an algorithm is called non-blocking if failure or suspension of any thread cannot cause failure or suspension of another thread; for some operations, these algorithms provide a useful alternative to traditional blocking implementations. A non-blocking algorithm is lock-free if there is guaranteed system-wide progress, and wait-free if there is also guaranteed per-thread progress.\nThe word \"non-blocking\" was traditionally used to describe telecommunications networks that could route a connection through a set of relays \"without having to re-arrange existing calls\", see Clos network. Also, if the telephone exchange \"is not defective, it can always make the connection\", see Nonblocking minimal spanning switch.","alt_names":[],"name":"Non-blocking algorithm","categories":["All articles needing additional references","All articles needing style editing","All articles with unsourced statements","Articles needing additional references from August 2010","Articles with unsourced statements from June 2014","CS1 maint: Date and year","Concurrency control","Concurrency control algorithms","Synchronization","Wikipedia articles needing style editing from October 2012"],"tag_line":"In computer science, an algorithm is called non-blocking if failure or suspension of any thread cannot cause failure or suspension of another thread; for some operations, these algorithms provide a useful alternative to traditional blocking implementations."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bully-algorithm","_score":0,"_source":{"description":"The bully algorithm is a programming mechanism that applies a hierarchy to nodes on a system, making a process coordinator or slave. This is used as a method in distributed computing for dynamically electing a coordinator by process ID number. The process with the highest process ID number is selected as the coordinator.","alt_names":["...mehr auf Wikipedia über Bullyalgorithmus","...more on Wikipedia about Bully algorithm","Algoritmo dello spaccone","Bully Algorithm overview","Bully algorithm","Bully algorithm - Wikipedia, the free encyclopedia","Bullyalgorithmus","Bully算法","Wikipedia article ''Bully algorithm''","Wikipedia article Bully Algorithm","Wikipedia article Bully algorithm","Wikipedia article on Bully algorithm","Wikipedia entry for Bully algorithm","Wikipedia-Artikel Bullyalgorithmus","Wikipedia-Seite zu 'Bullyalgorithmus'","[2] Bully algorithm","algorytmu Bully","buddy-algorithm","bully algorithm","de:Bullyalgorithmus","en.wikipedia.org/...Bully_algorithm","http://de.wikipedia.org/wiki/Bullyalgorithmus","http://en.Liarpedia.org/wiki/Bully_algorithm","http://en.wikipedia.org/wiki/Bully_Algorithm","http://en.wikipedia.org/wiki/Bully_algorithm","http://en.wikipedia.org/wiki/Bully_algorithm.","http://it.wikipedia.org/wiki/Algoritmo_dello_spaccone","yago-res:Bully algorithm","élection de Bully","алгоритма Bully","实施欺负"],"name":"Bully algorithm","categories":["All Wikipedia articles needing clarification","All self-contradictory articles","Distributed algorithms","Self-contradictory articles from January 2015","Wikipedia articles needing clarification from January 2015"],"tag_line":"The bully algorithm is a programming mechanism that applies a hierarchy to nodes on a system, making a process coordinator or slave."}}
,{"_index":"throwtable","_type":"algorithm","_id":"chandra–toueg-consensus-algorithm","_score":0,"_source":{"description":"The Chandra–Toueg consensus algorithm, published by Tushar Deepak Chandra and Sam Toueg in 1996, is an algorithm for solving consensus in a network of unreliable processes equipped with an eventually strong failure detector. The failure detector is an abstract version of timeouts; it signals to each process when other processes may have crashed. An eventually strong failure detector is one that never identifies some specific good process as having failed after some initial period of confusion, and at the same time eventually identifies all bad processes as failed. The algorithm itself is similar to the Paxos algorithm, which also relies on failure detectors. Both algorithms assume the number of faulty processes is less than n/2, where n is the total number of processes.","alt_names":[],"name":"Chandra–Toueg consensus algorithm","categories":["All articles needing additional references","All articles needing style editing","Articles needing additional references from October 2011","Distributed algorithms","Fault-tolerant computer systems","Fault tolerance","Wikipedia articles needing style editing from October 2011"],"tag_line":"The Chandra–Toueg consensus algorithm, published by Tushar Deepak Chandra and Sam Toueg in 1996, is an algorithm for solving consensus in a network of unreliable processes equipped with an eventually strong failure detector."}}
,{"_index":"throwtable","_type":"algorithm","_id":"raft-(computer-science)","_score":0,"_source":{"description":"Raft is a consensus algorithm designed as an alternative to Paxos. It was meant to be more understandable than Paxos by means of separation of logic, but it is also formally proven safe and offers some new features. Raft offers a generic way to distribute a state machine across a cluster of computing systems, ensuring that each node in the cluster agrees upon the same series of state transitions. It has a number of open-source reference implementations, with full-spec implementations in Go, C++, Java, and Scala.","alt_names":[],"name":"Raft (computer science)","categories":["All stub articles","Computer science stubs","Distributed algorithms","Fault-tolerant computer systems"],"tag_line":"Raft is a consensus algorithm designed as an alternative to Paxos."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lamport's-distributed-mutual-exclusion-algorithm","_score":0,"_source":{"description":"Lamport's Distributed Mutual Exclusion Algorithm is a contention-based algorithm for mutual exclusion on a distributed system.","alt_names":[],"name":"Lamport's distributed mutual exclusion algorithm","categories":["All articles to be merged","All stub articles","Articles to be merged from October 2013","Computer science stubs","Concurrency control algorithms"],"tag_line":"Lamport's Distributed Mutual Exclusion Algorithm is a contention-based algorithm for mutual exclusion on a distributed system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dual-ec-drbg","_score":0,"_source":{"description":"Dual Elliptic Curve Deterministic Random Bit Generator (Dual_EC_DRBG) is an algorithm from the branch of cryptography known as elliptic curve cryptography that implements a cryptographically secure pseudorandom number generator (CSPRNG) capable of generating a random bit stream. The algorithm is based on the mathematics of the elliptic curve discrete logarithm problem (ECDLP). Despite public criticism, it was for some time one of the four (now three) CSPRNGs standardized in NIST SP 800-90A as originally published circa March 2007.\nWeaknesses in the cryptographic security of the algorithm were known and publicly criticised well before the algorithm became part of a formal standard endorsed by the ANSI, ISO, and formerly by the National Institute of Standards and Technology (NIST). One of the weaknesses publicly identified was the potential of the algorithm to harbour a backdoor advantageous to the algorithm's designers—the United States government's National Security Agency (NSA)—and no-one else. In 2013, the New York Times reported that documents in their possession but never released to the public \"appear to confirm\" that the backdoor was real, and had been deliberately inserted by the NSA as part of the NSA's Bullrun decryption program. In December 2013, a Reuters news article alleged that in 2004, before NIST standardized Dual_EC_DRBG, NSA paid RSA Security $10 million in a secret deal to use Dual_EC_DRBG as the default in the RSA BSAFE cryptography library, which resulted in RSA Security becoming the most important distributor of the insecure algorithm. RSA responded that they \"categorically deny\" that they had ever knowingly colluded with the NSA to adopt an algorithm that was known to be flawed, saying \"we have never kept [our] relationship [with the NSA] a secret\".\nSometime before its first known publication in 2004, a possible backdoor was discovered with the Dual_EC_DRBG's design, with the design of Dual_EC_DRBG having the unusual property that it was theoretically impossible for anyone but Dual_EC_DRBG's designers (NSA) to confirm the backdoor's existence. Bruce Schneier concluded shortly after standardization that the \"rather obvious\" backdoor (along with other deficiencies) would mean that nobody would use Dual_EC_DRBG. The backdoor would allow NSA to decrypt for example SSL/TLS encryption which used Dual_EC_DRBG as a CSPRNG.\nMembers of the ANSI standard group, to which Dual_EC_DRBG was first submitted, were aware of the exact mechanism of the potential backdoor and how to disable it, but did not take sufficient steps to unconditionally disable the backdoor or to widely publicize it. The general cryptographic community was initially not aware of the potential backdoor, until Dan Shumow and Niels Ferguson's publication, or of Certicom's Daniel R. L. Brown and Scott Vanstone's 2005 patent application describing the backdoor mechanism.\nIn September 2013, The New York Times reported that internal NSA memos leaked by Edward Snowden indicated that the NSA had worked during the standardization process to eventually become the sole editor of the Dual_EC_DRBG standard, and concluded that the Dual_EC_DRBG standard did indeed contain a backdoor for the NSA. As response, NIST stated that \"NIST would not deliberately weaken a cryptographic standard.\" According to the New York Times story, the NSA spends $250 million per year to insert backdoors in software and hardware as part of the Bullrun program. A Presidential advisory committee subsequently set up to examine NSA's conduct recommended among other things that the US government \"fully support and not undermine efforts to create encryption standards\".\nIn April 21, 2014, NIST withdrew Dual_EC_DRBG from its draft guidance on random number generators recommending \"current users of Dual_EC_DRBG transition to one of the three remaining approved algorithms as quickly as possible.\"\n^ \"Recommendations for Random Number Generation Using Deterministic Random Bit Generators (Revised)\" (PDF). National Institute of Standards and Technology. January 2012. NIST SP 800-90. \n^ \n^ \n^ \n^ \n^ \n^ \"Revealed: how US and UK spy agencies defeat internet privacy and security\". The Guardian. \n^ Perlroth, Nicole (September 10, 2013). \"Government Announces Steps to Restore Confidence on Encryption Standards\". The New York Times. Retrieved September 11, 2013. \n^ Cryptographic Standards Statement NIST 10 September 2013\n^ \"Secret Documents Reveal N.S.A. Campaign Against Encryption\". The New York Times. 5 September 2013. \n^ \n^ \"NIST Removes Cryptography Algorithm from Random Number Generator Recommendations\". National Institute of Standards and Technology. 21 April 2014.","alt_names":["- Dual EC DRBG :","Controversy around NSA random number generator","Dual EC DRBG","Dual EC DRBG - Wikipedia, the free encyclopedia","Dual Ec Drbg","Dual_EC_DRBG","Dual_EC_DRBG - Wikipedia, the free encyclopedia","Wikipedia article Dual EC DRBG","Wikipedia entry for Dual EC DRBG","en.wikipedia.org/wiki/Dual_EC_DRBG","http://en.wikipedia.org/wiki/Dual_EC_DRB","http://en.wikipedia.org/wiki/Dual_EC_DRBG","random number generator with a backdoor","ru:Dual_EC_DRBG","Википедии статью Dual EC DRBG"],"name":"Dual EC DRBG","categories":["Articles with underscores in the title","Broken cryptography algorithms","Conspiracy theories","Cryptographically secure pseudorandom number generators","Kleptography","National Institute of Standards and Technology","National Security Agency","Pseudorandom number generators"],"tag_line":"Dual Elliptic Curve Deterministic Random Bit Generator (Dual_EC_DRBG) is an algorithm from the branch of cryptography known as elliptic curve cryptography that implements a cryptographically secure pseudorandom number generator (CSPRNG) capable of generating a random bit stream."}}
,{"_index":"throwtable","_type":"algorithm","_id":"feedback-with-carry-shift-registers","_score":0,"_source":{"description":"In sequence design, a Feedback with Carry Shift Register (or FCSR) is the arithmetic or with carry analog of a Linear feedback shift register (LFSR). If  is an integer, then an N-ary FCSR of length  is a finite state device with a state  consisting of a vector of elements  in  and an integer . The state change operation is determined by a set of coefficients  and is defined as follows: compute . Express s as  with  in . Then the new state is . By iterating the state change an FCSR generates an infinite, eventually period sequence of numbers in .\nFCSRs have been used in the design of stream ciphers (such as the F-FCSR generator), in the cryptanalyis of the summation combiner stream cipher (the reason Goresky and Klapper invented them), and in generating pseudorandom numbers for quasi-Monte Carlo (under the name Multiply With Carry (MWC) generator - invented by Couture and L'Ecuyer,) generalizing work of Marsaglia and Zaman.\nFCSRs are analyzed using number theory. Associated with the FCSR is a connection integer . Associated with the output sequence is the N-adic number  The fundamental theorem of FCSRs says that there is an integer  so that , a rational number. The output sequence is strictly periodic if and only if  is between  and . It is possible to express u as a simple quadratic polynomial involving the initial state and the qi.\nThere is also an exponential representation of FCSRs: if  is the inverse of , and the output sequence is strictly periodic, then , where  is an integer. It follows that the period is at most the order of N in the multiplicative group of units modulo q. This is maximized when q is prime and N is a primitive element modulo q. In this case, the period is . In this case the output sequence is called an l-sequence (for \"long sequence\").\nl-sequences have many excellent statistical properties that make them candidates for use in applications, including near uniform distribution of sub-blocks, ideal arithmetic autocorrelations, and the arithmetic shift and add property. They are the with-carry analog of m-sequences or maximum length sequences.\nThere are efficient algorithms for FCSR synthesis. This is the problem: given a prefix of a sequence, construct a minimal length FCSR that outputs the sequence. This can be solved with a variant of Mahler and De Weger's lattice based analysis of N-adic numbers when ; by a variant of the Euclidean algorithm when N is prime; and in general by Xu's adaptation of the Berlekamp-Massey algorithm. If L is the size of the smallest FCSR that outputs the sequence (called the N-adic complexity of the sequence), then all these algorithms require a prefix of length about  to be successful and have quadratic time complexity. It follows that, as with LFSRs and linear complexity, any stream cipher whose N-adic complexity is low should not be used for cryptography.\nFCSRs and LFSRs are special cases of a very general algebraic construction of sequence generators called Algebraic Feedback Shift Registers (AFSRs) in which the integers are replaced by an arbitrary ring R and N is replaced by an arbitrary non-unit in R. A general reference on the subject of LFSRs, FCSRs, and AFSRs is the book.","alt_names":["Feedback with Carry Shift Register","Feedback with Carry Shift Registers","Feedback with Carry Shift Registers - Wikipedia, the free","Registri a scorrimento a retroazione con riporto","Wikipedia article Feedback with Carry Shift Registers","Wikipedia entry for Feedback with Carry Shift Registers","feedback with carry shift registers","http://en.wikipedia.org/wiki/Feedback_with_Carry_Shift_Registers","ru:Регистр сдвига с обратной связью по переносу","yago-res:Feedback with Carry Shift Registers","Википедии статью Feedback with carry shift register","Регистр сдвига с обратной связью по переносу"],"name":"Feedback with Carry Shift Registers","categories":["Cryptographic algorithms","Cryptography","Digital registers","Pseudorandom number generators","Stream ciphers"],"tag_line":"In sequence design, a Feedback with Carry Shift Register (or FCSR) is the arithmetic or with carry analog of a Linear feedback shift register (LFSR)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"affinity-propagation","_score":0,"_source":{"description":"In statistics and data mining, affinity propagation (AP) is a clustering algorithm based on the concept of \"message passing\" between data points. Unlike clustering algorithms such as k-means or k-medoids, AP does not require the number of clusters to be determined or estimated before running the algorithm. Like k-medoids, AP finds \"exemplars\", members of the input set that are representative of clusters.","alt_names":[],"name":"Affinity propagation","categories":["All stub articles","Computer science stubs","Data clustering algorithms"],"tag_line":"In statistics and data mining, affinity propagation (AP) is a clustering algorithm based on the concept of \"message passing\" between data points."}}
,{"_index":"throwtable","_type":"algorithm","_id":"statistical-classification","_score":0,"_source":{"description":"In machine learning and statistics, classification is the problem of identifying to which of a set of categories (sub-populations) a new observation belongs, on the basis of a training set of data containing observations (or instances) whose category membership is known. An example would be assigning a given email into \"spam\" or \"non-spam\" classes or assigning a diagnosis to a given patient as described by observed characteristics of the patient (gender, blood pressure, presence or absence of certain symptoms, etc.).\nIn the terminology of machine learning, classification is considered an instance of supervised learning, i.e. learning where a training set of correctly identified observations is available. The corresponding unsupervised procedure is known as clustering, and involves grouping data into categories based on some measure of inherent similarity or distance.\nOften, the individual observations are analyzed into a set of quantifiable properties, known variously as explanatory variables or features. These properties may variously be categorical (e.g. \"A\", \"B\", \"AB\" or \"O\", for blood type), ordinal (e.g. \"large\", \"medium\" or \"small\"), integer-valued (e.g. the number of occurrences of a part word in an email) or real-valued (e.g. a measurement of blood pressure). Other classifiers work by comparing observations to previous observations by means of a similarity or distance function.\nAn algorithm that implements classification, especially in a concrete implementation, is known as a classifier. The term \"classifier\" sometimes also refers to the mathematical function, implemented by a classification algorithm, that maps input data to a category.\nTerminology across fields is quite varied. In statistics, where classification is often done with logistic regression or a similar procedure, the properties of observations are termed explanatory variables (or independent variables, regressors, etc.), and the categories to be predicted are known as outcomes, which are considered to be possible values of the dependent variable. In machine learning, the observations are often known as instances, the explanatory variables are termed features (grouped into a feature vector), and the possible categories to be predicted are classes. There is also some argument over whether classification methods that do not involve a statistical model can be considered \"statistical\". Other fields may use different terminology: e.g. in community ecology, the term \"classification\" normally refers to cluster analysis, i.e. a type of unsupervised learning, rather than the supervised learning described in this article.","alt_names":["classifieurs","decision model","classificatio","aprendizaje supervisado","classificatore","Classification rule - Wikipedia, the free encyclopedia","Klassifikationsverfahren","Klassifikator","Statistical classification","- Classification (machine learning) :","- Statistical classification :","...Wikipedia Klassificerare","...mehr auf Wikipedia über Klassifikationsverfahren","...more on Wikipedia about Classifier (mathematics)","...more on Wikipedia about Statistical classification","Again, wikipedia is a good (classifiers)","Aprendizaje Bayesiano","Aprendizaje y Minería de datos","Clasificadores (matem?tico) - Wikipedia, la enciclopedia libre","Clasificadores (matemático)","Clasificadores (matemático) - Wikipedia, la enciclopedia libre","Classification (Machine Learning)","Classification (machine learning) - Wikipedia, the free ...","Classification (machine learning) - Wikipedia, the free encyclopedia","Classification (machine learning) - Wikipedia, the free encyclopedia ...","Classification automatique","Classification automatique - Wikip?dia","Classification automatique - Wikipédia","Classification on Wikipedia","Classification_(machine_learning)","Classificatore","Classificatore - Wikipedia","Classificatori","Classifier (machine learning)","Classifier (mathematics)","Classifier (mathematics) - Wikipedia, the free encyclopedia","Classifier (mathematics) - Wikipedia, the free encyclopedia ...","Classifier (mathematics); it is used under the","Classifier mathematics","Classifier_(mathematics)","Classifiers and no free lunch theorem","Classifying dat","Classifying data","Klasifikacioni modeli","Klasifikavimo algoritmai","Klassificerare","Klassifikationsverfahren - Wikipedia","Klassifikationsverfahren ? Wikipedia","Klassifikationsverfahren in","Klassifikationsverfahren – Wikipedia","Klassifikator ? Wikipedia","Klassifikator – Wikipedia","Klassifikatoren","Lexikon: Klassifikator - ComputerBase","Luokitin","Luokitin – Wikipedia","P ( class | x &rightarrow; ) = f x &rightarrow; ; θ","P ( x &rightarrow; | class )","Pengelasan statistik","Pengelasan statistik - Wikipedia Bahasa Melayu, ensiklopedia bebas","Phân loại (toán học)","Phân loại bằng thống kê","Phân loại bằng thống kê - Wikipedia tiếng Việt","Phân loại bằng thống kê – Wikipedia tiếng Việt","Sichter","Statistic classifications","Statistical Classification","Statistical Pattern Classification","Statistical classification (machine learning)","Statistical classification (machine learning) - Wikipedia ...","Statistical classification (machine learning) - Wikipedia :: The free encyclopedia","Statistical classification (machine learning) - Wikipedia, the ...","Statistical classification (machine learning) - Wikipedia, the free encyclopedia","Statistical classification (machine learning); it is used under","Statistical classification - Wikipedia, the free encyclopedi...","Statistical classification - Wikipedia, the free encyclopedia","Statistical classification by Wikipedia","Statistical classification; it is used under the","Statistical_classification","Statisticalclassification","Stochastic discrimination","Sök Klassifikation på Wikipedia Sverige","Sök klassifikation på Wikipedia Sverige","Tipos de clasificadores","UclassificationU","View Classifier (mathematics) on Wikipedia","What are algorithms of Statistical classification","Wikipedia - 'Statistical Classification'","Wikipedia : 統計分類","Wikipedia article Clasificadores (matemático)","Wikipedia article Classification (machine learning)","Wikipedia article Classifier (mathematics)","Wikipedia article Klasigilo (matematiko)","Wikipedia article on Classifier (mathematics)","Wikipedia article on Statistical classification","Wikipedia article on Statistical classification (machine learning)","Wikipedia article on statistical classification","Wikipedia article تصنيف إحصائي","Wikipedia article شناساگر (ریاضیات)","Wikipedia article การแบ่งประเภทข้อมูล","Wikipedia entry for Classification (machine learning)","Wikipedia entry for Classifier (mathematics)","Wikipedia entry for Statistical classification","Wikipedia-Artikel Klassifikationsverfahren","Wikipedia-Artikel Klassifikator","Wikipedia-Seite zu 'Klassifikationsverfahren'","Wikipedia-Seite zu 'Klassifikator'","Wikipedia:Statistical_classification","Wikipediaで「統計分類」を調べる","Wikipediaで「統計的識別」を調べる","[32] Statistical classification","ar:تصنيف إحصائي","artículo de Wikipedia Clasificadores (matemático)","assification","assification,","bộ phân loại","classement statistique","classer les données","classifer","classificador","classificadores","classification (machine learning)","classification algorithm","classification algorithms","classification automatique","classification function","classification learning","classification model","classification statistique","classification tasks","classifications automatiques","classifier (mathematics)","classifieu","classifieur","computer classifier","cuando clasificamos","de Wikipedia-pagina voor statistische classificatie","de Wikipedia-side for statistiske nomenklatur","de:Klassifikationsverfahren","discriminative methods","en.wikipedia.org/...Statistical_classification","en.wikipedia.org/...ssification_(machine_learning)","en.wikipedia.org/wiki/Statistical_classification","en:Classification (machine learning)","en:Classifier (mathematics)","en:Statistical classification","en:Statistical classification (machine learning)","fa:شناساگر (ریاضیات)","feature classification","http://ca.wikipedia.org/wiki/Classificador_(matem%C3","http://de.wikipedia.org/wiki/Klassi","http://de.wikipedia.org/wiki/Klassifikationsv...","http://de.wikipedia.org/wiki/Klassifikationsverfahren","http://de.wikipedia.org/wiki/Klassifikator","http://en.Liarpedia.org/wiki/Statistical_classification","http://en.wikipedia.org/wiki/Classif...cs)#Algorithms","http://en.wikipedia.org/wiki/Classification_%28machine_learning%29","http://en.wikipedia.org/wiki/Classification_(machine_learning)","http://en.wikipedia.org/wiki/Classifier_%28mathematics%29","http://en.wikipedia.org/wiki/Classifier_(mathematic","http://en.wikipedia.org/wiki/Classifier_(mathematics)","http://en.wikipedia.org/wiki/Statistical_clas...","http://en.wikipedia.org/wiki/Statistical_classification","http://en.wikipedia.org/wiki/Statistical_classification_%28machine_learning%29","http://en.wikipedia.org/wiki/Statistical_classification_(machine_learning)","http://en.wikipedia.org/wiki/Statistical_classificationを","http://eo.wikipedia.org/wiki/Klasigilo_%28matematiko%29","http://es.wikipedia.org/wiki/Clasificadores_(matem%C3","http://fr.wikipedia.org/wiki/Classification_automatique","http://it.wikipedia.org/wiki/Classificatore","http://sv.wikipedia.org/wiki/Klassificerare","iltre bayésie","ja:統計分類","klasifikacia","klasifikačné metódy","klassificerare","l'article de Wikipédia Classification automatique","la pagina di Wikipedia per Classificazione statistica","la página de Wikipedia para la Clasificación Estadística","lassificatio","lassification,","lassification:","lassifikationsverfahren","learning classifiers","lt:Klasifikavimo algoritmai","luokittelijat","luokittelua","mathematical classifiers","more advanced classifiers","ms:Pengelasan statistik","na stronie Wikipedii Statystycznej Klasyfikacji","neural classifier","p://en.wikipedia.org/wiki/Statistical_classification","prediction of the class","ru.wikipedia.org/wiki/Классификация_(задача)","ru:Задача классификации","statistical classification","statistical classification wikipedia the free encyclopedia","statistical classifier","statistical classifiers","statistical-classification","th:การแบ่งประเภทข้อมูล","the Wikipedia page for Statistical Classification","ttp://en.wikipedia.org/wiki/Statistical_","vi:Phân loại bằng thống kê","w:Задача классификации","wikipedia:Classification (machine learning)","wikipedia:Statistical classification","ØªØµÙ†ÙŠÙ Ø¥ØØµØ§Ø¦ÙŠ","Википедии статью Задача классификации","Википедии статью Классификация (задача)","Задача классификации","задач классификации","задачи классификации","задачу классификации","классификации объектов","проблеме классификации","страницу Википедии для статистической классификации","تصنيف إحصائي","شناساگر (ریاضیات) - ویکیپدیا","การจำแนกประเภทข้อมูล","การแบ่งประเภท","การแบ่งประเภทข้อมูล","การแบ่งประเภทข้อมูล - วิกิพีเดีย","ลักษณนาม","統計分類","統計分類 - Wikipedia","統計分類-wikipedia","統計的分類のためのWikipediaのページは","統計的識別-wikipedia","維基百科～Statistical_classification"],"name":"Statistical classification","categories":["All articles lacking in-text citations","All articles with unsourced statements","All pages needing cleanup","Articles lacking in-text citations from January 2010","Articles needing cleanup from May 2012","Articles with sections that need to be turned into prose from May 2012","Articles with unsourced statements from August 2014","Classification algorithms","Machine learning","Statistical classification"],"tag_line":"In machine learning and statistics, classification is the problem of identifying to which of a set of categories (sub-populations) a new observation belongs, on the basis of a training set of data containing observations (or instances) whose category membership is known."}}
,{"_index":"throwtable","_type":"algorithm","_id":"k-medoids","_score":0,"_source":{"description":"The k-medoids algorithm is a clustering algorithm related to the k-means algorithm and the medoidshift algorithm. Both the k-means and k-medoids algorithms are partitional (breaking the dataset up into groups) and both attempt to minimize the distance between points labeled to be in a cluster and a point designated as the center of that cluster. In contrast to the k-means algorithm, k-medoids chooses datapoints as centers (medoids or exemplars) and works with an arbitrary matrix of distances between datapoints instead of . This method was proposed in 1987 for the work with  norm and other distances.\nk-medoid is a classical partitioning technique of clustering that clusters the data set of n objects into k clusters known a priori. A useful tool for determining k is the silhouette.\nIt is more robust to noise and outliers as compared to k-means because it minimizes a sum of pairwise dissimilarities instead of a sum of squared Euclidean distances.\nA medoid can be defined as the object of a cluster whose average dissimilarity to all the objects in the cluster is minimal. i.e. it is a most centrally located point in the cluster.","alt_names":["- K-medians clustering :","Algorisme K-medoids","Algoritmo K-medoids","Algoritmo k-medoids","K - Medoids","K medoids","K-Medoids","K-median problem","K-medians","K-medians clustering","K-medians clustering by Wikipedia","K-medians_clustering","K-medioids","K-medoid","K-medoids","K-medoids - Wikipedia","K-medoids - Wikipédia","K-medoids by Wikipedia","K-medoids |","Learning Algorithm","Partitioning Around Medoids","Wikipedia article K-median problem","Wikipedia article K-medians","Wikipedia article K-medians clustering","Wikipedia article K-medoid","Wikipedia article K-medoids","Wikipedia article Partitioning Around Medoids","Wikipedia article k-medoids","Wikipedia article on K-medoid","Wikipedia entry for K-medoids","Wikipedia l'articolo K-medoids","algorytm K-Medoids","cost ( x , c ) = ∑ i = 1 d | x - c","en.wikipedia.org/K-medoids","figure 1 2 clusters after step 1","fr:K-medoids","http://en.wikipedia.org/wiki/K-medians_clustering","http://en.wikipedia.org/wiki/K-medoids","http://en.wikipedia.org/wiki/K-medoidsを","http://en.wikipedia.org/wiki/K−medoids","http://en.wikipedia.org/wiki/Partitioning_...","http://en.wikipedia.org/wiki/Partitioning_Around_Medoids","http://it.wikipedia.org/wiki/K-medoids","it:K-medoids","k -medoids","k-median","k-median problem","k-medians","k-medians clustering","k-medians clustering - Wikipedia, the free encyclopedia","k-medians clustering - Wikipedia, the free encyclopedia ...","k-medoid","k-medoid clustering","k-medoids","k-medoids - Wikipedia, the free encyclopedia","k-medoids algorithm","k-medoids clustering algorithm","kmedoids","のK - Medoids","的K -中心点","的K -中心點","한국 Medoids"],"name":"K-medoids","categories":["All articles needing style editing","All articles with unsourced statements","Articles with unsourced statements from May 2015","Data clustering algorithms","Statistical algorithms","Wikipedia articles needing style editing from September 2015"],"tag_line":"The k-medoids algorithm is a clustering algorithm related to the k-means algorithm and the medoidshift algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dbscan","_score":0,"_source":{"description":"Density-based spatial clustering of applications with noise (DBSCAN) is a data clustering algorithm proposed by Martin Ester, Hans-Peter Kriegel, Jörg Sander and Xiaowei Xu in 1996. It is a density-based clustering algorithm: given a set of points in some space, it groups together points that are closely packed together (points with many nearby neighbors), marking as outliers points that lie alone in low-density regions (whose nearest neighbors are too far away). DBSCAN is one of the most common clustering algorithms and also most cited in scientific literature.\nIn 2014, the algorithm was awarded the test of time award (an award given to algorithms which have received substantial attention in theory and practice) at the leading data mining conference, KDD.","alt_names":["DBSCAN","DBSCAN - Wikipedia","DBSCAN - Wikipedia, the free encyclopedia","DBSCAN - Wikipedia, the free encyclopedia wikipedia.org DBSCAN","DBSCAN Clustering Algorithm","DBSCAN Wikipedia page","DBSCAN algorithm","DBSCAN by Wikipedia","DBSCAN |","DBSCAN – Wikipedia","DBSCAN-Algorithmus","DBScan","DBScan algorithm","DBscan","Dbscan","Nearest Neighborhood Detection","What are advantages of DBSCAN","Wikipedia article DBSCAN","Wikipedia entry for DBSCAN","Wikipedia l'articolo Dbscan","Wikipedia-Seite zu 'DBSCAN'","Wikipedia:DBSCAN","algorithm called DBSCAN","algorytm DBScan","dbscan wikipedia the encyclopedia","de:DBSCAN","density-based spatial clustering of applications with noise","en.wikipedia.org/wiki/DBSCAN","en:DBSCAN","http://de.wikipedia.org/wiki/DBSCAN","http://de.wikipedia.org/wiki/DBSCAN#DBSCAN-Algorithmus","http://en.wikipedia.org/wiki/DBSCAN","http://en.wikipedia.org/wiki/DBSCAN#Advantages","http://en.wikipedia.org/wiki/DBSCAN#Disadvantages","http://it.wikipedia.org/wiki/Dbscan","o DBSCAN,","yago-res:DBSCAN","| DBSCAN"],"name":"DBSCAN","categories":["Data clustering algorithms"],"tag_line":"Density-based spatial clustering of applications with noise (DBSCAN) is a data clustering algorithm proposed by Martin Ester, Hans-Peter Kriegel, Jörg Sander and Xiaowei Xu in 1996."}}
,{"_index":"throwtable","_type":"algorithm","_id":"optics-algorithm","_score":0,"_source":{"description":"Ordering points to identify the clustering structure (OPTICS) is an algorithm for finding density-based clusters in spatial data. It was presented by Mihael Ankerst, Markus M. Breunig, Hans-Peter Kriegel and Jörg Sander. Its basic idea is similar to DBSCAN, but it addresses one of DBSCAN's major weaknesses: the problem of detecting meaningful clusters in data of varying density. In order to do so, the points of the database are (linearly) ordered such that points which are spatially closest become neighbors in the ordering. Additionally, a special distance is stored for each point that represents the density that needs to be accepted for a cluster in order to have both points belong to the same cluster. This is represented as a dendrogram.","alt_names":["OPTICS","3 Extracting the Clusters","Extracting the Clusters","Learn about OPTICS algorithm>>>","OPTICS - Wikipedia","OPTICS Algorithm - Wikipedia, The Free Encyclopedia","OPTICS algorithm","OPTICS algorithm - Wikipedia, the free encyclopedia","OPTICS algorithm by Wikipedia","OPTICS algorithm from Wikipedia","OPTICS in Wikipedia","OPTICS – Wikipedia","Wikipedia article OPTICS algorithm","Wikipedia entry for OPTICS algorithm","Wikipedia-Seite zu 'OPTICS'","Wikipediaドイツ版 - Optics","de:OPTICS","en:OPTICS_algorithm","http://de.wikipedia.org/wiki/OPTICS","http://en.wikipedia.org/wiki/OPTICS","http://en.wikipedia.org/wiki/OPTICS_algorithm"],"name":"OPTICS algorithm","categories":["Articles with specifically marked weasel-worded phrases from October 2014","Data clustering algorithms"],"tag_line":"Ordering points to identify the clustering structure (OPTICS) is an algorithm for finding density-based clusters in spatial data."}}
,{"_index":"throwtable","_type":"algorithm","_id":"flame-clustering","_score":0,"_source":{"description":"Fuzzy clustering by Local Approximation of MEmberships (FLAME) is a data clustering algorithm that defines clusters in the dense parts of a dataset and performs cluster assignment solely based on the neighborhood relationships among objects. The key feature of this algorithm is that the neighborhood relationships among neighboring objects in the feature space are used to constrain the memberships of neighboring objects in the fuzzy membership space.","alt_names":["- FLAME Absorption :","A simple illustration on a 2D testing dataset","Description of the FLAME algorithm","FLAME Clustering","FLAME clustering","FLAME clustering - Wikipedia, the free encyclopedia","FLAME clustering algorithm","FLAME clustering by Wikipedia","FLAME clustering from Wikipedia","FLAME clustering; it is used under the","The optimization problem in FLAME","Wikipedia article FLAME Clustering","Wikipedia article FLAME clustering","Wikipedia entry for FLAME clustering","http://en.wikipedia.org/wiki/FLAME_Clustering","http://en.wikipedia.org/wiki/FLAME_clust","http://en.wikipedia.org/wiki/FLAME_clustering","yago-res:FLAME clustering"],"name":"FLAME clustering","categories":["Data clustering algorithms","Wikipedia articles with possible conflicts of interest from August 2010"],"tag_line":"Fuzzy clustering by Local Approximation of MEmberships (FLAME) is a data clustering algorithm that defines clusters in the dense parts of a dataset and performs cluster assignment solely based on the neighborhood relationships among objects."}}
,{"_index":"throwtable","_type":"algorithm","_id":"expectation–maximization-algorithm","_score":0,"_source":{"description":"In statistics, an expectation–maximization (EM) algorithm is an iterative method for finding maximum likelihood or maximum a posteriori (MAP) estimates of parameters in statistical models, where the model depends on unobserved latent variables. The EM iteration alternates between performing an expectation (E) step, which creates a function for the expectation of the log-likelihood evaluated using the current estimate for the parameters, and a maximization (M) step, which computes parameters maximizing the expected log-likelihood found on the E step. These parameter-estimates are then used to determine the distribution of the latent variables in the next E step.","alt_names":[],"name":"Expectation–maximization algorithm","categories":["Data clustering algorithms","Estimation theory","Machine learning algorithms","Missing data","Optimization algorithms and methods","Statistical algorithms"],"tag_line":"In statistics, an expectation–maximization (EM) algorithm is an iterative method for finding maximum likelihood or maximum a posteriori (MAP) estimates of parameters in statistical models, where the model depends on unobserved latent variables."}}
,{"_index":"throwtable","_type":"algorithm","_id":"k-svd","_score":0,"_source":{"description":"In applied mathematics, K-SVD is a dictionary learning algorithm for creating a dictionary for sparse representations, via a singular value decomposition approach. K-SVD is a generalization of the k-means clustering method, and it works by iteratively alternating between sparse coding the input data based on the current dictionary, and updating the atoms in the dictionary to better fit the data. K-SVD can be found widely in use in applications such as image processing, audio processing, biology, and document analysis.","alt_names":[],"name":"K-SVD","categories":["All articles lacking reliable references","All articles with close paraphrasing","All pages needing cleanup","Articles lacking reliable references from May 2014","Articles needing cleanup from May 2014","Articles with close paraphrasing from May 2014","Data clustering algorithms","Linear algebra","Norms (mathematics)"],"tag_line":"In applied mathematics, K-SVD is a dictionary learning algorithm for creating a dictionary for sparse representations, via a singular value decomposition approach."}}
,{"_index":"throwtable","_type":"algorithm","_id":"k-means++","_score":0,"_source":{"description":"In data mining, k-means++ is an algorithm for choosing the initial values (or \"seeds\") for the k-means clustering algorithm. It was proposed in 2007 by David Arthur and Sergei Vassilvitskii, as an approximation algorithm for the NP-hard k-means problem—a way of avoiding the sometimes poor clusterings found by the standard k-means algorithm. It is similar to the first of three seeding methods proposed, in independent work, in 2006 by Rafail Ostrovsky, Yuval Rabani, Leonard Schulman and Chaitanya Swamy. (The distribution of the first seed is different.)","alt_names":[],"name":"K-means++","categories":["All articles with dead external links","Articles with dead external links from May 2013","Data clustering algorithms","Statistical algorithms"],"tag_line":"In data mining, k-means++ is an algorithm for choosing the initial values (or \"seeds\") for the k-means clustering algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fsa-red-algorithm","_score":0,"_source":{"description":"FSA-Red Algorithm is an algorithm for data reduction which is suitable to build strong association rule using data mining method such as Apriori algorithm.","alt_names":[],"name":"FSA-Red Algorithm","categories":["Data analysis","Data mining algorithms","Formal sciences"],"tag_line":"FSA-Red Algorithm is an algorithm for data reduction which is suitable to build strong association rule using data mining method such as Apriori algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"goertzel-algorithm","_score":0,"_source":{"description":"The Goertzel algorithm is a Digital Signal Processing (DSP) technique that provides a means for efficient evaluation of individual terms of the Discrete Fourier Transform (DFT), thus making it useful in certain practical applications, such as recognition of DTMF tones produced by the buttons pushed on a telephone keypad. The algorithm was first described by Gerald Goertzel in 1958.\nLike the DFT, the Goertzel algorithm analyses one selectable frequency component from a discrete signal. Unlike direct DFT calculations, the Goertzel algorithm applies a single real-valued coefficient at each iteration, using real-valued arithmetic for real-valued input sequences. For covering a full spectrum, the Goertzel algorithm has a higher order of complexity than Fast Fourier Transform (FFT) algorithms; but for computing a small number of selected frequency components, it is more numerically efficient. The simple structure of the Goertzel algorithm makes it well suited to small processors and embedded applications, though not limited to these.\nThe Goertzel algorithm can also be used \"in reverse\" as a sinusoid synthesis function, which requires only 1 multiplication and 1 subtraction per generated sample.","alt_names":["http://en.wikipedia.org/wiki/Goe...","- Goertzel algorithm :","...Wikipedia Algoritmo di Goertzel","...more on Wikipedia about Goertzel algorithm",".http://en.wikipedia.org/wiki/Goertzel_algorithm","1 Explanation of algorithm","4 Sample code for a DTMF detector","Algoritmo Goertzel di","Algoritmo di Goertzel","Algorytm Goertzla – Wikipedia, wolna encyklopedia","Explanation of algorithm","Goertzel - Algorithmus","Goertzel Aglorithmus","Goertzel Algorithm","Goertzel algorithm","Goertzel algorithm (seeWikipedia)","Goertzel algorithm - Wikipedia :: The free encyclopedia","Goertzel algorithm - Wikipedia, the free encyclopedia","Goertzel algorithm – Wikipedia, the free encyclopedia","Goertzel algoritme","Goertzel filter algorithm","Goertzel het algoritme","Goertzel info","Goertzel ของ ขั้น ตอน วิธี","Goertzel 알고리즘","Goertzel's Algorithm","Goertzel's algorithm","Goertzel-Algorithm","Goertzel-Algorithmus","Goertzel-Algorithmus – Wikipedia","Goertzel-algoritmen","Goertzel_algorithm","Goertzels algorithm","Goertzelのアルゴリズム","Goertzel의 알고리즘은","Goetzel","Gortzel","Gortzel algorithm","Görtzel-Algorithmus","Informacje na temat szybkiego algorytmu detekcji częstotliwości na","Learn about Goertzel algorithm>>>","S ( z ) X ( z ) = 1 1 - 2 cos","Sample code for a DTMF detector","Thuật toán Goertzel của","Wikipedia (Goertzel algorithm)","Wikipedia article Algorytm Goertzla","Wikipedia article Goertzel algorithm","Wikipedia entry for Goertzel algorithm","Wikipedia-Artikel Goertzel-Algorithmus","algorithme de Goertzel de","algoritmo Goertzel de","algoritmo de Goertzel","algoritmo de goertzel","algoritmo del Goertzel","algoritmo di Goertzel","algorytm Goertzla","en.wikipedia.org/wiki/Goertzel_algorithm","goertzel","goertzel algorithm","goertzelはのアルゴリズムを","http://de.wikipedia.org/wiki/Goertzel-Al","http://de.wikipedia.org/wiki/Goertzel-Algorithmus","http://en.wikipedia....a_DTMF_detector","http://en.wikipedia....rtzel_algorithm","http://en.wikipedia.org/wiki/Goertzel_al","http://en.wikipedia.org/wiki/Goertzel_algo...a_DTMF_detector","http://en.wikipedia.org/wiki/Goertzel_algorit...","http://en.wikipedia.org/wiki/Goertzel_algorithm","http://en.wikipedia.org/wiki/Goertzel_algorithm.","http://en.wikipedia.org/wiki/Goertzel_al…","http://it.wikipedia.org/wiki/Algoritmo_di_Goertzel","http://pl.wikipedia.org/wiki/Algorytm_Goertzla","l'algorithme de Goertzel","of Gertselja","the Goertzel algorithm","tp://en.wikipedia.org/wiki/Goertzel_algorithm","w Algorithm Goertzel","Алгоритм Герцеля","Алгоритм Горцеля","Алгоритм Гёрцеля","алгорим Герцеля","алгоритм Гертцеля","алгоритм Герцеля's","фильтр Герцеля (Goertzel)","אלגוריתם גרצל","אלגוריתם גרצל – ויקיפדיה","גרצל","ויקיפדיה - 'אלגוריתם גרצל'","格策尔的算法","格策爾的算法"],"name":"Goertzel algorithm","categories":["All articles needing additional references","All articles needing cleanup","All articles with specifically marked weasel-worded phrases","All articles with unsourced statements","Articles needing additional references from February 2014","Articles needing cleanup from February 2014","Articles with specifically marked weasel-worded phrases from February 2014","Articles with unsourced statements from February 2014","CS1 errors: external links","Cleanup tagged articles with a reason field from February 2014","Digital signal processing","FFT algorithms","Pages using citations with accessdate and no URL","Pages using web citations with no URL","Wikipedia pages needing cleanup from February 2014"],"tag_line":"The Goertzel algorithm is a Digital Signal Processing (DSP) technique that provides a means for efficient evaluation of individual terms of the Discrete Fourier Transform (DFT), thus making it useful in certain practical applications, such as recognition of DTMF tones produced by the buttons pushed on a telephone keypad."}}
,{"_index":"throwtable","_type":"algorithm","_id":"random-forest","_score":0,"_source":{"description":"Random forests is a notion of the general technique of random decision forests that are an ensemble learning method for classification, regression and other tasks, that operate by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees. Random decision forests correct for decision trees' habit of overfitting to their training set.\nThe algorithm for inducing Breiman's random forest was developed by Leo Breiman and Adele Cutler, and \"Random Forests\" is their trademark. The method combines Breiman's \"bagging\" idea and the random selection of features, introduced independently by Ho and Amit and Geman in order to construct a collection of decision trees with controlled variance.\nThe selection of a random subset of features is an example of the random subspace method, which, in Ho's formulation, is a way to implement the \"stochastic discrimination\" approach to classification proposed by Eugene Kleinberg.","alt_names":["- Random forest :","- Random forests :","...more on Wikipedia about Random forest","A related method","Features and Advantages","Forêt d'arbres décisionnels","Forêt d'arbres décisionnels - Wikipédia","Forêt d`arbres décisionnels","Random Bos","Random Decision","Random Forest","Random Forest ? Wikipedia","Random Forest method","Random Forest – Wikipedia","Random Forests","Random forest","Random forest - Wikipedia","Random forest - Wikipedia, the free encyclopedia","Random forest Wikipedia the free encyclopedia","Random forest by Wikipedia","Random forest classifier","Random forest.","Random forest; it is used under the","Random foreste","Random forests","Random forests; it is used under the","Random forrest","Random subspace methods","Random_Forest","Random_forest","Random_forest-wikipedia","Randomized Bossen","Randomized Forests","Read More About random forest wikipedia the free","What are the disadvantages of Random forest","Wiki for Random Forest","Wikipedia article ''Random forest''","Wikipedia article Random forest","Wikipedia article Random forests","Wikipedia article about random forest","Wikipedia article on Random Forests","Wikipedia article on Random forest","Wikipedia article on Random forests","Wikipedia entry for Random forest","Wikipedia-Artikel Random Forest","Wikipedia-Seite zu 'Random Forest'","Wikipedia:Random_forest","[10] Random forest","al azar de bosque","de:Random Forest","decision forests","e random fores","en.wikipedia.org/...Random_forests","en.wikipedia.org/wiki/Random_forest","en.wikipedia.org/wiki/Random_forest#Disadvantages","en.wikipedia.org/wiki/Random_forests","foreste casuali","foreste randomizzati","forests of random decision trees","http://de.wikipedia.org/wiki/Random_Forest","http://en.wikipedia.org/wiki/Random_fore","http://en.wikipedia.org/wiki/Random_forest","http://en.wikipedia.org/wiki/Random_forest (Retrieved on","http://en.wikipedia.org/wiki/Random_forests","http://en.wikipedia.org/wiki/Random_fores…","http://ja.wikipedia.org/wiki/Random_forest","http://ru.wikipedia....i/Random_forest","ja:Random forest","lasy losowe","los bosques aleatorios","náhodné lesa","random forest","random forest walk","random forests","randomizované Lesy","randomizowane Lasy","ru:Random forest","see also Wikipedia page","simple:Random forest","tilfældige skove","willekeurige bossen","zh:随机森林","Рандомизированные Леса","ансамбль деревьев","ансамбль деревьев решений (Random Forest)","случайного леса","случайные леса","случайные леса,","случайный лес","ランダムフォレスト","無作為化森林は","随机森林","隨機森林"],"name":"Random forest","categories":["All articles to be merged","All articles with unsourced statements","Articles to be merged from May 2015","Articles with unsourced statements from June 2015","CS1 errors: invisible characters","Classification algorithms","Decision trees","Ensemble learning","Pages using duplicate arguments in template calls"],"tag_line":"Random forests is a notion of the general technique of random decision forests that are an ensemble learning method for classification, regression and other tasks, that operate by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sort-merge-join","_score":0,"_source":{"description":"The sort-merge join (also known as merge join) is a join algorithm and is used in the implementation of a relational database management system.\nThe basic problem of a join algorithm is to find, for each distinct value of the join attribute, the set of tuples in each relation which display that value. The key idea of the Sort-merge algorithm is to first sort the relations by the join attribute, so that interleaved linear scans will encounter these sets at the same time.\nIn practice, the most expensive part of performing a sort-merge join is arranging for both inputs to the algorithm to be presented in sorted order. This can be achieved via an explicit sort operation (often an external sort), or by taking advantage of a pre-existing ordering in one or both of the join relations. The latter condition can occur because an input to the join might be produced by an index scan of a tree-based index, another merge join, or some other plan operator that happens to produce output sorted on an appropriate key.\nLet's say that we have two relations  and  and .  fits in  pages memory and  fits in  pages memory. So, in the worst case Sort-Merge Join will run in  I/Os. In the case that  and  are not ordered the worst case time cost will contain additional terms of sorting time: , which equals  (as linearithmic terms outweigh the linear terms, see Big O notation – Orders of common functions).\n\n","alt_names":["sort merge","MERGE JOIN","Merge Join","Merge Join (Wikipedia)","Merge Joins","Merge join","SORT-Sloučit","Self-merge join","Sort Merge","Sort Merge Join","Sort merge join","Sort-Flet","Sort-Fusionar","Sort-Merge","Sort-Merge Join","Sort-Merge-Join","Sort-combinación de mezcla","Sort-merge join","Sort-merge join - Wikipedia, the ...","Sort-merge join - Wikipedia, the free encyclopedia","Sort-merge join - Wikipedia, the free encyclopedia - Vimperator","Sort-merge join - Wikipedia, the free encyclopedia ...","Sort-merge join: Pseudocode","Sort-merge_join","Sorteer-merge sluiten","Sortmerge join","Sortuj seryjnej dołączyć","Wikipedia article Merge join","Wikipedia article Sort-merge join","Wikipedia entry for Sort-merge join","en.wikipedia.org/...Sort-merge_join","http://en.wikipedia.org/wiki/Merge_join","http://en.wikipedia.org/wiki/Sort-Merge_Join","http://en.wikipedia.org/wiki/Sort-merge_","http://en.wikipedia.org/wiki/Sort-merge_join","http://ru.wikipedia.org/wiki/Алгоритм_соединения_слиянием_сортированных_списков","merge join","merge join algorithm","merge-join","merge-joins","mergejoin","sort-merge join","sort-merge-join","sorted-merge join","Řadit-sloučení spojit","Алгоритм соединения слиянием сортированных списков","Сортировать-соединение слиянием","сортировки и слияния","है के आधार पर क्रमबद्ध मर्ज में शामिल","है के आधार पर क्रमबद्ध-","ソートマージ結合"],"name":"Sort-merge join","categories":["All articles lacking sources","Articles lacking sources from December 2009","Join algorithms"],"tag_line":"The sort-merge join (also known as merge join) is a join algorithm and is used in the implementation of a relational database management system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"kernel-method","_score":0,"_source":{"description":"In machine learning, kernel methods are a class of algorithms for pattern analysis, whose best known member is the support vector machine (SVM). The general task of pattern analysis is to find and study general types of relations (for example clusters, rankings, principal components, correlations, classifications) in datasets. For many algorithms that solve these tasks, the data in raw representation have to be explicitly transformed into feature vector representations via a user-specified feature map: in contrast, kernel methods require only a user-specified kernel, i.e., a similarity function over pairs of data points in raw representation.\nKernel methods owe their name to the use of kernel functions, which enable them to operate in a high-dimensional, implicit feature space without ever computing the coordinates of the data in that space, but rather by simply computing the inner products between the images of all pairs of data in the feature space. This operation is often computationally cheaper than the explicit computation of the coordinates. This approach is called the \"kernel trick\". Kernel functions have been introduced for sequence data, graphs, text, images, as well as vectors.\nAlgorithms capable of operating with kernels include the kernel perceptron, support vector machines (SVM), Gaussian processes, principal components analysis (PCA), canonical correlation analysis, ridge regression, spectral clustering, linear adaptive filters and many others. Any linear model can be turned into a non-linear model by applying the kernel trick to the model: replacing its features (predictors) by a kernel function.\nMost kernel algorithms are based on convex optimization or eigenproblems and are statistically well-founded. Typically, their statistical properties are analyzed using statistical learning theory (for example, using Rademacher complexity).","alt_names":[],"name":"Kernel method","categories":["All articles lacking in-text citations","Articles lacking in-text citations from January 2011","Classification algorithms","Geostatistics","Kernel methods for machine learning"],"tag_line":"In machine learning, kernel methods are a class of algorithms for pattern analysis, whose best known member is the support vector machine (SVM)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"least-mean-squares-filter","_score":0,"_source":{"description":"Least mean squares (LMS) algorithms are a class of adaptive filter used to mimic a desired filter by finding the filter coefficients that relate to producing the least mean squares of the error signal (difference between the desired and the actual signal). It is a stochastic gradient descent method in that the filter is only adapted based on the error at the current time. It was invented in 1960 by Stanford University professor Bernard Widrow and his first Ph.D. student, Ted Hoff.","alt_names":["Problem Formulation","Delta-Regel","- Least mean squares :","- Least mean squares filter :","-> Leggi tutto l'articolo su 'Least Mean Square","Algorisme LMS","Algoritmo LMS","Algoritmo LMS - Wikipedia, la enciclopedia libre","Deltaregel","HREF=http://en.wikipedia.org/wiki/Least_mean_squares_filter","LMS (Least mean squares) algorithms","LMS Algorithm Overview","LMS Filter","LMS Theorem","LMS adaptive","LMS algorithm","LMS algorithm summary","LMS filters","LMS-Algorithmus","LMS-Algorithmus - Wikipedia","LMS-Algorithmus – Wikipedia","Least Mean Square","Least Mean Square - Wikipedia","Least Mean Square Filter","Least Mean Squares","Least Mean Squares (","Least Mean Squares (LMS)","Least Mean Squares Filter","Least Mean Squares algorithms","Least Squares Filter","Least mean squares","Least mean squares filter","Least mean squares filter (LMS)","Least mean squares filter - Wikipedia :: The free encyclopedia","Least mean squares filter - Wikipedia, the free encyclopedia","Least mean squares filter Wikipedia the free encyclopedia","Least mean squares filter from Wikipedia","Least_mean_squares","Least_mean_squares_filter","Lms_filter.png","NLMS","NLMS-фильтрами","Normalised least mean squares filter (NLMS)","Normalized Least Mean Squares","Read More least mean squares filter wikipedia the","Widrow-Hoff Least mean squares filter (LMS) adaptive","Wikipedia (Least mean squares filter)","Wikipedia Algoritmo LMS","Wikipedia article Least mean squares","Wikipedia article Least mean squares filter","Wikipedia article on Least mean squares","Wikipedia article on Least mean squares filter","Wikipedia entry for Least mean squares filter","Wikipedia l'articolo Least Mean Square","Wikipedia-Artikel Delta-Regel","Wikipedia-Artikel Deltaregel","Wikipedia-Artikel LMS-Algorithmus","Wikipedia-Seite zu 'Delta-Regel'","Wikipedia-Seite zu 'LMS-Algorithmus'","Wikipedia: Least mean squares filter","Wikipedia:Least_Mean_Square","[LMS","artículo de Wikipedia Algoritmo LMS","de:LMS-Algorithmus","en.wikipedia.org/wiki/Least_mean_squares_filter","http://de.wikipedia.org/wiki/Delta-Regel","http://de.wikipedia.org/wiki/Deltaregel","http://de.wikipedia.org/wiki/LMS-Algorit","http://de.wikipedia.org/wiki/LMS-Algorithmus","http://en.wikipedia.org/wiki/Least_me","http://en.wikipedia.org/wiki/Least_mean_","http://en.wikipedia.org/wiki/Least_mean_squar...","http://en.wikipedia.org/wiki/Least_mean_squares","http://en.wikipedia.org/wiki/Least_mean_squares_filter","http://en.wikipedia.org/wiki/Least_mean_…","http://es.wikipedia.org/wiki/Algoritmo_LMS","introduction to LMS filters","least mean square adaptive filter","least mean squares","least mean squares (LMS)","least mean squares filter","least squares correlation","least-mean-squares","this explanation is both correct and easier to","𝐡 &Hat; ( n + 1 ) = 𝐡 &Hat; ( n ) + μ","𝐡 ( n )"],"name":"Least mean squares filter","categories":["Digital signal processing","Filter theory","Stochastic algorithms"],"tag_line":"Least mean squares (LMS) algorithms are a class of adaptive filter used to mimic a desired filter by finding the filter coefficients that relate to producing the least mean squares of the error signal (difference between the desired and the actual signal)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fast-walsh–hadamard-transform","_score":0,"_source":{"description":"In computational mathematics, the Hadamard ordered fast Walsh–Hadamard transform (FWHTh) is an efficient algorithm to compute the Walsh–Hadamard transform (WHT). A naive implementation of the WHT would have a computational complexity of O(). The FWHTh requires only  additions or subtractions.\nThe FWHTh is a divide and conquer algorithm that recursively breaks down a WHT of size  into two smaller WHTs of size . This implementation follows the recursive definition of the  Hadamard matrix :\n\nThe  normalization factors for each stage may be grouped together or even omitted.\nThe sequency ordered, also known as Walsh ordered, fast Walsh–Hadamard transform, FWHTw, is obtained by computing the FWHTh as above, and then rearranging the outputs.\n\n","alt_names":[],"name":"Fast Walsh–Hadamard transform","categories":["Algorithms and data structures stubs","All articles lacking in-text citations","All stub articles","Articles lacking in-text citations from September 2015","Computer science stubs","Digital signal processing","Signal processing stubs"],"tag_line":"In computational mathematics, the Hadamard ordered fast Walsh–Hadamard transform (FWHTh) is an efficient algorithm to compute the Walsh–Hadamard transform (WHT)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"brownboost","_score":0,"_source":{"description":"BrownBoost is a boosting algorithm that may be robust to noisy datasets. BrownBoost is an adaptive version of the boost by majority algorithm. As is true for all boosting algorithms, BrownBoost is used in conjunction with other machine learning methods. BrownBoost was introduced by Yoav Freund in 2001.","alt_names":["- BrownBoost :","592873820e4f79f03ce8bd6fe865 ...","BrownBoost","BrownBoost - Wikipedia, the free encyclopedia","BrownBoost Learning Algorithm Definition","BrownBoost algorithm","BrownBoost on Wikipedia","BrownBoost |","What is motivation of BrownBoost","Wikipedia article BrownBoost","Wikipedia article on BrownBoost","Wikipedia entry for BrownBoost","http://en.wikipedia.org/wiki/BrownBoost","yago-res:BrownBoost","“BrownBoost - Wikipedia, the free encyclopedia”, en.wikipedia.org"],"name":"BrownBoost","categories":["Classification algorithms","Ensemble learning"],"tag_line":"BrownBoost is a boosting algorithm that may be robust to noisy datasets."}}
,{"_index":"throwtable","_type":"algorithm","_id":"nearest-centroid-classifier","_score":0,"_source":{"description":"In machine learning, a nearest centroid classifier or nearest prototype classifier is a classification model that assigns to observations the label of the class of training samples whose mean (centroid) is closest to the observation.\nWhen applied to text classification using tf*idf vectors to represent documents, the nearest centroid classifier is known as the Rocchio classifier because of its similarity to the Rocchio algorithm for relevance feedback.\nAn extended version of the nearest centroid classifier has found applications in the medical domain, specifically classification of tumors.","alt_names":[],"name":"Nearest centroid classifier","categories":["Classification algorithms"],"tag_line":"In machine learning, a nearest centroid classifier or nearest prototype classifier is a classification model that assigns to observations the label of the class of training samples whose mean (centroid) is closest to the observation."}}
,{"_index":"throwtable","_type":"algorithm","_id":"floyd–steinberg-dithering","_score":0,"_source":{"description":"Floyd–Steinberg dithering is an image dithering algorithm first published in 1976 by Robert W. Floyd and Louis Steinberg. It is commonly used by image manipulation software, for example when an image is converted into GIF format that is restricted to a maximum of 256 colors.\nThe algorithm achieves dithering using error diffusion, meaning it pushes (adds) the residual quantization error of a pixel onto its neighboring pixels, to be dealt with later. It spreads the debt out according to the distribution (shown as a map of the neighboring pixels):\n\nThe pixel indicated with a star (*) indicates the pixel currently being scanned, and the blank pixels are the previously-scanned pixels. The algorithm scans the image from left to right, top to bottom, quantizing pixel values one by one. Each time the quantization error is transferred to the neighboring pixels, while not affecting the pixels that already have been quantized. Hence, if a number of pixels have been rounded downwards, it becomes more likely that the next pixel is rounded upwards, such that on average, the quantization error is close to zero.\nThe diffusion coefficients have the property that if the original pixel values are exactly halfway in between the nearest available colors, the dithered result is a checkerboard pattern. For example 50% grey data could be dithered as a black-and-white checkerboard pattern. For optimal dithering, the counting of quantization errors should be in sufficient accuracy to prevent rounding errors from affecting the result.\nIn some implementations, the horizontal direction of scan alternates between lines; this is called \"serpentine scanning\" or boustrophedon transform dithering.\nIn pseudocode:\n\nfor each y from top to bottom\n   for each x from left to right\n      oldpixel  := pixel[x][y]\n      newpixel  := find_closest_palette_color(oldpixel)\n      pixel[x][y]  := newpixel\n      quant_error  := oldpixel - newpixel\n      pixel[x+1][y  ] := pixel[x+1][y  ] + quant_error * 7/16\n      pixel[x-1][y+1] := pixel[x-1][y+1] + quant_error * 3/16\n      pixel[x  ][y+1] := pixel[x  ][y+1] + quant_error * 5/16\n      pixel[x+1][y+1] := pixel[x+1][y+1] + quant_error * 1/16\n\nWhen converting 16 bit greyscale to 8 bit, find_closest_palette_color() may perform just a simple rounding, for example:\n\nfind_closest_palette_color(oldpixel) = floor(oldpixel / 256)","alt_names":[],"name":"Floyd–Steinberg dithering","categories":["Articles with example code","Articles with example pseudocode","Computer graphics algorithms","Image processing"],"tag_line":"Floyd–Steinberg dithering is an image dithering algorithm first published in 1976 by Robert W. Floyd and Louis Steinberg."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bruun's-fft-algorithm","_score":0,"_source":{"description":"Bruun's algorithm is a fast Fourier transform (FFT) algorithm based on an unusual recursive polynomial-factorization approach, proposed for powers of two by G. Bruun in 1978 and generalized to arbitrary even composite sizes by H. Murakami in 1996. Because its operations involve only real coefficients until the last computation stage, it was initially proposed as a way to efficiently compute the discrete Fourier transform (DFT) of real data. Bruun's algorithm has not seen widespread use, however, as approaches based on the ordinary Cooley–Tukey FFT algorithm have been successfully adapted to real data with at least as much efficiency. Furthermore, there is evidence that Bruun's algorithm may be intrinsically less accurate than Cooley–Tukey in the face of finite numerical precision (Storn, 1993).\nNevertheless, Bruun's algorithm illustrates an alternative algorithmic framework that can express both itself and the Cooley–Tukey algorithm, and thus provides an interesting perspective on FFTs that permits mixtures of the two algorithms and other generalizations.","alt_names":["Bruun's FFT algorithm","Bruun's FFT algorithm - Wikipedia, the free encyclopedia",") Bruun's","-> Read the article about 'Bruun's FFT algorithm'","...more on Wikipedia about Bruun's FFT algorithm","00dcbaac9cee26d1a8d1f7bf79d ...","Bruun s FFT algorithm Wikipedia the free encyclopedia","Bruun%27s_FFT_algorithm","Bruun's FFT algorithm - Wikipedia :: The free encyclopedia","Bruun's FFT algorithm - Wikipedia, the ...","Bruun's algorithm","G. Bruun feat. FFT Algorithm","Learn about Bruun's FFT algorithm>>>","Source Wikipedia.org Arcticle - Bruun's FFT algorithm","Wikipedia article Bruun's FFT algorithm","en.wikipedia.org/wiki/Bruun's_FFT_algorithm","http://en.wikipedia.org/wiki/Bruun%27s_FFT_algorithm","http://en.wikipedia.org/wiki/Bruun's_FFT_algorithm"],"name":"Bruun's FFT algorithm","categories":["FFT algorithms"],"tag_line":"Bruun's algorithm is a fast Fourier transform (FFT) algorithm based on an unusual recursive polynomial-factorization approach, proposed for powers of two by G. Bruun in 1978 and generalized to arbitrary even composite sizes by H. Murakami in 1996."}}
,{"_index":"throwtable","_type":"algorithm","_id":"evolutionary-music","_score":0,"_source":{"description":"Evolutionary music is the audio counterpart to Evolutionary art, whereby algorithmic music is created using an evolutionary algorithm. The process begins with a population of individuals which by some means or other produce audio (e.g. a piece, melody, or loop), which is either initialized randomly or based on human-generated music. Then through the repeated application of computational steps analogous to biological selection, recombination and mutation the aim is for the produced audio to become more musical. Evolutionary sound synthesis is a related technique for generating sounds or synthesizer instruments. Evolutionary music is typically generated using an interactive evolutionary algorithm where the fitness function is the user or audience, as it is difficult to capture the aesthetic qualities of music computationally. However, research into automated measures of musical quality is also active. Evolutionary computation techniques have also been applied to harmonization and accompaniment tasks. The most commonly used evolutionary computation techniques are genetic algorithms and genetic programming.","alt_names":["- Evolutionary music :","Evolutionary Music","Evolutionary methods of composing music","Evolutionary music","Evolutionary music - Wikipedia, the free encyclopedia","Evolutionary music; it is used under the","Evolutionary_music","What is the history of Evolutionary music","Wikipedia Evolutionary music","Wikipedia article Evolutionary music","Wikipedia article on Evolutionary music","Wikipedia entry for Evolutionary music","Wikipedia: Evolutionary music","evolutionary music","evolutionary music can be found on Wikipedia","http://en.wikipedia.org/wiki/Evolutionary_music","música evolutiva","yago-res:Evolutionary music"],"name":"Evolutionary music","categories":["Electronic music","Evolutionary algorithms"],"tag_line":"Evolutionary music is the audio counterpart to Evolutionary art, whereby algorithmic music is created using an evolutionary algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cellular-evolutionary-algorithm","_score":0,"_source":{"description":"A Cellular Evolutionary Algorithm (cEA) is a kind of evolutionary algorithm (EA) in which individuals cannot mate arbitrarily, but every one interacts with its closer neighbors on which a basic EA is applied (selection, variation, replacement).\n\nThe cellular model simulates Natural evolution from the point of view of the individual, which encodes a tentative (optimization, learning, search) problem solution. The essential idea of this model is to provide the EA population with a special structure defined as a connected graph, in which each vertex is an individual who communicates with his nearest neighbors. Particularly, individuals are conceptually set in a toroidal mesh, and are only allowed to recombine with close individuals. This leads us to a kind of locality known as isolation by distance. The set of potential mates of an individual is called its neighborhood. It is known that, in this kind of algorithm, similar individuals tend to cluster creating niches, and these groups operate as if they were separate sub-populations (islands). Anyway, there is no clear borderline between adjacent groups, and close niches could be easily colonized by competitive niches and maybe merge solution contents during the process. Simultaneously, farther niches can be affected more slowly.","alt_names":[],"name":"Cellular evolutionary algorithm","categories":["Evolutionary algorithms"],"tag_line":"A Cellular Evolutionary Algorithm (cEA) is a kind of evolutionary algorithm (EA) in which individuals cannot mate arbitrarily, but every one interacts with its closer neighbors on which a basic EA is applied (selection, variation, replacement)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"marzullo's-algorithm","_score":0,"_source":{"description":"Marzullo's algorithm, invented by Keith Marzullo for his Ph.D. dissertation in 1984, is an agreement algorithm used to select sources for estimating accurate time from a number of noisy time sources. A refined version of it, renamed the \"intersection algorithm\", forms part of the modern Network Time Protocol. The Marzullo's algorithm is also used to compute the relaxed intersection of n boxes (or more generally n subsets of Rn), as required by several robust set estimation methods.","alt_names":["...more on Wikipedia about Marzullo's algorithm","Marzullo algoritme","Marzullo je algoritmus","Marzullo's Algorithm","Marzullo's algorithm","Marzullo's algorithm - Wikipedia :: The free encyclopedia","Marzullo's algorithm - Wikipedia, the free encyclopedia","Marzullo's algorithm wiki","Marzullo's algoritme","Marzullo's_algorithm","Marzullo-Algorithmus","Marzulloのアルゴリズムは","Marzullo的算法","Wikipedia article ''Marzullo's algorithm''","Wikipedia article Marzullo's algorithm","[13] Marzullo algorithm","algoritmo de Marzullo","algoritmo di Marzullo","algorytm Marzullo","di algoritmo di Marzullo","el algoritmo de Marzullo","en.wikipedia.org/wiki/Marzullo's_algorithm","http://en.wikipedia.org/ wik...o%27s_algorithm","http://en.wikipedia.org/wiki/Marzullo%27s_alg...","http://en.wikipedia.org/wiki/Marzullo%27s_algorithm","http://en.wikipedia.org/wiki/Marzullo's_algorithm","il mio algoritmo","l'algoritmo di Marzullo","Алгоритм Marzullo","алгоритм Марзулло","алгоритъм на Марзуло","अनुवाद Marzullo","है Marzullo एल्गोरिथ्म"],"name":"Marzullo's algorithm","categories":["Agreement algorithms"],"tag_line":"Marzullo's algorithm, invented by Keith Marzullo for his Ph.D. dissertation in 1984, is an agreement algorithm used to select sources for estimating accurate time from a number of noisy time sources."}}
,{"_index":"throwtable","_type":"algorithm","_id":"k-independent-hashing","_score":0,"_source":{"description":"A family of hash functions is said to be -independent or -universal if selecting a hash function at random from the family guarantees that the hash codes of any designated  keys are independent random variables (see precise mathematical definitions below). Such families allow good average case performance in randomized algorithms or data structures, even if the input data is chosen by an adversary. The trade-offs between the degree of independence and the efficiency of evaluating the hash function are well studied, and many -independent families have been proposed.\n^ Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2009). Introduction to Algorithms (3rd ed.). MIT Press. ISBN 0-262-03384-4.","alt_names":["2-independent hash function","K-Independent Hashing","K-Independent Hashing; it is used under the","K-independent hashing","k-independent hashing"],"name":"K-independent hashing","categories":["Error detection and correction","Hash functions","Pages containing cite templates with deprecated parameters","Search algorithms"],"tag_line":"A family of hash functions is said to be -independent or -universal if selecting a hash function at random from the family guarantees that the hash codes of any designated  keys are independent random variables (see precise mathematical definitions below)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cooley–tukey-fft-algorithm","_score":0,"_source":{"description":"The Cooley–Tukey algorithm, named after J.W. Cooley and John Tukey, is the most common fast Fourier transform (FFT) algorithm. It re-expresses the discrete Fourier transform (DFT) of an arbitrary composite size N = N1N2 in terms of smaller DFTs of sizes N1 and N2, recursively, to reduce the computation time to O(N log N) for highly composite N (smooth numbers). Because of the algorithm's importance, specific variants and implementation styles have become known by their own names, as described below.\nBecause the Cooley-Tukey algorithm breaks the DFT into smaller DFTs, it can be combined arbitrarily with any other algorithm for the DFT. For example, Rader's or Bluestein's algorithm can be used to handle large prime factors that cannot be decomposed by Cooley–Tukey, or the prime-factor algorithm can be exploited for greater efficiency in separating out relatively prime factors.\nThe algorithm, along with its recursive application, was invented by Carl Friedrich Gauss. Cooley and Tukey independently rediscovered and popularized it 160 years later.","alt_names":[],"name":"Cooley–Tukey FFT algorithm","categories":["Articles with example pseudocode","FFT algorithms"],"tag_line":"The Cooley–Tukey algorithm, named after J.W."}}
,{"_index":"throwtable","_type":"algorithm","_id":"intersection-algorithm","_score":0,"_source":{"description":"The intersection algorithm is an agreement algorithm used to select sources for estimating accurate time from a number of noisy time sources, it forms part of the modern Network Time Protocol. It is a modified form of Marzullo's algorithm.\nWhile Marzullo's algorithm will return the smallest interval consistent with the largest number of sources, the returned interval does not necessarily include the center point (calculated offset) of all the sources in the intersection. The Intersection algorithm returns an interval that includes that returned by Marzullo's algorithm but may be larger since it will include the center points. This larger interval allows using additional statistical data to select a point within the interval, reducing the jitter in repeated execution.","alt_names":["...more on Wikipedia about Intersection algorithm","Intersection Algorithm","Intersection algorithm","Intersection algorithm - Wikipedia, the free encyclopedia","What is method of Intersection algorithm","Wikipedia article Intersection algorithm","Wikipedia entry for Intersection algorithm","[12] Intersection algorithm","http://en.wikipedia.org/wiki/Intersection_algorithm","intersection algorithm","una variación","yago-res:Intersection algorithm"],"name":"Intersection algorithm","categories":["Agreement algorithms"],"tag_line":"The intersection algorithm is an agreement algorithm used to select sources for estimating accurate time from a number of noisy time sources, it forms part of the modern Network Time Protocol."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bat-algorithm","_score":0,"_source":{"description":"Bat-inspired algorithm is a metaheuristic optimization algorithm developed by Xin-She Yang in 2010. This bat algorithm is based on the echolocation behaviour of microbats with varying pulse rates of emission and loudness.\n\n","alt_names":["Bat Algorithm","Bat algorithm","Bat algorithm - Wikipedia, the free encyclopedia","Bat algorithm; it is used under the","Wikipedia article Bat algorithm","Wikipedia article on Bat algorithm","bat algorithm","http://en.Liarpedia.org/wiki/Bat_algorithm","http://en.wikipedia.org/wiki/Bat_algorithm","yago-res:Bat algorithm"],"name":"Bat algorithm","categories":["Evolutionary algorithms","Heuristic algorithms"],"tag_line":"Bat-inspired algorithm is a metaheuristic optimization algorithm developed by Xin-She Yang in 2010."}}
,{"_index":"throwtable","_type":"algorithm","_id":"linear-programming","_score":0,"_source":{"description":"Linear programming (LP; also called linear optimization) is a method to achieve the best outcome (such as maximum profit or lowest cost) in a mathematical model whose requirements are represented by linear relationships. Linear programming is a special case of mathematical programming (mathematical optimization).\nMore formally, linear programming is a technique for the optimization of a linear objective function, subject to linear equality and linear inequality constraints. Its feasible region is a convex polytope, which is a set defined as the intersection of finitely many half spaces, each of which is defined by a linear inequality. Its objective function is a real-valued affine (linear) function defined on this polyhedron. A linear programming algorithm finds a point in the polyhedron where this function has the smallest (or largest) value if such a point exists.\nLinear programs are problems that can be expressed in canonical form as\n\nwhere x represents the vector of variables (to be determined), c and b are vectors of (known) coefficients, A is a (known) matrix of coefficients, and  is the matrix transpose. The expression to be maximized or minimized is called the objective function (cTx in this case). The inequalities Ax ≤ b and x ≥ 0 are the constraints which specify a convex polytope over which the objective function is to be optimized. In this context, two vectors are comparable when they have the same dimensions. If every entry in the first is less-than or equal-to the corresponding entry in the second then we can say the first vector is less-than or equal-to the second vector.\nLinear programming can be applied to various fields of study. It is widely used in business and economics, and is also utilized for some engineering problems. Industries that use linear programming models include transportation, energy, telecommunications, and manufacturing. It has proved useful in modeling diverse types of problems in planning, routing, scheduling, assignment, and design.","alt_names":["Linear program","7 Theory","programação linear","linear program","lineair programmeren","ottimizzazione lineare","数理計画法","linear programming","integer linear programming problem","mixed integer programming","linear optimization","Interior point","good old Wikipedia.","linear programs","integer linear programming","Linear programming","Linear Programming","% 5Fprogramming http://en.wikipedia.org/wiki/Linear # Usa","% http://en.wikipedia.org/wiki/Linear 5Fprogramming","'linear programming","(0,1)-integer optimization problem","(LP","(entero) de programación lineal","(entier) de programmation linéaire","(integer) linear programming","(integer) linearen Programmierung","(inteiro) de programação linear","(intero) di programmazione lineare","(số nguyên) tuyến tính lập trình","(целое) линейного программирования","(정수)을 선형 프로그래밍",", er heltal begrænsninger NP-komplet","- Integer programming :","- Linear program :","- Linear programming :","- Mixed integer programming :","-> Read more about Integer programming","... purpose convex optimization solver written in Python, with","...Wikipedia Programación lineal","...Wikipedia Programação linear","...Wikipedia Programmation linéaire","...Wikipedia Programowanie liniowe","...http://en.wikipedia.org/wiki/Linear_programming#Inte","...mehr auf Wikipedia über Ganzzahlige lineare Optimierung","...mehr auf Wikipedia über Lineare Optimierung","...more on Wikipedia about Linear programming","/wiki/Линейное_программирование","0-1 INTEGER PROGRAMMING","0-1 integer program","0-1 integer programming","0-1 linear programming","0a3c2445d6c49ef0615b617407601 ...","0–1 integer program","1 Historia de la programación lineal","1 History of linear programming","1. Linear programming - Wikipedia, the free encyclopedia","10 Integer unknowns","10 Open problems and recent work","11 Integer unknowns","11 Solvers and Scripting (Programming) Languages","12 Integral Linear Programs","12 Solvers and scripting (programming) languages","13 Solvers and scripting (programming) languages","2) LINEAR PROGRAMMING FROM Wikipedia","2. Linear programming - Wikipedia, the free encyclopedia","22)Linear Programming","3 Algoritmos","3 Standard form","4 Augmented form (slack form)","4 Función Objetivo","4 Variáveis inteiras","4. Linear programming - Wikipedia, the free encyclopedia","5 Duality","5 Programación entera","5. Linear programming - Wikipedia, the free encyclopedia","5.2 Another example","5Fprogramming% http://en.wikipedia.org/wiki/Linear # Usa","6 Complementary slackness","6 Covering-packing dualities","6. Linear programming - Wikipedia, the free encyclopedia","7 Caso curioso","7 Complementary slackness","8 Theory","8. Linear programming - Wikipedia, the free encyclopedia","8.1 Existence of optimal solutions","8.2 Optimal vertices (and rays) of polyhedra","9 Algorithms","9 Open problems and recent work","9 Tutorial","9.1 Simplex algorithm of Dantzig","9.1 The simplex algorithm of Dantzig","9.2 Ellipsoid algorithm, following Khachiyan","9.2 The ellipsoid algorithm, following Khachiyan","9.3 Interior point methods, following Karmarkar","9.4 Comparison of interior-point methods versus simplex","9.4 Other algorithms","9.5 Comparison of interior-point methods versus simplex",": Linear programming","Algorithmes de la ...","Analyse du problème","Augmented form (slack ...","Augmented form (slack form)","Beispiels zur Produktionsplanung","Binary integer programming","Complemento UNIDAD 2","Covering-Packing Dualities","Covering-packing dualities","Definición de Programación lineal más completo","Definição de programação linear da wikipédia","Diskrete Optimierung","Diskrete_Optimierung","Do?rusal programlama - Vikipedi","Dogrusal programlama - Vikipedi","Doğrusal programlama","Doğrusal programlama - Vikipedi","Duality theorem","Dualitätsprinzip in der LP (Wiki)","Einschränkungen ist integer NP-vollständig","Em matemática, problemas de Programação Linear (PL) são","Ganzzahlige Optimierung","Ganzzahlige Optimierung - Wikipedia","Ganzzahlige Programmierung - Wikipedia","Ganzzahlige lineare","Ganzzahlige lineare Optimierung","Ganzzahlige lineare Optimierung - Wikipedia","Ganzzahlige lineare Optimierung ? Wikipedia","Ganzzahlige lineare Optimierung – Wikipedia","Ganzzahlige_Optimierung","Ganzzahlige_lineare_Optimierung","Geheeltallig lineair programmeren","Geheeltallige programmering","Go. Figure.","History of linear programming","How is Linear Programming's theory?","How is Linear optimization's theory?","How is Linear programming duality's theory?","Häufig lassen sich lineare Programme LPs zur Lösung","I was into at school","ILP-probleem","In mathematics, linear programming (LP) problems are optimization","Integer Linear Programming","Integer Linear Programming (ILP)","Integer Linear programming","Integer Programming","Integer Programming Problem","Integer linear program","Integer linear programming","Integer program","Integer programming","Integer programming - Wikipedia, the free encyclopedia","Integer programming Wikipedia the free encyclopedia","Integer programming from Wikipedia","Integer programs","Integer_programming","Integral polytope","Introduction of LP from WIKI","LP [Linear Programming]","LP problem","LP(LP)","LP-problem","La programacion lineal Consiste en optimizar (minimizar o","La programación lineal","La programmazione lineare (PL oppure LP) è quella","Learn about Linear programming>>>","Line?ris optimaliz?l?s - Wikip?dia","Line?rn? programov?n? - Wikipedie","Lineair Programmeren","Lineair programmeerprobleem","Lineair programmeren","Lineair programmeren - Wikipedia","Lineair programmeringsprobleem","Lineaire programmering","Lineale Optimierung","Linear Integer Programming","Linear Program!","Linear Programing","Linear Programing Link","Linear Programming (LP)","Linear Programming (Wikipedia)","Linear Programming - Wikipedia","Linear Programming - Wikipedia, The Free Encyclopedia","Linear Programming Duality","Linear Programming Wikipedia The Free Encyclopedia","Linear Programming and Mixed Integer Linear Programming links","Linear Programming at Wikipedia","Linear Programming in Wikipedia","Linear Programming on Wikipedia »","Linear Programming page","Linear Programming wikipedia entry","Linear Programming.","Linear Programming:","Linear Programming: Wikipedia","Linear Programming（線形計画問題）","Linear and nonlinear programming","Linear optimization","Linear programming (LP)","Linear programming (wikipedia)","Linear programming - Wikipe...","Linear programming - Wikipedia","Linear programming - Wikipedia, the free encyclope...","Linear programming - Wikipedia, the free encyclopedia","Linear programming - Wikipedia, the free encyclopedia:","Linear programming - Wikipedia, the free encyclop…","Linear programming - Wikipedia, the free...","Linear programming - Wikipedia,...","Linear programming Wikipedia the free encyclopedia","Linear programming Wikipedia the free encyclopedia - result","Linear programming Wikipedia, the ...","Linear programming from Wikipedia","Linear programming techniques","Linear programming – Wikipedia, the free encyclopedia","Linear programming#Open problems and recent work","Linear programming.","Linear programming: Duality","Linear programming: Duality - Wikipedia","Linear programming?","Linear programs","Linear-Programming","Linear_programming","Linear_programming#Integer_unknowns [Wikipedia]","Lineare Optimierung","Lineare Optimierung - Wikipedia","Lineare Optimierung ? Wikipedia","Lineare Optimierung Wikipedia","Lineare Optimierung – Wikipedia","Lineare Optimierung..","Lineare Programmierung","Lineare Programmierung - Wikipedia, die freie Enzyklopädie:","Lineare_Optimierung","Lineare_Programmierung","Linearen Optimierung","Linearer Programmierung","Lineares Programm","Linearno programiranje","Linearno programiranje - Wikipedia","Linearno programiranje - Wikipedija, prosta enciklopedija","Linearprogramming - Wikipedia, the free encyclopedia","Lineer programlama","Linerare Programmierung","Lineáris optimalizálás","Lineáris optimalizálás - Wikipédia","Lineáris programozás","Lineární programování","Lineární programování - Wikipedie","Lineêre programmering","Lineêre programmering - Wikipedia","Lp solve","MINLP/MILP","MiP","Mixed Integer Linear Programming","Mixed Integer Programming","Mixed Integer Programs","Mixed integer programming","Mixed-integer programming","Mínimo Coste","Optimierung, Lineare","Optimisation linéaire","Optimisation linéaire - Wikipédia","Optimisation linéaire en ...","P 1 x 1 + P 2 x 2","P.S. Вот что кстати написано в английской Вики","PLNE","Pemrograman linear","Pemrograman linear - Wikipedia bahasa Indonesia, ensiklopedia bebas","Pemrograman linear :: Wikipedia Bahasa Indonesia","Pemrograman linier","Pemrograman linier - Wikipedia bahasa Indonesia, ensiklopedia bebas","Pemrograman linier :: Wikipedia Bahasa Indonesia","Pemrograman linier Wikipedia bahasa Indonesia ensiklopedia bebas","Petrol sanayiinde uygulamalar","Planteamiento de optimización en términos de ecuaciones lineales","Problema de la Programación lineal entera","Profit maximization formulae","Programa??o linear ? Wikip?dia, a enciclop?dia","Programaci n lineal Wikipedia la enciclopedia libre","Programaci?n lineal - Wikipedia, la enciclopedia libre","Programació Lineal","Programació lineal","Programació lineal entera","Programación Lineal","Programación Lineal.","Programación entera","Programación lineal","Programación lineal - Wikipedia","Programación lineal - Wikipedia, la enciclopedia libre","Programación linear - Wikipedia, la enciclopedia libre:","Programazio lineal","Programação Inteira","Programação Linear","Programação Linear na Wikipédia","Programação Linear.","Programação inteira","Programação linear","Programação linear (I)","Programação linear - Wikipédia, a enciclopédia livre","Programação linear – Wikipédia, a enciclopédia livre","Programmation Linéaire en Nombre Entiers (PLNE)","Programmation lin?aire - Wikip?dia","Programmation linéaire","Programmation linéaire - Wikipédia","Programmazione Lineare Intera","Programmazione lineare","Programmazione lineare - Wikipedia","Programmazione lineare - Wikipedia- /w/opensearch_desc.php title= Wikipedia","Programme linéaire","Programowanie liniowe","Programowanie liniowe ? Wikipedia, wolna encyklopedia","Programowanie liniowe – Wikipedia, wolna encyklopedia","Quy hoạch số nguyên","Quy hoạch tuyến tính","Read Linear programming Wikipedia the free encyclopedia","Read More linear programming wikipedia the free encyclopedia","Screenshot http://en.wikipedia.org/wiki/Linear_programming","Softwares de programação linea","Solvers_and_scripting_.28programming.29_languages ​​をhttp://en.wikipedia.org","Standart şekil","The Wikipedia entry for linear programming","The dual of a covering LP is a","The linear programming","User:Broccin/proglin","Utente:Broccin/proglin - Wikipedia","Utente:Broggifaccin/pl","Vazirani (2001","View Linear programming on Wikipedia","Você sabe o que é programação linear?","What are algorithms of Linear optimization","What are the uses of Linear programmer?","What is Linear Programming?","What is theory of Linear optimization?","What is theory of Linear programming problem?","Wiki - Linear Programming","Wiki Linear Programming","Wiki page on Linear Programming","Wiki-page for Linear Programming","WikiPedia.ja:線形計画問題","Wikipedia - Linear programming","Wikipedia - Programacao Linear","Wikipedia - 정수계획법","Wikipedia : Linear Programming","Wikipedia : Programmation Linéaire","Wikipedia : 線形計画法","Wikipedia Programación lineal","Wikipedia article Integer programming","Wikipedia article Lineair programmeren","Wikipedia article Linear program","Wikipedia article Linear programming","Wikipedia article Lineare Optimierung","Wikipedia article Linearno programiranje","Wikipedia article Lineêre programmering","Wikipedia article Linjärprogrammering","Wikipedia article Optimisation linéaire","Wikipedia article Pemrograman linear","Wikipedia article Programación lineal","Wikipedia article Programazio lineal","Wikipedia article Programação inteira","Wikipedia article Programação linear","Wikipedia article Programmazione lineare","Wikipedia article Quy hoạch tuyến tính","Wikipedia article on Programação linear","Wikipedia article on linear programming","Wikipedia article on the dual of a linear","Wikipedia article Линейное программирование","Wikipedia article תכנון לינארי","Wikipedia article لکیری برمجہ","Wikipedia article रैखिक प्रोग्रामन","Wikipedia article กำหนดการเชิงเส้น","Wikipedia artikel Lineair programmeren","Wikipedia auf ganzzahliger linearer Programmierung","Wikipedia en programación lineal entera","Wikipedia entry for Integer programming","Wikipedia entry for Linear programming","Wikipedia entry on Linear Programming","Wikipedia na celočíselného lineárního programování","Wikipedia om heltal lineær programmering","Wikipedia on LP »","Wikipedia on integer linear programming","Wikipedia over geheeltallige lineaire programmering","Wikipedia su programmazione lineare intera","Wikipedia sur Programmation linéaire","Wikipedia sur Programme linéaire","Wikipedia | Lineair programmeren","Wikipedia 「線形計画法」","Wikipedia-Artikel Diskrete Optimierung","Wikipedia-Artikel Ganzzahlige Optimierung","Wikipedia-Artikel Ganzzahlige Programmierung","Wikipedia-Artikel Ganzzahlige lineare Optimierung","Wikipedia-Artikel Linear programming","Wikipedia-Artikel Lineare Optimierung","Wikipedia-Artikel Lineare Programmierung","Wikipedia-Seite zu 'Diskrete Optimierung'","Wikipedia-Seite zu 'Ganzzahlige Optimierung'","Wikipedia-Seite zu 'Ganzzahlige lineare Optimierung'","Wikipedia-Seite zu 'Lineare Optimierung'","Wikipedia-Seite zu 'Lineare Programmierung'","Wikipedia.jp:線形計画法","Wikipedia: Ganzzahlige Lineare Optimierung","Wikipedia: Linear Programming","Wikipedia: Lineare Optimierung","Wikipedia: Programación Lineal","Wikipedia: Standard form","Wikipedia:Linear_programming","Wikipediaで「線型計画問題」を調べる","Wikipediaで「線形計画問題」を調べる","Wikipédia artigo Programação linear","af:Lineêre programmering","algoritmo lineal","also known as 0/1-integer programming","an ILP","aprogramación lineal","aqui um link que fala sobre isso","ar:برمجة خطية","augmented form","ausführlicher Wikipedia Artikel zu lin. Opt.","awesome integer programming libraries","basic optimal solution","binary integer linear programming","bs:Linearno programiranje","ca:Programació lineal","ca:Programació_lineal","całkowitą programowania liniowego","celočíselného lineárního programování","chương trình tuyến tính","cjelobrojnog linearnog programiranja","complementary slackness","covering and packing","covering and packing dual linear programs","cs:Lineární programování","d integer programmin","de programación lineal","de programación lineal.","de programação linear.","de programmation linéaire.","de.wikipedia.org/ wiki/Ganzzahlige_lineare_Opti»","de.wikipedia.org/ wiki/Lineare_Optimierung","de.wikipedia.org/wiki/Diskrete_Optimierung","de.wikipedia.org/wiki/Ganzzahlige_lineare_Optimierung","de.wikipedia.org/wiki/Ganzzahlige_lineare_Optimierung#Komplexit.C3.A4t_und_L","de.wikipedia.org/wiki/Lineare_Optimierung","de:Ganzzahlige lineare Optimierung","de:Lineare Optimierung","der linearen Programmierung","di programmazione lineare","di programmazione lineare.","diskrete Optimierung","duale Problem","duality Linear Programming","duality theorem","duality theorem in linear programming","einfache Umformungen","en.wikipedia.org/...Linear_programming","en.wikipedia.org/...Mixed_integer_programming","en.wikipedia.org/wiki/Linear programming","en.wikipedia.org/wiki/Linear_pro...","en.wikipedia.org/wiki/Linear_programm...","en.wikipedia.org/wiki/Linear_programming","en.wikipedia.org/wiki/Linear_programming#Duality","en.wikipedia.org/wiki/Linear_programming#Standard_form","en.wikipedia.org/wiki/Linear_programming, vi","en:Linear_programming","es:Programación lineal","eu:Programazio lineal","exakten","excellent article on Linear Programming","f7bc02d88ad6ba493ed183a6d93a ...","fa.wikipedia.org/wiki/برنامهریزی_خطی","fa:برنامهریزی خطی","fr.wikipedia.org/...Programmation_lin%C3%A9aire","fr:Optimisation linéaire","fr:Programmation linéaire","ganzzahligen Optimierung","ganzzahligen linearen","ganzzahligen linearen Programmierung","geheeltallige lineaire programmering","geheeltallige programmering","guhit","he:תכנון לינארי","heltals lineær programmering","hi:रैखिक प्रोग्रामन","http//de.wikipedia.org/wiki/Lineare_Optimierung","http//de.wikipedia.org/wiki/Lineare_Optimierung#Beispiel_aus_der_Produktionsplanung_.28zweidimensional","http://af.wikipedia.org/wiki/Line%C3%AAre_programmering","http://bit.ly/axMG2D","http://bs.wikipedia.org/wiki/Linearno_programiranje","http://ca.wikipedia.org/wiki/Programaci%C3%B3_lineal_entera","http://de.wikipedia.org/wiki/Diskrete_Optimierung","http://de.wikipedia.org/wiki/Ganzzah...re_Optimierung","http://de.wikipedia.org/wiki/Ganzzahlige","http://de.wikipedia.org/wiki/Ganzzahlige_Optimierung","http://de.wikipedia.org/wiki/Ganzzahlige_Programmierung","http://de.wikipedia.org/wiki/Ganzzahlige_lineare_Optimierung","http://de.wikipedia.org/wiki/Li neare_Optimierung","http://de.wikipedia.org/wiki/Linear_programming","http://de.wikipedia.org/wiki/Lineare...Interpretation","http://de.wikipedia.org/wiki/Lineare...e_Formulierung","http://de.wikipedia.org/wiki/LineareOptimierung#GeometrischeInterpretation","http://de.wikipedia.org/wiki/Lineare_Opt","http://de.wikipedia.org/wiki/Lineare_Optimierung","http://de.wikipedia.org/wiki/Lineare_Optimierung#Mischungsprobleme","http://de.wikipedia.org/wiki/Lineare_Optimierung#P...","http://de.wikipedia.org/wiki/Lineare_Opt…","http://de.wikipedia.org/wiki/Lineare_Programmierung","http://en.wikipedia....ear_programming","http://en.wikipedia.org / wiki / Lineaire% 5Fprogramming # Algorithms","http://en.wikipedia.org / wiki / Linear% 5Fprogramming # Algorithmen","http://en.wikipedia.org / wiki / Linear% 5Fprogramming # Algorithms","http://en.wikipedia.org / wiki / Linear% 5Fprogramming # Algorytmy","http://en.wikipedia.org / wiki / lineal 5Fprogramming% # Algoritmos","http://en.wikipedia.org / wiki / lineare 5Fprogramming% # Algoritmi","http://en.wikipedia.org / wiki / lineární% 5Fprogramming # algoritmy","http://en.wikipedia.org / вики / Линейная% 5Fprogramming # алгоритмов","http://en.wikipedia.org /ウィキ/リニア％の5Fprogramming","http://en.wikipedia.org /维基/线性％5Fprogramming＃算法","http://en.wikipedia.org/wiki/Integer...teger_unknowns","http://en.wikipedia.org/wiki/Integer_linear_programming","http://en.wikipedia.org/wiki/Integer_linear_programming#Integer_unknowns","http://en.wikipedia.org/wiki/Integer_linear_programming#Integer_unknowns.","http://en.wikipedia.org/wiki/Integer_program","http://en.wikipedia.org/wiki/Integer_programming","http://en.wikipedia.org/wiki/Integer_programming#Integer_unknowns","http://en.wikipedia.org/wiki/Lin ... amming.29_languages","http://en.wikipedia.org/wiki/Linear 5Fprogramming%","http://en.wikipedia.org/wiki/Linear 5Fprogramming% # использованию","http://en.wikipedia.org/wiki/Linear% 5Fprogramming","http://en.wikipedia.org/wiki/Linear% 5Fprogramming # Bruger","http://en.wikipedia.org/wiki/Linear% 5Fprogramming # Gebruikt","http://en.wikipedia.org/wiki/Linear% 5Fprogramming # Używa","http://en.wikipedia.org/wiki/Linear% 5Fprogramming # Verwendet","http://en.wikipedia.org/wiki/Linear% 5Fprogramming # použití","http://en.wikipedia.org/wiki/Linear%5Fprogramming","http://en.wikipedia.org/wiki/Linear%5Fprogramming#Algorithms","http://en.wikipedia.org/wiki/Linear%5Fprogramming#Uses","http://en.wikipedia.org/wiki/Linear_...8slack_form.29","http://en.wikipedia.org/wiki/Linear_...f_linear_progr","http://en.wikipedia.org/wiki/Linear_...ing#Algorithms","http://en.wikipedia.org/wiki/Linear_...teger_unknowns","http://en.wikipedia.org/wiki/Linear_pro ... ndard_form","http://en.wikipedia.org/wiki/Linear_pro ... r_unknowns","http://en.wikipedia.org/wiki/Linear_prog","http://en.wikipedia.org/wiki/Linear_prog ...","http://en.wikipedia.org/wiki/Linear_prog....","http://en.wikipedia.org/wiki/Linear_program","http://en.wikipedia.org/wiki/Linear_program#Integer_unknowns","http://en.wikipedia.org/wiki/Linear_program#Integer_unknowns.","http://en.wikipedia.org/wiki/Linear_programmi...","http://en.wikipedia.org/wiki/Linear_programming","http://en.wikipedia.org/wiki/Linear_programming # Algoritmi","http://en.wikipedia.org/wiki/Linear_programming # Algoritmos","http://en.wikipedia.org/wiki/Linear_programming # Algorytmy","http://en.wikipedia.org/wiki/Linear_programming # Solvers_and_scripting_.28programming","http://en.wikipedia.org/wiki/Linear_programming # Алгоритмы","http://en.wikipedia.org/wiki/Linear_programming Solvers_and_scripting_.28programming","http://en.wikipedia.org/wiki/Linear_programming →","http://en.wikipedia.org/wiki/Linear_programming#Algorithms","http://en.wikipedia.org/wiki/Linear_programming#Duality","http://en.wikipedia.org/wiki/Linear_programming#Example","http://en.wikipedia.org/wiki/Linear_programming#Example_3","http://en.wikipedia.org/wiki/Linear_programming#External_links","http://en.wikipedia.org/wiki/Linear_programming#History","http://en.wikipedia.org/wiki/Linear_programming#History_of_linear_programming","http://en.wikipedia.org/wiki/Linear_programming#Integer_unknowns","http://en.wikipedia.org/wiki/Linear_programming#Simplex_algorithm_of_Dantzig","http://en.wikipedia.org/wiki/Linear_programming#Simplex_algorithm_of_DantzigThe","http://en.wikipedia.org/wiki/Linear_programming#Solvers_and_","http://en.wikipedia.org/wiki/Linear_programming#Solvers_and_Scripting_.28Programming","http://en.wikipedia.org/wiki/Linear_programming#Solvers_and_s...","http://en.wikipedia.org/wiki/Linear_programming#Solvers_and_scripting_.28prog","http://en.wikipedia.org/wiki/Linear_programming#Solvers_and_scripting_.28progra","http://en.wikipedia.org/wiki/Linear_programming#Solvers_and_scripting_.28programming","http://en.wikipedia.org/wiki/Linear_programming#Standard_form","http://en.wikipedia.org/wiki/Linear_programming#Theory","http://en.wikipedia.org/wiki/Linear_programming).","http://en.wikipedia.org/wiki/Linear_programming.","http://en.wikipedia.org/wiki/Linear_programming~~V","http://en.wikipedia.org/wiki/Linear_programming＃Solvers_and_scripting_.28programming","http://en.wikipedia.org/wiki/Linear_prog…","http://en.wikipedia.org/wiki/Linear_p…","http://en.wikipedia.org/wiki/Linear％5Fprogramming","http://en.wikipedia.org/wiki/Linear％5Fprogramming＃使用","http://en.wikipedia.org/wiki/Linear％が5Fprogramming","http://en.wikipedia.org/wiki/Linear％の5Fprogramming","http://en.wikipedia.org/wiki/Mixed_integer_programming","http://en.wikipedia.org/wiki/Mixed_integer_programming # Integer_unknowns","http://en.wikipedia.org/wiki/Mixed_integer_programming#Integer_unknowns","http://es.wikipedia.org/wiki/Programaci%C3%B3n_entera","http://es.wikipedia.org/wiki/Programaci%C3%B3n_lineal","http://es.wikipedia.org/wiki/Programación_lineal","http://fa.wikipedia.org/wiki/برنامهریزی_خطی","http://fr.wikipedia.org/wiki/Optimisation_lin","http://fr.wikipedia.org/wiki/Optimisation_lin%C3%A9aire","http://fr.wikipedia.org/wiki/PLNE","http://fr.wikipedia.org/wiki/PLNE#Dualit.C3","http://fr.wikipedia.org/wiki/PLNE#plne","http://fr.wikipedia.org/wiki/Progra...n_lin%C3","http://fr.wikipedia.org/wiki/Program..._lin%C3","http://fr.wikipedia.org/wiki/Programmation_lin%C3%A9aire","http://fr.wikipedia.org/wiki/Programmation_linéaire","http://id.wikipedia.org/wiki/Pemrograman_linear","http://it.wikipedia.org/wiki/Programmazione_lineare","http://ja.wikipedia.org/wiki/線形計画法","http://nl.wikipedia.org/wiki/Lineair_pr ... ogrammeren","http://nl.wikipedia.org/wiki/Lineair_programmeren","http://pl.wikipedia.org/wiki/Programowanie_liniowe","http://pt.wikipedia.org/wiki/Program...%C3%A3o_linear","http://pt.wikipedia.org/wiki/Programação_linear","http://ru.wikipedia.org/wiki/Линейно...B0.D1","http://ru.wikipedia.org/wiki/Линейно...BD.D0","http://ru.wikipedia.org/wiki/Линейное_пр...","http://ru.wikipedia.org/wiki/Линейное_программирование","http://scn.wikipedia.org/wiki/Prugrammazzioni_lini%C3%A0ri","http://sh.wikipedia.org/wiki/Linearno_programiranje","http://sl.wikipedia.org/wiki/Linearno_programiranje","http://sv.wikipedia.org/wiki/Linj%C3%A4rprogrammering","http://tr.wikipedia.org/wiki/Do%C4%9Frusal_programlama","http://ur.wikipedia.org/wiki/Linear_programming","hu:Lineáris optimalizálás","id:Pemrograman linier","inear programming: t","integer (linear) program","integer beperkingen is NP-compleet","integer constraints","integer constraints is NP-complete","integer linear * programming","integer linear program programming","integer linear programming (ILP)","integer linear programs","integer linear-programming","integer problem","integer program","integer programming","integer programming solver","integer programming wikipedia the free encyclopedia","integer programming.","integer unknowns","integer_programming","integral (0/1) linear program","it:Programmazione lineare","ja:線形計画問題","ko:선형 계획법","l'article de Wikipédia PLNE","la programación lineal","la programación lineal con incógnitas entero","la programmation linéaire","la programmation linéaire.","la programmazione lineare","limitaciones entero es NP-completo","lineaire algoritmen","lineaire programmering","lineaire programmerings","lineaire programmeringsprobleem","lineaire-optimaliseringsprobleem","linear and integer programming","linear constraints","linear integer programming problem","linear program in its standard form","linear programmeren","linear programming algorithms","linear programming duality","linear programming model","linear programming optimization problem","linear programming problem","linear programming wikipedia the free encyclopedia","linear programming with integer unknowns","linear programming,","linear programming.","linear solver","linear-integer","linear-programming","lineare Optimierung","lineare Programmierung","linearen Optimierung","linearen Programmen","linearer Optimierung","linearer Optimierungsprobleme","linearer Programmierung","lineares Programm","linearly constrained optimization","linearno programiranje","linear–inequality constraints","lineer programlamada","lineární programování","lineárního programování","lineárního programování s celočíselnými neznámých","lineárního programování.","lineär programmering","lineær optimering","lineær programmering","lineær programmering med heltal ubekendte","lineêre programmering","linjärt program","list of solvers","lập trình tuyến tính","lập trình tuyến tính.","math programming","mixed integer","mixed integer programming (MIP)","mixed integer programs","mixed-integer program","mixed-integer programming","multi-variable functions","n augmented form","nl:Lineair programmeren","número entero de programación lineal","o en Berkley. Bell","of integer programming","of the linear programming","ograniczenia liczby całkowitej jest NP-zupełny","omezením celé číslo je NP-úplný","on closer inspection","one-norm solvers","optimally","optimisation linéaire","optimisation linéaire en nombres entiers","packing and covering LPs","padre de la programación lineal","passenden Artikel.","pemrograman linear","pemrograman linier wikipedia bahasa indonesia ensiklopedia","pl:Programowanie liniowe","problema lineal","program linear","program linier","programa lineal","programa linear","programacion lineal","programació lineal","programación Lineal","programación entera","programación lineal","programación lineal wikipedia la enciclopedia libre","programarea liniara","programação linear inteira","programação matemática","programma lineare","programmation linéaire","programmation linéaire en nombres entiers","programmazione lineare","programmazione lineare intera","programmazione lineare misto-intera","programme linéaire","programowania liniowego","programowania liniowego (to klasa problemów programowania matematycznego, w","programowania liniowego z niewiadomych liczbą całkowitą","programowanie liniowe","programowaniu liniowym","pt:Programação linear","pure integer programming","pure linear programs","quy hoạch tuyến tính","quy hoạch tuyến tính.","r linear programming","ru:Линейное программирование","s entr","sa guhit programming","scn:Prugrammazzioni liniàri","several solvers","sh:Linearno programiranje","sl:Linearno programiranje","solve for an optimal trade-off","sr:Линеарно програмирање","stran Wikipedie za 'Linearno programiranje'","strong duality theorem","sv:LP-problem","sv:Linjärprogrammering","texto para probar","th:กำหนดการเชิงเส้น","the linear ones","tr.wikipedia.org/wiki/Do%C4%9Frusal_programlama","tr:Doğrusal programlama","uk:Лінійне програмування","ur:لکیری برمجہ","van lineaire programmering","vi:Quy hoạch tuyến tính","vincoli di numero intero è NP-completo","w Wikipedii integer programowania liniowego","wiki:Линейное_программирование","wp:Linear programming","zh:线性规划","Çözücüler ve Scripting (Programlama) Dilleri","Şu örnekte","Γραμμικό Προγραμματισμό","Γραμμικός Προγραμματισμός","Википедии статью Целочисленное программирование","Википедия на целочисленного линейного программирования","Задача лінійного програмування","Линейное программирование","Линейное программирование — Википедия","Линейное программирование — теории и методам решения экстремальных задач","Линейное программирование. Материал из Википедии — свободной энциклопедии","Лінійне програмування","Ссылка на статью по мат. программированию","Ф в ж з джг ж бго з","Целочисленное программирование","задача линейного программирования","задача оптимізації з","задачи линейного программирования","задачи линейной оптимизации","линейного программирования","линейного программирования.","линейное программирование","линейной проблемы","линейном программировании","линейному программированию","лінійне програмування","лінійного","набора условий и функции цели","описание симплекс-метода","теории программирования","целочисленного","целочисленного линейного программирования","целочисленного программирования","целым ограничений NP-полной","ויקיפדיה - 'תכנון לינארי'","ליניארי","תכנון לינארי","תכנון לינארי – ויקיפדיה","תכנות ליניארי","البرمجة الخطية","برنامه ریزی خطی","برنامهریزی خطی","برنامهریزی خطی - ویکیپدیا","لينك ويكي پديا درباره برنامه ريزي خطي","لکیری برمجہ","لکیری برمجہ - وکیپیڈیا","रैखिक प्रोग्रामिंग","विकिपीडिया के पूर्णांक रैखिक प्रोग्रामिंग","การ โปรแกรม เชิง เส้น.","กำหนดการเชิงเส้น","กำหนดการเชิงเส้น - วิกิพีเดีย","ตัวเลข () กำหนดการเชิงเส้น","โปรแกรม เชิง เส้น.","โปรแกรมเชิงเส้น","「線形計画問題」をWikipediaで調べる","「線形計画法」についてWikipediaで調査","「線形計画法」をWikipediaで調べる","と解決","のテクニックを","プログラミング線形ウィキペディアは整数","リニアプログラミング","对偶原理","整数制約がNP完全である","整数線形計画法の","整数约束的NP完全问题","整数线性规划百科","整数规划","整数計画法","整数）線形計画法。","整數規劃","維基百科的文章“ 整数规划”","維基百科的文章“ 線性規劃”","維基百科的文章“ 线性规划”","線型計画問題","線型計画問題-wikipedia","線形計画","線形計画問題","線形計画問題 - Wikipedia","線形計画問題 – Wikipedia","線形計画問題-wikipedia","線形計画法","線形計画法 - Wikipedia","線形計画法-wikipedia","線形計画法を","線性編程","線性規劃","線性規劃- 維基百科，自由的百科全書","线性编程","线性规划","线性规划- 维基百科，自由的百科全书","维基百科的文章“ 整数规划”","维基百科的文章“ 線性規劃”","维基百科的文章“ 线性规划”","선형 계획법","선형 프로그래밍","선형 프로그램","선형계획법","위키 피 디아 문서 선형 계획법","정수계획법 (IP)","＃Integer_unknownsをhttp://en.wikipedia.org/wiki/Mixed_integer_programming","＃アルゴリズムをhttp://en.wikipedia.org/wiki/Linear_programming~~ROOT","（整数）线性规划","（整數）線性規劃","𝐜 𝐓 𝐱"],"name":"Linear programming","categories":["All articles needing additional references","Articles containing Russian-language text","Articles needing additional references from October 2015","Convex optimization","Geometric algorithms","Linear programming","Mathematical and quantitative methods (economics)","Operations research","P-complete problems","Unsolved problems in computer science","Wikipedia external links cleanup from August 2010","Wikipedia spam cleanup from August 2010"],"tag_line":"Linear programming (LP; also called linear optimization) is a method to achieve the best outcome (such as maximum profit or lowest cost) in a mathematical model whose requirements are represented by linear relationships."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lloyd's-algorithm","_score":0,"_source":{"description":"In computer science and electrical engineering, Lloyd's algorithm, also known as Voronoi iteration or relaxation, is an algorithm named after Stuart P. Lloyd for finding evenly spaced sets of points in subsets of Euclidean spaces, and partitions of these subsets into well-shaped and uniformly sized convex cells. Like the closely related k-means clustering algorithm, it repeatedly finds the centroid of each set in the partition, and then re-partitions the input according to which of these centroids is closest. However, Lloyd's algorithm differs from k-means clustering in that its input is a continuous geometric region rather than a discrete set of points. Thus, when re-partitioning the input, Lloyd's algorithm uses Voronoi diagrams rather than simply determining the nearest center to each of a finite set of points as the k-means algorithm does.\nAlthough the algorithm may be applied most directly to the Euclidean plane, similar algorithms may also be applied to higher-dimensional spaces or to spaces with other non-Euclidean metrics. Lloyd's algorithm can be used to construct close approximations to centroidal Voronoi tessellations of the input, which can be used for quantization, dithering, and stippling. Other applications of Lloyd's algorithm include smoothing of triangle meshes in the finite element method.","alt_names":["Lloyd's Algorithm","Lloyd's algorithm","- Lloyd's algorithm :","- Voronoi iteration :","Algorithme de Lloyd Max","Algorithme de Lloyd-Max","Lloyd algorithm","Lloyd relaxation","Lloyd&#39;s algorithm - Wikipedia, the free encyclopedia","Lloyd's Method I algorithm","Lloyd's algorithm - Wikipedia :: The free encyclopedia","Lloyd's algorithm - Wikipedia, the free encyclopedia","Lloyd's algorithm by Wikipedia","Lloyd's k-means algorithm","Lloyd's method","Lloyd's_algorithm","Lloyds algorithm","Lloyds algorithms","Voronoi iteration","Wikipedia (Lloyd's algorithm)","Wikipedia article Algorithme de Lloyd-Max","Wikipedia article Lloyd's algorithm","Wikipedia article Voronoi iteration","Wikipedia article about Lloyd's algorithm","Wikipedia:Lloyd's_algorithm","en.wikipedia.org/wiki/Lloyd's_algorithm","http://en.wikipedia....d%27s_algorithm","http://en.wikipedia.org/wiki/Lloyd%27s_algorithm","http://en.wikipedia.org/wiki/Lloyd's algorithm","http://en.wikipedia.org/wiki/Lloyd's_algorithm","http://en.wikipedia.org/wiki/Voronoi_iteration","http://fr.wikipedia.org/wiki/Algorithme_de_Lloyd-Max","l'algorithme de quantification de Lloyd-Max","ur:لائیڈ الخوارزم","wikipedia:Lloyd's algorithm","релаксации Ллойда","لائیڈ الخوارزم"],"name":"Lloyd's algorithm","categories":["Geometric algorithms","Mathematical optimization"],"tag_line":"In computer science and electrical engineering, Lloyd's algorithm, also known as Voronoi iteration or relaxation, is an algorithm named after Stuart P. Lloyd for finding evenly spaced sets of points in subsets of Euclidean spaces, and partitions of these subsets into well-shaped and uniformly sized convex cells."}}
,{"_index":"throwtable","_type":"algorithm","_id":"largest-empty-rectangle","_score":0,"_source":{"description":"In computational geometry, the largest empty rectangle problem, maximal empty rectangle problem or maximum empty rectangle problem, is the problem of finding a rectangle of maximal size to be placed among obstacles in the plane. There are a number of variants of the problem, depending on the particularities of this generic formulation, in particular, depending on the measure of the \"size\", domain (type of obstacles), and the orientation of the rectangle.\nThe problems of this kind arise e.g., in electronic design automation, in design and verification of physical layout of integrated circuits.\nA maximal empty rectangle (MER) is a rectangle which is not contained in another empty rectangle. Each side of a MER abuts an obstacle (otherwise the side may be shifted outwards, increasing the empty rectangle). An application of this kind is enumeration of \"maximal white rectangles\" in image segmentation R&D of image processing and pattern recognition. In the contexts of many algorithms for largest empty rectangles, \"maximal empty rectangles\" are candidate solutions to be considered by the algorithm, since it is easily proven that, e.g., a maximum-area empty rectangle is a maximal empty rectangle.\n^ \n^ Search Google Scholar for \"largest empty rectangle\" term usageDo not use Template:Google scholar cite in articles as Google links are not appropriate for an encyclopedia\n^ Search Google Scholar for \"maximal empty rectangle\" term usageDo not use Template:Google scholar cite in articles as Google links are not appropriate for an encyclopedia\n^ Search Google Scholar for \"maximum empty rectangle\" term usageDo not use Template:Google scholar cite in articles as Google links are not appropriate for an encyclopedia\n^ Jeffrey Ullman (1984). \"Ch.9: Algorithms for VLSI Design Tools\". Computational Aspects of VLSI. Computer Science Press. ISBN 0-914894-95-1.  describes algorithms for polygon operations involved in electronic design automation (design rule checking, circuit extraction, placement and routing).\n^ Baird, H. S., Jones, S. E., Fortune, S.J. (1990). \"Image segmentation by shape-directed covers\". Proc. 10th International Conference on Pattern Recognition 1: 820–825. doi:10.1109/ICPR.1990.118223.","alt_names":["Largest empty rectangle","Largest empty rectangle - Wikipedia, the free encyclopedia","Largest empty rectangle Wikipedia the free encyclopedia","Maximal empty rectangle","Maximum empty rectangle","What is classification of Largest empty rectangle","Wikipedia article Largest empty rectangle","Wikipedia entry for Largest empty rectangle","http://en.wikipedia.org/wiki/Largest empty rectangle","http://en.wikipedia.org/wiki/Largest_empty_rectangle"],"name":"Largest empty rectangle","categories":["Geometric algorithms"],"tag_line":"In computational geometry, the largest empty rectangle problem, maximal empty rectangle problem or maximum empty rectangle problem, is the problem of finding a rectangle of maximal size to be placed among obstacles in the plane."}}
,{"_index":"throwtable","_type":"algorithm","_id":"planar-straight-line-graph","_score":0,"_source":{"description":"Planar straight-line graph (PSLG) is a term used in computational geometry for an embedding of a planar graph in the plane such that its edges are mapped into straight line segments. Fáry's theorem (1948) states that every planar graph has this kind of embedding.\nIn computational geometry PSLGs have often been called planar subdivisions, with an assumption or assertion that subdivisions are polygonal.\nA PSLG without vertices of degree 1 defines a subdivision of the plane into polygonal regions and vice versa. The absence of vertices of degree 1 simplifies descriptions of various algorithms, but it is not essential.\nPSLGs may serve as representations of various maps, e.g., geographical maps in geographical information systems.\nSpecial cases of PSLGs are triangulations (polygon triangulation, point set triangulation). Point set triangulations are maximal PSLGs in the sense that it is impossible to add straight edges to them. Triangulations have numerous applications in various areas.\nPSLGs may be seen as a special kind of Euclidean graphs. However in discussions involving Euclidean graphs the primary interest is their metric properties, i.e., distances between vertices, while for PSLGs the primary interest is the topological properties. For some graphs, such as Delaunay triangulations, both metric and topological properties are of importance.","alt_names":["- Planar straight line graph :","Planar straight line graph","Planar straight-line graph","Planar straight-line graph - Wikipedia :: The free encyclopedia","Planar straight-line graph - Wikipedia, the free encyclopedia","Planar straight-line graph; it is used under","Planar subdivision","Planar_straight-line_graph","Wikipedia article Planar straight line graph","Wikipedia article Planar straight-line graph","Wikipedia article Planar subdivision","Wikipedia article on Planar straight-line graph","Wikipedia entry for Planar straight-line graph","en.wikipedia.org/wiki/Planar_straight...","http://en.wikipedia.org/wiki/Planar_stra","http://en.wikipedia.org/wiki/Planar_straight-line_graph","planar polygonal subdivision","planar straight line graph","planar straight line graphs","planar straight-line graph","planar straight-line graphs","planar subdivision","straight line embedding","گراف مسطح با خطوط مستقیم"],"name":"Planar straight-line graph","categories":["Geometric algorithms","Geometric graphs","Planar graphs"],"tag_line":"Planar straight-line graph (PSLG) is a term used in computational geometry for an embedding of a planar graph in the plane such that its edges are mapped into straight line segments."}}
,{"_index":"throwtable","_type":"algorithm","_id":"nesting-algorithm","_score":0,"_source":{"description":"Nesting algorithms are used to make the most efficient use of material or space by evaluating many different possible combinations via recursion.\nLinear (1-dimensional): The simplest of the algorithms illustrated here. For an existing set there is only one position where a new cut can be placed – at the end of the last cut. Validation of a combination involves a simple Stock - Yield - Kerf = Scrap calculation.\nPlate (2-dimensional): These algorithms are significantly more complex. For an existing set, there may be as many as eight positions where a new cut may be introduced next to each existing cut, and if the new cut is not perfectly square then different rotations may need to be checked. Validation of a potential combination involves checking for intersections between two-dimensional objects.\nPacking (3-dimensional): These algorithms are the most complex illustrated here due to the larger number of possible combinations. Validation of a potential combination involves checking for intersections between three-dimensional objects.\n\n^ a b Herrmann, Jeffrey; Delalio, David. \"Algorithms for Sheet Metal Nesting\" (PDF). IEEE TRANSACTIONS ON ROBOTICS AND AUTOMATION. Retrieved 29 August 2015.","alt_names":["Learn about Nesting algorithm>>>","Nesting algorithm","Nesting algorithm - Wikipedia, the free encyclopedia","Nesting algorithm from Wikipedia","Nesting algorithms","Wikipedia article Nesting algorithm","Wikipedia entry for Nesting algorithm","http://en.wikipedia.org/wiki/Nesting algorithm","http://en.wikipedia.org/wiki/Nesting_alg","http://en.wikipedia.org/wiki/Nesting_algorithm","yago-res:Nesting algorithm"],"name":"Nesting algorithm","categories":["All articles needing additional references","All orphaned articles","All stub articles","Articles needing additional references from September 2015","Geometric algorithms","Orphaned articles from February 2013","Science software stubs"],"tag_line":"Nesting algorithms are used to make the most efficient use of material or space by evaluating many different possible combinations via recursion."}}
,{"_index":"throwtable","_type":"algorithm","_id":"stencil-jumping","_score":0,"_source":{"description":"Stencil jumping, at times called stencil walking, is an algorithm to locate the grid element enclosing a given point for any structured mesh. In simple words, given a point and a structured mesh, this algorithm will help locate the grid element that will enclose the given point.\nThis algorithm finds extensive use in Computational Fluid Dynamics (CFD) in terms of holecutting and interpolation when two meshes lie one inside the other. The other variations of the problem would be something like this: Given a place, at which latitude and longitude does it lie? The brute force algorithm would find the distance of the point from every mesh point and see which is smallest. Another approach would be to use a binary search algorithm which would yield a result comparable in speed to the stencil jumping algorithm. A combination of both the binary search and the stencil jumping algorithm will yield an optimum result in the minimum possible time.","alt_names":["How does it move forward?","Stencil jumping","Stencil jumping - Wikipedia, the free encyclopedia","Stencil jumping from Wikipedia","Wikipedia article Stencil jumping","Wikipedia article about Stencil jumping","Wikipedia entry for Stencil jumping","http://en.wikipedia.org/wiki/Stencil_jum","http://en.wikipedia.org/wiki/Stencil_jumping","yago-res:Stencil jumping"],"name":"Stencil jumping","categories":["All articles with dead external links","Articles with dead external links from October 2010","Geometric algorithms"],"tag_line":"Stencil jumping, at times called stencil walking, is an algorithm to locate the grid element enclosing a given point for any structured mesh."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bowyer–watson-algorithm","_score":0,"_source":{"description":"In computational geometry, the Bowyer–Watson algorithm is a method for computing the Delaunay triangulation of a finite set of points in any number of dimensions. The algorithm can be used to obtain a Voronoi diagram of the points, which is the dual graph of the Delaunay triangulation.\nThe Bowyer–Watson algorithm is an incremental algorithm. It works by adding points, one at a time, to a valid Delaunay triangulation of a subset of the desired points. After every insertion, any triangles whose circumcircles contain the new point are deleted, leaving a star-shaped polygonal hole which is then re-triangulated using the new point. By using the connectivity of the triangulation to efficiently locate triangles to remove, the algorithm can take O(N log N) operations to triangulate N points, although special degenerate cases exist where this goes up to O(N2).\nThe algorithm is sometimes known just as the Bowyer Algorithm or the Watson Algorithm. Adrian Bowyer and David Watson devised it independently of each other at the same time, and each published a paper on it in the same issue of The Computer Journal (see below).","alt_names":[],"name":"Bowyer–Watson algorithm","categories":["Geometric algorithms"],"tag_line":"In computational geometry, the Bowyer–Watson algorithm is a method for computing the Delaunay triangulation of a finite set of points in any number of dimensions."}}
,{"_index":"throwtable","_type":"algorithm","_id":"proximity-problems","_score":0,"_source":{"description":"Proximity problems is a class of problems in computational geometry which involve estimation of distances between geometric objects.\nA subset of these problems stated in terms of points only are sometimes referred to as closest point problems, although the term \"closest point problem\" is also used synonymously to the nearest neighbor search.\nA common trait for many of these problems is the possibility to establish the Θ(n log n) lower bound on their computational complexity by reduction from the element uniqueness problem basing on an observation that if there is an efficient algorithm to compute some kind of minimal distance for a set of objects, it is trivial to check whether this distance equals to 0.","alt_names":["Atomic problems","Closest point problems","Closest points","Learn about Proximity problems>>>","Problems on points","Proximity Problems","Proximity problem","Proximity problems","Proximity problems - Wikipedia, the free encyclopedia","Proximity problems: Problems on points","Wikipedia article Proximity problem","Wikipedia article Proximity problems","Wikipedia article on Proximity problem","Wikipedia entry for Proximity problems","closest point problems","closest points","http://en.Liarpedia.org/wiki/Proximity_problems","http://en.wikipedia.org/wiki/Proximity_problems","proximity problem","proximity problems"],"name":"Proximity problems","categories":["Geometric algorithms"],"tag_line":"Proximity problems is a class of problems in computational geometry which involve estimation of distances between geometric objects."}}
,{"_index":"throwtable","_type":"algorithm","_id":"painter's-algorithm","_score":0,"_source":{"description":"The painter's algorithm, also known as a priority fill, is one of the simplest solutions to the visibility problem in 3D computer graphics. When projecting a 3D scene onto a 2D plane, it is necessary at some point to decide which polygons are visible, and which are hidden.\nThe name \"painter's algorithm\" refers to the technique employed by many painters of painting distant parts of a scene before parts which are nearer thereby covering some areas of distant parts. The painter's algorithm sorts all the polygons in a scene by their depth and then paints them in this order, farthest to closest. It will paint over the parts that are normally not visible — thus solving the visibility problem — at the cost of having painted invisible areas of distant objects. The ordering used by the algorithm is called a 'depth order', and does not have to respect the numerical distances to the parts of the scene: the essential property of this ordering is, rather, that if one object obscures part of another then the first object is painted after the object that it obscures. Thus, a valid ordering can be described as a topological ordering of a directed acyclic graph representing occlusions between objects.\n\nThe algorithm can fail in some cases, including cyclic overlap or piercing polygons. In the case of cyclic overlap, as shown in the figure to the right, Polygons A, B, and C overlap each other in such a way that it is impossible to determine which polygon is above the others. In this case, the offending polygons must be cut to allow sorting. Newell's algorithm, proposed in 1972, provides a method for cutting such polygons. Numerous methods have also been proposed in the field of computational geometry.\nThe case of piercing polygons arises when one polygon intersects another. As with cyclic overlap, this problem may be resolved by cutting the offending polygons.\nIn basic implementations, the painter's algorithm can be inefficient. It forces the system to render each point on every polygon in the visible set, even if that polygon is occluded in the finished scene. This means that, for detailed scenes, the painter's algorithm can overly tax the computer hardware.\nA reverse painter's algorithm is sometimes used, in which objects nearest to the viewer are painted first — with the rule that paint must never be applied to parts of the image that are already painted (unless they are partially transparent). In a computer graphic system, this can be very efficient, since it is not necessary to calculate the colors (using lighting, texturing and such) for parts of the more distant scene that are hidden by nearby objects. However, the reverse algorithm suffers from many of the same problems as the standard version.\nThese and other flaws with the algorithm led to the development of Z-buffer techniques, which can be viewed as a development of the painter's algorithm, by resolving depth conflicts on a pixel-by-pixel basis, reducing the need for a depth-based rendering order. Even in such systems, a variant of the painter's algorithm is sometimes employed. As Z-buffer implementations generally rely on fixed-precision depth-buffer registers implemented in hardware, there is scope for visibility problems due to rounding error. These are overlaps or gaps at joins between polygons. To avoid this, some graphics engine implementations \"overrender\", drawing the affected edges of both polygons in the order given by painter's algorithm. This means that some pixels are actually drawn twice (as in the full painter's algorithm) but this happens on only small parts of the image and has a negligible performance effect.","alt_names":["закрашивающего алгоритма","painter's algorithm","Painter's algorithm - Wikipedia, the free encyclopedia","Painter's algorithm","-> Read the article about 'Painter's algorithm'","...Wikipedia Algorithme du peintre","...Wikipedia Algoritmo del pintor","...Wikipedia Algoritmo do Pintor","...Wikipedia Algorytm malarza","...mehr auf Wikipedia über Maleralgorithmus","Algorithme du peintre","Algorithme du peintre - Wikipédia","Algoritmo del pintor","Algoritmo del pintor - Wikipedia, la enciclopedia libre","Algoritmo del pittore","Algoritmo del pittore - Wikipedia","Algoritmo do pintor","Algorytm malarza","Algorytm malarza – Wikipedia, wolna encyklopedia","Learn about Painter's algorithm>>>","Maleralgorithmus","Maleralgorithmus (Wikipedia)","Maleralgorithmus – Wikipedia","Painter 's algorithm","Painter algorithm","Painter s algorithm - Wikipedia, the free encyclopedia","Painter 算法","Painter%27s_algorithm","Painter&#39;s algorithm - Wikipedia, the free encyclopedia","Painter's Algorithm","Painter's Algorithm.","Painter's Algorithmus - Wikipedia","Painter's algorithm - Wikipedia :: The free encyclopedia","Painter's algorithm - Wikipedia, the free ...","Painter's algorithm from Wikipedia","Painter's algorithm.","Painter's_algorithm","Painters Algorithm","Painters Algorithmus»","Painters algorithm","Painters algorithm???","Painters algoritm","Schildersalgoritme","Schildersalgoritme - Wikipedia","The Painter's Algorithm Problem","The painter's problem","Tuo tapa","Wikipedia article Algorithme du peintre","Wikipedia article Algoritmo do pintor","Wikipedia article Algorytm malarza","Wikipedia article Painter's algorithm","Wikipedia article Painters algorithm","Wikipedia article on Algoritmo del pintor","Wikipedia article Նկարչի ալգորիթմ","Wikipedia l'articolo Algoritmo del pittore","Wikipedia-Artikel Maleralgorithmus","Wikipedia-Artikel Painter's Algorithmus","Wikipedia: Painter's algorithm","Wikipediaで「Zソート法」を調べる","Zソート法 - Wikipedia","Zソート法（ペインターズアルゴリズム）","a common analogy","algorithme du peintre","algoritmo del pintor","algoritmo del pittore","algoritmo do pintor","algorytm malarza","algorytmu malarza","algorítmo del pintor","article Painter's algorithm","artigo da Wikipédia Algoritmo do Pintor","artículo de Wikipedia Algoritmo del pintor","draw your scene back to front","en.wikipedia.org/wiki/Painter%27s_algorithm","en.wikipedia.org/wiki/Painter's_algorithm","en:Painter's algorithm","from back to front","http://de.wikipedia.org/wiki/Maleralgori","http://de.wikipedia.org/wiki/Maleralgorithmus","http://en.wikipedia.org/wiki/Painter%27s_algo...","http://en.wikipedia.org/wiki/Painter%27s_algorith","http://en.wikipedia.org/wiki/Painter%27s_algorithm","http://en.wikipedia.org/wiki/Painter%27s_algorithm...","http://en.wikipedia.org/wiki/Painter%27s…","http://en.wikipedia.org/wiki/Painter's_a","http://en.wikipedia.org/wiki/Painter's_algorithm","http://en.wikipedia.org/wiki/Painters_algorithm","http://es.wikipedia.org/wiki/Algoritmo_del_pintor","http://fr.wikipedia.org/wiki/Algorithme_du_peintre","http://it.wikipedia.org/wiki/Algoritmo_del_pittore","http://nl.wikipedia.org/wiki/Schildersalgoritme","http://pl.wikipedia.org/wiki/Algorytm_malarza","http://pl.wikipedia.org/wiki/Algorytm_malaża","hy:Նկարչի ալգորիթմ","it:Algoritmo del pittore","ja:画家のアルゴリズム","l'algorithme du peintre","l'algoritmo di pittore","malíři algoritmus","painter algorithm","painter%27s_algorithm","painter's algorithm,","painter's problem","painters algorithm","pt:Algoritmo do pintor","schilder-algoritme","schildersalgoritme","see the all-knowing trash heap","something less efficent like this","the Painter's Algorithm","the painter's algorithm","zh:画家算法","Алгоритм художника","алгоритм художника","алгоритму художника","Նկարչի ալգորիթմ","ಬಣ್ಣಗಾರನ ಕ್ರಮಾವಳಿ","油画家算法","画家のアルゴリズム","画家のアルゴリズム - Wikipedia","画家のアルゴリズムを","画家のｱﾙｺﾞﾘｽﾞﾑ-wikipedia","画家算法","画家算法(Painter's Algorithm)","画家算法- 维基百科，自由的百科全书","維基百科的文章“ 画家算法”","维基百科的文章“ 画家算法”","陰面処理"],"name":"Painter's algorithm","categories":["3D computer graphics","All articles with unsourced statements","Articles with unsourced statements from January 2008","Commons category with local link same as on Wikidata","Computer graphics algorithms"],"tag_line":"The painter's algorithm, also known as a priority fill, is one of the simplest solutions to the visibility problem in 3D computer graphics."}}
,{"_index":"throwtable","_type":"algorithm","_id":"line-drawing-algorithm","_score":0,"_source":{"description":"A line drawing algorithm is a graphical algorithm for approximating a line segment on discrete graphical media. On discrete media, such as pixel-based displays and printers, line drawing requires such an approximation (in nontrivial cases). Basic algorithms rasterize lines in one color. A better representation with multiple color gradations requires an advanced process, anti-aliasing.\nOn continuous media, by contrast, no algorithm is necessary to draw a line. For example, oscilloscopes use natural phenomena to draw lines and curves.\nThe Cartesian slope-intercept equation for a straight line is  With m representing the slope of the line and b as the y intercept. Given that the two endpoints of the line segment are specified at positions  and . we can determine values for the slope m and y intercept b with the following calculations,  so, .\n\n","alt_names":["% Http://en.wikipedia.org/wiki/Line 5Fdrawing% 5Falgorithm","- Line drawing algorithm :","...Wikipedia Algorithme de tracé de segment","...Wikipedia Algoritmo di rasterizzazione di linea","...Wikipedia Algoritmo di rasterizzazione di poligono","...more on Wikipedia about Line drawing algorithm","A naïve line-drawing algorithm","Algorithme de tracé de segment","Algorithme de tracé de segment - Wikipédia","Algoritmi za crtanje linija","Algoritmo di rasterizzazione di linea","Algoritmo di rasterizzazione di linea - Wikipedia","DDA – Algorithmen","Il problema si complica nel caso di poligoni","Line Drawing","Line Drawing Algorithm","Line drawing algorithm","Line drawing algorithm - Wikipedia, the free ...","Line drawing algorithm - Wikipedia, the free encyclopedia","Line drawing algorithm Wikipedia the free encyclopedia","Line drawing algorithm from Wikipedia","Line drawing algorithm; it is used under the","Linien-Algorithmus","Linjetegningsalgoritme","Rastern von Linien","Rastern von Linien (de)","Rastern von Linien - Wikipedia","Rasterung v Linien","Rasterung von Linien","Rasterung von Linien - Wikipedia","Rasterung von Linien ? Wikipedia","Rasterung von Linien Wikipedia","Rasterung von Linien – Wikipedia","Rasterung_von_Linien","Screenshot http://de.wikipedia.org/wiki/Rasterung_von_Linien","Von links nach rechts: Kein Antialiasing (Bresenham), Gupta","Wikipedia (Line drawing algorithm)","Wikipedia article Algorithme de tracé de segment","Wikipedia article Line drawing algorithm","Wikipedia entry for Line drawing algorithm","Wikipedia sur Algorithme de tracé de segment","Wikipedia-Artikel Rastern von Linien","Wikipedia-Artikel Rasterung von Linien","Wikipedia-Seite zu 'Rasterung von Linien'","Wikipedia: Rastern von Linien (Strecken, Bögen)","Wikipedia:Algoritmo_di_rasterizzazione_di_poligono","algoritmo di rasterizzazione di linea","ar:خوارزمية رسم مستقيم","bs:Algoritmi za crtanje linija","de:Rastern von Linien","de:Rasterung von Linien","de:Rasterung_von_Linien","en.wikipedia.org/wiki/Line_drawing_al...","http://bs.wikipedia.org/wiki/Algoritmi_za_crtanje_linija","http://de.wikipedia.org/wiki/Rastern_von_Linien","http://de.wikipedia.org/wiki/Rasterung_von_Linien","http://en.wikipedia.org/wiki/Line% 5Fdrawing% 5Falgorithm","http://en.wikipedia.org/wiki/Line%5Fdrawing%5Falgorithm","http://en.wikipedia.org/wiki/Line_drawing_algorithm","http://en.wikipedia.org/wiki/Line％5Falgorithm 5Fdrawing","http://en.wikipedia.org/wiki/Line％5Fdrawing％5Falgorithm","http://fr.wikipedia.org/wiki/Algorithme_de_trac%C3%A9_de_segment","http://it.wikipedia.org/wiki/Algorit...zione_di_linea","http://it.wikipedia.org/wiki/Algoritmo_di_rasterizzazione_di_linea","http://it.wikipedia.org/wiki/Algoritmo_di_rasterizzazione_di_linea#Rasterizzazione_di_poligono","http://ru.wikipedia.org/wiki/Алгоритмы_построения_отрезка","it:Algoritmo_di_rasterizzazione_di_linea","no:Linjetegningsalgoritme","rasterizza","ru:Алгоритмы построения отрезка","Алгоритам за исцртавање линија","Алгоритмы построения отрезка","Википедия - построение отрезка","Растеризация отрезков на Википедии","двумерного растра нужно закрасить, чтобы получить близкое приближение","двумерного растра нужно закрасить, чтобы получить наиболее точную","خوارزميات رسم المستقيم","خوارزمية رسم مستقيم"],"name":"Line drawing algorithm","categories":["All articles to be expanded","Articles to be expanded from December 2009","Computer graphics algorithms","Featured articles needing translation from German Wikipedia","Science articles needing translation from German Wikipedia"],"tag_line":"A line drawing algorithm is a graphical algorithm for approximating a line segment on discrete graphical media."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ray-casting","_score":0,"_source":{"description":"Ray casting is the use of ray–surface intersection tests to solve a variety of problems in computer graphics and computational geometry. The term was first used in computer graphics in a 1982 paper by Scott Roth to describe a method for rendering constructive solid geometry models.\nRay casting can refer to a variety of problems and techniques:\nthe general problem of determining the first object intersected by a ray,\na technique for hidden surface removal based on finding the first intersection of a ray cast from the eye through each pixel of an image,\na non-recursive ray tracing rendering algorithm that only casts primary rays, or\na direct volume rendering method, also called volume ray casting, in which the ray is \"pushed through\" the object and the 3D scalar field of interest is sampled along the ray inside the object. No secondary rays are spawned in this method.\nAlthough \"ray casting\" and \"ray tracing\" were often used interchangeably in early computer graphics literature, more recent usage tries to distinguish the two. The distinction is that ray casting is a rendering algorithm that never recursively traces secondary rays, whereas other ray tracing-based rendering algorithms may do so.","alt_names":["VoxelSpace","ray casting","Ray Casting","Raycasting","raycasting","Ray casting","- Ray casting :","- Raycasting :","Grundlegende Idee ist, wie Volumendaten mit Hilfe des","Indirekte Verfahren visualisieren das Volumen mit Hilfe einer","Pesquisar ray casting na Wikipedia Portugal","RAY-CASTING","Ray Casting on Wikipedia","Ray casting - Wikipedia, the free encyclopedia","Ray casting - Wikipédia, a enciclopédia livre","Ray casting in computer games","Ray casting – Wikipédia, a enciclopédia livre","Ray casting; it is used under the","Ray shooting","Ray-Casting","Ray-Casting Wikipedia","Ray-casting","RayCasters","RayCasting","RayCasting del original","Ray_casting","Raycast","Raycaster","Raycasters","Raycasting (de)","Raycasting - Wikipédia","Raycasting ? Wikipedia","Raycasting at Wikipedia","Raycasting – Wikipedia","Raycasting,","Raycasting.","Raycasting:","The build Engine uses raycasting as well.","The mechanics behind ray casting","What is the concept of Ray casting","Wikipedia article Ray casting","Wikipedia article Ray-casting","Wikipedia article Raycasting","Wikipedia article on Ray casting","Wikipedia article on Raycasting","Wikipedia entry for Ray casting","Wikipedia on Ray casting","Wikipedia-Artikel Raycasting","Wikipedia-Seite zu 'Raycasting'","Wikipedia:Ray casting","Wikipédia artigo Ray casting","brute force raycasting","de.wikipedia.org/wiki/Raycasting","de:Raycasting","en.wikipedia.org/wiki/Ray_casting","en.wikipedia.org/wiki/Raycasting","fr:Raycasting","http://bs.wikipedia.org/wiki/Ray_Casting","http://de.wikipedia.org/wiki/Raycasting","http://de.wikipedia.org/wiki/Raycasting#Raycasting_bei_Computerspielen","http://de.wikipedia.org/wiki/Volume_rendering","http://en.wikipedia....iki/Ray_casting","http://en.wikipedia....wiki/Raycasting","http://en.wikipedia.org/w...sting","http://en.wikipedia.org/wiki/Ray-casting","http://en.wikipedia.org/wiki/Ray_castin","http://en.wikipedia.org/wiki/Ray_casting","http://en.wikipedia.org/wiki/Ray_casting#Doom","http://en.wikipedia.org/wiki/Ray_casting#Duke_Nukem_3d","http://en.wikipedia.org/wiki/Ray_casting.","http://en.wikipedia.org/wiki/Ray_casting;","http://en.wikipedia.org/wiki/Raycasting","http://en.wikipedia.org/wiki/Raycasting#Duke_Nukem_3d","http://fr.wikipedia.org/wiki/Raycasting","http://pl.wikipedia.org/wiki/Ray casting","http://pl.wikipedia.org/wiki/Ray_casting","http://pt.wikipedia.org/wiki/Ray_casting","http://ru.wikipedia....iki/Ray_casting","http://ru.wikipedia.org/wiki/Ray_casting","l'article de Wikipédia Raycasting","lancer de rayons primaires","pl:Ray casting","pt:Ray casting","ray cast engines","ray casteria","ray casting -algoritmi Wolfenstein 3-D:n tyylillä","ray casting at Wikipedia","ray shooting","ray-caster","ray-casting","ray-casting engine","ray_casting","raycaster","raycasting engines","raycastingu","ru.wikipedia.org/wiki/Ray_casting","ru:Ray casting","ttp://de.wikipedia.org/wiki/Raycasting,","voilà, satisfait ?","w:Ray casting","wikipedia :: Ray casting","» Raycasting","Википедии статью Ray casting","РейКаст","Рейкастинг","рейкастинг","рэй-кастинга","рэйкастинга","レイキャスティング","光線投射","光线投射"],"name":"Ray casting","categories":["All articles to be expanded","Articles to be expanded from May 2010","CS1 errors: chapter ignored","Computer graphics algorithms"],"tag_line":"Ray casting is the use of ray–surface intersection tests to solve a variety of problems in computer graphics and computational geometry."}}
,{"_index":"throwtable","_type":"algorithm","_id":"scanline-rendering","_score":0,"_source":{"description":"Scanline rendering is an algorithm for visible surface determination, in 3D computer graphics, that works on a row-by-row basis rather than a polygon-by-polygon or pixel-by-pixel basis. All of the polygons to be rendered are first sorted by the top y coordinate at which they first appear, then each row or scanline of the image is computed using the intersection of a scanline with the polygons on the front of the sorted list, while the sorted list is updated to discard no-longer-visible polygons as the active scan line is advanced down the picture.\nThe main advantage of this method is that sorting vertices along the normal of the scanning plane reduces the number of comparisons between edges. Another advantage is that it is not necessary to translate the coordinates of all vertices from the main memory into the working memory—only vertices defining edges that intersect the current scan line need to be in active memory, and each vertex is read in only once. The main memory is often very slow compared to the link between the central processing unit and cache memory, and thus avoiding re-accessing vertices in main memory can provide a substantial speedup.\nThis kind of algorithm can be easily integrated with many other graphics techniques, such as the Phong reflection model or the Z-buffer algorithm.","alt_names":["- Scanline rendering :","-> Read the article about 'Scanline rendering'",". Categories walls.","...mehr auf Wikipedia über Scanline Rendering","...mehr auf Wikipedia über Scanline-Algorithmus","...more on Wikipedia about Scanline rendering","4 Use in realtime rendering","5 Similar techniques","6 Comparison with Z-buffer algorithm",": Scanline renderin","Explanation of scanline algorithm","Explicação do algoritmo scanline","Learn about Scanline rendering>>>","Pyyhkäisyviivarenderointi","Rendu scanline","S-Buffer","Scan line rendering","Scan-line renderer","Scan-line rendering","Scan-line_renderer","Scanline Renderer","Scanline Rendering","Scanline Rendering - Wikipedia","Scanline Rendering Engine","Scanline algorithm","Scanline algorithms","Scanline renderer","Scanline rendering","Scanline rendering - Wikipedia, la enciclopedia libre","Scanline rendering - Wikipedia, the free encyclopedia","Scanline rendering Wikipedia the free encyclopedia","Scanline rendering; it is used under the","Scanline-Algorithmus","Scanline-Algorithmus - Wikipedia","Scanline-Algorithmus ? Wikipedia","Scanline-Algorithmus – Wikipedia","Scanline-Rendering","Scanline_Rendering","Scanline_rendering","Use in realtime rendering","What variants of Scanline rendering are there","Wikipedia article Rendu scanline","Wikipedia article Scan-line renderer","Wikipedia article Scanline rendering","Wikipedia article on Scanline Rendering","Wikipedia article on Scanline rendering","Wikipedia entry for Scanline rendering","Wikipedia-Artikel Scanline Rendering","Wikipedia-Artikel Scanline-Algorithmus","Wikipedia-Seite zu 'Scanline-Algorithmus'","Wikipedia: Scanline Rendering","artículo de Wikipedia Scanline Rendering","artículo de Wikipedia Scanline rendering","de:Scanline Rendering","de:Scanline-Algorithmus","en.wikipedia.org/wiki/Scanline_rendering","es:Scanline rendering","fi:Pyyhkäisyviiva-renderointi","fi:Pyyhkäisyviivarenderointi","fr:Rendu scanline","http://de.wikipedia.org/wiki/Scanline-Al","http://de.wikipedia.org/wiki/Scanline-Algorithmus","http://de.wikipedia.org/wiki/Scanline_Rendering","http://en.Liarpedia.org/wiki/Scanline_rendering","http://en.wikipedia....nline_rendering","http://en.wikipedia.org/wiki/Scanline_re","http://en.wikipedia.org/wiki/Scanline_rendering","http://en.wikipedia.org/wiki/Scanline_rendering#Use_in_Realtime_Rendering","http://es.wikipedia.org/wiki/Scanline_Rendering","http://es.wikipedia.org/wiki/Scanline_rendering","http://fr.wikipedia.org/wiki/Rendu_scanline","l'article de Wikipédia Rendu scanline","polygon-fill algorithm","scan line rendering","scan-line rasterizeris","scan-line renderer","scanline algorithm","scanline algorithms","scanline conversion","scanline renderers","scanline rendering","scanline, scanline, and more scanlines","uk:Алгоритм Scanline","uk:Алгоритм «Scanline»","zh:扫描线渲染","сканлайновой","扫描线渲染","掃描線渲染","維基百科的文章“ 扫描线渲染”"],"name":"Scanline rendering","categories":["3D rendering","All articles with unsourced statements","Articles with unsourced statements from November 2015","Computer graphics algorithms","Optics"],"tag_line":"Scanline rendering is an algorithm for visible surface determination, in 3D computer graphics, that works on a row-by-row basis rather than a polygon-by-polygon or pixel-by-pixel basis."}}
,{"_index":"throwtable","_type":"algorithm","_id":"jon-bentley","_score":0,"_source":{"description":"Jon Louis Bentley (born February 20, 1953 in Long Beach, California) is an American computer scientist who is credited with the heuristic based partitioning algorithm k-d tree.\nBentley received a B.S. in mathematical sciences from Stanford University in 1974, and M.S. and Ph.D in 1976 from the University of North Carolina at Chapel Hill; while a student, he also held internships at the Xerox Palo Alto Research Center and Stanford Linear Accelerator Center. After receiving his Ph.D., he joined the faculty at Carnegie Mellon University as an assistant professor of computer science and mathematics. At CMU, his students included Brian Reid, John Ousterhout, Jeff Eppinger, Joshua Bloch, and James Gosling, and he was one of Charles Leiserson's advisors. Later, Bentley moved to Bell Laboratories.\nHe found an optimal solution for the two dimensional case of Klee's measure problem: given a set of n rectangles, find the area of their union. He and Thomas Ottmann invented the Bentley–Ottmann algorithm, an efficient algorithm for finding all intersecting pairs among a collection of line segments. He wrote the Programming Pearls column for the Communications of the ACM magazine, and later collected the articles into two books of the same name.\nBentley received the Dr. Dobb's Excellence in Programming award in 2004.","alt_names":["...more on Wikipedia about Jon Bentley","Bentley, Jon","Bentley, Jon Louis","J Bentley","J.Bentleya","J.L. Bentley","J.L._Bentley","Jon Bentley","Jon Bentley - Programming","Jon Bentley - Wikipe","Jon Bentley - Wikipedia :: The free encyclopedia","Jon Bentley - Wikipedia, la enciclopedia libre","Jon Bentley - Wikipedia, the free ...","Jon Bentley - Wikipedia, the free encyclopedia","Jon Bentley - Wikipedia, the free encyclopedia Jon Louis","Jon Bentley - Wikipedia, the free encyclopedia wikipedia.org","Jon Bentley Wikipedia the free encyclopedia","Jon Bentley in Wikipedia","Jon Bentley on Wikipedia","Jon Bentley quotes on Wikipedia","Jon Bentley – Wikipedia, wolna encyklopedia","Jon Bentley's","Jon Bentleyの","Jon Louis Bentley","Jon_Bentley","Programming Pearls","Programming Pearls - Wikipedia","Programming Pearls w","Read more about Jon Bentley on Wikipedia","Who is Jon Bentley","Who is Jon Bentley?","Wikipedia English - Jon Bentley","Wikipedia article J.L. Bentley","Wikipedia article Jon Bentley","Wikipedia article Programming Pearls","Wikipedia article about Jon Bentley","Wikipedia article on J.L. Bentley","Wikipedia article on Jon Bentley","Wikipedia entry for Jon Bentley","Wikipedia:Jon Bentleys","en.wikipedia.org/wiki/Jon_Bentley","http://en.wikipedia.org/wiki/J.L._Bentley","http://en.wikipedia.org/wiki/Jon Bentley","http://en.wikipedia.org/wiki/Jon_Bentley","http://es.wikipedia.org/wiki/Jon_Bentley","http://pl.wikipedia.org/wiki/Jon_Bentley","on Bentley a","pl:Jon Bentley","wikipedia: ジョン・ベントリー","·Jon Bentley","Джона Бентли","जॉन बेंटले","乔恩宾利"],"name":"Jon Bentley","categories":["1953 births","American computer programmers","American computer scientists","Carnegie Mellon University faculty","Living people","People from Long Beach, California","Researchers in geometric algorithms","Stanford University alumni","University of North Carolina at Chapel Hill alumni","Wikipedia articles with BNF identifiers","Wikipedia articles with ISNI identifiers","Wikipedia articles with LCCN identifiers","Wikipedia articles with VIAF identifiers"],"tag_line":"Jon Louis Bentley (born February 20, 1953 in Long Beach, California) is an American computer scientist who is credited with the heuristic based partitioning algorithm k-d tree."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pierre-rosenstiehl","_score":0,"_source":{"description":"Pierre Rosenstiehl (born 1933) is a French mathematician recognized for his work in graph theory, planar graphs, and graph drawing.\nThe Fraysseix-Rosenstiehl's planarity criterion is at the origin of the left-right planarity algorithm implemented in Pigale software, which is considered as the fastest implemented planarity testing algorithm.\nRosenstiehl was directeur d’études at the École des Hautes Études en Sciences Sociales in Paris, before his retirement. He is co-editor in chief of the European Journal of Combinatorics. Rosenstiehl, Giuseppe Di Battista, Peter Eades and Roberto Tamassia organized in 1992 at Marino (Italy) a meeting devoted to graph drawing which initiated a long series of international conferences, the International Symposia on Graph Drawing.\nHe has been a member of the French literary group Oulipo since 1992. He married the French author and illustrator Agnès Rosenstiehl.","alt_names":["- Pierre Rosenstiehl :","...Wikipedia Agnès Rosenstiehl","AgnÃ¨s Rosenstiehl","Agnès Rosenstiehl","Agnès Rosenstiehl - Wikipédia","Agnès Rosenstiehw","More about Rosenstiehl","Pierre Rosenstiehl","Pierre Rosenstiehl - Wikipedia, the free encyclopedia","Pierre Rosenstiehl - Wikipédia","Pierre Rosenstiehl; it is used under the","Prof. Pierre Rosenstiehl","Rosenstiehl","Rosenstiehl, P.","Rosenstiehl, Pierre","Wikipedia article Pierre Rosenstiehl","Wikipedia article on Pierre Rosenstiehl","Wikipedia entry for Pierre Rosenstiehl","agnès rosenstiehl","en.wikipedia.org/wiki/Pierre_Rosenstiehl","fr.wikipedia.org/...Pierre_Rosenstiehl","ht:Pierre Rosenstiehl","http://en.wikipedia.org/wiki/Pierre Rosenstiehl","http://en.wikipedia.org/wiki/Pierre_Rosenstiehl","http://fr.wikipedia.org/wiki/Agn%C3%A8s_Rosenstiehl","http://fr.wikipedia.org/wiki/Pierre_Rosenstiehl","l'article de Wikipédia Agnès Rosenstiehl","yago-res:Pierre Rosenstiehl","Études en"],"name":"Pierre Rosenstiehl","categories":["1933 births","20th-century mathematicians","21st-century mathematicians","Academic journal editors","All stub articles","Combinatorialists","French male writers","French mathematician stubs","French mathematicians","Graph drawing people","Graph theorists","Living people","Oulipo members","Researchers in geometric algorithms","Wikipedia articles with BNF identifiers","Wikipedia articles with LCCN identifiers","Wikipedia articles with VIAF identifiers"],"tag_line":"Pierre Rosenstiehl (born 1933) is a French mathematician recognized for his work in graph theory, planar graphs, and graph drawing."}}
,{"_index":"throwtable","_type":"algorithm","_id":"velocity-obstacle","_score":0,"_source":{"description":"In robotics and motion planning, a velocity obstacle, commonly abbreviated VO, is the set of all velocities of a robot that will result in a collision with another robot at some moment in time, assuming that the other robot maintains its current velocity. If the robot chooses a velocity inside the velocity obstacle then the two robots will eventually collide, if it chooses a velocity outside the velocity obstacle, such a collision is guaranteed not to occur.\nThis algorithm for robot collision avoidance has been repeatedly rediscovered and published under different names: in 1989 as a maneuvering-board approach, in 1993 it was first introduced as the \"velocity obstacle\", in 1998 as collision cones, and in 2009 as forbidden velocity maps. The same algorithm has been used in maritime port navigation since at least 1903.\nThe velocity obstacle for a robot  induced by a robot  may be formally written as\n\nwhere  has position  and radius , and  has position , radius , and velocity . The notation  represents a disc with center  and radius .\nVariations include common velocity obstacles (CVO), finite-time-interval velocity obstacles (FVO), generalized velocity obstacles (GVO), hybrid reciprocal velocity obstacles (HRVO), nonlinear velocity obstacles (NLVO), reciprocal velocity obstacles (RVO), and recursive probabilistic velocity obstacles (PVO).","alt_names":["220px-Velocity_obstacle.svg.png","Learn about Velocity obstacle>>>","Velocity Obstacle","Velocity Obstacles","Velocity obstacle","Velocity obstacle - Wikipedia :: The free encyclopedia","Velocity obstacle - Wikipedia, the free encyclopedia","Velocity obstacles","Wikipedia entry for Velocity obstacle","http://en.wikipedia.org/wiki/Velocity_obstacle","reciprocal velocity obstacle","velocity obstacle","velocity obstacles","yago-res:Velocity obstacle","| Velocity Obstacles"],"name":"Velocity obstacle","categories":["All stub articles","Geometric algorithms","Multi-robot systems","Robot kinematics","Robotics stubs"],"tag_line":"In robotics and motion planning, a velocity obstacle, commonly abbreviated VO, is the set of all velocities of a robot that will result in a collision with another robot at some moment in time, assuming that the other robot maintains its current velocity."}}
,{"_index":"throwtable","_type":"algorithm","_id":"nimrod-megiddo","_score":0,"_source":{"description":"Nimrod Megiddo (Hebrew: נמרוד מגידו‎) is a mathematician and computer scientist. He is a research scientist at the IBM Almaden Research Center.\nHis interests include optimization, algorithm design and analysis, game theory, and machine learning.\nMegiddo received his Ph.D. in mathematics from the Hebrew University of Jerusalem.\nMegiddo received the 2014 John von Neumann Theory Prize and is a 1992 Frederick W. Lanchester Prize recipient.\n\n","alt_names":["Megiddo, Nimrod","Nimrod Megiddo","Nimrod Megiddo - Wikipedia, the free encyclopedia","Nimrod Megiddo Wikipedia the free encyclopedia","Wikipedia article Nimrod Megiddo","Wikipedia article about Nimrod Megiddo","Wikipedia article on Nimrod Megiddo","http://en.wikipedia.org/wiki/Nimrod Megiddo","http://en.wikipedia.org/wiki/Nimrod_Megiddo"],"name":"Nimrod Megiddo","categories":["American computer scientists","American operations researchers","Articles containing Hebrew-language text","Game theorists","Hebrew University of Jerusalem alumni","Israeli operations researchers","John von Neumann Theory Prize winners","Living people","Numerical analysts","Researchers in geometric algorithms","Wikipedia articles with GND identifiers","Wikipedia articles with ISNI identifiers","Wikipedia articles with LCCN identifiers","Wikipedia articles with VIAF identifiers","Year of birth missing (living people)"],"tag_line":"Nimrod Megiddo (Hebrew: נמרוד מגידו‎) is a mathematician and computer scientist."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pankaj-k.-agarwal","_score":0,"_source":{"description":"Pankaj Kumar Agarwal is an Indian computer scientist and mathematician researching algorithms in computational geometry and related areas. He is the RJR Nabisco Professor of Computer Science and Mathematics at Duke University, where he has been chair of the computer science department since 2004. He obtained his Ph.D. in Computer Science in 1989 from the Courant Institute, New York, under the supervision of Micha Sharir.","alt_names":["- Pankaj K. Agarwal :","Agarwal, P. K.","Agarwal, Pankaj","Agarwal, Pankaj K.","Pankaj K. Agarwal","Pankaj K. Agarwal - Wikipedia :: The free encyclopedia","Pankaj K. Agarwal - Wikipedia, the free encyclopedia","Wikipedia article Pankaj K. Agarwal","http://en.wikipedia.org/wiki/Pankaj_K._Agarwal"],"name":"Pankaj K. Agarwal","categories":["Courant Institute of Mathematical Sciences alumni","Duke University faculty","Fellows of the Association for Computing Machinery","Indian mathematicians","Living people","Researchers in geometric algorithms","Year of birth missing (living people)"],"tag_line":"Pankaj Kumar Agarwal is an Indian computer scientist and mathematician researching algorithms in computational geometry and related areas."}}
,{"_index":"throwtable","_type":"algorithm","_id":"strassen-algorithm","_score":0,"_source":{"description":"In linear algebra, the Strassen algorithm, named after Volker Strassen, is an algorithm used for matrix multiplication. It is faster than the standard matrix multiplication algorithm and is useful in practice for large matrices, but would be slower than the fastest known algorithms for extremely large matrices.","alt_names":["Strassen's","Strassen's algorithm","'algorithme de Strassen","(détail ici)","-> Leggi tutto l'articolo su 'Algoritmo di Strassen","-> Read more about Strassen algorithm","-> Read the article about 'Strassen algorithm'","...Wikipedia Algoritmo di Strassen","...more on Wikipedia about Strassen algorithm","36e413950cb0ad2419334b21f1d5b0 ...","About Strassen","Algorithm of Shtrassena","Algorithme de Strassen","Algorithme de Strassen - Wikipédia","Algorithmus von Strassen","Algoritma Strassen","Algoritma Strassen - Wikipedia bahasa Indonesia, ensiklopedia bebas","Algoritma Strassen :: Wikipedia Bahasa Indonesia","Algoritma Strassen Wikipedia bahasa Indonesia ensiklopedia bebas","Algoritma Strassen Wikipedia bahasa Indonesia ensiklopedia bebas.","Algoritmo De Strassen (Multiplicación de Matrices)","Algoritmo de Strassen","Algoritmo de Strassen (Wikipedia)","Algoritmo de Strassen (multiplicação de matrizes)","Algoritmo de Strassen - Vikipedio","Algoritmo de Strassen - Wikipedia, la enciclopedia libre","Algoritmo de Strassen – Wikipédia, a enciclopédia livre","Algoritmo di Strassen","Algoritmo di Strassen - Wiki...","Algoritmo di Strassen - Wikipedia","Algoritmo_de_Strassen","Avec l'algorithme de Strassen,","C21 C22 A21 A22 B21 B22. 1 - Divisão","Fast matrix multiplication","L'algorithme de Strassen","Matrixmultiplikation nach Strassen","O(n^2.8)","Reiknirit Strassens","Source Wikipedia.org Arcticle - Strassen algorithm","Stassen's algorithm","Strassen Algo","Strassen Algorithm","Strassen Algorithm - Wikipedia, The Free Encyclopedia","Strassen Algoritm","Strassen algorithm","Strassen algorithm (Wikipedia)","Strassen algorithm (extra)","Strassen algorithm - Wikipedia :: The free encyclopedia","Strassen algorithm - Wikipedia, the free encyclopedia","Strassen algorithm - Wikipedia, the free encyclopedia In the","Strassen algorithm Wikipedia the free encyclopedia","Strassen algorithm for matrix multiplication","Strassen algorithm from Wikipedia","Strassen algorithm(extra)","Strassen algoritma.","Strassen algoritme","Strassen algoritme,","Strassen algoritmus","Strassen fast matrix multiplication method","Strassen fast multiplication","Strassen matrix multiplication","Strassen multiplication","Strassen thuật toán.","Strassen एल्गोरिथ्म","Strassen 알고리즘에","Strassen's Algorithm","Strassen's Method for Matrix Multiplication","Strassen's algorithm for matrix multiplication","Strassen's algorithm.","Strassen's algoritme","Strassen's matrix multiplication algorithm","Strassen's method","Strassen-Algorithmus","Strassen-Algorithmus – Wikipedia","Strassen-Algorithmus.","Strassen_algorithm","Strassena","Strassenin matriisikertolasku","Strassenov algoritmus","Strassens Algorithm","Strassenův algoritmus","Strassenův multiplikační algoritmus","Strassenのアルゴリズム","Strassenのアルゴリズム - Wikipedia","Strassenのアルゴリズム - 行列の乗算の高速化","Strassenのアルゴリズムとは？ (Wikipediaへのリンク)","Strassenのｱﾙｺﾞﾘｽﾞﾑ-wikipedia","Strassen乗算","Strassen演算法","Strassen的算法","Strassen算法","Stressen","Wikipedia (EN): Strassen-Algorithmus","Wikipedia (Strassen algorithm)","Wikipedia article ''Strassen algorithm''","Wikipedia article Algoritmo de Strassen","Wikipedia article Strassen algorithm","Wikipedia article on Algoritmo de Strassen","Wikipedia article on Strassen algorithm","Wikipedia entry for Strassen algorithm","Wikipedia sur Algorithme de Strassen","Wikipedia-Artikel Strassen-Algorithmus","Wikipedia-Seite zu 'Strassen-Algorithmus'","Wikipediaで「Strassenのアルゴリズム」を調べる","[2] Strassen algorithm","algorithme de Strassen","algorithme de Strassen.","algoritma Strassen","algoritmo de Strassen","algoritmo de Strassen.","algoritmo di Strassen","algoritmo di Strassen.","algoritmus Strassen je","algorytm Strassen","bg:Алгоритъм на Щрасен","cs:Strassenův algoritmus","de.wikipedia.org/wiki/Strassen-Algorithmus","de:Strassen-Algorithmus","di Strassen","e http://en.wikipedia.org/wiki/Strassen_algorithm","el algoritmo de Strassen","en http://es.wikipedia.org/wiki/Algoritmo_de_Strassen","en.wikipedia.org/...Strassen_algorithm","en:Strassen algorithm","eo:Algoritmo de Strassen","es:Algoritmo de Strassen","fa:الگوریتم استراسن","giải thuật Strassen","http://cs.wikipedia.org/wiki/Strassen%C5%AFv_algoritmus","http://de.wikipedia.org/wiki/Strassen-","http://de.wikipedia.org/wiki/Strassen-Al","http://de.wikipedia.org/wiki/Strassen-Algorithmus","http://en.wikipedia....assen_algorithm","http://en.wikipedia.org/wi ki/Strassen_algorithm","http://en.wikipedia.org/wiki/Strassen% 5Falgorithm # 5Fanalysis","http://en.wikipedia.org/wiki/Strassen%27s_algorithm","http://en.wikipedia.org/wiki/Strassen%5Falgorithm#Numerical","http://en.wikipedia.org/wiki/Strassen_al","http://en.wikipedia.org/wiki/Strassen_algorithm","http://en.wikipedia.org/wiki/Strassen_algorithm#Numerical_analysis","http://en.wikipedia.org/wiki/Strassen_al…","http://en.wikipedia.org/wiki/Strassen％5Falgorithm＃数值","http://eo.wikipedia.org/wiki/Algoritmo_de_Strassen","http://es.wikipedia.org/wiki/Algoritmo_de_Strassen","http://fr.wikipedia.org/wiki/Algorithme_de_Strassen","http://id.wikipedia.org/wiki/Algoritma_Strassen","http://it.wikipedia.org/wiki/Algoritmo_di_Strassen","http://ja.wikipedia.org/wiki/Strassen%E3%81","http://pt.wikipedia.org/wiki/Algoritmo_de_Strassen","http://ru.wikipedia.org/wiki/Алгоритм_Штрассена","http://www.wikipedia.org/wiki/Strassen_algorithm","http://zh.wikipedia.org/zh-cn/Strassen%E6","id:Algoritma Strassen","l'algorithme de Strassen","lbh cepat dr atas","metoda lui Strassen","of Strassen","pt:Algoritmo de Strassen","ru:Алгоритм Штрассена","seven matrix multiplications","sk:Strassenov algoritmus","the Strassen algorithm page","um resultado, devido a Strassen a partir de","wikipedia.org/wiki/Strassen_algorithm","zh:施特拉森演算法","Ð ÐÐ³Ð¾Ñ€Ð ̧ÑÑŠÐ¼ Ð½Ð° Ð","ìŠˆíŠ¸ë ¼ì„¼ ì•Œê³ ë¦¬ì","Алгоритм Штрассена","Алгоритм Штрассена — Википедия","Алгоритм Штрассена.","Алгоритъм на Щрасен","Описание самого алгоритма на Вики.","Штрассена","Штрассена Алгоритм","алгоритм Штрассена","алгоритм штрассена","ขั้น ตอน วิธี Strassen.","ウィキペディアの記事 Strassenのアルゴリズム","施特拉森演算法","施特拉森算法","維基百科的文章“ Strassen演算法”","维基百科的文章“ Strassen演算法”","슈트라센 알고리즘","슈트라센 알고리즘 - 위키백과","슈트라센 알고리즘 - 위키백과, 우리 모두의 백과사전 \\mathbf{} = \\mathbf","위키 피 디아 문서 슈트라센 알고리즘","위키 피 디아 문서 위노그라드 알고리즘","위키 피 디아 문서 코퍼스미스-위노그라드 알고리즘","％の5Fanalysisをhttp://en.wikipedia.org/wiki","）Strassenのアルゴリズム","𝐂 = 𝐀 𝐁 𝐀 , 𝐁 , 𝐂 &Element; R"],"name":"Strassen algorithm","categories":["All articles needing additional references","Articles needing additional references from January 2015","Matrix multiplication algorithms"],"tag_line":"In linear algebra, the Strassen algorithm, named after Volker Strassen, is an algorithm used for matrix multiplication."}}
,{"_index":"throwtable","_type":"algorithm","_id":"2-opt","_score":0,"_source":{"description":"In optimization, 2-opt is a simple local search algorithm first proposed by Croes in 1958 for solving the traveling salesman problem. The main idea behind it is to take a route that crosses over itself and reorder it so that it does not.\n\n - A   B -             - A - B -\n     X         ==>     \n - C   D -             - C - D -\n\nA complete 2-opt local search will compare every possible valid combination of the swapping mechanism. This technique can be applied to the travelling salesman problem as well as many related problems. These include the vehicle routing problem (VRP) as well as the capacitated VRP, which require minor modification of the algorithm.\nThis is the mechanism by which the 2-opt swap manipulates a given route:\n\n   2optSwap(route, i, k) {\n       1. take route[1] to route[i-1] and add them in order to new_route\n       2. take route[i] to route[k] and add them in reverse order to new_route\n       3. take route[k+1] to end and add them in order to new_route\n       return new_route;\n   }\n\nHere is an example of the above with arbitrary input:\n\n   example route: A ==> B ==> C ==> D ==> E ==> F ==> G ==> H ==> A\n   example i = 4, example k = 7\n   new_route:\n       1. (A ==> B ==> C)\n       2. A ==> B ==> C ==> (G ==> F ==> E ==> D)\n       3. A ==> B ==> C ==> G ==> F ==> E ==> D (==> H ==> A)\n\nThis is the complete 2-opt swap making use of the above mechanism:\n\n   repeat until no improvement is made {\n       start_again:\n       best_distance = calculateTotalDistance(existing_route)\n       for (i = 0; i < number of nodes eligible to be swapped - 1; i++) {\n           for (k = i + 1; k < number of nodes eligible to be swapped; k++) {\n               new_route = 2optSwap(existing_route, i, k)\n               new_distance = calculateTotalDistance(new_route)\n               if (new_distance < best_distance) {\n                   existing_route = new_route\n                   goto start_again\n               }\n           }\n       }\n   }\n\nNote: If you start/end at a particular node or depot, then you must remove this from the search as an eligible candidate for swapping, as reversing the order will cause an invalid path.\nFor example, with depot at A:\n\n   A ==> B ==> C ==> D ==> A\n\nSwapping using node[0] and node[2] would yield\n\n   C ==> B ==> A ==> D ==> A \n\nwhich is not valid (does not leave from A, the depot).","alt_names":["K-Opt-Heuristik","...mehr auf Wikipedia über K-Opt-Heuristik","2 Opt","2 opt","2-opt","2-opt - Wikipedia, the free encyclopedia","2-opt - Wikipédia","2-opt @ Wiki","2-opt algorithm for the TSP","2-opt algorithm for the Traveling Salesman Problem","K-Opt-Heuristik - Wikipedia","Présentation de l'algorithme 2-opt en pseudo","Wikipedia article 2-opt","Wikipedia article on 2-opt","Wikipedia entry for 2-opt","Wikipedia sur 2-opt","Wikipedia-Artikel 2-opt","Wikipedia-Artikel K-Opt-Heuristik","Wikipedia-Seite zu '2-opt'","Wikipedia-Seite zu 'K-Opt-Heuristik'","Wikipedia: k-opt-Heuristik","de.wikipedia.org/wiki/K-Opt-Heuristik","de:K-Opt-Heuristik","fr:2-opt","http://de.wikipedia.org/wiki/K-Opt-Heuristik","http://en.wikipedia.org/wiki/2-opt","http://fr.wikipedia.org/wiki/2-opt","k-Opt-Heuristik","k-Opt-Heuristik ? Wikipedia","k-Opt-Heuristik – Wikipedia","k-opt-Heuristik","۲-opt برای مسئله فروشنده دوره گرد"],"name":"2-opt","categories":["All stub articles","Heuristic algorithms","Mathematical analysis stubs","Mathematical optimization","Travelling salesman problem"],"tag_line":"In optimization, 2-opt is a simple local search algorithm first proposed by Croes in 1958 for solving the traveling salesman problem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"3-opt","_score":0,"_source":{"description":"In optimization, 3-opt is a simple local search algorithm for solving the travelling salesman problem and related network optimization problems.\n3-opt analysis involves deleting 3 connections (or edges) in a network (or tour), reconnecting the network in all other possible ways, and then evaluating each reconnection method to find the optimum one. This process is then repeated for a different set of 3 connections.","alt_names":["3 Opt","3 opt","3-opt","3-opt - Wikipedia, the free encyclopedia","3-opt local search","3opt local search","Wikipedia article 3-opt","Wikipedia article on 3-opt","Wikipedia entry for 3-opt","http://en.Liarpedia.org/wiki/Colonial French","http://en.wikipedia.org/wiki/3-opt"],"name":"3-opt","categories":["All stub articles","Combinatorics stubs","Heuristic algorithms","Mathematical optimization","Travelling salesman problem"],"tag_line":"In optimization, 3-opt is a simple local search algorithm for solving the travelling salesman problem and related network optimization problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"loss-functions-for-classification","_score":0,"_source":{"description":"In machine learning and mathematical optimization, loss functions for classification are computationally feasible loss functions representing the price paid for inaccuracy of predictions in classification problems. Given  as the vector space of all possible inputs, and Y = {–1,1} as the vector space of all possible outputs, we wish to find a function  which best maps  to . However, because of incomplete information, noise in the measurement, or probabilistic components in the underlying process, it is possible for the same  to generate different . As a result, the goal of the learning problem is to minimize expected risk, defined as\n\nwhere  represents the loss function, and  represents the probability distribution of the data, which can equivalently be written using Bayes' theorem as\n\nIn practice, the probability distribution  is unknown. Consequently, utilizing a training set of  independently and identically distributed samples\n\ndrawn from the data sample space, one seeks to minimize empirical risk\n\nas a proxy for expected risk. (See statistical learning theory for a more detailed description.)\nFor computational ease, it is standard practice to write loss functions as functions of only one variable. Within classification, loss functions are generally written solely in terms of the product of the true classifier  and the predicted value . Selection of a loss function within this framework\n\nimpacts the optimal  which minimizes empirical risk, as well as the computational complexity of the learning algorithm.\nGiven the binary nature of classification, a natural selection for a loss function (assuming equal cost for false positives and false negatives) would be the 0–1 indicator function which takes the value of 0 if the predicted classification equals that of the true class or a 1 if the predicted classification does not match the true class. This selection is modeled by\n\nwhere  indicates the Heaviside step function. However, this loss function is non-convex and non-smooth, and solving for the optimal solution is an NP-hard combinatorial optimization problem. As a result, it is better to substitute continuous, convex loss function surrogates which are tractable for commonly used learning algorithms. In addition to their computational tractability, one can show that the solutions to the learning problem using these loss surrogates allows for the recovery of the actual solution to the original classification problem. Some of these surrogates are described below.","alt_names":[],"name":"Loss functions for classification","categories":["CS1 errors: invisible characters","Machine learning algorithms"],"tag_line":"In machine learning and mathematical optimization, loss functions for classification are computationally feasible loss functions representing the price paid for inaccuracy of predictions in classification problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"raimund-seidel","_score":0,"_source":{"description":"Raimund G. Seidel is a German and Austrian theoretical computer scientist and an expert in computational geometry.\nSeidel was born in Graz, Austria, and studied with Hermann Maurer at the Graz University of Technology. He received his Ph.D. in 1987 from Cornell University under the supervision of John Gilbert. After teaching at the University of California, Berkeley, he moved in 1994 to Saarland University. In 1997 he and Christoph M. Hoffmann were program chairs for the Symposium on Computational Geometry. In 2014, he became director of the Leibniz Center for Informatics at Schloss Dagstuhl.\nSeidel invented backwards analysis of randomized algorithms and used it to analyze a simple linear programming algorithm that runs in linear time for problems of bounded dimension. With his student Cecilia R. Aragon in 1989 he devised the treap data structure, and he is also known for the Kirkpatrick–Seidel algorithm for computing two-dimensional convex hulls.","alt_names":["- Raimund Seidel :","Raimund Seidel","Raimund Seidel - Wikipedia, the free encyclopedia","Raimund Seidel; it is used under the","Raimund_Seidel","Seidel, R.","Seidel, Raimund","Who is Raimund Seidel","Wikipedia article Raimund Seidel","Wikipedia entry for Raimund Seidel","en.wikipedia.org/wiki/Raimund_Seidel","http://en.wikipedia.org/wiki/Raimund Seidel","http://en.wikipedia.org/wiki/Raimund_Seidel","yago-res:Raimund Seidel"],"name":"Raimund Seidel","categories":["Austrian computer scientists","Cornell University alumni","German computer scientists","Living people","Researchers in geometric algorithms","University of California, Berkeley faculty","Year of birth missing (living people)"],"tag_line":"Raimund G. Seidel is a German and Austrian theoretical computer scientist and an expert in computational geometry."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pvlv","_score":0,"_source":{"description":"The primary value learned value (PVLV) model is a possible explanation for the reward-predictive firing properties of dopamine (DA) neurons. It simulates behavioral and neural data on Pavlovian conditioning and the midbrain dopaminergic neurons that fire in proportion to unexpected rewards. It is an alternative to the temporal-differences (TD) algorithm.\nIt is used as part of Leabra.","alt_names":["- PVLV :","PVLV","PVLV - Wikipedia, the free encyclopedia","PVLV by Wikipedia","PVLV; it is used under the","Wikipedia article about PVLV","http://en.wikipedia.org/wiki/PVLV"],"name":"PVLV","categories":["All stub articles","Machine learning algorithms","Neuroscience","Neuroscience stubs"],"tag_line":"The primary value learned value (PVLV) model is a possible explanation for the reward-predictive firing properties of dopamine (DA) neurons."}}
,{"_index":"throwtable","_type":"algorithm","_id":"subhash-suri","_score":0,"_source":{"description":"Subhash Suri (born July 7, 1960) is an Indian-American computer scientist, a professor at the University of California, Santa Barbara. He is known for his research in computational geometry, computer networks, and algorithmic game theory.","alt_names":[],"name":"Subhash Suri","categories":["1960 births","American computer scientists","Fellow Members of the IEEE","Fellows of the American Association for the Advancement of Science","Fellows of the Association for Computing Machinery","Indian computer scientists","Indian mathematicians","Johns Hopkins University alumni","Living people","Researchers in geometric algorithms","University of California, Santa Barbara faculty","Washington University in St. Louis faculty"],"tag_line":"Subhash Suri (born July 7, 1960) is an Indian-American computer scientist, a professor at the University of California, Santa Barbara."}}
,{"_index":"throwtable","_type":"algorithm","_id":"freivalds'-algorithm","_score":0,"_source":{"description":"Freivalds' algorithm (named after Rusins Freivalds) is a probabilistic randomized algorithm used to verify matrix multiplication. Given three n × n matrices A, B, and C, a general problem is to verify whether A × B = C. A naïve algorithm would compute the product A × B explicitly and compare term by term whether this product equals C. However, the best known matrix multiplication algorithm runs in O(n2.3729) time. Freivalds' algorithm utilizes randomization in order to reduce this time bound to O(n2)  with high probability. In O(kn2) time the algorithm can verify a matrix product with probability of failure less than .","alt_names":[],"name":"Freivalds' algorithm","categories":["Articles containing proofs","Matrix multiplication algorithms","Matrix theory","Randomized algorithms"],"tag_line":"Freivalds' algorithm (named after Rusins Freivalds) is a probabilistic randomized algorithm used to verify matrix multiplication."}}
,{"_index":"throwtable","_type":"algorithm","_id":"almeida–pineda-recurrent-backpropagation","_score":0,"_source":{"description":"Almeida–Pineda recurrent backpropagation is an extension to the backpropagation algorithm that is applicable to recurrent neural networks. It is a type of supervised learning.\nA recurrent neural network for this algorithm consists of some input units, some output units and eventually some hidden units.\nFor a given set of (input, target) states, the network is trained to settle into a stable activation state with the output units in the target state, based on a given input state clamped on the input units.","alt_names":[],"name":"Almeida–Pineda recurrent backpropagation","categories":["All stub articles","Machine learning algorithms","Neuroscience","Neuroscience stubs"],"tag_line":"Almeida–Pineda recurrent backpropagation is an extension to the backpropagation algorithm that is applicable to recurrent neural networks."}}
,{"_index":"throwtable","_type":"algorithm","_id":"exponential-backoff","_score":0,"_source":{"description":"Exponential backoff is an algorithm that uses feedback to multiplicatively decrease the rate of some process, in order to gradually find an acceptable rate.","alt_names":["-> Leggi tutto l'articolo su 'Algoritmo di backoff","-> Read more about Exponential backoff","...mehr auf Wikipedia über Binary Exponential Backoff","...more on Wikipedia about Exponential backoff","...more on Wikipedia about Truncated binary exponential backoff","1 Binary exponential backoff / truncated exponential backoff","2 An example of an exponential backoff algorithm","3 Expected backoff","Algoritmo di backoff esponenziale binario","Algoritmo di backoff esponenziale binario - Wikipedia","Backoff Zeit,","Backoff-Verfahren","Binary Exponential Backoff","Binary Exponential Backoff - Wikipedia","Binary Exponential Backoff - Wikipédia","Binary Exponential Backoff – Wikipedia","Binary exponential backoff","Expential backoff","Exponential Backoff","Exponential Backoff.","Exponential backoff","Exponential backoff - Wikipedia, the free encyclopedia","Exponential backoff Wikipedia the free encyclopedia","Exponential_backoff","Kırpılmış ikilik üstel geri çekilme","TCP's exponential backoff algorithm","Truncated Binary Exponential Backoff","Truncated Binary Exponential Backoff Algorithm","Truncated binary exponential backoff","Truncated binary exponential backoff - Wikipedia, the free encyclopedia","Truncated_binary_exponential_backoff","Wikipedia article Binary Exponential Backoff","Wikipedia article Binary exponential backoff","Wikipedia article Exponential backoff","Wikipedia article Truncated binary exponential backoff","Wikipedia entry for Truncated binary exponential backoff","Wikipedia sur Binary Exponential Backoff","Wikipedia-Artikel Binary Exponential Backoff","Wikipedia-Seite zu 'Binary Exponential Backoff'","Wikipedia:Algoritmo_di_backoff_esponenziale_binario","algoritmo de back-off","algoritmo di backoff esponenziale binario","back-off","back-off policy","backoff","backoff esponenziale","backoff exponencial","backoff time","backoff 시간을,있을","binary exponential backoff","bináris exponenciális visszalépés","binäre exponentielle Backoff","coordinate without communication","de:Binary Exponential Backoff","eksponentiel backoff","en.wikipedia.org/wiki/Exponential_backoff","en:Exponential backoff#Binary exponential backoff / truncated exponential","en:truncated binary exponential backoff","exponenciális visszalépés","exponenciální backoff","exponential back off","exponential back off.","exponential back-off","exponential back-off algorithm","exponential backoff","exponential backoff algorithm","exponential backoff retry algorhythm.","exponentiellen Backoff","exponentiële backoff","http://de.wikipedia.org/wiki/Binary_Expo","http://de.wikipedia.org/wiki/Binary_Exponential_Backoff","http://en.wikipedia.org/wiki/Exponential_backoff","http://en.wikipedia.org/wiki/Exponential_backoff#Binary_exponential_backoff_.2F_truncated_exponential_backoff","http://en.wikipedia.org/wiki/Exponential_backoff.","http://en.wikipedia.org/wiki/Exponential_backoff?utm_source=twitterfeed&utm_medium","http://en.wikipedia.org/wiki/Truncat...ential_backoff","http://en.wikipedia.org/wiki/Truncated_ ... al_backoff","http://en.wikipedia.org/wiki/Truncated_binary...","http://en.wikipedia.org/wiki/Truncated_binary_e...","http://en.wikipedia.org/wiki/Truncated_binary_exponential_backoff","http://it.wikipedia.org/wiki/Algoritmo_di_backoff_esponenziale_binario","http://pl.wikipedia.org/wiki/Binary_Exponential_Backoff","k · 51 . 2 μ s","pl:Binary Exponential Backoff","random exponential backoff","retardo (backoff) exponencial","tempo de backoff,","tempo di backoff,","temps de ralentissement,","thời gian backoff,","tiempo de retroceso,","truncated binary","truncated binary exponential back off","truncated binary exponential back-off","truncated binary exponential backoff","truncated binary exponential backoff time","waktu backoff,","wykładnicza backoff","шнурковая время,","экспоненциальный отката","экспоненциальных пауз перед повторным запуском","باكوف إسبونينزيال بيناريو دي الجوريتمو","เวลา backoff","べき乗再送処理","バックオフ時間が","截断二进制指数避退算法","截斷二進位指數避退演算法","指数バックオフを","指数退避","用截斷二進位指數避退演算法","舍狎乗謖摓処逤","退避时间","退避時間"],"name":"Exponential backoff","categories":["Ethernet","Networking algorithms","Scheduling algorithms","Use dmy dates from July 2013","Wikipedia articles incorporating text from the Federal Standard 1037C"],"tag_line":"Exponential backoff is an algorithm that uses feedback to multiplicatively decrease the rate of some process, in order to gradually find an acceptable rate."}}
,{"_index":"throwtable","_type":"algorithm","_id":"luleå-algorithm","_score":0,"_source":{"description":"The Luleå algorithm of computer science, designed by Degermark et al. (1997), is a technique for storing and searching internet routing tables efficiently. It is named after the Luleå University of Technology, the home institute of the technique's authors. The name of the algorithm does not appear in the original paper describing it, but was used in a message from Craig Partridge to the Internet Engineering Task Force describing that paper prior to its publication.\nThe key task to be performed in internet routing is to match a given IPv4 address (viewed as a sequence of 32 bits) to the longest prefix of the address for which routing information is available. This prefix matching problem may be solved by a trie, but trie structures use a significant amount of space (a node for each bit of each address) and searching them requires traversing a sequence of nodes with length proportional to the number of bits in the address. The Luleå algorithm shortcuts this process by storing only the nodes at three levels of the trie structure, rather than storing the entire trie.\nThe main advantage of the Luleå algorithm for the routing task is that it uses very little memory, averaging 4–5 bytes per entry for large routing tables. This small memory footprint often allows the entire data structure to fit into the routing processor's cache, speeding operations. However, it has the disadvantage that it cannot be modified easily: small changes to the routing table may require most or all of the data structure to be reconstructed.\nThe Luleå algorithm is patented in the United States (Degermark et al. 2001).\n^ \"second Europe trip for IETFers...\", Craig Partridge to IETF, May 1, 1997.","alt_names":[],"name":"Luleå algorithm","categories":["Internet architecture","Networking algorithms","Routing algorithms","Routing software"],"tag_line":"The Luleå algorithm of computer science, designed by Degermark et al."}}
,{"_index":"throwtable","_type":"algorithm","_id":"slob","_score":0,"_source":{"description":"The SLOB (Simple List Of Blocks) allocator is one of three available memory allocators in the Linux kernel. (The other two are SLAB and SLUB.) The SLOB allocator is designed to require little memory for the implementation and housekeeping, for use in small systems such as embedded systems. Unfortunately, a major limitation of the SLOB allocator is that it suffers greatly from internal fragmentation.\nSLOB currently uses a first-fit algorithm, which uses the first available space for memory. In 2008, a reply from Linus Torvalds on a Linux mailing list was made where he suggested the use of a best-fit algorithm, which tries to find a memory block which suits needs best. Best fit finds the smallest space which fits the required amount available, avoiding loss of performance, both by fragmentation and consolidation of memory.\nBy default, Linux kernel used a SLAB Allocation system until version 2.6.23, when SLUB allocation became the default. When the CONFIG_SLAB flag is disabled, the kernel falls back to using the \"SLOB\" allocator. The SLOB allocator was used in DSLinux on Nintendo DS handheld console.","alt_names":["- SLOB :","SLOB - Wikipedia, the free encyclopedia","SLOB Allocator","SLOB memory allocator","SLOB; it is used under the","Wikipedia article SLOB","Wikipedia article SLOB memory allocator","Wikipedia article about SLOB","Wikipedia article on SLOB","Wikipedia, alokator SLOB","You are not allowed to view links.","article SLOB","http://en.wikipedia.org/wiki/SLOB","slob - Wikipedia, the free encyclopedia","“SLOB - Wikipedia, the free encyclopedia”, en.wikipedia.org"],"name":"SLOB","categories":["All articles lacking in-text citations","All articles needing cleanup","All stub articles","Articles lacking in-text citations from August 2008","Articles needing cleanup from August 2008","Cleanup tagged articles without a reason field from August 2008","Linux kernel","Linux stubs","Memory management algorithms","Use dmy dates from August 2012","Wikipedia pages needing cleanup from August 2008"],"tag_line":"The SLOB (Simple List Of Blocks) allocator is one of three available memory allocators in the Linux kernel."}}
,{"_index":"throwtable","_type":"algorithm","_id":"interleaved-polling-with-adaptive-cycle-time","_score":0,"_source":{"description":"Interleaved Polling with Adaptive Cycle Time (IPACT) is an algorithm designed by Glen Kramer, Biswanath Mukherjee and Gerry Pesavento Advanced Technology Lab.at the University of California, Davis. IPACT is a dynamic bandwidth allocation algorithm for use in Ethernet passive optical networks (EPONs).\nIPACT uses the Gate and Report messages provided by the EPON Multi-Point Control Protocol (MPCP) to allocate bandwidth to Optical Network Units (ONUs). If the optical line terminal grants bandwidth to an ONU and waits until it has received that particular ONU's transmission before granting bandwidth to another ONU, then time equivalent to a whole messaging round-trip is wasted during which the upstream may remain idle. IPACT eliminates this idle time by sending downstream grant messages to succeeding ONUs while receiving transmissions from previously granted ONUs. It accomplishes this by calculating the time at which a transmission grant allocated to a previous ONU ends.","alt_names":["Interleaved polling with adaptive cycle time","Interleaved polling with adaptive cycle time - Wikipedia, the","Interleaved_polling_with_adaptive_cycle_time","Wikipedia article Interleaved polling with adaptive cycle time","http://en.wikipedia.org/wiki/Interleaved_polling_with_adaptive_cycle_time"],"name":"Interleaved polling with adaptive cycle time","categories":["All articles lacking sources","All stub articles","Articles lacking sources from June 2007","Computer network stubs","Network scheduling algorithms"],"tag_line":"Interleaved Polling with Adaptive Cycle Time (IPACT) is an algorithm designed by Glen Kramer, Biswanath Mukherjee and Gerry Pesavento Advanced Technology Lab.at the University of California, Davis."}}
,{"_index":"throwtable","_type":"algorithm","_id":"adaptive-replacement-cache","_score":0,"_source":{"description":"Adaptive Replacement Cache (ARC) is a page replacement algorithm with better performance than LRU (least recently used) developed at the IBM Almaden Research Center. This is accomplished by keeping track of both frequently used and recently used pages plus a recent eviction history for both. In 2006, IBM was granted a patent for the adaptive replacement cache policy.","alt_names":["AdaptativeReplacement Cache","Adaptive Replacement Cache","Adaptive Replacement Cache (ARC)","Adaptive Replacement Cache (Wikipedia)","Adaptive Replacement Cache - Wikipedia, the free encyclopedia","Adaptive Replacement Cache; it is used under the","Adaptive Replacement Caching","Adaptive replacement cache","Adaptive replacement cache - Wikipedia :: The free encyclopedia","Adaptive replacement cache - Wikipedia, the free encyclopedia","Adaptive replacement cache Wikipedia the free encyclopedia","Adaptive replacement cache Wikipedia the free encyclopedia - result","Adaptive replacement cache; it is used under the","Adaptive_replacement_cache","How is the Adaptive Replacement Cache's deployment","More Adaptive Replacement Cache Algorithm","Read More adaptive replacement cache wikipedia the free","Wikipedia article Adaptive Replacement Cache","Wikipedia article Adaptive replacement cache","Wikipedia article on Adaptive Replacement Cache","Wikipedia entry for Adaptive replacement cache","Wikipedia: Adaptive Replacement Cache","Wikipedia: Adaptive_Replacement_Cache","adaptive replacement cache","en.wikipedia.org/wiki/Adaptive_Replacement_Cache","http://en.wikipedia.org/wiki/Adaptive_Re","http://en.wikipedia.org/wiki/Adaptive_Replace...","http://en.wikipedia.org/wiki/Adaptive_Replacement_Cache","http://en.wikipedia.org/wiki/Adaptive_replace...","http://en.wikipedia.org/wiki/Adaptive_replacement_cache","yago-res:Adaptive replacement cache"],"name":"Adaptive replacement cache","categories":["Memory management algorithms","Use dmy dates from August 2012","Virtual memory"],"tag_line":"Adaptive Replacement Cache (ARC) is a page replacement algorithm with better performance than LRU (least recently used) developed at the IBM Almaden Research Center."}}
,{"_index":"throwtable","_type":"algorithm","_id":"deficit-round-robin","_score":0,"_source":{"description":"Deficit Round Robin (DRR), also Deficit Weighted Round Robin (DWRR), is a scheduling algorithm for the network scheduler. DRR is, like weighted fair queuing (WFQ), a packet-based implementation of the ideal Generalized Processor Sharing (GPS) policy. It was proposed by M. Shreedhar and G. Varghese in 1995 as an efficient (with O(1) complexity) and fair algorithm.\n^ Shreedhar, M.; Varghese,G. (October 1995). \"Efficient fair queueing using deficit round robin\". ACM SIGCOMM Computer Communication Review 25 (4): 231. doi:10.1145/217391.217453. ISSN 0146-4833.","alt_names":["DWRR","-> Read more about Deficit round robin","-> Read the article about 'Deficit round robin'","...more on Wikipedia about Deficit round robin","Deficit Round Robin","Deficit Round Robin (DRR)","Deficit round robin","Deficit round robin (DRR)","Deficit round robin - Wikipedia :: The free encyclopedia","Deficit round robin - Wikipedia, the free encyclopedia","Deficit round robin - Wikipedia, the free encyclopedia ...","Deficit round robin Wikipedia the free encyclopedia","Deficit round robin Wikipedia the free encyclopedia - result","Deficit weighted round robin","Deficit_round_robin","Deficit_weighted_round_robin","Wikipedia article DWRR","Wikipedia article Deficit round robin","Wikipedia article Deficit weighted round robin","Wikipedia entry for Deficit round robin","deficit round robin","deficit round robin (DRR)","deficit round robin wikipedia the free encyclopedia","deficit round-robin","en.wikipedia.org/wiki/Deficit_round_r...","en.wikipedia.org/wiki/Deficit_round_robin","http://en.wikipedia.org/wiki/Deficit_rou","http://en.wikipedia.org/wiki/Deficit_round_robin","http://en.wikipedia.org/wiki/Deficit_weighted_round_robin"],"name":"Deficit round robin","categories":["Network scheduling algorithms"],"tag_line":"Deficit Round Robin (DRR), also Deficit Weighted Round Robin (DWRR), is a scheduling algorithm for the network scheduler."}}
,{"_index":"throwtable","_type":"algorithm","_id":"local-replacement-algorithm","_score":0,"_source":{"description":"With multiple processes competing for frames, page-replacement algorithms can be classified into two broad categories: global replacement and local replacement. Global replacement allows a process to select a replacement frame from the set of all frames, even if that frame is currently allocated to some other process; that is; one process can take a frame from another. Local replacement requires that each process select from only its own set of allocated frames.","alt_names":["Local replacement algorithm","Local replacement algorithm - Wikipedia, the free encyclopedia","Local replacement algorithm Wikipedia the free encyclopedia","Read More local replacement algorithm wikipedia the free","What is the overview of Local replacement algorithm","Wikipedia article Local replacement algorithm","Wikipedia entry for Local replacement algorithm","http://en.wikipedia.org/wiki/Local replacement algorithm","http://en.wikipedia.org/wiki/Local_replacement_algorithm"],"name":"Local replacement algorithm","categories":["All articles covered by WikiProject Wikify","All articles with too few wikilinks","Articles covered by WikiProject Wikify from October 2012","Articles with too few wikilinks from October 2012","Memory management algorithms","Use dmy dates from August 2012","Virtual memory"],"tag_line":"With multiple processes competing for frames, page-replacement algorithms can be classified into two broad categories: global replacement and local replacement."}}
,{"_index":"throwtable","_type":"algorithm","_id":"chung-kwei-(algorithm)","_score":0,"_source":{"description":"Chung Kwei is a spam filtering algorithm based on the TEIRESIAS Algorithm for finding coding genes within bulk DNA.\n\n","alt_names":["-> Read more about Chung Kwei (algorithm)","...more on Wikipedia about Chung Kwei (algorithm)","Chung Kwei (algorithm)","Chung Kwei (algorithm) - Wikipedia, the free encyclopedia","Chung Kwei (algorithm) - Wikipedia, the free encyclopedia ...","Chung Kwei algorithm","Wikipedia article Chung Kwei (algorithm)","Wikipedia article on Chung Kwei (algorithm)","Wikipedia entry for Chung Kwei (algorithm)","http://en.wikipedia.org/wiki/Chung_Kwei_(algorithm)","yago-res:Chung_Kwei_(algorithm)"],"name":"Chung Kwei (algorithm)","categories":["Algorithms and data structures stubs","All stub articles","Anti-spam","Computer science stubs","Networking algorithms"],"tag_line":"Chung Kwei is a spam filtering algorithm based on the TEIRESIAS Algorithm for finding coding genes within bulk DNA.\n\n"}}
,{"_index":"throwtable","_type":"algorithm","_id":"euclidean-algorithm","_score":0,"_source":{"description":"In mathematics, the Euclidean algorithm, or Euclid's algorithm, is an efficient method for computing the greatest common divisor (GCD) of two numbers, the largest number that divides both of them without leaving a remainder. It is named after the ancient Greek mathematician Euclid, who first described it in Euclid's Elements (c. 300 BC). It is an example of an algorithm, a step-by-step procedure for performing a calculation according to well-defined rules, and is one of the oldest numerical algorithms in common use. It can be used to reduce fractions to their simplest form, and is a part of many other number-theoretic and cryptographic calculations.\nThe Euclidean algorithm is based on the principle that the greatest common divisor of two numbers does not change if the larger number is replaced by its difference with the smaller number. For example, 21 is the GCD of 252 and 105 (252 = 21 × 12 and 105 = 21 × 5), and the same number 21 is also the GCD of 105 and 147 = 252 − 105. Since this replacement reduces the larger of the two numbers, repeating this process gives successively smaller pairs of numbers until one of the two numbers reaches zero. When that occurs, the other number (the one that is not zero) is the GCD of the original two numbers. By reversing the steps, the GCD can be expressed as a sum of the two original numbers each multiplied by a positive or negative integer, e.g., 21 = 5 × 105 + (−2) × 252. The fact that the GCD can always be expressed in this way is known as Bézout's identity.\nThe version of the Euclidean algorithm described above (and by Euclid) can take many subtraction steps to find the GCD when one of the given numbers is much bigger than the other. A more efficient version of the algorithm shortcuts these steps, instead replacing the larger of the two numbers by its remainder when divided by the smaller of the two. With this improvement, the algorithm never requires more steps than five times the number of digits (base 10) of the smaller integer. This was proven by Gabriel Lamé in 1844, and marks the beginning of computational complexity theory. Additional methods for improving the algorithm's efficiency were developed in the 20th century.\nThe Euclidean algorithm has many theoretical and practical applications. It is used for reducing fractions to their simplest form and for performing division in modular arithmetic. Computations using this algorithm form part of the cryptographic protocols that are used to secure internet communications, and in methods for breaking these cryptosystems by factoring large composite numbers. The Euclidean algorithm may be used to solve Diophantine equations, such as finding numbers that satisfy multiple congruences according to the Chinese remainder theorem, to construct continued fractions, and to find accurate rational approximations to real numbers. Finally, it is a basic tool for proving theorems in number theory such as Lagrange's four-square theorem and the uniqueness of prime factorizations. The original algorithm was described only for natural numbers and geometric lengths (real numbers), but the algorithm was generalized in the 19th century to other types of numbers, such as Gaussian integers and polynomials of one variable. This led to modern abstract algebraic notions such as Euclidean domains.","alt_names":["http://en.wikipedia....idean_algorithm","Rozszerzony algorytm Euklidesa","Euklido algoritmas","Wikipedia 참고","algoritme van Euclides","Euklidischen Algorithmus","Euclid's algorithm","Euklidischer_Algorithmus","ユークリッドの互除法","algoritmo de Euclides","algorithme d'Euclide","Euclidean algorithm","Euclid's Algorithm","'algorithme d'Euclide","(Euclid's algorith","(Euklidischer Algorithmus Rekursive Variante)","- Euclid's algorithm :","- Euclidean algorithm :","...Wikipedia Algorithme d'Euclide","...Wikipedia Algorithme d'Euclide (mathématiques élémentaires)","...Wikipedia Algoritmo de Euclides","...Wikipedia Algoritmo di Euclide","...Wikipedia Algoritmo extendido de Euclides","...Wikipedia Algorytm Euklidesa","...Wikipedia Euklides algoritm","...mehr auf Wikipedia über Euklidischer Algorithmus","...more on Wikipedia about Euclidean algorithm","1 Remarque préliminaire","1 예시","170px-Square_tiling_24x60.svg.png","2 Description de l'algorithme","2. Algoritmo de Euclides","2.1 Exemple","2.2 Exemples d'implémentations","2.2.1 Pseudocode","2.2.2 Python","2.2.3 C","220px-Euclidean_algorithm_ ...","3 Número de pasos elementales","3 호제법의 확장","36a4208e05059a2e73c3de6464be3d59.png","4 Démonstration de sa finitude et de son","4 Fracciones continuas","4 계산량","5 Generalización a los polinomios","5 Le théorème de Lamé","5 연분수","6 Algorithme étendu aux coefficients de Bézout","6.1 Description","6.2 Commentaires","7 Fractions continues","854f976d82b3e38c9bcc1287ddf6c ...","<http://de.wikipedia.org/wiki/Euklidischer_Algorithmus>",">>Euklideszi algoritmus","???????µ?? t?? ????e?d? - ????pa?de?a","???????ĩ?? t?? ????e?d? - ????pa?de?a","A more subtle definition of the GCD is","A set of dots lying within a circle","ALGORITMO DE EUCLIDES","Algorisme d'Euclides","Algorisme d'Euclides - Viquipèdia","Algorithme d'Euclide","Algorithme d'Euclide - Wikip?dia","Algorithme d'Euclide - Wikipédia","Algorithme d'Euclide, récursif","Algorithme d'euclide","Algorithme pour déterminer les PGCD..","Algorithmus nach Euklid","Algorithmus von Euklid","Algoritma Euklidean","Algoritma Euklidean - Wikipedia bahasa Indonesia, ensiklopedia bebas","Algoritma Euklidean :: Wikipedia Bahasa Indonesia","Algoritma Euklidean Wikipedia bahasa Indonesia ensiklopedia bebas","Algoritme van Euclides","Algoritme van Euclides - Wikipedia","Algoritme van Euklides","Algoritmo Euclidiano","Algoritmo de Euclides","Algoritmo de Euclides - Wikipedia, la enciclopedia libre","Algoritmo de Euclides tradicional","Algoritmo de Euclides – Wikipédia, a enciclopédia livre","Algoritmo de Euclides – Wikipédia, a…","Algoritmo de Euclides.","Algoritmo di Euclide","Algoritmo di Euclide - Wikipedia","Algoritmo euclidiano","Algoritmo extendido de Euclides","Algoritmo_de_Euclides","Algoritmul lui Euclid","Algoritmul lui Euclid - Wikipedia","Algortimo de Euclides","Algorytm Euklidesa","Algorytm Euklidesa ? Wikipedia, wolna encyklopedia","Algorytm Euklidesa – Wikipedia, wolna encyklopedia","Algorytm Euklidesa – Wikipedia, wolna…","Algorytm_Euklidesa","Algorítmo de Euclides","AnswerQuestions article on 輾轉相除法","Computing the Greatest Common Divisor of two integers","Description de l'algorithme","E. algorithm","EUKLIDISCHER ALGORITHMUS","Eiklīda algoritms","Eiklīda algoritms - Vikipēdija","El algoritmo de Euclides","Eucleadian Algorithm","Euclid Algorithm","Euclid algorithm by Wikipedia","Euclid had a good thing going","Euclid 互除法","Euclid's GCD Algorithm","Euclid's algorithm - Using Iteration","Euclid's algorithm - Using Iteration, Original Version","Euclid's algorithm - Using Recursion","Euclid's algorithm for calculating GCD","Euclid's algorithm for finding the GCD","Euclid's algorithm for finding the Greatest Common Divisor","Euclid's greatest common denominator algorithm","Euclid's greatest-common-divisor algorithm","Euclid's original algorithm","Euclid's_algorithm","Euclidead Algorithm","Euclidean Algorithm","Euclidean Algorithm 2","Euclidean Algorithm @ Wikipedia","Euclidean Algorithm to find the Greatest Common Denominator","Euclidean Division Algorithm","Euclidean GCF Algorithm","Euclidean algorithm (Wikipedia entry)","Euclidean algorithm - Simple English Wikipedia, the free","Euclidean algorithm - Simple English Wikipedia, the free encyclopedia","Euclidean algorithm - Wikipe...","Euclidean algorithm - Wikipedia","Euclidean algorithm - Wikipedia :: The free encyclopedia","Euclidean algorithm - Wikipedia, the free encyclopedia","Euclidean algorithm - Wikipedia, the free encyclopedia The GCD","Euclidean algorithm - Wikipedia, the free encyclo…","Euclidean algorithm - Wikipedia, t…","Euclidean algorithm Wikipedia the free encyclopedia","Euclidean algorithm Wikipedia the free encyclopedia - result","Euclidean algorithm Wikipedia, the ...","Euclidean algorithm for gcd","Euclidean algorithm for the Greatest Common Divisor","Euclidean algorithm from Wikipedia","Euclidean algorithm from Wikipedia, the free encyklopedia","Euclidean algorithm implementations","Euclidean algorithm in Wikipedia","Euclidean algorithm procedure","Euclidean algorithm#Historical_development","Euclidean algorithm:","Euclidean algorithms","Euclidean algoritmus","Euclidean divisions","Euclidean subtraction algorithm","Euclidean subtraction algorithm.","Euclidean_algorithm","Euclidean_algorithm [Wikipedia]","Euclideen algoritmi","Euclideen algoritmia","Euclidian Algorithm","Euclidian algorithm","Euclidiean algorithm","Euclidisch algoritme","Euclidische algoritme","Euclids algorithm","Euclid¡¯s algorithm","Euclídea","Eukleideen algoritmi","Eukleideen algoritmi – Wikipedia","Eukleidova algoritmu","Euklideen algoritmilla","Euklides algoritm","Euklides algoritm - Wikipedia","Euklideszi algoritmus","Euklideszi algoritmus - Wikip?dia","Euklideszi algoritmus - Wikipédia","Euklidische Algorithmus","Euklidischem Algorithmus","Euklidischer Algorithmus","Euklidischer Algorithmus - Wikipedia","Euklidischer Algorithmus ? Wikipedia","Euklidischer Algorithmus Wikipedia","Euklidischer Algorithmus für die Berechnug des ggT","Euklidischer Algorithmus in","Euklidischer Algorithmus â€“ Wikipedia","Euklidischer Algorithmus – Wikipedia","Euklidischer Algorithmus,","Euklidiske algoritme","Euklido algoritmas – Vikipedija","Euklido_algoritmas","Euklidov algoritam","Euklidov algoritmus","Euklidova algoritma","Euklidova algoritmu","Euklids Algorithmus","Euklids algoritme","Euklidsch Algorithmus","Euklidsch Algorithmus – Wikipedia","Euklidsche Algorithmus","Euklidscher Algorithmus","Euklidscher Algorithmus auf der Deutschen Wikipedia","Euklidscher Algorithmus bei Wikipedia","Euklidészi algoritmus","Euklidův algoritmus","Evklidov algoritem","Evklidovega algoritma","Evklidovim algoritmom","Eŭklida algoritmo","Eŭklida algoritmo - Vikipedio","FPB metode Euclid","File:Gaussian primes.png","File:Gaussian primes.png - Wikimedia Commons","GCD 1071 462 q k","GCD Algorithm","GCD algorithm","GCD computation algorithm","GCD: Euclid's Algorithm","GCD: Euclid\\'s Algorithm","Gauss 素数の可視化(Mathmatica)","Gaussian primes.png","Giải thuật Euclid","Giải thuật Euclid - Wikipedia tiếng Việt","Giải thuật Euclid – Wikipedia tiếng Việt","Hier wird der euklidische Algorithmus mit Pseudocode beschrieben","History of the Euclidean algorithm","Infos zu dem Algorithmus","Joval a zart forras elott","L' algoritmo di Euclide è un algoritmo per","L'algorithme d'Euclide","Learn about Euclidean algorithm>>>","MDC :: Algoritmo de Euclides","More Informaiton on Euclid's Algoritm","More Information on Euclid's Algoritm","More detailed explanation of Euclid's algorithm","Normale Algoritme van Euclides","O Euklidovom algoritmu na Wikipediji","Read More euclidean algorithm wikipedia the free encyclopedia","Read More eŭklida algoritmo vikipedio","Recursive ebob(gcd)","Remarque historique","Remarque préliminaire","Rodzaje algorytmu algorytm Euklidesa","Satz von Euklid - bestes Beispiel für eine Rekursion","Simplificar fracciones","Tante Wiki hilft","The Euclidean Algorithm","The Euclidean Algorithm: An efficient method to find","The greatest common divisor is often written as","Ver Referencia","Wechselwegnahme","What is historical development of Euclidean Algorithm?","Wikepedia on Euclid's algorithm.","Wikipedia Algoritmo de Euclides","Wikipedia article Algorithme d'Euclide","Wikipedia article Algoritm d'Euclid","Wikipedia article Algoritma Euklidean","Wikipedia article Algoritme van Euclides","Wikipedia article Algoritmo de Euclides","Wikipedia article Algoritmo di Euclide","Wikipedia article Algorytm Euklidesa","Wikipedia article Euclidean algorithm","Wikipedia article Euklides algoritm","Wikipedia article Euklidischer Algorithmus","Wikipedia article Euklidov algoritmus","Wikipedia article Eŭklida algoritmo","Wikipedia article on Algoritmo de Euclides","Wikipedia article on Algoritmo extendido de Euclides","Wikipedia article on Euclidean algorithm","Wikipedia article Алгоритм Евклида","Wikipedia article Алгоритм Евкліда","Wikipedia article Алгоритъм на Евклид","Wikipedia article Евклидийн алгоритм","Wikipedia article خوارزمية أقليدس","Wikipedia article ইউক্লিডীয় এলগরিদম","Wikipedia article യൂക്ലിഡിന്റെ അൽഗൊരിതം","Wikipedia artikel Algoritme van Euclides","Wikipedia artikel Algoritme van Euklides","Wikipedia entry for Euclidean algorithm","Wikipedia has an excellent page on the Euclidian","Wikipedia's Article on the Euclidian Algorithm","Wikipedia, PGCD (Mathématiques élémentaires)","Wikipedia-Artikel Euklidischer Algorithmus","Wikipedia-Artikel Euklidscher Algorithmus","Wikipedia-Seite zu 'Euklidischer Algorithmus'","Wikipedia-Seite zum euklidschen Algorithmus","Wikipedia: Euclidean Algorithm","Wikipedia: Euclidean algorithm","Wikipedia: Euklidischer Algorithmus","Wikipedia: ユークリッドの互除法","Wikipedia::Euclidean_algorithm","Wikipedia:Algoritmo_di_Euclide","Wikipediaからの引用）","Wikipediaで「互除法」を調べる","Wikipédia - Algorithme d'Euclide","Wikkipedia: Euclidean algorithm","Wkipedia zum Euklidschen Algorithmus","Zadatak_3","a) Euklidischer Algorithmus","absztrakt algebrai terekben","algorisme d'Euclides","algorithme d'Euclide,","algorithme de Euclide","algoritma Euclid","algoritma Euklidean","algoritma Euklidean,","algoritma euclid","algoritmesnappertjes","algoritmo de Euclides para el cálculo del máximo","algoritmo de Euclides,","algoritmo de euclides","algoritmo di Euclide","algoritmo di Euclide,","algoritmo euclideo","algoritmo euclidiano","algoritmo euclidiano,","algoritmo extendido de Euclides","algoritmos euclídeos","algoritmul lui Euclid","algoritmus Euclid","algorytm Euklidesa","algorytmem Euklidesa","algorytmu Eukledesa","algorytmu Euklidesa","algorytmu Euklidesa;","ar:خوارزمية أقليدس","ar:خوارزمية إقليدس","artigo da Wikipédia Algoritmo de Euclides","artículo de Wikipedia Algoritmo de Euclides","artículo de Wikipedia Algoritmo extendido de Euclides","b) Euclidean algorithm","beat her","bg:Алгоритъм на Евклид","bn:ইউক্লিডীয় এলগরিদম","ca:Algorisme d'Euclides","caf84229f04c0fed16e202258d3ac3 ...","calcul du PGCD","calculating the GCF is O(n 2 )","celui du PGCD d'Euclide","cs:Eukleidův algoritmus","cs:Euklidův algoritmus","de Euclidische algoritme","de.wikipedia.org/wiki/Euklidischer_Algorithmus","de.wikipedia.org/wiki/Euklidischer_Algorithmus#Der_klassische_Algorithmus","de.wikipedia.org/wiki/Euklidischer_Algorithmus#Moderner_Euklidischer_Algorithmus","de:Euklidischer Algorithmus","del método de Euclides","deleteeigenschaftA;","descrição do algoritmo de Euclides","die euklidische Algorithmus","diofantikus egyenletek és egyenletrendszerek","e Euclidean","e Euclidean algorithm","ecuación euclídea","eigentlichen von Euklid stammenden Algorithmus","el algoritmo de Euclides","el:Αλγόριθμος του Ευκλείδη","elegante rekursive Version","en Wikipedia lo tenias re clarito!","en.wikipedia.org/...Euclidean_algorithm","en.wikipedia.org/wiki/Euclidean_algorithm","en.wikipedia.org/wiki/Euclidean_algorithm#Implementations","en.wikipedia.org/wiki/Euclidean_algorithm#Running_time","en.wikipedia.org/​wiki/​Euclidean_algorithm","en:Euclidean algorithm","en:Euclidean_algorithm#Implementations","eo:Eŭklida algoritmo","es:Algoritmo de Euclides","eucledian algorithm","euclidean algorithm","euclidean algorithm simple english wikipedia the free encyclopedia","euclidean algorithm wikipedia the free encyclopedia","euclidean equation","euclidische algoritme","euklid'schen algorithmus","euklideszi algoritmus","euklideszi algoritmussal","euklidische Algorithmus","euklidische Algorithmus für Polynome","euklidische Divisionsalgorithmus","euklidischem Algorithmus","euklidischen Algorithmus'","euklidischer Algorithmus","euklidischer algorithmus","euklidiske algoritme","euklidschen Algorithmus","euklidske algoritme","euklidészi algoritmust","evklidovega algoritma","eŭklida algoritmo","f Euclid's algorith","fa:الگوریتم اقلیدس","fi:Eukleideen algoritmi","fr:Algorithme d'Euclide","gaussian primes","gcd algorithm","giải thuật Euclid","het algoritme van Euclides","http : //en.wikipedia.org/wiki/Euclidean","http://bg.wikipedia.org/wiki/Алгоритъм_на_Евклид","http://ca.wikipedia.org/wiki/Algorisme_d'Euclides","http://ca.wikipedia.org/wiki/Algoritme_d'Euclides","http://cs.wikipedia.org/wiki/Euklid%C5%AFv_algoritmus","http://cs.wikipedia.org/wiki/Euklidův_algoritmus","http://de.wikipedia.org/wiki/E...lgorithmus","http://de.wikipedia.org/wiki/Eu klidischer_Algorithmus","http://de.wikipedia.org/wiki/Eu klidischer_Algorithmus#Beispiel","http://de.wikipedia.org/wiki/Euklidi...ative_Variante","http://de.wikipedia.org/wiki/Euklidi...rch_Pseudocode","http://de.wikipedia.org/wiki/Euklidi...thmus#Beispiel","http://de.wikipedia.org/wiki/Euklidisch ... e_Variante","http://de.wikipedia.org/wiki/Euklidisch ... eudocode_2","http://de.wikipedia.org/wiki/Euklidische...her_Algorithmus","http://de.wikipedia.org/wiki/Euklidischer Algorithmus","http://de.wikipedia.org/wiki/Euklidischer_Algorith...","http://de.wikipedia.org/wiki/Euklidischer_Algorithmus","http://de.wikipedia.org/wiki/Euklidischer_Algorithmus#Beschreibung_durch_Pseudocode","http://de.wikipedia.org/wiki/Euklidischer_Algorithmus#Beschreibung_durch_Pseudocode_2","http://de.wikipedia.org/wiki/Euklidischer_Algorithmus#Der_bin.C3","http://de.wikipedia.org/wiki/Euklidischer_Algorithmus#Iterative_Variante","http://de.wikipedia.org/wiki/Euklidischer_Algorithmus)","http://de.wikipedia.org/wiki/Euklidscher_Algorithmus","http://el.wikipedia....%AF%CE%B4%CE%B7","http://el.wikipedia.org/wiki/Αλγόριθμος_του_Ευκλείδη","http://en.wikipedia....hm#Running_time","http://en.wikipedia.org/ wiki/Euclidean algorithm.","http://en.wikipedia.org/wiki/Euclid%27s_algorithm","http://en.wikipedia.org/wiki/Euclid%27s_algorithm#B","http://en.wikipedia.org/wiki/Euclid%27s_algorithm#Description","http://en.wikipedia.org/wiki/Euclid's_algorithm","http://en.wikipedia.org/wiki/Euclid's_algorithm#Gaussian_integers","http://en.wikipedia.org/wiki/Euclid's_al…","http://en.wikipedia.org/wiki/Euclid_algorithm","http://en.wikipedia.org/wiki/Euclide...mic_efficiency","http://en.wikipedia.org/wiki/Euclide...mplementations","http://en.wikipedia.org/wiki/Euclide...of_of_validity","http://en.wikipedia.org/wiki/Euclide...ratic_integers","http://en.wikipedia.org/wiki/Euclide...ssian_integers","http://en.wikipedia.org/wiki/Euclide...t.27s_identity","http://en.wikipedia.org/wiki/Euclidea...","http://en.wikipedia.org/wiki/Euclidean algorithm","http://en.wikipedia.org/wiki/Euclidean algorithm.","http://en.wikipedia.org/wiki/Euclidean_","http://en.wikipedia.org/wiki/Euclidean_ ... _algorithm","http://en.wikipedia.org/wiki/Euclidean_ ... ementation","http://en.wikipedia.org/wiki/Euclidean_ … r_of_steps","http://en.wikipedia.org/wiki/Euclidean_Algorithm","http://en.wikipedia.org/wiki/Euclidean_Algorithm#Proof_of_validity","http://en.wikipedia.org/wiki/Euclidean_A…","http://en.wikipedia.org/wiki/Euclidean_a","http://en.wikipedia.org/wiki/Euclidean_alg...Using_recursion","http://en.wikipedia.org/wiki/Euclidean_alg...hm#Running_time","http://en.wikipedia.org/wiki/Euclidean_algori...","http://en.wikipedia.org/wiki/Euclidean_algorithm","http://en.wikipedia.org/wiki/Euclidean_algorithm#Algorithmic_efficiency","http://en.wikipedia.org/wiki/Euclidean_algorithm#Description_of_the_algorithm","http://en.wikipedia.org/wiki/Euclidean_algorithm#Gaussian_integers","http://en.wikipedia.org/wiki/Euclidean_algorithm#Generalization_to_Euclidean_dom...","http://en.wikipedia.org/wiki/Euclidean_algorithm#Greatest_common_divisor","http://en.wikipedia.org/wiki/Euclidean_algorithm#Implementations","http://en.wikipedia.org/wiki/Euclidean_algorithm#Number_of_steps","http://en.wikipedia.org/wiki/Euclidean_algorithm#Number_of_steps.","http://en.wikipedia.org/wiki/Euclidean_algorithm#Polynomials","http://en.wikipedia.org/wiki/Euclidean_algorithm#Procedure","http://en.wikipedia.org/wiki/Euclidean_algorithm#Proof","http://en.wikipedia.org/wiki/Euclidean_algorithm#Proof_of_val...","http://en.wikipedia.org/wiki/Euclidean_algorithm#Proof_of_validity","http://en.wikipedia.org/wiki/Euclidean_algorithm#Rational_and_real_numbers","http://en.wikipedia.org/wiki/Euclidean_algorithm#Running_time","http://en.wikipedia.org/wiki/Euclidean_algorithm#Using_iteration","http://en.wikipedia.org/wiki/Euclidean_algorithm#Using_recursion","http://en.wikipedia.org/wiki/Euclidean_algorithm#Worked_example","http://en.wikipedia.org/wiki/Euclidean_algorithm#Worked_example...","http://en.wikipedia.org/wiki/Euclidean_algorithm#Worst-case_number_of_steps","http://en.wikipedia.org/wiki/Euclidean_algorithm#cite_note-Ore_least_abs_remainders","http://en.wikipedia.org/wiki/Euclidean_algorithm#cite_note-Stewart_1964","http://en.wikipedia.org/wiki/Euclidean_algorithm)","http://en.wikipedia.org/wiki/Euclidean_a¡","http://en.wikipedia.org/wiki/Euclidean_a…","http://en.wikipedia.org/wiki/Euclideanalgorithm#Algorithmicefficiency","http://en.wikipedia.org/…id_algorithm","http://eo.wikipedia.org/wiki/E%C5%ADklida_algoritmo","http://es.wikipedia.org/wiki/Algoritmo%20de%20Euclides","http://es.wikipedia.org/wiki/Algoritmo_ ... .C3.B3digo","http://es.wikipedia.org/wiki/Algoritmo_de_...lides_extendido","http://es.wikipedia.org/wiki/Algoritmo_de_Euclides","http://es.wikipedia.org/wiki/Algoritmo_de_Euclides#Algoritmo_de_Euclides_extendido","http://es.wikipedia.org/wiki/Algoritmo_de_Euclides#Implementaci.C3","http://es.wikipedia.org/wiki/Algoritmo_extendido_de_Euclides","http://es.wikipedia.org/wiki/Algoritmo_e…","http://fi.wikipedia.org/wiki/Eukleideen_algoritmi","http://fi.wikipedia.org/wiki/​Eukleideen_algoritmi","http://fr.wikipedia.org/wiki/Algorithme_d","http://fr.wikipedia.org/wiki/Algorithme_d%27Euclide","http://fr.wikipedia.org/wiki/Algorithme_d'Euclide","http://hu.wikipedia.org/wiki/Euklid%C3%A9szi_algoritmus","http://hu.wikipedia.org/wiki/Euklideszi_algoritmus","http://id.wikipedia.org/wiki/Algoritma_Euklidean","http://it.wikipedia....itmo_di_Euclide","http://it.wikipedia.org/wiki/Algoritmo_ ... .2FC.2B","http://it.wikipedia.org/wiki/Algoritmo_di_Euclide","http://ja.wikipedia.org/wiki/ユークリッドの互除法","http://lv.wikipedia.org/wiki/Eiklīda_algoritms","http://nds.wikipedia.org/wiki/Euklidsch_Algorithmus","http://nds.wikipedia.org/wiki/Euklidsche_Algorithmus","http://nl.wikipedia.org/wiki/Algoritme_van_Euclides","http://nl.wikipedia.org/wiki/Euclidisch_algoritme","http://pl.wikipedia....desa#Dow.C3.B3d","http://pl.wikipedia....orytm_Euklidesa","http://pl.wikipedia.org/wiki/Algorytm Euklidesa","http://pl.wikipedia.org/wiki/Algorytm_Euklidesa","http://pl.wikipedia.org/wiki/Algorytm_Euklidesa#Rozszerzony_algorytm_Euklidesa","http://pt.wikipedia.org/wiki/Algoritmo de Euclide","http://pt.wikipedia.org/wiki/Algoritmo_de_Euclides","http://ro.wikipedia.org/wiki/Algoritmul_lui_Euclid#Descriere","http://ru.wikipedia....лгоритм_Евклида","http://ru.wikipedia.org/wiki/Алгори....B8.D0","http://ru.wikipedia.org/wiki/Алгорит...BA.D0","http://ru.wikipedia.org/wiki/Алгоритм Евклида#Алгоритм","http://ru.wikipedia.org/wiki/Алгоритм_Ев...","http://ru.wikipedia.org/wiki/Алгоритм_Евклида","http://ru.wikipedia.org/wiki/Алгоритм_Евклида#Pascal","http://simple.wikipedia.org/wiki/Euclidean_algorithm","http://sk.wikipedia.org/wiki/Euklidov_algoritmus","http://sl.wikipedia.org/wiki/Evklidov_algoritem","http://sv.wikipedia.org/wiki/Euklides_algoritm","http://vi.wikipedia.org/wiki/Giải_thuật_Euclid","http://zh.wikipedia.org/wiki/%E8%BC%BE","http://zh.wikipedia.org/wiki/%E8%BE%97","http://zh.wikipedia.org/zh/%E8%BC%BE","hu:Euklideszi algoritmus","hu:Euklidészi algoritmus","i algoritma Euklid","id:Algoritma Euklidean","it.wikipedia.org/wiki/Algoritmo_di_Euclide","it:Algoritmo di Euclide","ja:ユークリッドの互除法","jcオナニー","ko:유클리드 호제법","krásná animace","l'Algorimo di Euclide","l'algo d'euclide","l'algorithme d'Euclide","l'algorithme de Euclide","l'algoritmo di Euclide","l'algoritmo euclideo","l'article de Wikipédia Algorithme d'Euclide","lgoritmo de Euclides","lt:Euklido algoritmas","lv:Eiklīda algoritms","m Wikipedia::Euclidean_algorithm","ml:യൂക്ലിഡിന്റെ അൽഗൊരിതം","mn:Евклидийн алгоритм","modernen euklidischen Algorithmus","moderner Euklid-Algorithmus","nds:Euklidsch Algorithmus","nice method of calculating GCD","nl.wikipedia.org/wiki/Algoritme_van_Euclides","nl:Algoritme van Euclides","no:Euklids algoritme","o algoritmo de Euclides","pl:Algorytm Euklidesa","pms:Algoritm d'Euclid","pt:Algoritmo de Euclides","recursive form of the Euclidean Algorithm","reiknirit Evklíðs","rekursiven Berechnung","ro:Algoritmul lui Euclid","rozszerzonym algorytmem Euklidesa","ru.wikipedia.org/wiki/Алгоритм_Евклида","ru:Алгоритм Евклида","running time of the Euclidean Algorithm","równanie euklidesowej","s (http://fr.wikipedia.org/wiki/Algorithme_d'Euclide","schnellere Methode","se detallan aquí","simple:Euclidean algorithm","sk:Euklidov algoritmus","sl:Evklidov algoritem","sr:Еуклидов алгоритам","stran Wikipedie za 'Evklidov algoritem'","sv:Euklides algoritm","the Euclidean algorithm","the Wikipedia article on the Euclidean algorithm","the euclidean algorithm","thuật toán Euclid","thuật toán Euclid,","thuật toán Euclide","thuật toán chia của Euclide","tr:Öklid algoritması","ttp://en.wikipedia.org/wiki/Euclidean_algorithm","ttp://en.wikipedia.org/wiki/Euclidean_algorithm#Greatest_common_divisor","two integers","uf http://de.wikipedia.org/wiki/Euklidischer_Algorithmus.","uk:Алгоритм Евкліда","van de Euclidische algoritme","varianta clasica","verallgemeinern auf Polynome","vi:Giải thuật Euclid","von Clemens Thaer,","vrij lastig te berekenen is","w:Algorytm Euklidesa","w:Euclidean algorithm","wiki: Euclidean_algorithm","wiki:Euclidean_algorithm","wikipedia page on Euclidean algorithm","wikipedia.en article on the Euclidian algorithm","wikipedia: algorytm Euklidesa","wikipedia:ユークリッドの互除法","x 3 + 2 3 x 2 + 5 3","z euklidesa","zh.wikipedia.org/wiki/%E8%BC%BE%E8","zh:輾轉相除法","Öklid algoritması","Öklidiyan algoritma","älteste bekannte nicht-triviale Algorithmus","Αλγόριθμος του Ευκλείδη","Αλγόριθμος του Ευκλείδη - Βικιπαίδεια","αλγόριθμο του Ευκλείδη","αλγόριθμος του Ευκλείδη","Алгоритм Евклида","Алгоритм Евклида и расширенный алгоритм Евклида","Алгоритм Евклида — Википедия","Алгоритм Евкліда","Алгоритм Евкліда:","Алгоритм Эвклида","Алгоритм_Евклида","Алгоритма Евклида","Алгоритму Евкліда","Алгоритъм на Евклид","Алгоритъмът на Евклид","Википедии статью Алгоритм Евклида","Википедии статью Соотношение Безу","Евклидийн алгоритм","Евклидийн алгоритмаар","Евклидов алгоритм","Еуклидов алгоритам","Расширеный алгоритм Эвклида","РђР»РіРѕСЂРёС‚Рј Р•РІРєР»РёРґР° вЂ” Р","Связь с цепными дробями","Соотношение Безу","Читаем, читаем.","алгоритм Евклида","алгоритм Евклида,","алгоритм Евкліда","алгоритм Эвклида","алгоритма Евклида","алгоритма Евкліда","алгоритме Евклида","алгоритмом Евкліда","алгоритмом эвклида","алгоритъмът на Евклид","в Педивикии.","евклидов алгоритъм","евклидовы уравнения","расширенному алгоритму Евклида","соотношением Безу","соотношения Безу","через вычитание","אלגוריתם האוקלידי המורחב","האלגוריתם של אוקלידס","الگوریتم اقلیدس","الگوریتم اقلیدس - ویکیپدیا","خوارزمية أقليدس","خوارزمية أقليدس - ويكيبيديا ...","خوارزمية إقليدس","خوارزمية اقليدس","سدﯾﻟﻗإ ﺔﯾﻣزراوﺧ","यूक्लिड के एल्गोरिथ्म","ইউক্লিডীয় এলগরিদম","ইউক্লিডীয় এলগরিদম।","กลไก ของ Euclid","ขั้น ตอน วิธี Euclidean","ขั้น ตอน วิธี Euclidean,","ขั้นตอนวิธีของยูคลิด","วิธีแบบยุคลิด","„modernen“ Euklidischen Algorithmus","「ユークリッドの互除法」","「ユークリッドの互除法」についてWikipediaで調査","「ユークリッドの互除法」をWikipediaで調べる","「互除法」についてWikipediaで調査","「互除法」をWikipediaで調べる","ショタ拷問小説","ユークリッドのアルゴリズム","ユークリッドの互助法詳細－Wikipedia","ユークリッドの互除法 - Wikipedia","ユークリッドの互除法 - wikipedia","ユークリッドの互除法 -- Wikipedia","ユークリッドの互除法 – Wikipedia","ユークリッドの互除法-Wikipedia","ユークリッドの互除法.PNG","ユークリッドの互除法⇗","ユークリッドの互除法とは?","ユークリッドアルゴリズム","ユークリッド互除法-wiki","ユーグリッドの互除法","互除法","宇野実彩子のセックス","室井佑月 お宝画像","小学生の体画像","拡張されたユークリッドの互除法","拡張ユークリッドの互除法","星空に橋が掛かるBL画像","柏木ゆきの写真","欧几里得公式","欧几里得算法","欧几里德的算法","欧几里德算法","欧几里德算法的","欧几里德算法（Euclidean algorithm）","歐幾裏得算法","歐幾里得演算法","歐幾里得算法","歐幾里德算法","正确性的证明","的欧几里德","的欧几里德算法","簡単説明","詳しいアルゴリズムはここ","輾轉相除法","輾轉相除法 - 维基百科，自由的百科全书","輾轉相除法- 維基百科，自由的百科全書","輾轉相除法- 维基百科，自由的百科全书","輾轉相除法，維基百科","辗转相除法","辗转相除法- 维基百科，自由的百科全书","辗转相除法-维基百科","위키 피 디아 문서 유클리드 호제법","위키에서 찾아보면","유클리드 알고리즘","유클리드 알고리즘,","유클리드 알고리즘의","유클리드 호제법","유클리드 호제법 위키백과, 우리 모두의백과사전","유클리드의 알고리즘을","이런거..","ﾕｰｸﾘｯﾄﾞの互除法-wikipedia"],"name":"Euclidean algorithm","categories":["Articles containing proofs","Articles with example pseudocode","CS1 German-language sources (de)","Commons category with local link same as on Wikidata","Euclid","Featured articles","Number theoretic algorithms"],"tag_line":"In mathematics, the Euclidean algorithm, or Euclid's algorithm, is an efficient method for computing the greatest common divisor (GCD) of two numbers, the largest number that divides both of them without leaving a remainder."}}
,{"_index":"throwtable","_type":"algorithm","_id":"extended-euclidean-algorithm","_score":0,"_source":{"description":"In arithmetic and computer programming, the extended Euclidean algorithm is an extension to the Euclidean algorithm, which computes, besides the greatest common divisor of integers a and b, the coefficients of Bézout's identity, that is integers x and y such that\n\nIt allows one to compute also, with almost no extra cost, the quotients of a and b by their greatest common divisor.\nExtended Euclidean algorithm also refers to a very similar algorithm for computing the polynomial greatest common divisor and the coefficients of Bézout's identity of two univariate polynomials.\nThe extended Euclidean algorithm is particularly useful when a and b are coprime, since x is the modular multiplicative inverse of a modulo b, and y is the modular multiplicative inverse of b modulo a. Similarly, the polynomial extended Euclidean algorithm allows one to compute the multiplicative inverse in algebraic field extensions and, in particular in finite fields of non prime order. It follows that both extended Euclidean algorithms are widely used in cryptography. In particular, the computation of the modular multiplicative inverse is an essential step in RSA public-key encryption method.\n\n","alt_names":["http://fr.wikipedia.org/wiki/Algorithme_d%27Euclide_%C3","Extended Euclidean Algorithm","algorithme d'Euclide étendu","http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm","(extended) Euclidean Algorithm","(extended) Euclidean algorithm","- Extended Euclidean algorithm :","...Wikipedia Algorithme d'Euclide étendu","...mehr auf Wikipedia über Erweiterter euklidischer Algorithmus","...more on Wikipedia about Extended Euclidean algorithm","1 Informal formulation of the algorithm","1.1 Iterative method","1.2 Recursive method","1.3 Table method","2 Formal description of the algorithm","2.1 Iterative method","2.2 Recursive method","2.2.1 Proof of correctness","2000多年来","3 Computing a multiplicative inverse in a finite","3.2 Note","4 The case of more than 2 numbers",": Algorithme d'Euclide étendu","Algorisme d'Euclides ampliat","Algorithme d Euclide étendu","Algorithme d'Euclide ?tendu - Wikip?dia","Algorithme d'Euclide étendu","Algorithme d'Euclide étendu - Wikipédia","Algoritmo de Euclides Estendido","Algoritmo de Euclides Estendido (para criptografia RSA)","Algoritmo de Euclides estendido","Algoritmo de Euclides estendido - Wikipédia, a enciclopédia livre","Algoritmo de Euclides estendido – Wikipédia, a enciclopédia livre","Algoritmo de Euclides estendido –…","Article de Wikipédia sur l'algorithme d'Euclide","Beipiel mit Zahlen","Computing a multiplicative inverse in a finite field","Das Haupteinsatzgebiet des erweiterten euklidischen Algorithmus ist die","Der Algorithmus ist eine Erweiterung des bereits in","Diesen Schritt wiederholen wir solange, bis in der","EEA (Wiki)","Erw. eukl. Algo.","Erweiterte Euklidische Algorithmus","Erweiterten Euklidischen Algorithmus","Erweiterten Euklidischer Algorithmus (EEA)","Erweiterten Euklidschen Algorithmus","Erweiterten euklidischen Algorithmus","Erweiterter Euklidischer Algorithmus","Erweiterter euklidischen Algorithmus","Erweiterter euklidischer Algorithmus","Erweiterter euklidischer Algorithmus - Funktionsweise am Beispiel","Erweiterter euklidischer Algorithmus ? Wikipedia","Erweiterter euklidischer Algorithmus Wiki Seite","Erweiterter euklidischer Algorithmus â€“ Wikipedia","Erweiterter euklidischer Algorithmus – Wikipedia","Erweiterter_Euklidischer_Algorithmus","Erweiterter_euklidischer_Algorithmus","Es wird die Division mit Rest ausgeführt, und","Euclid's extended algorithm","Euclids litt mer hårete algoritme","Euklid-Algorithmus","Euklides utökade algoritm","Euklids utvidede algoritme","Extended Eucleidean algorithm","Extended Euclid","Extended Euclid (rekurzivni)","Extended Euclid algorithm","Extended Euclid's Algorithm","Extended Euclidean","Extended Euclidean Algorithm.","Extended Euclidean algor","Extended Euclidean algorithm","Extended Euclidean algorithm - Wikipedia :: The free encyclopedia","Extended Euclidean algorithm - Wikipedia, the free encyclopedia","Extended Euclidean algorithm - Wikipedia, the free encyclopedia ...","Extended Euclidean algorithm -- from Wikipedia","Extended Euclidean algorithm, From Wikipedia, the free encyclopedia","Extended Euclidean algorithm; it is used under the","Extended Euclidisch algoritme","Extended Euklidiske algoritme","Extended GCD (Euclidean algorithm)","Extended algoritmo di Euclide","Extended euklidisk algoritme","Extended-Euclidean algorithm","Extended_Euclidean_algorithm","Formal description of the algorithm","Giải thuật Euclid mở rộng","Giải thuật Euclide mở rộng","HTTP://EN.WIKIPEDIA.ORG/WIKI/EXTENDED_EUCLIDEAN_ALGORITHM","Induktiven Variante","Informal formulation of the algorithm","Išplėstinis Euklido algoritmas","JavaScript implementation of the Extended Euclidean algorithm","L'algorithme d'Euclide étendu","Razširjen Evklidov algoritem","Read More extended euclidean algorithm wikipedia the free","The Extended Euclidean Algorithm","The extended Euclidean algorithm","Uitgebreid Euclidsch algoritme","Uitgebreid algoritme van Euclides","Uitgebreid algoritme van Euclides - Wikipedia","Understand the Extended Euclidean algorithm","Wikipedia - Extended Euclidian Algorithm Site Link","Wikipedia article ''Extended Euclidean algorithm''","Wikipedia article Algorithme d'Euclide étendu","Wikipedia article Algoritmo de Euclides estendido","Wikipedia article Extended Euclidean algorithm","Wikipedia article Extended euclidean algorithm","Wikipedia article on Extended Euclid","Wikipedia article on Extended Euclidean algorithm","Wikipedia article on the extended Euclidean algorithm and","Wikipedia artikel Uitgebreid Euclidisch algoritme","Wikipedia artikel Uitgebreid Euclidsch algoritme","Wikipedia artikel Uitgebreid algoritme van Euclides","Wikipedia entry for Extended Euclidean algorithm","Wikipedia-Artikel Erweiterter Euklidischer Algorithmus","Wikipedia-Artikel Erweiterter euklidischer Algorithmus","Wikipedia-Seite zu 'Erweiterter euklidischer Algorithmus'","Wikipedia/Extended Euclidian algorithm","Wikipedia::Extended_Euclidean_algorithm","Wikipedia::Extended_Euclidean_algorithm. Pl","YES! Read about it here.","YES! Read about it here..","a x + b y = gcd ( a , b ) .","algorithm can easily be extended","algorithme d'Euclide-Bezout","algoritmo de Euclides estendido","algoritmo di Euclide esteso","aqui têm a base","at least as described at Wikipedia","bővített euklideszi algoritmus","cs:Rozšířený Eukleidův algoritmus","d'Euclide etendu","de.wikipedia.org/wik...Rekursive_Variante_2","de.wikipedia.org/wiki/Erweiterter_Euklidischer_Algorithmus","de.wikipedia.org/wiki/Erweiterter_euklidischer_Algorithmus","dieses (Erweiterter Euklidischer Algorithmus)","en.wikipedia.org/.../Extended_Euclidean_algorithm","en.wikipedia.org/...Extended_Euclidean_algorithm","en.wikipedia.org/wiki/Extended_Euclidean_algorithm","erweiterte Euklidische Algorithmus","erweiterte eudklidische Algorithmus","erweiterte euklidische Algorithmus","erweiterte euklidischen Algorithmus","erweiterten Euklidischen Algorithmus","erweiterten euklidischen Algorithmus","erweiterten euklidischen Algorithmus (EEA)","erweiterten euklidischen Algoritmus","erweiterten euklidischen Algortihmus","erweiterten euklischen Algorithmus","euclid's algorithm","euklidischer_Algorithmus","expanded Euclidean algorithm","extended Eucleadean algorithm","extended Euclid's algorithm","extended Euclidean","extended Euclidean Algorithm","extended Euclidean algorithm","extended Euclidean algorithm,","extended Euclidean algorithm.","extended Euclidean algortihm","extended GCD algorithm","extended eucledian algorithm.","extended euclidean algorithm","extended euclidean algorithm wikipedia the free encyclopedia","extended version of Euclid's algorithm","extended version of it","extended version of the Euclidian Algorithm","folgenden Rezept","giải thuật Euclid mở rộng","hast du schon mal als quelle angegeben","http : //en.wikipedia.org/wiki/Extended","http//de.wikipedia.org/wiki/Erweiterter_euklidischer_Algorithmus","http//de.wikipedia.org/wiki/Erweiterter_euklidischer_Algorithmus#Funktionsweise_am_Beispiel","http://de.wikipedia.org/wiki/Erweite...er_Algorithmus","http://de.wikipedia.org/wiki/Erweite...ive_Variante_2","http://de.wikipedia.org/wiki/Erweite...sche_Umsetzung","http://de.wikipedia.org/wiki/Erweite...se_am_Beispiel","http://de.wikipedia.org/wiki/Erweiterte ... lgorithmus","http://de.wikipedia.org/wiki/Erweiterter","http://de.wikipedia.org/wiki/Erweiterter euklidischer Algorithmus","http://de.wikipedia.org/wiki/Erweiterter...her_Algorithmus","http://de.wikipedia.org/wiki/Erweiterter...ise_am_Beispiel","http://de.wikipedia.org/wiki/Erweiterter...lgorithmus","http://de.wikipedia.org/wiki/Erweiterter_Euklidischer_Algorithmus","http://de.wikipedia.org/wiki/Erweiterter_euklidische...","http://de.wikipedia.org/wiki/Erweiterter_euklidischer_Algorithmus","http://de.wikipedia.org/wiki/Erweiterter_euklidischer_Algorithmus#Rekursive_Variante","http://de.wikipedia.org/wiki/Erweiterter…","http://en.wikipedia.org/wiki/E...hm#Table_method","http://en.wikipedia.org/wiki/Extende...a_finite_field","http://en.wikipedia.org/wiki/Extende...dean_algorithm","http://en.wikipedia.org/wiki/Extended_E ... _algorithm","http://en.wikipedia.org/wiki/Extended_E … _algorithm","http://en.wikipedia.org/wiki/Extended_Eu","http://en.wikipedia.org/wiki/Extended_Eu...nite_field","http://en.wikipedia.org/wiki/Extended_Euclidean_Algorithm","http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Computing_a_multiplicative_inverse_in_a_finite_field","http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Computing_a_multiplicative_inverse_in_a_finite_fiel​d","http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Javascript_implementation","http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Proof_of_correctness","http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Recursive_method_2","http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Table_method","http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#The_iterative_method","http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)","http://en.wikipedia.org/wiki/Extended_Eu…","http://en.wikipedia.org/wiki/Extended_euclidean_algorithm","http://en.wikipedia.org/wiki/Extended_eu…","http://fr.wikipedia.org/wiki/Algori...ide_%C3","http://fr.wikipedia.org/wiki/Algorit...de_%C3","http://fr.wikipedia.org/wiki/Algorithme ? C3%A9tendu","http://fr.wikipedia.org/wiki/Algorithme_","http://fr.wikipedia.org/wiki/Algorithme_d%...ide_%C3","http://fr.wikipedia.org/wiki/Algorithme_d%27","http://fr.wikipedia.org/wiki/Algorithme_d&...ide_%C3","http://fr.wikipedia.org/wiki/Algorithme_d'Euclide_%C3","http://fr.wikipedia.org/wiki/Algorithme_d'Euclide_étendu","http://nl.wikipedia.org/wiki/Uitgebreid_Euclidisch_algoritme","http://pt.wikipedia.org/wiki/Algoritmo_de_Euclides_estendido","http://www.wikipedia.org/wiki/Extend...dean_algorithm","http://www.wikipedia.org/wiki/Extended_Euclidean_algorithm","http://www.wikipedia.org/wiki/Extended_Euclidean_algorithm>","kiterjesztett változata","l'algorithme d'Euclide étendu","l'algorithme de Bézout","laajennettu Eukleideen algoritmi","most incarnations","método das tabelas","opis rozszerzonego algorytmu Euklidesa","prodlouženým Euclidean algoritmem","pt.wikipedia.org/wiki/Algoritmo_de_Euclides_estendido","recursive variant of the extended Euclidean algorithm","rekursive Implementation","reversing the steps","reversing the steps in the Euclidean algorithm","reverter os passos do algoritmo de Euclides","rozszerzonego algorytmu Euklidesa","rozszerzony algorytm Euklidesa","rozšířeného Euclidean algoritmus","rozšířený Euklidův algoritmus","sl:Razširjen Evklidov algoritem","the extended Euclidean algorithm","ttp://en.wikipedia.org/wiki/Extended Euclidean algorithm","ttp://www.wikipedia.org/wiki/Extended_Euclidean_algorithm,","uitgebreid Euclidisch algoritme","uitgebreid algoritme van Euclides","uitgebreid euclidisch algoritme","uitgebreide","uitgebreide Euclidische algoritme","uitgebreide algoritme van Euclides","uk:Розширений алгоритм Евкліда","versing the steps in the Euclidean algorithm","version étendue","versione estesa","xtended Euclidean algorithm, i","étendu d'Euclide","αλγόριθμος σε ψευδοκώδικα","μέθοδο του Ευκλείδη","Розширений алгоритм Евкліда","иид ЛЛ жКл д Кгж Лл Л а","расширенный Евклидов алгоритм","розширеного алгоритму Евкліда","युक्लिडची विस्तारित प्रणाली [extended Euclidean algorithm]","“extended” version","扩展欧几里德算法","拡張ユークリッドアルゴリズムを","维基百科Extended Euclidean algorithm(扩展欧几里德定理)","위키피디아 – Extended Euclidean algorithm"],"name":"Extended Euclidean algorithm","categories":["Articles with example pseudocode","Euclid","Number theoretic algorithms"],"tag_line":"In arithmetic and computer programming, the extended Euclidean algorithm is an extension to the Euclidean algorithm, which computes, besides the greatest common divisor of integers a and b, the coefficients of Bézout's identity, that is integers x and y such that\n\nIt allows one to compute also, with almost no extra cost, the quotients of a and b by their greatest common divisor."}}
,{"_index":"throwtable","_type":"algorithm","_id":"distance-vector-routing-protocol","_score":0,"_source":{"description":"In computer communication theory relating to packet-switched networks, a distance-vector routing protocol is one of the two major classes of intra domain routing protocols, the other major class being the link-state protocol. Distance-vector routing protocols use the Bellman–Ford algorithm, Ford–Fulkerson algorithm, or DUAL FSM (in the case of Cisco Systems's protocols) to calculate paths.\nA distance-vector routing protocol requires that a router inform its neighbors of topology changes periodically. Compared to link-state protocols, which require a router to inform all the nodes in a network of topology changes, distance-vector routing protocols have less computational complexity and message overhead.\nThe term distance vector refers to the fact that the protocol manipulates vectors (arrays) of distances to other nodes in the network. The vector distance algorithm was the original ARPANET routing algorithm and was also used in the internet under the name of RIP (Routing Information Protocol).\nExamples of distance-vector routing protocols include RIPv1 and RIPv2 and IGRP.","alt_names":["distance-vector routing protocol","Distanzvektor","distance-vector protocols","distance vector","Distance Vector","distance-vector routing algorithm","Distance-vector routing protocol","- Distance-vector routing protocol :","-> Read the article about 'Distance-vector routing protocol","...Wikipedia Distance Vector","...Wikipedia Vector de distancias","...mehr auf Wikipedia über Distanzvektoralgorithmus","...more on Wikipedia about Distance-vector routing protocol","://en.wikipedia.org/wiki/Distance-vector_routing_protocol","Bellman-Ford Algorithm for distance-vector routing","Count to infinity","Count-To-Infinity","Count-to-infinity problem","Count-to-infinity_problem","Distance Vector - Wikipedia","Distance Vector Algorithm","Distance Vector Routing","Distance Vector Routing Protocol","Distance Vector Routing protocols","Distance Vector routing","Distance Vector routing protocol","Distance vector","Distance vector Routing.","Distance vector routing","Distance vector routing protocol","Distance vector routing protocol ...","Distance vector routing protocol Wikipedia the free encyclopedia","Distance vektor Routing.","Distance-Vector","Distance-Vector protocols","Distance-Vector-Protocol","Distance-vector","Distance-vector Routing Protocol","Distance-vector Routing Protocol - Vikipedi","Distance-vector protocols","Distance-vector routing","Distance-vector routing protocol - Wikipedia :: The free encyclopedia","Distance-vector routing protocol - Wikipedia, the free ...","Distance-vector routing protocol - Wikipedia, the free encyclopedia","Distance-vector routing protocol: Example","Distance-vector routing protocol: Limitations","Distance-vector routing protocol: Method","Distance-vector routing protocol: Partial solutions","Distance-vector routing protocol; it is used under","Distance-vector routing protocols","Distance-vector_protocols","Distance-vector_routing_protocol","Distance-vector_routing_protocols","Distance_Vector","Distancevector routing protocol Wikipedia the free encyclopedia","Distanzvektor-Routingprotokollen","Distanzvektoralgorithmus","Distanzvektoralgorithmus - Wikipedia","Distanzvektoralgorithmus ? Wikipedia","Distanzvektoralgorithmus – Wikipedia","Kısmi Çözümler","Kısıtlamalar","Learn about Distance-vector routing protocol>>>","Protocols d'algorisme de vector de distància","Směrování podle vektoru vzdáleností.","VECTOR DE DISTANCIAS","Vecteur de distance","Vecteur de distance - Wikipédia","Vector Distance","Vector Distance RIP","Vector I","Vector de distancia","Vector de distancias","Vector de distancias - Wikipedia, la enciclopedia libre","Vector de distancias la enciclopedia libre","Vetor distância","WP: Distanzvektoralgorithmus","What are limitations of Distance-vector routing protocol","What is Count to infinity's example?","What is method of Distance vector protocols?","What is method of Distance-vector routing algorithm","What is the example of Distance-vector algorithm","What is the example of Distance-vector routing","Wikipedia Distance Vector Routing Protocol","Wikipedia Vector de distancias","Wikipedia article Count-to-infinity problem","Wikipedia article Distance-vector protocols","Wikipedia article Distance-vector routing protocol","Wikipedia article Distance-vector routing protocols","Wikipedia article on Distance-vector routing protocol","Wikipedia entry for Distance-vector routing protocol","Wikipedia-Artikel Count-To-Infinity","Wikipedia-Artikel Distance-Vector","Wikipedia-Artikel Distanzvektor","Wikipedia-Artikel Distanzvektoralgorithmus","Wikipedia-Seite zu 'Count-To-Infinity'","Wikipedia-Seite zu 'Distance-Vector'","Wikipedia-Seite zu 'Distanzvektoralgorithmus'","Wikipedia: Distanzvektoralgorithmus","Wikipedia:Distance_Vector","Wikipedia:Distance_vector","[1] Distance vector routing protocol","a distance-vector routing protoc","algorytmu wektora odległości","artículo de Wikipedia Vector de distancias","ca:Protocol de vector de distàncies","count to infinity problem","count-to-infinity","count-to-infinity problem","de distancias","de:Distanzvektoralgorithmus","di routing Distance Vector.","distance vector routing protocol","distance-vector","distance-vector routing","distance-vector routing protocolos","distance-vector routing protocols","distancia vectorial","en.wikipedia.org/...stance-vector_routing_protocol","es:Vector de distancias","es:Vector_de_distancias","http://ca.wikipedia.org/wiki/Protocol_de_vector_de_dist%C3%A0ncies","http://de.wikipedia.org/wiki/Count-To-Infinity","http://de.wikipedia.org/wiki/Distance-Vec ...","http://de.wikipedia.org/wiki/Distance-Vector","http://de.wikipedia.org/wiki/Distanzvekt","http://de.wikipedia.org/wiki/Distanzvektor","http://de.wikipedia.org/wiki/Distanzvektoralgorithmus","http://de.wikipedia.org/wiki/Distanzvektoralgorithmus#Probleme","http://en.Liarpedia.org/wiki/Distance-vector_routing_protocol","http://en.wikipedia.org/wiki/Distanc...uting_protocol","http://en.wikipedia.org/wiki/Distance-v ... g_protocol","http://en.wikipedia.org/wiki/Distance-v ... ol","http://en.wikipedia.org/wiki/Distance-ve","http://en.wikipedia.org/wiki/Distance-vector_routing_protocol","http://en.wikipedia.org/wiki/Distance-vector_routing_protocol#Count","http://en.wikipedia.org/wiki/Distance-vector_routing_protocols","http://en.wikipedia.org/wiki/Distance-ve…","http://es.wikipedia.org/wiki/Vector_de_distancias","http://fr.wikipedia.org/wiki/Vecteur_de_distance","http://fr.wikipedia.org/wiki/Vector_Distance","http://it.wikipedia.org/wiki/Distance_Vector","http://it.wikipedia.org/wiki/Distance_vector","http://pl.wikipedia.org/wiki/Algorytm_wektora_odleg%C5%82o","it:Distance Vector","lihat di wiki","protokoły routingu wektora odległości","pt:Vetor distância","routingu wektora odległości.","tr:Distance-vector Routing Protocol","vecteur de distance","vector de distancias","vector distancia","vector routing algorithm","vector-distancia","vectores de distancias","wektora odległości","wikipedia:Distance-vector routing protocol","Расстояние Вектор маршрутизации.","дистантен вектор (distance vector)","距离矢量路由。","距離ベクトルルーティングの"],"name":"Distance-vector routing protocol","categories":["All articles lacking in-text citations","All articles needing expert attention","All articles that are too technical","All articles with unsourced statements","Articles lacking in-text citations from September 2010","Articles needing expert attention from November 2013","Articles with unsourced statements from January 2009","Articles with unsourced statements from October 2015","Routing algorithms","Routing protocols","Wikipedia articles that are too technical from November 2013"],"tag_line":"In computer communication theory relating to packet-switched networks, a distance-vector routing protocol is one of the two major classes of intra domain routing protocols, the other major class being the link-state protocol."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pathfinding","_score":0,"_source":{"description":"Pathfinding or pathing is the plotting, by a computer application, of the shortest route between two points. It is a more practical variant on solving mazes. This field of research is based heavily on Dijkstra's algorithm for finding a shortest path on a weighted graph.","alt_names":["Wegfindung","pathfinding algorithm","pathfinding algorithms","path finding","pathfinding","- Pathfinding :","...mehr auf Wikipedia über Pathfinding","Article de Wikipédia sur le PathFinding","Búsqueda de caminos en la Wikipedia","Ca t'aidera comprendre de quoi on parle","Initial Terminal Guidance","Merintis jalan algoritma.","Path Finding","Path finding","Path finding wiki","PathFinding (en.wiki)","Pathfind","Pathfinding","Pathfinding - Wikipedia, the free encyclopedia","Pathfinding Wikipedia the free encyclopedia","Pathfinding Wikipedia the free encyclopedia - result","Pathfinding algorithmes.","Pathfinding algorithms.","Pathfinding algoritmen.","Pathfinding algoritmer.","Pathfinding algoritmi.","Pathfinding algoritmos.","Pathfinding algoritmy.","Pathfinding algorytmów.","Pathfinding at Wikipedia","Pathfinding bei Wikipedia","Pathfinding from Wikipedia","Pathfinding in","Pathfinding is a method of determining how NPCs","Pathfinding problem","Pathfinding thuật toán.","Pathfinding |","Pathfinding алгоритмов.","Pathfinding อั ลก อริ.","Pathfinding; it is used under the","Pathing","Pfadfindungsalgorithmen.","Plus de détail sur Wikipedia ;)","Polunetsintä","Recherche de Chemin","Recherche de chemin","Recherche de chemin - Wikipédia","Search for Pathfinding on Wikipedia!","Search for Pathing on Wikipedia!","Wegfindung - Wikipedia","Wegfindung Algorithmen.","Wegfindung Algorithmus","Wegfindungsroutine","Wegsuche","Wikipedia - Pathfinding","Wikipedia article Pathfinding","Wikipedia article Pathing","Wikipedia article on Pathfinding","Wikipedia article on pathfinding","Wikipedia article on “Pathfinding”","Wikipedia entry for Pathfinding","Wikipedia page talking about &quot;pathfinding&quot; in french","Wikipedia page talking about pathfinding in french","Wikipedia sur Path-finding","Wikipedia-Artikel Pathfinding","Wikipedia-Artikel Wegfindung","Wikipedia-Artikel über Pathfinding","Wikipedia-Seite zu 'Pathfinding'","Wikipedia-Seite zu 'Wegfindung'","Wikipedia/Pathfinding","Wikipedia: Pathfinding","algoritma mencari jalan","algoritmo de búsqueda de ruta","algoritmo de encontrar o caminho","article de Wikipedia sur pathfinding","articolo di Wikipedia su Pathfinding","artigo da Wikipedia sobre Pathfinding","artikel Wikipedia pada Perintis","artículo de Wikipedia sobre Pathfinding","bài viết Wikipedia trên Pathfinding","búsqueda de caminos","caminho de descoberta algoritmo","chemin algorithme de recherche","chemin d'accès algorithme de recherche","con đường tìm kiếm thuật toán","en.wikipedia.org/Pathfinding","en.wikipedia.org/wiki/Pathfinding","en.wikipedia.org/wiki/Pathfinding#Algorithms","en:Pathfinding","fi:Polunetsintä","fr:Pathfinding","http://de.wikipedia.org/wiki/Pathfinding","http://de.wikipedia.org/wiki/Wegfindung","http://en.wikipedia....ding#Algorithms","http://en.wikipedia....iki/Pathfinding","http://en.wikipedia.org/wiki/Path_finding","http://en.wikipedia.org/wiki/Pathfin...mple_algorithm","http://en.wikipedia.org/wiki/Pathfinding","http://en.wikipedia.org/wiki/Pathfinding#Algorithms","http://en.wikipedia.org/wiki/Pathfinding#Algorithms.","http://en.wikipedia.org/wiki/Pathfinding#Sample_algorithm","http://en.wikipedia.org/wiki/Pathfinding.","http://fr.wikipedia....erche_de_chemin","http://fr.wikipedia.org/wiki/Path-finding","http://fr.wikipedia.org/wiki/Pathfinding","http://fr.wikipedia.org/wiki/Recherche_de_chemin","http://ru.wikipedia.org/wiki/Поиск_пути","l'article de Wikipédia Path-finding","la définition du pathfinding sur Wikipédia","la recherche de chemin (pathfinding)","mencari jalan algoritma","merintis jalan","odnajdywania","path finding algorithm","pathfiding","pathfind","pathfinding Algorithmen","pathfinding problem","pathfinding system","pathfinding와","pathing (pathfinding)","pathing bugs","percorso di ricerca di algoritmo","percorso finding algoritmo","pioneiro","recherche de chemin","ru:Поиск пути","thuật toán tìm đường dẫn","trovare la strada","ttp://en.wikipedia.org/wiki/Pathfinding.","wiki *générale*","zh:寻路","Алгоритм поиска пути","Поиск пути","Статье Википедии о троп","есть кучи способов","нахождения путей","поиск пути","поиска пути","บทความ Wikipedia ที่ Pathfinding","เส้นทางการค้นหาวิธี","เส้นทางการหาวิธี","“Pathfinding - Wikipedia, the free encyclopedia”, en.wikipedia.org","“Pathfinding” is a method of determining how NPCs","“pathfinding”","アルゴリズムを草分け。","アルゴリズムを見つける。","アルゴリズムを見つける目標","アルゴリズム経路探索。","创路人","創路人","对创路人维基百科的文章","寻路","寻路算法。","尋路","尋路算法。","的寻路","経路探索","経路探索資料では、ウィキペディアのアルゴリズム","維基百科文章的創路人","路径寻找算法","路径查找算法","路徑尋找算法","路徑查找算法","경로를 알고리즘을 찾는","경로를 찾는 알고리즘을","알고리즘 Pathfinding.","에 Pathfinding 문서가 위키 피 디아"],"name":"Pathfinding","categories":["All articles needing additional references","Articles needing additional references from January 2013","Game artificial intelligence","Routing algorithms"],"tag_line":"Pathfinding or pathing is the plotting, by a computer application, of the shortest route between two points."}}
,{"_index":"throwtable","_type":"algorithm","_id":"link-state-routing-protocol","_score":0,"_source":{"description":"Link-state routing protocols are one of the two main classes of routing protocols used in packet switching networks for computer communications, the other being distance-vector routing protocols. Examples of link-state routing protocols include open shortest path first (OSPF) and intermediate system to intermediate system (IS-IS).\nThe link-state protocol is performed by every switching node in the network (i.e., nodes that are prepared to forward packets; in the Internet, these are called routers). The basic concept of link-state routing is that every node constructs a map of the connectivity to the network, in the form of a graph, showing which nodes are connected to which other nodes. Each node then independently calculates the next best logical path from it to every possible destination in the network. The collection of best paths will then form the node's routing table.\nThis contrasts with distance-vector routing protocols, which work by having each node share its routing table with its neighbours. In a link-state protocol the only information passed between nodes is connectivity related.\nLink-state algorithms are sometimes characterized informally as each router 'telling the world about its neighbours\"","alt_names":["Link state","'Link state routing protocol'","- Link-state protocol :","- Link-state routing protocol :","-> Leggi tutto l'articolo su 'Link State'","-> Read the article about 'Link-state routing protocol","...Wikipedia Link State","...more on Wikipedia about Link-state routing protocol","2 Detailed description: Distributing maps","2.1 Determining the neighbours of each node","2.2 Distributing the information for the map","2.3 Creating the map","2.4 Notes about this stage","3 Detailed description: Calculating the routing table","3.1 Calculating the shortest paths","3.2 Filling the routing table","3.3 Optimizations to the algorithm","4 Failure modes","5 Advantages and disadvantages of link-state routing","Calculating the routing table","Distributing maps","Estado de enlace","Estado de enlace - Wikipedia, la enciclopedia libre","Estado de los enlaces","Link State","Link State Algorithm","Link State Algorithms","Link State Algorithms Protocols per estat de l","Link State Routing","Link State Routing Protocol","Link State routing","Link State.","Link state routing","Link state routing protocol","Link-State","Link-State - Wikipedia","Link-State Protokoll","Link-State RIP","Link-State Routing Protokoll","Link-State – Wikipedia","Link-state","Link-state Routing","Link-state Routing Protocol","Link-state algorithms","Link-state protocol","Link-state routing","Link-state routing protocol","Link-state routing protocol - Wikipedia, the free encyclopedia","Link-state routing protocol: Advantages and disadvantages of","Link-state routing protocol: Calculating the routing table","Link-state routing protocol: Calculating the shortest paths","Link-state routing protocol: Creating the map","Link-state routing protocol: Determining the neighbors of","Link-state routing protocol: Distributing maps","Link-state routing protocol: Distributing the information for","Link-state routing protocol: Failure modes","Link-state routing protocol: Filling the routing table","Link-state routing protocol: History","Link-state routing protocol: Notes about this stage","Link-state routing protocol: Optimizations to the algorithm","Link-state routing protocol; it is used under","Link-state routing protocols","Link-state_routing_protocol","Linke-State","Linkstatusprotokoll","The Optimized Link State Routing Protocol for Mobile","What is the history of Link state routing","Wikipedia (Link-state routing protocol)","Wikipedia Link State Routing Protocol","Wikipedia article Link-state","Wikipedia article Link-state protocol","Wikipedia article Link-state routing protocol","Wikipedia article Link-state routing protocols","Wikipedia article on Link-state protocol","Wikipedia entry for Link-state routing protocol","Wikipedia-Artikel Link-State","Wikipedia-Artikel Link-State Routing Protokoll","Wikipedia-Artikel Linkstatusprotokoll","Wikipedia-Seite zu 'Link-State'","Wikipedia-Seite zu 'Linkstatusprotokoll'","Wikipedia: Link State Routing Protocols","Wikipedia: Link-state_routing_protocol","[4] Link-state routing protocol","artículo de Wikipedia Estado de enlace","artículo de Wikipedia Estado de los enlaces","de:Link-State","en.wikipedia.org/wiki/Link-...","en.wikipedia.org/wiki/Link-state_routing_protocol","en:Link-state routing protocol","es:Estado de enlace","es:Estado_de_enlace","estado de enlace","estado de los enlaces","estado del enlace","estados de los enlaces","http://de.wikipedia.org/wiki/Link-State","http://de.wikipedia.org/wiki/Link-State_Routing_","http://de.wikipedia.org/wiki/Linkstatusprotokoll","http://en.wikipedia.org/w...outing_protocol","http://en.wikipedia.org/wi ki/Link-state_routing_protocol","http://en.wikipedia.org/wiki/Link-","http://en.wikipedia.org/wiki/Link-state","http://en.wikipedia.org/wiki/Link-state ... g_protocol","http://en.wikipedia.org/wiki/Link-state routing","http://en.wikipedia.org/wiki/Link-state_","http://en.wikipedia.org/wiki/Link-state_protocol","http://en.wikipedia.org/wiki/Link-state_routing_protocol","http://en.wikipedia.org/wiki/Link-state_…","http://es.wikipedia.org/wiki/Estado_de_enlace","http://es.wikipedia.org/wiki/Estado_de_los_enlaces","http://it.wikipedia.org/wiki/Link_State","ink-state routing protoco","ink-state,","it:Link State","link state","link state protocol","link state routing","link state ruutingu","link-state","link-state protocol","link-state routing","link-state routing protocol","link-state routing protocols","mk:Link-state routing protocol","protocolo de estado enlace","protocols d'enrutament","routers face in a large network","wikipedia:Link-state routing protocol"],"name":"Link-state routing protocol","categories":["All articles lacking in-text citations","All articles with unsourced statements","Articles lacking in-text citations from September 2010","Articles with unsourced statements from February 2013","Routing algorithms","Routing protocols"],"tag_line":"Link-state routing protocols are one of the two main classes of routing protocols used in packet switching networks for computer communications, the other being distance-vector routing protocols."}}
,{"_index":"throwtable","_type":"algorithm","_id":"chakravala-method","_score":0,"_source":{"description":"The chakravala method (Sanskrit: चक्रवाल विधि) is a cyclic algorithm to solve indeterminate quadratic equations, including Pell's equation. It is commonly attributed to Bhāskara II, (c. 1114 – 1185 CE) although some attribute it to Jayadeva (c. 950 ~ 1000 CE). Jayadeva pointed out that Brahmagupta's approach to solving equations of this type could be generalized, and he then described this general method, which was later refined by Bhāskara II in his Bijaganita treatise. He called it the Chakravala method: chakra meaning \"wheel\" in Sanskrit, a reference to the cyclic nature of the algorithm. E. O. Selenius held that no European performances at the time of Bhāskara, nor much later, exceeded its marvellous height of mathematical complexity.\nThis method is also known as the cyclic method and contains traces of mathematical induction.","alt_names":["Bhaskara's lemma","''chakravala'' method","- Chakravala method :","Bhaskara's lemma - Wikipedia, the free encyclopedia","Chakravala","Chakravala method","Chakravala method - Wikipedi...","Chakravala method - Wikipedia :: The free encyclopedia","Chakravala method - Wikipedia, the free encyclopedia","Chakravala method Wikipedia the free encyclopedia","Chakravala method: Example","Chakravala method; it is used under the","Chakravala's Method","Chakravala_method","Kaedah chakravala","Mètode chakravala","Mètode chakravala - Viquipèdia","Méthode chakravala","Méthode chakravala - Wikipédia","N x 2 + 1 = y 2 ,","N x 2 + k = y 2 &Rightarrow; N","Proof of Bhaskara's lemma","What is Chakravala method's example","What is proof of Proof of Bhaskara's Lemma","Wikipedia article Bhaskara's lemma","Wikipedia article Chakravala method","Wikipedia article Kaedah chakravala","Wikipedia article Mètode chakravala","Wikipedia article Méthode chakravala","Wikipedia article Proof of Bhaskara's Lemma","Wikipedia article Proof of Bhaskara's lemma","Wikipedia entry for Chakravala method","article Chakravala method","ca:Mètode chakravala","chakravala","chakravala (cyclic) method","chakravala method","cyclic method","en.wikipedia.org/wiki/Chakravala_method","fr:Méthode chakravala","hi:चक्रवाल विधि","http://en.wikipedia.org/wiki/Bhaskara %27s_lemma","http://en.wikipedia.org/wiki/Bhaskara%27s_lemma","http://en.wikipedia.org/wiki/Bhaskara's lemma","http://en.wikipedia.org/wiki/Chakravala method","http://en.wikipedia.org/wiki/Chakravala_","http://en.wikipedia.org/wiki/Chakravala_method","http://fr.wikipedia.org/wiki/M%C3%A9thode_chakravala","http://fr.wikipedia.org/wiki/Méthode_chakravala","ms:Kaedah chakravala","méthode chakravala","méthode du chakravala","y = 1766319049 .","yago-res:Chakravala method","चक्रवाल विधि"],"name":"Chakravala method","categories":["Articles containing Sanskrit-language text","Brahmagupta","Diophantine equations","Indian mathematics","Number theoretic algorithms"],"tag_line":"The chakravala method (Sanskrit: चक्रवाल विधि) is a cyclic algorithm to solve indeterminate quadratic equations, including Pell's equation."}}
,{"_index":"throwtable","_type":"algorithm","_id":"diffusing-update-algorithm","_score":0,"_source":{"description":"DUAL, the Diffusing Update ALgorithm, is the algorithm used by Cisco's EIGRP routing protocol to ensure that a given route is recalculated globally whenever it might cause a routing loop. It was developed by J.J. Garcia-Luna-Aceves at SRI International. According to Cisco, the full name of the algorithm is DUAL finite-state machine (DUAL FSM). EIGRP is responsible for the routing within an autonomous system and DUAL responds to changes in the routing topology and dynamically adjusts the routing tables of the router automatically.\nEIGRP uses a feasibility condition to ensure that only loop-free routes are ever selected. The feasibility condition is conservative: when the condition is true, no loops can occur, but the condition might under some circumstances reject all routes to a destination although some are loop-free.\nWhen no feasible route to a destination is available, the DUAL algorithm  invokes a Diffusing Computation  to ensure that all traces of the problematic route are eliminated from the network. At which point the normal Bellman–Ford algorithm is used to recover a new route.","alt_names":["- DUAL algorithm :","...mehr auf Wikipedia über Diffusing Update Algorithm","DUAL algorithm","DUAL algorithm; it is used under the","DUAL – Wikipedia","Diffusing Update Algorithm","Diffusing Update Algorithm (DUAL)","Diffusing Update Algorithm - Wikipedia, la enciclopedia libre","Diffusing Update Algorithm – Wikipedia","Diffusing update algorithm","Diffusing update algorithm - Wikipedia, the free encyclopedia","Diffusing update algorithm - Wikipedia, the free encyclopedia ...","Diffusing_Update_Algorithm","Dual-pelaajaa .","Wikipedia - DUAL","Wikipedia article DUAL algorithm","Wikipedia article Diffusing Update Algorithm","Wikipedia article Diffusing update algorithm","Wikipedia article on Diffusing Update Algorithm","Wikipedia entry for Diffusing update algorithm","Wikipedia-Artikel Diffusing Update Algorithm","Wikipedia-Seite zu 'Diffusing Update Algorithm'","artículo de Wikipedia DUAL","artículo de Wikipedia Diffusing Update Algorithm","de.wikipedia.org/wiki/Diffusing_Update_Algorithm","en.wikipedia.org/wiki/Diffusing_update_algorithm","en:Diffusing update algorithm","es.wikipedia.org/wiki/Diffusing_Update_Algorithm","http://de.wikipedia.org/wiki/Diffusing_U","http://de.wikipedia.org/wiki/Diffusing_Update_Algorithm","http://en.wikipedia.org/wiki/Diffusing_u","http://en.wikipedia.org/wiki/Diffusing_update_algorithm","http://es.wikipedia.org/wiki/DUAL","http://es.wikipedia.org/wiki/Diffusing_Update_Algorithm","http://fi.wikipedia.org/wiki/DUAL","الگوریتم انتشار به روز - ویکیپدیا"],"name":"Diffusing update algorithm","categories":["Routing algorithms","Routing protocols","SRI International software"],"tag_line":"DUAL, the Diffusing Update ALgorithm, is the algorithm used by Cisco's EIGRP routing protocol to ensure that a given route is recalculated globally whenever it might cause a routing loop."}}
,{"_index":"throwtable","_type":"algorithm","_id":"klee–minty-cube","_score":0,"_source":{"description":"The Klee–Minty cube (named after Victor Klee and George J. Minty) is a unit cube whose corners have been slightly perturbed. Klee and Minty demonstrated that Dantzig's simplex algorithm has poor worst-case performance when initialized at one corner of their \"squashed cube\".\nIn particular, many optimization algorithms for linear optimization exhibit poor performance when applied to the Klee–Minty cube. In 1973 Klee and Minty showed that Dantzig's simplex algorithm was not a polynomial-time algorithm when applied to their cube. Later, modifications of the Klee–Minty cube have shown poor behavior both for other basis-exchange pivoting algorithms and also for interior-point algorithms.","alt_names":[],"name":"Klee–Minty cube","categories":["All articles to be expanded","All articles with unsourced statements","Analysis of algorithms","Articles to be expanded from April 2011","Articles with unsourced statements from October 2015","Computational complexity theory","Convex geometry","Cubes","Linear programming","Mathematical optimization","Pages containing links to subscription-only content","Pages using duplicate arguments in template calls"],"tag_line":"The Klee–Minty cube (named after Victor Klee and George J. Minty) is a unit cube whose corners have been slightly perturbed."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lemke's-algorithm","_score":0,"_source":{"description":"In mathematical optimization, Lemke's algorithm is a procedure for solving linear complementarity problems, and more generally mixed linear complementarity problems. It is named after Carlton E. Lemke.\nLemke's algorithm is of pivoting or basis-exchange type. Similar algorithms can compute Nash equilibria for two-person matrix and bimatrix games.","alt_names":["Lemke's algorithm - Wikipedia, the free encyclopedia","Lemke's algorithm","- Lemke's algorithm :","Lemke s algorithm Wikipedia the free encyclopedia","Lemke's algorithm - Wikipedia :: The free encyclopedia","Principal pivoting algorithm of Lemke","Wikipedia article Lemke's algorithm","http://en.wikipedia.org/wiki/Lemke%27s_algorithm"],"name":"Lemke's algorithm","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Mathematical optimization","Optimization algorithms and methods"],"tag_line":"In mathematical optimization, Lemke's algorithm is a procedure for solving linear complementarity problems, and more generally mixed linear complementarity problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"newton's-method","_score":0,"_source":{"description":"In numerical analysis, Newton's method (also known as the Newton–Raphson method), named after Isaac Newton and Joseph Raphson, is a method for finding successively better approximations to the roots (or zeroes) of a real-valued function.\n\nThe Newton–Raphson method in one variable is implemented as follows:\nGiven a function ƒ defined over the reals x, and its derivative ƒ', we begin with a first guess x0 for a root of the function f. Provided the function satisfies all the assumptions made in the derivation of the formula, a better approximation x1 is\n\nGeometrically, (x1, 0) is the intersection with the x-axis of the tangent to the graph of f at (x0, f (x0)).\nThe process is repeated as\n\nuntil a sufficiently accurate value is reached.\nThis algorithm is first in the class of Householder's methods, succeeded by Halley's method. The method can also be extended to complex functions and to systems of equations.","alt_names":["7 Ejemplo","Ньютона-Рафсона","Newton-Raphson iteration","Newton Method","Newton method","牛頓法","Newton-Raphson method","Newton-Raphson","http://en.wikipedia.org/wiki/Newton's_method","Newton-módszer","Newton's method - Wikipedia, the free encyclopedia","Newton's Method","Newton-Verfahren",", http://en.wikipedia.org/wiki/Newton%27s_method","- Newton Wiki page","- Newton's method :","- Newton-Raphson :","-Newton, aby vysoké","-Raphson iteración de Newton","-Raphsona iteracji Newtona","-ラプソンで","...Wikipedia Metoda Newtona","...Wikipedia Metodo delle tangenti","...Wikipedia Méthode de Newton","...Wikipedia Método de Newton","...Wikipedia Newtons metod","...mehr auf Wikipedia über Newton-Verfahren","...more on Wikipedia about Newton's method","1 導入","1. Метод Ньютона-Рафсона","2 Descripción del método","2 方法說明","2 方法说明","2 高次元の場合","3 Obtención del Algoritmo","3 注意","3 牛顿法开方的例子","300px-NewtonsMethodConvergence ...","4 Convergencia del Método","4 其它例子","4 改良","4.1 第一个例子","4.2 第二个例子","5 Estimación del Error","5. نیوتن-رافسون Newton-Raphson","5.1 Complex functions","6 Teorema de Convergencia Local del Método de","8 Codigo en MatLab","Analysis section","Animation: Iteration","Application to minimization ...","Application to minimization and maximization problems","Das Newton-Verfahren im Mehrdimensionalen","Das Newtonverfahren im Mehrdimensionalen","De lo primero que he encontrado","Ejemplos de resolución numérica de ecuaciones algebraicas (Método","Esim. Newtonin metodi.","Euler iteration using Jacobian determinate","High-Order Newton","Ir a Método de Newton - Wikipedia, la enciclopedia","It looks a bit different","Iterazione Newton-Raphson","La méthode des fluxions et des suites infinies","Lien externe : wikipedia, méthodes de Newton...","M?thode de Newton - Wikip?dia","M?todo de Newton - Wikipedia, la enciclopedia libre","M?todo de Newton ? Wikip?dia, a enciclop","Methode van Newton","Methode van Newton-Raphson","Metoda Newtona","Metoda Newtona ? Wikipedia, wolna encyklopedia","Metoda Newtona – Wikipedia, wolna encyklopedia","Metoda Newtona – Wikipedia, wolna…","Metoda tečen","Metoda tečen - Wikipedie","Metode Newton","Metode Newton - Wikipedia bahasa Indonesia, ensiklopedia bebas","Metodo de Newton explicado en la Wikipedia","Metodo delle tangenti","Metodo delle tangenti (altrimenti detto anche metodo di","Metodo delle tangenti - Wikipedia","Metodo di Newton o metodo delle tangenti","Metodo di Newton(-Raphson) o metodo delle tangenti","Metodo di Newton-Raphson","Mr Newton or Mr Raphson","Mthode de Newt pdia","Mètode de Newton","Méthode de Newton","Méthode de Newton - Wikipédia","Méthode de Newton-Raphson","Méthode_de_Newton","Méthode_de_Newton-Raphson","Método Newton-Raphson","Método de Newton","Método de Newton - Wikipedia, la enciclopedia libre","Método de Newton - Wikipédia, a enciclopédia livre","Método de Newton – Wikipédia, a enciclopédia livre","Método de Newton-Raphson","M鴯do de Newton - Wikipedia, la enciclopedia","NEWTON'S METHOD","NEWTON-RAPHSON","Netwon Raphson","Netwon's Method of Approximation","Netwon-Raphson","Netwon法","Newotn法","Newt's method","Newton 's Method","Newton - Raphson","Newton - Raphson方法","Newton - Raphson法の繰り返し","Newton - Raphson法を","Newton - Verfahren","Newton Iteration","Newton Rapheson","Newton Raphson","Newton Raphson Method","Newton Raphson iteration","Newton Raphson method","Newton Raphson methode","Newton Raphson metode","Newton Raphsonova metoda","Newton Verfahren","Newton Verfahren *klick*","Newton Verfahren – Wikipedia","Newton für cos und sin","Newton iterací","Newton iteratie","Newton iteration","Newton methods","Newton módszer","Newton módszerével","Newton s method - Wikipedia, the free encyclopedia","Newton s method Simple English Wikipedia the free","Newton s method Wikipedia the free encyclopedia","Newton s method Wikipedia the free encyclopedia - result","Newton und Fixpunkt","Newton verfahren","Newton%27s_method","Newton%27s_method [Wikipedia]","Newton's (or Newton-Raphson) Method","Newton's (or the Newton-Raphson) method","Newton's Algorithm","Newton's Approximation Method","Newton's Method - Wikipedia","Newton's Method - Wikipedia, The Free Encyclopedia","Newton's Method @ Wiki","Newton's Method for Finding Square Roots","Newton's Method of approximation","Newton's Method page","Newton's algorithm","Newton's algorithm.","Newton's approximation method","Newton's direction","Newton's famous method","Newton's iteration","Newton's iteration formula","Newton's iterative method","Newton's metho","Newton's method","Newton's method (also known as the Newton-Raphson","Newton's method (wikipedia)","Newton's method - Simple English Wikipedia, the free encyclopedia","Newton's method - Wikipedia","Newton's method - Wikipedia, the free ...","Newton's method - Wikipedia...","Newton's method for approximating roots","Newton's method for calculating the square root","Newton's method for finding roots of equations","Newton's method i","Newton's method in Wikipedia","Newton's method of finding a root","Newton's method on Wikipedia","Newton's method sucks","Newton's method t","Newton's method,","Newton's method.","Newton's method..","Newton's method: History","Newton's root finding method","Newton's_method","Newton'sche Näherungsverfahren","Newton'schen Näherungsverfahren","Newton'sches Näherungsverfahren","Newton(ニュートン)法","Newton-Iteration","Newton-Iterationen","Newton-Methode","Newton-Ralphson","Newton-Ralpson","Newton-Raphson - Wikipedia","Newton-Raphson Algorithm","Newton-Raphson Have a look at the","Newton-Raphson Iteration","Newton-Raphson Method","Newton-Raphson algorithm","Newton-Raphson approximation","Newton-Raphson for a system on non-linear","Newton-Raphson method wh","Newton-Raphson method.","Newton-Raphson methode","Newton-Raphson metode","Newton-Raphson metode - Wikipedia","Newton-Raphson módszer","Newton-Raphson optimization","Newton-Raphson'a metody","Newton-Raphson's method","Newton-Raphson-Iteration","Newton-Raphson-Methode","Newton-Raphson-Verfahren","Newton-Raphsona","Newton-Raphsonmethode","Newton-Raphsonova","Newton-Raphsonova iterace","Newton-Raphsonova metoda","Newton-Raphsons iterationsformel","Newton-Raphsons iterationsmetod","Newton-Raphsons metod","Newton-Rapshon","Newton-Rapson","Newton-Rhapson's method","Newton-Verfahre","Newton-Verfahren (Heronverfahren)","Newton-Verfahren (Wikipedia)","Newton-Verfahren - Wikipedia","Newton-Verfahren ? Wikipedia","Newton-Verfahren bei Wikipedia","Newton-Verfahren für Systeme","Newton-Verfahren – Wikipedia","Newton-Verfahren#Konstruktion_am_Graphen","Newton-Verfahrens","Newton-based","Newton-eljárás","Newton-féle fraktált","Newton-m?dszer - Wikip?dia","Newton-módszer - Wikipédia","Newton-ove metode","Newton-type methods","Newton??Raphson","NewtonRaphson","Newton_Verfahren","Newton`s Method","Newtonin iteraatiomenetelmällä","Newtonin menetelmä","Newtonin menetelmä – Wikipedia","Newtonin menetelmästä","Newtonin menetelmää","Newtonin metodista englanniksi","Newtonin-Raphsonin menetelmä","Newtonmethode","Newtonova metoda","Newtonova metoda - Wikipedija, prosta enciklopedija","Newtonovou metodou","Newtonovu metodu","Newtonovy metody","Newtons Method Wikipedia The Free Encyclopedia","Newtons Method at Wikipedia","Newtons Näherungsverfahren","Newtons approksimationsmetode","Newtons method","Newtons method - Wikipedia, the free encyclopedia","Newtons metod","Newtons metod - Wikipedia","Newtons metod för icke-linjära ekvationssystem","Newtons metode","Newtons metode - Wikipedia, den frie enc...","Newtons metode - Wikipedia, den frie encyklopædi","Newtonsche Näherungsverfahren","Newtonschen Dings","Newtonschen Näherungsverfahren","Newtonschen Verfahrens","Newtonschen-Näherungsverfahren (Newton-Iteration)","Newtonsches Näherungsverfahren","NewtonschesNäherungsverfahren","Newtonsches_Näherungsverfahren","Newtonverfahren","Newtonverfahrens","Newtonâ€“Raphson","Newtonähnliche Verfahren","Newton–Raphson","Newton–Raphson algorithm","Newton–Raphson iteration","Newton法","Nullstellenbestimmung mit dem Newton-Verfahren","Näherungsverfahren nach newton","Obavezno pogledati animaciju u ovom nemačkom tekstu, pošto","Quadratwurzelberechnung nach Newton","Read the page at Wikipedia","Rhapson","The Newton-Fourier Imaginary Problem","The Newton-Raphson method","The introduction of Newton's method can be read","This is Newton's Method","Verfahren von Newton","What are generalizations of Newton-Raphson Algorithm?","What are generalizations of Newton-raphson method?","What are some examples of Newton-Raphson iteration","What are some examples of Newton-Raphson?","What are some examples of Newtons method?","What is the history of Newton-Raphson Method","Wiki: Newton's Method","Wikimedia Foundation, Inc. (2009, February 4 th 2009","Wikipedia (Newton's method)","Wikipedia - Newton's Method","Wikipedia -> Newton-Verfahren","Wikipedia Met. stycznych","Wikipedia Newton-Verfahren","Wikipedia article Metoda Newtona","Wikipedia article Metodo delle tangenti","Wikipedia article Méthode de Newton","Wikipedia article Método de Newton","Wikipedia article Newton iteration","Wikipedia article Newton's method","Wikipedia article Newton-Raphson","Wikipedia article Newton-Raphson metode","Wikipedia article Newton-Verfahren","Wikipedia article Newtonova metoda","Wikipedia article Newton–Raphson","Wikipedia article about Newton-Raphson","Wikipedia article on Método de Newton","Wikipedia article on Método de Newton-Raphson","Wikipedia article Μέθοδος Νιούτον","Wikipedia article Метод на Нютон","Wikipedia article שיטת ניוטון-רפסון","Wikipedia article طريقة نيوتن","Wikipedia article 牛顿法","Wikipedia artikel Newton-Raphson","Wikipedia sur Méthode de Newton-Raphson","Wikipedia | Newton-Raphson","Wikipedia, about Newton's method","Wikipedia-Artikel Newton-Raphson-Verfahren","Wikipedia-Artikel Newton-Verfahren","Wikipedia-Artikel Newtonsches Näherungsverfahren","Wikipedia-Artikel Newtonverfahren","Wikipedia-Seite zu 'Newton-Raphson-Verfahren'","Wikipedia-Seite zu 'Newton-Verfahren'","Wikipedia-Seite zu 'Newtonsches Näherungsverfahren'","Wikipedia-Seite zu 'Newtonverfahren'","Wikipedia.jp:ニュートン法","Wikipedia: Newton's Method","Wikipedia: Newton's method","Wikipedia: Newton's method.","Wikipedia: Newton-Raphson","Wikipedia: Newton-Verfahren","Wikipedia: Newton-Verfahren (mit Animation)","Wikipedia:Metodo_di_Newton","Wikipedia:Newton's method","Wikipedia:Newton's_method","Wikipedia:Newton-Raphson","Wikipediaで「ニュートン・ラプソン法」を調べる","Wikipediaで「ニュートン法」を調べる","Wikipédia artigo Método de Newton","[COLOR=**********]وطريقة نيوتن[/COLOR]","_method","a generalization of Newton's method","a méthode de Newton","af:Newton-Raphson metode","algoritmo de Newton","analysis section","approssimazione del metodo di Newton","artigo da Wikipédia Método de Newton","artículo de Wikipedia Metodo de Newton","clicale aquí","computation of functional roots","cálculo de raíces funcionales","d'itérations de Newton-Raphson","da:Newtons metode","das Newton-Verfahren","das Newtonverfahren","de alto orden de Newton","de methode van Newton","de onderlinge aanpassing Newton-methode","de.wikipedia.org/wik...nometrische_Funktion","de.wikipedia.org/wiki/Newton-Verfahren","de.wikipedia.org/wiki/Newtonverfahren","de.wikipedia.org/wiki/Newtonverfahren#Das_Newton","de:Newton-Verfahren","detaljan opis (na engleskom)","di metodo di Newton","do metody Newtona","e Newton-Raphson method w","el Método de Newton","el método de Newto","el método de Newton","el:Μέθοδος Νιούτον","en.wikipedia.org/...Newton%27s_method","en.wikipedia.org/...Newton's_method","en.wikipedia.org/wik...systems_of_equations","en.wikipedia.org/wiki/...n's_method","en.wikipedia.org/wiki/Newton%27s_method","en:Newton's method","enter a cycle","ewton's method,","high-order Newton","http//de.wikipedia.org/wiki/Newton-Verfahren","http//de.wikipedia.org/wiki/Newton-Verfahren#Konstruktion_am_Graphen","http://af.wikipedia.org/wiki/Newton-Raphson_metode","http://ar.wikipedia.org/wiki/طريقة_نيوتن","http://ca.wikipedia.org/wiki/M%C3%A8tode_de_Newton","http://cs.wikipedia.org/wiki/Metoda_te","http://cs.wikipedia.org/wiki/Metoda_te%C4%8Den","http://cs.wikipedia.org/wiki/Metoda_tečen ...","http://cs.wikipedia.org/wiki/Newtonova_metoda","http://cs.wikipedia.org/…a_te%C4%8Den","http://da.wikipedia.org/wiki/Newtons_metode","http://de.wikipedia.org/wiki/Ne wton-Verfahren","http://de.wikipedia.org/wiki/Ne wtonsches_N%C3","http://de.wikipedia.org/wiki/Ne wtonverfahren","http://de.wikipedia.org/wiki/Newton-..._Quadratwurzel","http://de.wikipedia.org/wiki/Newton-...ewtonverfahren","http://de.wikipedia.org/wiki/Newton-Raphson-Verfahren","http://de.wikipedia.org/wiki/Newton-Verf","http://de.wikipedia.org/wiki/Newton-Verf...bbruchkriterien","http://de.wikipedia.org/wiki/Newton-Verf...nzbetrachtungen","http://de.wikipedia.org/wiki/Newton-Verf...tion_am_Graphen","http://de.wikipedia.org/wiki/Newton-Verfahren","http://de.wikipedia.org/wiki/Newton-Verfahren#Beispiele_f","http://de.wikipedia.org/wiki/Newton-Verfahren#Berechnung_der_Quadratwurzel","http://de.wikipedia.org/wiki/Newton-Verfahren#Das_Newton","http://de.wikipedia.org/wiki/Newton-Verfahren#Erstes_Beispiel","http://de.wikipedia.org/wiki/Newton-Verfahren#Konstruktion_am_Graphen","http://de.wikipedia.org/wiki/Newton-Verfahren#Konvergenzbetrachtungen","http://de.wikipedia.org/wiki/Newton-Verfahren. On","http://de.wikipedia.org/wiki/Newton-Verf…","http://de.wikipedia.org/wiki/Newtons...rungsverfahren","http://de.wikipedia.org/wiki/Newtonsches...Erstes_Beispiel","http://de.wikipedia.org/wiki/Newtonsches...erungsverfahren","http://de.wikipedia.org/wiki/Newtonsches_N%C3%A4herungsverfahren","http://de.wikipedia.org/wiki/Newtonsches_Näherungsverfahren","http://de.wikipedia.org/wiki/Newtonverf ... Konvergenz","http://de.wikipedia.org/wiki/Newtonverf ... ensionalen","http://de.wikipedia.org/wiki/Newtonverfa...C3.A4nderlichen","http://de.wikipedia.org/wiki/Newtonverfa...sche_Konvergenz","http://de.wikipedia.org/wiki/Newtonverfahren","http://de.wikipedia.org/wiki/Newtonverfa…","http://de.wikipedia.org/wiki/Newton−Raphson−Verfahren","http://de.wikipedia.org/wiki/Newton−Verfahren","http://de.wikipedia.org/wiki/Newton−Verfahren)","http://el.wikipedia.org/wiki/Μέθοδος_Νιούτον","http://en.wikipedia..../Newton-Raphson","http://en.wikipedia....wton%27s_method","http://en.wikipedia.o...uare_root_of_a_number","http://en.wikipedia.org/wiki/ Newton%27s_method","http://en.wikipedia.org/wiki/N ewton%27s_method","http://en.wikipedia.org/wiki/Newton%...ot_of_a_number","http://en.wikipedia.org/wiki/Newton%27s ... _equations","http://en.wikipedia.org/wiki/Newton%27s_me...oot_of_a_number","http://en.wikipedia.org/wiki/Newton%27s_metho...","http://en.wikipedia.org/wiki/Newton%27s_method","http://en.wikipedia.org/wiki/Newton%27s_method#Analysis","http://en.wikipedia.org/wiki/Newton%27s_method#Exa","http://en.wikipedia.org/wiki/Newton%27s_method#Examples","http://en.wikipedia.org/wiki/Newton%27s_method#Nonlinear_sys","http://en.wikipedia.org/wiki/Newton%27s_method#Solution_of_a_non","http://en.wikipedia.org/wiki/Newton%27s_method#Square_root_of_a_number","http://en.wikipedia.org/wiki/Newton%27s_m…","http://en.wikipedia.org/wiki/Newton&...ot_of_a_number","http://en.wikipedia.org/wiki/Newton&...s_of_equations","http://en.wikipedia.org/wiki/Newton'...ot_of_a_number","http://en.wikipedia.org/wiki/Newton's method","http://en.wikipedia.org/wiki/Newton's_","http://en.wikipedia.org/wiki/Newton's_...oot_of_a_number","http://en.wikipedia.org/wiki/Newton's_m ... f_a_number","http://en.wikipedia.org/wiki/Newton's_me...","http://en.wikipedia.org/wiki/Newton's_method#Analysis","http://en.wikipedia.org/wiki/Newton's_method#Example","http://en.wikipedia.org/wiki/Newton's_method#Examples","http://en.wikipedia.org/wiki/Newton's_method#Failure_Analysis","http://en.wikipedia.org/wiki/Newton's_method#Square_root_of_a","http://en.wikipedia.org/wiki/Newton's_method#Square_root_of_a_numb","http://en.wikipedia.org/wiki/Newton's_method#Square_root_of_a_number","http://en.wikipedia.org/wiki/Newton's_method.","http://en.wikipedia.org/wiki/Newton's_me´","http://en.wikipedia.org/wiki/Newton's_me…","http://en.wikipedia.org/wiki/Newton-Raphson","http://en.wikipedia.org/wiki/Newton-Raph…","http://en.wikipedia.org/wiki/Newton_iteration","http://en.wikipedia.org/wiki/newton%27s_method","http://en.wikipedia.org/…n%27s_method","http://es.wikipedia.org/wiki/M%C3%A9todo_de_Newton","http://es.wikipedia.org/wiki/Metodo_de_N…","http://es.wikipedia.org/wiki/Método_de_Newton","http://es.wikipedia.org/wiki/Método_de_N…","http://fr.wikipedia.org/wiki/M%C3%A9thode_de","http://fr.wikipedia.org/wiki/M%C3%A9thode_de_Newton","http://fr.wikipedia.org/wiki/M%c3%a9thode_de_Newton","http://fr.wikipedia.org/wiki/Méthode_de_Newton","http://he.wikipedia.org/wiki/שיטת_ניוטון-רפסון","http://it.wikipedia.org/wiki/Metodo delle tangenti","http://it.wikipedia.org/wiki/Metodo_delle_tangenti","http://it.wikipedia.org/wiki/Metodo_di_Newton","http://it.wikipedia.org/wiki/Metodo_di_N…","http://ja.wikipedia.org/wiki/ニュートン法","http://nl.wikipedia.org/wiki/Newton-Raphson","http://pl.wikipedia.org/wiki/Metoda_Newtona","http://pl.wikipedia.org/wiki/Metoda_Newtona#Warunek_stopu","http://pl.wikipedia.org/wiki/Metoda_Newtona#Zadanie","http://pl.wikipedia.org/wiki/Metoda_stycznych","http://pt.wikipedia.org/wiki/M%C3%A9todo_de_Newton","http://pt.wikipedia.org/wiki/Método_de_Newton","http://ru.wikipedia.org/wiki/Метод Ньютона","http://ru.wikipedia.org/wiki/Метод_Ньюто...","http://ru.wikipedia.org/wiki/Метод_Ньютона","http://ru.wikipedia.org/wiki/Метод_Ньютона#.D0.9C","http://sl.wikipedia.org/wiki/Metoda_pospe%C5%A1ene_iteracije","http://sl.wikipedia.org/wiki/Newtonova_iteracija","http://sl.wikipedia.org/wiki/Newtonova_metoda","http://sl.wikipedia.org/wiki/Tangentna_metoda","http://sv.wikipedia.org/wiki/Newton-Raphsons_metod","http://sv.wikipedia.org/wiki/Newtons_metod","http://zh.wikipedia.org/wiki/牛顿法","hu:Newton-módszer","i høj For Newton","id:Metode Newton","il metodo di Newton","in a Newton-Raphson","iteración de Newton","iteracja Newtona","iterazione di Newton","ja.wikipedia.org/wiki/ニュートン法","jego metody Newtona","ko:뉴턴의 방법","l método de Newton-Raphson d","la méthode de Newton","linearisierter Form","mehrdimensionalen Newton-Verfahren","methode de newton","methode van Newton","methode van Newton-Raphson","metoda Newtona","metoda lui Newton","metode Newton","metoden enligt Wikipedia","metodo delle tangenti","metodo di Newton","metodo di Newton Raphson","metodo di Newton-Raphson","metodou tečen","metody Newtona","metody Newtona-Raphsona","metody newtona","metodą Newtona","mètode de Newton","méthode de Newton","méthode de Newton-Raphson","método Newton","método de Newton","método de Newton Raphson","método de Newton-Raphson","método de Newton-Raphson para encontrar raízes de","método de la tangente o de Newton-Raphson","método de optimización de Newton","método iterativo de aproximação numérica de Newton","newton methode","newton raphson","newton's method","newton's method of finding square roots","newtonian iteration","newtons method","newtonsche Näherungsverfahren","newtonsches Näherungsverfahren","newtonsches näherungsverfahren","newtonverfahren","nicht-konvergenz","nl.wikipedia.org/wiki/Newton-Raphson","operaciones iteradas","ordine elevato Newton","other numerical method might be easier to implement","pl.wikipedia.or.../Metoda_Newtona","pl.wikipedia.org/wiki/Metoda_Newtona","proof of quadratic convergence of Newton's method","sehr ausführliche Erklärung","the Newton-Raphson approximation","the Newton-Raphson method","the Newton-Raphson method for approximating roots","the Newton-Raphson method for determining the roots","the Wikipedia article about Newton's method","the Wikipedia article entitled Newton's method.","the analysis of its error","ttp://en.wikipedia.org/wiki/Newton%27s_method","uk:Метод Ньютона","w:Newton's method","w:Newton's_method","w:ニュートン法","what goes on inside a calculator","wiki: Newtons method","wikipedia - ニュートン法","wikipedia/Newton's_method","wikipedia:ニュートン法","wikpedia Newtonverfahren","wysokiej celu Newton","x_{n+1} = x_n - \\frac{f(x_n)}{f","zbliżenia metoda Newton","» Newton's method (En)","» Newtonova metoda (Cz)","ą metodą Newtona","Μέθοδος Νιούτον - Βικιπαίδεια","άρθρο Newton's method","Википедии статью Метод Ньютона","Метод Ньютона(ВИКИ)","Метод Ньютона-Рафсона","Метод на Нютон","Ньютон итерации","Обавезно погледати анимацију у овом немачком тексту, пошто","Рафсона Ньютона","Статья о Методе Ньютона","алгоритма Ньютона","в методе Ньютона","высокого порядка Ньютона","детаљан опис (на енглеском)","информация по методу","метод Ньютона","метода Ньютона","методом Ньютона","ньютоновского метода касательных","אלגוריתם ניוטון רפסון","הנה זה בוויקיפדיה","ויקיפדיה - 'שיטת ניוטון-רפסון'","כלל ניוטון","ניוטון-רפסון","שיטת ניוטון","שיטת ניוטון-רפסון","שיטת ניוטון-רפסון – ויקיפדיה","طريقة ??","طريقة النّيوتن","طريقة نيوتن","طريقة نيوتن - ويكيبيديا، الموسوعة ...","طريقةنيوتن","نيوتن - رافسون","نﺗوﯾﻧ ﺔﻘﯾرط","وطريقة نيوتن","ٔتْٛٝ ١كٜلط","अंतराल द्विभाजन या न्यूटन","न्यूटन की विधि","न्यूटन-Raphson","न्यूटन-Raphson विधि","होगा न्यूटन-","“Newton-Raphson”","“good”","「ニュートン法」をWikipediaで調べる","「ニュートン法」をWikiで調べる","ニュートンRaphson法は、","ニュートンの近似法","ニュートンラプソン法","ニュートン・ラプソン法","ニュートン反復","ニュートン法","ニュートン法 - Wikipedia","ニュートン法 Newton's method","ニュートン法 Wikipedia","ニュートン法-Wikipedia","ニュートン法-Wikipedia-","ニュートン法の式","ニュートン法を","ニュートン法＠ja.wikipedeia","方法高阶","方程式の数値解","熙剛猜","牛頓法- 維基百科,自由的百科全書","牛頓法的詳細說明請參考維基百科","牛頓迭代","牛顿Raphson迭代","牛顿法","牛顿法- 维基百科，自由的百科全书","牛顿的方法","牛顿的近似方法","牛顿迭代","牛顿迭代法","維基百科的文章“ 牛顿法”","维基百科牛顿法条目","维基百科的文章“ 牛顿法”","高次ニュートンは","뉴턴 - Raphson","뉴턴의 방법","ﾆｭｰﾄﾝ法-wikipedia"],"name":"Newton's method","categories":["All articles lacking in-text citations","All articles needing additional references","Articles lacking in-text citations from February 2014","Articles needing additional references from February 2014","Articles needing additional references from November 2013","Articles with inconsistent citation formats","Commons category with local link same as on Wikidata","Optimization algorithms and methods","Root-finding algorithms","Use dmy dates from January 2012"],"tag_line":"In numerical analysis, Newton's method (also known as the Newton–Raphson method), named after Isaac Newton and Joseph Raphson, is a method for finding successively better approximations to the roots (or zeroes) of a real-valued function."}}
,{"_index":"throwtable","_type":"algorithm","_id":"list-update-problem","_score":0,"_source":{"description":"The List Update or the List Access problem is a simple model used in the study of competitive analysis of online algorithms. Given a set of items in a list where the cost of accessing an item is proportional to its distance from the head of the list, e.g. a Linked List, and a request sequence of accesses, the problem is to come up with a strategy of reordering the list so that the total cost of accesses is minimized. The reordering can be done at any time but incurs a cost. The standard model includes two reordering actions:\nA free transposition of the item being accessed anywhere ahead of its current position;\nA paid transposition of a unit cost for exchanging any two items in the list. Performance of algorithms depend on the construction of request sequences by adversaries under various Adversary models\nAn online algorithm for this problem has to reorder the elements and serve requests based only on the knowledge of previously requested items and hence its strategy may not have the optimum cost as compared to an offline algorithm that gets to see the entire request sequence and devise a complete strategy before serving the first request.","alt_names":["- List update problem :","List update problem","List update problem - Wikipedia, the free encyclopedia","List update problem; it is used under the","Wikipedia article List update problem","http://en.wikipedia.org/wiki/List_update_problem"],"name":"List update problem","categories":["Analysis of algorithms","Online algorithms","Randomized algorithms"],"tag_line":"The List Update or the List Access problem is a simple model used in the study of competitive analysis of online algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"graeffe's-method","_score":0,"_source":{"description":"In mathematics, Graeffe's method or Dandelin–Graeffe method is an algorithm for finding all of the roots of a polynomial. It was developed independently by Germinal Pierre Dandelin in 1826 and Karl Heinrich Gräffe in 1837. Lobachevsky in 1834 also discovered the principal idea of the method. The method separates the roots of a polynomial by squaring them repeatedly. This squaring of the roots is done implicitly, that is, only working on the coefficients of the polynomial. Finally, Viète's formulas are used in order to approximate the roots.\n\n","alt_names":["Graeffe's method","- Dandelin–Gräffe method :","Dandelin-Graeffe iteration","Dandelin-Gräffe method","Dandelin-Gräffe method,","Dandelin-Gräffe numerical method","Dandelin-Gräffe方法","Dandelin–Graeffe method","Dandelin–Gräffe method","Dandelin–Gräffe numerical method","Graeffe's Method","Graeffe's method - Wikipedia, the free ...","Graeffe's method - Wikipedia, the free encyclopedia","Suggested: graeffe's method","Wikipedia article Dandelin-Graffe method","Wikipedia article Dandelin-Gräffe method","Wikipedia article Dandelin–Gräffe method","Wikipedia article Graeffe's method","Wikipedia article on Dandelin-Gräffe method","fe080851e6bf035974cf9be45f ...","graeffe's method","http://en.wikipedia.org/wiki/Dandelin-Gräffe_method","http://en.wikipedia.org/wiki/Graeffe%27s_method","http://en.wikipedia.org/wiki/Graeffe's_method","q ( x 2 ) = p ( x ) p ( - x ) = ( - 1","zh:当德兰-格拉夫方法","当德兰-格拉夫方法","当德兰-格拉夫方法-维基百科，自由的百科全书","維基百科的文章“ Dandelin-Gräffe方法”","维基百科的文章“ Dandelin-Gräffe方法”"],"name":"Graeffe's method","categories":["Root-finding algorithms"],"tag_line":"In mathematics, Graeffe's method or Dandelin–Graeffe method is an algorithm for finding all of the roots of a polynomial."}}
,{"_index":"throwtable","_type":"algorithm","_id":"multicanonical-ensemble","_score":0,"_source":{"description":"In statistics and physics, multicanonical ensemble (also called multicanonical sampling or flat histogram) is a Markov chain Monte Carlo sampling technique that uses the Metropolis–Hastings algorithm to compute integrals where the integrand has a rough landscape with multiple local minima. It samples states according to the inverse of the density of states, which has to be known a priori or be computed using other techniques like the Wang and Landau algorithm. Multicanonical sampling is an important technique for spin systems like the Ising model or spin glasses.","alt_names":[],"name":"Multicanonical ensemble","categories":["Computational physics","Monte Carlo methods","Statistical algorithms"],"tag_line":"In statistics and physics, multicanonical ensemble (also called multicanonical sampling or flat histogram) is a Markov chain Monte Carlo sampling technique that uses the Metropolis–Hastings algorithm to compute integrals where the integrand has a rough landscape with multiple local minima."}}
,{"_index":"throwtable","_type":"algorithm","_id":"gauss–newton-algorithm","_score":0,"_source":{"description":"The Gauss–Newton algorithm is used to solve non-linear least squares problems. It is a modification of Newton's method for finding a minimum of a function. Unlike Newton's method, the Gauss–Newton algorithm can only be used to minimize a sum of squared function values, but it has the advantage that second derivatives, which can be challenging to compute, are not required.\nNon-linear least squares problems arise for instance in non-linear regression, where parameters in a model are sought such that the model is in good agreement with available observations.\nThe method is named after the mathematicians Carl Friedrich Gauss and Isaac Newton.\n\n","alt_names":[],"name":"Gauss–Newton algorithm","categories":["Least squares","Optimization algorithms and methods","Statistical algorithms"],"tag_line":"The Gauss–Newton algorithm is used to solve non-linear least squares problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lehmer–schur-algorithm","_score":0,"_source":{"description":"In mathematics, the Lehmer–Schur algorithm (named after Derrick Henry Lehmer and Issai Schur) is a root-finding algorithm extending the idea of enclosing roots like in the one-dimensional bisection method to the complex plane. It uses the Schur–Cohn test to test increasingly smaller disks for the presence or absence of roots. Alternative methods like Wilf's algorithm apply different tests to differently shaped areas but keep the idea of descent by subdivision.\n\n","alt_names":[],"name":"Lehmer–Schur algorithm","categories":["All articles lacking reliable references","Articles lacking reliable references from June 2011","Root-finding algorithms"],"tag_line":"In mathematics, the Lehmer–Schur algorithm (named after Derrick Henry Lehmer and Issai Schur) is a root-finding algorithm extending the idea of enclosing roots like in the one-dimensional bisection method to the complex plane."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rrqr-factorization","_score":0,"_source":{"description":"An RRQR factorization or rank-revealing QR factorization is a matrix decomposition algorithm based on the QR factorization which can be used to determine the rank of a matrix. The SVD can be used to generate an RRQR, but it is not an efficient method to do so. A RRQR implementation is available for MATLAB.","alt_names":["RRQR factorization","RRQR factorization - Wikipedia, the free encyclopedia"],"name":"RRQR factorization","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Linear algebra stubs","Matrix decompositions","Numerical linear algebra","Use dmy dates from April 2011"],"tag_line":"An RRQR factorization or rank-revealing QR factorization is a matrix decomposition algorithm based on the QR factorization which can be used to determine the rank of a matrix."}}
,{"_index":"throwtable","_type":"algorithm","_id":"benson's-algorithm","_score":0,"_source":{"description":"Benson's algorithm, named after Harold Benson, is a method for solving linear multi-objective optimization problems. This works by finding the \"efficient extreme points in the outcome set\". The primary concept in Benson's algorithm is to evaluate the upper image of the vector optimization problem by cutting planes.","alt_names":[],"name":"Benson's algorithm","categories":["All stub articles","Applied mathematics stubs","Linear programming","Optimization algorithms and methods"],"tag_line":"Benson's algorithm, named after Harold Benson, is a method for solving linear multi-objective optimization problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"interior-point-method","_score":0,"_source":{"description":"Interior point methods (also referred to as barrier methods) are a certain class of algorithms that solves linear and nonlinear convex optimization problems.\n\nJohn von Neumann suggested an interior point method of linear programming which was neither a polynomial time method nor an efficient method in practice. In fact, it turned out to be slower in practice compared to simplex method which is not a polynomial time method. In 1984, Narendra Karmarkar developed a method for linear programming called Karmarkar's algorithm which runs in provably polynomial time and is also very efficient in practice. It enabled solutions of linear programming problems which were beyond the capabilities of simplex method. Contrary to the simplex method, it reaches a best solution by traversing the interior of the feasible region. The method can be generalized to convex programming based on a self-concordant barrier function used to encode the convex set.\nAny convex optimization problem can be transformed into minimizing (or maximizing) a linear function over a convex set by converting to the epigraph form. The idea of encoding the feasible set using a barrier and designing barrier methods was studied by Anthony V. Fiacco, Garth P. McCormick, and others in the early 1960s. These ideas were mainly developed for general nonlinear programming, but they were later abandoned due to the presence of more competitive methods for this class of problems (e.g. sequential quadratic programming).\nYurii Nesterov and Arkadi Nemirovski came up with a special class of such barriers that can be used to encode any convex set. They guarantee that the number of iterations of the algorithm is bounded by a polynomial in the dimension and accuracy of the solution.\nKarmarkar's breakthrough revitalized the study of interior point methods and barrier problems, showing that it was possible to create an algorithm for linear programming characterized by polynomial complexity and, moreover, that was competitive with the simplex method. Already Khachiyan's ellipsoid method was a polynomial time algorithm; however, it was too slow to be of practical interest.\nThe class of primal-dual path-following interior point methods is considered the most successful. Mehrotra's predictor-corrector algorithm provides the basis for most implementations of this class of methods.","alt_names":["Innere-Punkte-Verfahren","- Interior point method :","- Interior-point method :","-> Read more about Interior point method","...mehr auf Wikipedia über Innere-Punkte-Verfahren","...more on Wikipedia about Interior point method","Innere-Punkte-Verfahren ? Wikipedia","Innere-Punkte-Verfahren – Wikipedia","Interior Point Method","Interior Point method","Interior point method","Interior point method - Wikipedia :: The free encyclopedia","Interior point method - Wikipedia, the free ...","Interior point method - Wikipedia, the free encyclopedia","Interior point method - Wikipedia, the free encyclopedia ...","Interior point methods","Interior-Point","Interior-point method","Interior-point methods","Interior_point_method","M?thode du point int?rieur - Wikip?dia","Méthode du point intérieur - Wikipédia","Méthodes de points intérieurs","Pour compléter le message de C. de Pluquaire","Wikipedia (Interior point method)","Wikipedia article Interior point method","Wikipedia article Interior point methods","Wikipedia article Interior-point method","Wikipedia article Méthode du point intérieur","Wikipedia article on Interior point method","Wikipedia article on Interior point methods","Wikipedia sur Méthode du point intérieur","Wikipedia-Artikel Innere-Punkte-Verfahren","Wikipedia-Seite zu 'Innere-Punkte-Verfahren'","Wikipedia: Interior point method","Wikipedia:Interior_point_method","central-path algorithms","de.wikipedia.org/wiki/Innere-Punkte-Verfahren","de:Innere-Punkte-Verfahren","en.wikipedia.org/wiki/Interior_point_method","en:Interior point method","fr:Méthode du point intérieur","http://de.wikipedia.org/wiki/Innere-Punk","http://de.wikipedia.org/wiki/Innere-Punkte-Verfahren","http://en.wikipedia.org/wiki/Interior_po","http://en.wikipedia.org/wiki/Interior_point_method","http://www.de.wikipedia.org/wiki/Innere-Punkte","inter point method","interior point method","interior point methods","interior-point","interior-point method","interior-point methods","interior-point paradigm","interior-point techniques","methods for LP","méthode du point intérieur","método dos pontos interiores","métodos de punto interior","on by cutting","path-following algorithms","point intérieur","points intérieurs","–following algorithms","内点法"],"name":"Interior point method","categories":["CS1 errors: chapter ignored","Optimization algorithms and methods","Use dmy dates from February 2011"],"tag_line":"Interior point methods (also referred to as barrier methods) are a certain class of algorithms that solves linear and nonlinear convex optimization problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"great-deluge-algorithm","_score":0,"_source":{"description":"The Great Deluge algorithm (GD) is a generic algorithm applied to optimization problems. It is similar in many ways to the hill-climbing and simulated annealing algorithms.\nThe name comes from the analogy that in a great deluge a person climbing a hill will try to move in any direction that does not get his/her feet wet in the hope of finding a way up as the water level rises.\nIn a typical implementation of the GD, the algorithm starts with a poor approximation, S, of the optimum solution. A numerical value called the badness is computed based on S and it measures how undesirable the initial approximation is. The higher the value of badness the more undesirable is the approximate solution. Another numerical value called the tolerance is calculated based on a number of factors, often including the initial badness.\nA new approximate solution S' , called a neighbour of S, is calculated based on S. The badness of S' , b' , is computed and compared with the tolerance. If b' is better than tolerance, then the algorithm is recursively restarted with S : = S' , and tolerance := decay(tolerance) where decay is a function that lowers the tolerance (representing a rise in water levels). If b' is worse than tolerance, a different neighbour S* of S is chosen and the process repeated. If all the neighbours of S produce approximate solutions beyond tolerance, then the algorithm is terminated and S is put forward as the best approximate solution obtained.","alt_names":["Gunter Dueck","...mehr auf Wikipedia über Gunter Dueck","...mehr auf Wikipedia über Sintflutalgorithmus","6unt3r Dück","DE: Gunter Dueck","De : Gunter Dueck","De: Gunter Dueck","DeWikiPedia:Gunter_Dueck","Dueck Gunter","Er forschte zehn Jahre mit seinem wissenschaftlichen Vater","G. Dueck","Great Deluge Algorithm","Great Deluge algorithm","Great Deluge algorithm - Wikipedia :: The free encyclopedia","Great Deluge algorithm - Wikipedia, the free encyclopedia","Great Deluge algorithm - Wikipedia, the free encyclopedia ...","Great Deluge algorithm Wikipedia the free encyclopedia","Gunter Duck","Gunter Dueck - Wikipedia","Gunter Dueck ? Wikipedia","Gunter Dueck bei Wikipedia","Gunter Dueck â Wikipedia","Gunter Dueck – Wikipedia","Gunter Dueck,","Gunter Dueck.","Gunter Duecks","Gunter Dück","Gunter_Dueck","Günter Dueck","Prof. Dr. Guenter Dueck","Prof. Dr. Gunter Dueck","Prof. Dueck","Prof. Gunter Dueck","Screenshot http://de.wikipedia.org/wiki/Gunter_Dueck","Sintflut-Algorithmus","Sintflutalgorithmus","Sintflutalgorithmus - Wikipedia","Sintflutalgorithmus ? Wikipedia","Sintflutalgorithmus – Wikipedia","Wikipedia entry for Great Deluge algorithm","Wikipedia-Artikel Gunter Dueck","Wikipedia-Artikel Sintflut-Algorithmus","Wikipedia-Artikel Sintflutalgorithmus","Wikipedia-Seite zu 'Gunter Dueck'","Wikipedia-Seite zu 'Sintflutalgorithmus'","Wikipedia: Gunter Dueck","[د]: غنتر [دوك]","de ：Gunter Dueck","de.wikipedia.org/wiki/Sintflutalgorithmus","de: Gunter Dueck","de:Gunter Dueck","de:Sintflutalgorithmus","en.wikipedia.org/wiki/Great_De...","http://de.wikipedia.org/wiki/Gu nter_Dueck","http://de.wikipedia.org/wiki/Gunter_Duec","http://de.wikipedia.org/wiki/Gunter_Dueck","http://de.wikipedia.org/wiki/Sintflutalg","http://de.wikipedia.org/wiki/Sintflutalgorithmus","http://en.wikipedia.org/wiki/Great_Delug","http://en.wikipedia.org/wiki/Great_Deluge_Algorithm","http://en.wikipedia.org/wiki/Great_Deluge_algorithm","yago-res:Great Deluge algorithm","大洪水演算法"],"name":"Great Deluge algorithm","categories":["Optimization algorithms and methods"],"tag_line":"The Great Deluge algorithm (GD) is a generic algorithm applied to optimization problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"glowworm-swarm-optimization","_score":0,"_source":{"description":"The glowworm swarm optimization (GSO) is a swarm intelligence optimization algorithm developed based on the behaviour of glowworms (also known as fireflies or lightning bugs). The behaviour pattern of glowworms which is used for this algorithm is the apparent capability of the glowworms to change the intensity of the luciferin emission and thus appear to glow at different intensities.\n1.The GSO algorithm makes the agents glow at intensities approximately proportional to the function value being optimized. It is assumed that glowworms of brighter intensities attract glowworms that have lower intensity.\n2.The second significant part of the algorithm incorporates a dynamic decision range by which the effect of distant glowworms are discounted when a glowworm has sufficient number of neighbours or the range goes beyond the range of perception of the glowworms.\nThe part 2 of the algorithm makes it different from Firefly algorithm(FA). In the Firefly algorithm, fireflies can automatically subdivide into subgroups and thus can find multiple global solutions simultaneously, and thus FA is very suitable for multimodal problems. However, in GSO, there is no \"sufficient number or neighbours\" limit and there is no perception limit based on distance, but it can have still have \"cognitive limits\" which allows swarms of glowworms to split into sub-groups and converge to high function value points. This property of the algorithm allows it to be used to identify multiple peaks of a multi-modal function and makes it part of Evolutionary multi-modal optimization algorithms family.\nThe GSO algorithm was developed and introduced by K.N. Krishnanand and Debasish Ghose in 2005 at the Guidance, Control, and Decision Systems Laboratory in the Department of Aerospace Engineering at the Indian Institute of Science, Bangalore, India. Subsequently, it has been used in various applications and several papers have appeared in the literature using the GSO algorithm.","alt_names":["- Glowworm swarm optimization :","Glowworm swarm optimization","Glowworm swarm optimization - Wikipedia, the free encyclopedia","Glowworm swarm optimization Wikipedia the free encyclopedia - result","Glowworm swarm optimization; it is used under the","Glowworm_swarm_optimization","Wikipedia article Glowworm swarm optimization","Wikipedia entry for Glowworm swarm optimization","en.wikipedia.org/wiki/Glowworm_swarm_optimization","http://cs.wikipedia.org/wiki/Optimalizace_hejnem_sv%C4%9Btlu","http://en.wikipedia.org/wiki/Glowworm_swarm_optimization","yago-res:Glowworm swarm optimization"],"name":"Glowworm swarm optimization","categories":["Optimization algorithms and methods"],"tag_line":"The glowworm swarm optimization (GSO) is a swarm intelligence optimization algorithm developed based on the behaviour of glowworms (also known as fireflies or lightning bugs)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"mehrotra-predictor–corrector-method","_score":0,"_source":{"description":"Mehrotra's predictor–corrector method in optimization is an implementation of interior point methods. It was proposed in 1989 by Sanjay Mehrotra.\nThe method is based on the fact that at each iteration of an interior point algorithm it is necessary to compute the Cholesky decomposition (factorization) of a large matrix to find the search direction. The factorization step is the most computationally expensive step in the algorithm. Therefore it makes sense to use the same decomposition more than once before recomputing it.\nAt each iteration of the algorithm, Mehrotra's predictor–corrector method uses the same Cholesky decomposition to find two different directions: a predictor and a corrector.\nThe idea is to first compute an optimizing search direction based on a first order term (predictor). The step size that can be taken in this direction is used to evaluate how much centrality correction is needed. Then, a corrector term is computed: this contains both a centrality term and a second order term.\nThe complete search direction is the sum of the predictor direction and the corrector direction.\nAlthough there is no theoretical complexity bound on it yet, Mehrotra's predictor–corrector method is widely used in practice. Its corrector step uses the same Cholesky decomposition found during the predictor step in an effective way, and thus it is only marginally more expensive than a standard interior point algorithm. However, the additional overhead per iteration is usually paid off by a reduction in the number of iterations needed to reach an optimal solution. It also appears to converge very fast when close to the optimum.","alt_names":[],"name":"Mehrotra predictor–corrector method","categories":["All stub articles","Applied mathematics stubs","Optimization algorithms and methods"],"tag_line":"Mehrotra's predictor–corrector method in optimization is an implementation of interior point methods."}}
,{"_index":"throwtable","_type":"algorithm","_id":"guided-local-search","_score":0,"_source":{"description":"Guided Local Search is a metaheuristic search method. A meta-heuristic method is a method that sits on top of a local search algorithm to change its behaviour.\nGuided Local Search builds up penalties during a search. It uses penalties to help local search algorithms escape from local minima and plateaus. When the given local search algorithm settles in a local optimum, GLS modifies the objective function using a specific scheme (explained below). Then the local search will operate using an augmented objective function, which is designed to bring the search out of the local optimum. The key is in the way that the objective function is modified.\n\n","alt_names":["Guided Local Search","Guided Local Search - Wikipedia, the free encyclopedia","Guided Local Search - Wikipedia, the free encyclopedia ...","Guided Local Search Wikipedia the free encyclopedia","Guided Local Search on wikipedia.org","Source Wikipedia.org Arcticle - Guided Local Search","What is the overview of Guided Local Search","Wikipedia article Guided Local Search","Wikipedia article on Guided Local Search","Wikipedia entry for Guided Local Search","guided local search wikipedia the free encyclopedia","http://en.wikipedia.org/wiki/Guided Local Search","http://en.wikipedia.org/wiki/Guided_Local_Search","util ( x , i )"],"name":"Guided Local Search","categories":["All articles needing additional references","All articles with unsourced statements","Articles needing additional references from December 2009","Articles with unsourced statements from July 2014","Heuristics","Optimization algorithms and methods"],"tag_line":"Guided Local Search is a metaheuristic search method."}}
,{"_index":"throwtable","_type":"algorithm","_id":"tolmin-(optimization-software)","_score":0,"_source":{"description":"TOLMIN  is a numerical optimization algorithm by Michael J. D. Powell. It is also the name of Powell's Fortran 77 implementation of the algorithm.\nTOLMIN seeks the minimum of a differentiable nonlinear function subject to linear constraints (equality and/or inequality) and simple bounds on variables. Each search direction is calculated so that it does not intersect the boundary of any inequality constraint that is satisfied and that has a \"small\" residual at the beginning of the line search. The meaning of \"small\" depends on a parameter called TOL which is automatically adjusted, and which gives the name of the software.\nFeatures of the software include: quadratic approximations of the objective function whose second derivative matrices are updated by means of the BFGS formula, active sets technique, primal-dual quadratic programming procedure for calculation of the search direction.\nThe TOLMIN software is distributed under The GNU Lesser General Public License (LGPL).","alt_names":[],"name":"TOLMIN (optimization software)","categories":["Optimization algorithms and methods"],"tag_line":"TOLMIN  is a numerical optimization algorithm by Michael J. D. Powell."}}
,{"_index":"throwtable","_type":"algorithm","_id":"imperialist-competitive-algorithm","_score":0,"_source":{"description":"In computer science, Imperialist Competitive Algorithm (ICA) is a computational method that is used to solve optimization problems of different types. Like most of the methods in the area of evolutionary computation, ICA does not need the gradient of the function in its optimization process.\nFrom a specific point of view, ICA can be thought of as the social counterpart of genetic algorithms (GAs). ICA is the mathematical model and the computer simulation of human social evolution, while GAs are based on the biological evolution of species.\n^","alt_names":["An interesting concept","Imperialist Competitive Algorithm","Imperialist competitive algorithm","Imperialist competitive algorithm - Wikipedia :: The free encyclopedia","Imperialist competitive algorithm - Wikipedia, the free encyclopedia","Imperialistic Competition Algorithm","In English Wiki","http://en.wikipedia.org/wiki/Imperialist_competitive_algorithm","http://en.wikipedia.org/wiki/I​mperialist_competitive_algorit​hm"],"name":"Imperialist competitive algorithm","categories":["Optimization algorithms and methods","Pages with reference errors"],"tag_line":"In computer science, Imperialist Competitive Algorithm (ICA) is a computational method that is used to solve optimization problems of different types."}}
,{"_index":"throwtable","_type":"algorithm","_id":"penalty-method","_score":0,"_source":{"description":"Penalty methods are a certain class of algorithms for solving constrained optimization problems.\nA penalty method replaces a constrained optimization problem by a series of unconstrained problems whose solutions ideally converge to the solution of the original constrained problem. The unconstrained problems are formed by adding a term, called a penalty function, to the objective function that consists of a penalty parameter multiplied by a measure of violation of the constraints. The measure of violation is nonzero when the constraints are violated and is zero in the region where constraints are not violated.","alt_names":["- Penalty method :","Penalty Method","Penalty function","Penalty method","Penalty method - Wikipedia :: The free encyclopedia","Penalty method - Wikipedia, the free encyclopedia","Penalty methods","Wikipedia article Penalty function","Wikipedia article Penalty method","Wikipedia entry for Penalty method","Wikipedia: Penalty method","http://en.wikipedia.org/wiki/Penalty_met","http://en.wikipedia.org/wiki/Penalty_method","min f ( 𝐱 )","penalty force method","penalty function","penalty method","penalty methods","“Penalty method - Wikipedia, the free encyclopedia”, en.wikipedia","ペナルティ法"],"name":"Penalty method","categories":["Optimization algorithms and methods"],"tag_line":"Penalty methods are a certain class of algorithms for solving constrained optimization problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"nelder–mead-method","_score":0,"_source":{"description":"See simplex algorithm for Dantzig's algorithm for the problem of linear optimization.\nThe Nelder–Mead method or downhill simplex method or amoeba method is a commonly applied numerical method used to find the minimum or maximum of an objective function in a multidimensional space. It is applied to nonlinear optimization problems for which derivatives may not be known. However, the Nelder–Mead technique is a heuristic search method that can converge to non-stationary points on problems that can be solved by alternative methods.\nThe Nelder–Mead technique was proposed by John Nelder & Roger Mead (1965).","alt_names":[],"name":"Nelder–Mead method","categories":["Operations research","Optimization algorithms and methods"],"tag_line":"See simplex algorithm for Dantzig's algorithm for the problem of linear optimization."}}
,{"_index":"throwtable","_type":"algorithm","_id":"string-searching-algorithm","_score":0,"_source":{"description":"In computer science, string searching algorithms, sometimes called string matching algorithms, are an important class of string algorithms that try to find a place where one or several strings (also called patterns) are found within a larger string or text.\nLet Σ be an alphabet (finite set). Formally, both the pattern and searched text are vectors of elements of Σ. The Σ may be a usual human alphabet (for example, the letters A through Z in the Latin alphabet). Other applications may use binary alphabet (Σ = {0,1}) or DNA alphabet (Σ = {A,C,G,T}) in bioinformatics.\nIn practice, how the string is encoded can affect the feasible string search algorithms. In particular if a variable width encoding is in use then it is slow (time proportional to N) to find the Nth character. This will significantly slow down many of the more advanced search algorithms. A possible solution is to search for the sequence of code units instead, but doing so may produce false matches unless the encoding is specifically designed to avoid it.","alt_names":["well-known algorithms","actual algorithm","**string **searching **algorithm","- Mintaillesztő algoritmusok","- String searching algorithm :","...Wikipedia Algorithme de recherche de sous-chaîne","...mehr auf Wikipedia über String-Matching-Algorithmus","...more on Wikipedia about String searching algorithm","1 Basic classification","1 Contoh algoritma pencocokkan string","1.1 Single pattern algorithms","1.2 Algorithms using finite set of patterns","1.3 Algorithms using infinite number of patterns","2 Algoritma brute force dalam pencarian string","2 Other classification","2.1 Cara kerja","2.1 Naïve string search","2.2 Finite state automation based search","2.2 Pseudocode","2.3 Stubs","2.4 Index methods","2.5 Other variants","Algorithme de recherche de sous-cha?ne - Wikip","Algorithme de recherche de sous-chaîne","Algorithme de recherche de sous-chaîne - Wikipédia","Algorithms using finite set of patterns","Algoritma Brute Force","Algoritma Pencarian String - Wikipedia Bahasa Indonesia ...","Algoritma brute force","Algoritma panggolkan string","Algoritma panggolèkan string - Wikipedia","Algoritma pencarian string","Algoritma pencarian string - Wikipedia bahasa Indonesia","Algoritma pencarian string - Wikipedia bahasa Indonesia ...","Algoritma pencarian string Wikipedia bahasa Indonesia","Algoritmo de búsqueda de cadenas","Algoritmo di ricerca di stringhe","Algoritmy pre vyhľadávanie podreťazcov","Algoritmy pro vyhledávání v textu","Algoritmy pro vyhledávání v textu - Wikipedie","Beschreibung allgemein","Better search algorithms exist","Cadena algoritmo de búsqueda","Dizi arama algoritması","Dizi arama algoritması - Vikipedi","Finite State Automation Based Search","Finite State Automation Based Search.","Http://en.wikipedia.org/wiki/String_searching_algorithm","Jump to: navigation, search. String searching algorithms, sometimes","La correspondencia de cadenas","Learn about String searching algorithm>>>","Liebhaber Algorithmen","Merkkijonohakualgoritmi","Mustererkennung und wie das funktioniert","Naive Algorithm","O(n) string searching algorithm","Other classification","Pencocokan string","Read More string searching algorithm wikipedia the free","Search and replace","Sonlu örüntü kümesi kullanan algoritmalar","String Matching","String Search Algorithms","String Searching","String Searching Algorithm","String Searching Algorithm Comparison","String Searching Algorithm Wikipedia The Free Encyclopedia","String Searching Algorithm on Wikipedia","String Searching en.wikipedia.org/wiki/String_searching_algorithm","String Suchalgorithmus","String algorithme de recherche","String algoritmo de busca","String algoritmo di ricerca","String algoritmus vyhledávání","String algorytm wyszukiwania","String matching","String matching; it is used under the","String search algorithm","String search algorithms","String search algos","String searching","String searching algorithm","String searching algorithm - Wikipedia","String searching algorithm - Wikipedia :: The free encyclopedia","String searching algorithm - Wikipedia, the free ...","String searching algorithm - Wikipedia, the free e...","String searching algorithm - Wikipedia, the free encyclopedi...","String searching algorithm - Wikipedia, the free encyclopedia","String searching algorithm - Wikipedia, the free encyclopedia ...","String searching algorithm - Wikipedia, the free …","String searching algorithm - Wikip…","String searching algorithm Wikipedia the free encyclopedia","String searching algorithm Wikipedia the free encyclopedia - result","String searching algorithm Wikipedia the free encyclopedia.","String searching algorithm from Wikipedia","String searching algorithm; it is used under the","String searching algorithms","String searching/matching","String searching; it is used under the","String searchingalgorithm - Wikipedia, the free encyclopedia","String søge algoritme","String thuật toán tìm kiếm","String zoeken algoritme","String-Matching","String-Matching-Algorithmen","String-Matching-Algorithmus","String-Matching-Algorithmus - Wikipedia (http://de.wikipedia.org","String-Matching-Algorithmus ? Wikipedia","String-Matching-Algorithmus Wikipedia","String-Matching-Algorithmus – Wikipedia","String-Suchalgorithmus","String_searching_algorithm","Stringa di algoritmo di ricerca","Stringmatching","Substring search","Such-Algorithmen","Suche berücksichtigen","Suche nach Textstrings","Suchmaske","Textsuche","Vikipedi: String Arama Algoritması -","Wiki on String Searhing Algorithm","WikiPedia—String searching algorithm","Wikipedia - String Searching Algorithm","Wikipedia -- String searching algorithm","Wikipedia String Matching","Wikipedia article Algorithme de recherche de sous-chaîne","Wikipedia article Algoritma panggolèkan string","Wikipedia article Algoritma pencarian string","Wikipedia article String matching","Wikipedia article String searching","Wikipedia article String searching algorithm","Wikipedia article on String matching","Wikipedia article on String searching","Wikipedia article on String searching algorithm","Wikipedia article on search algorithms","Wikipedia entry for String searching algorithm","Wikipedia indrejse for streng søgning algoritmer","Wikipedia über String-Matching-Algorithmen","Wikipedia's String searching algorithm entry","Wikipedia-Artikel String-Matching-Algorithmen","Wikipedia-Artikel String-Matching-Algorithmus","Wikipedia-Artikel Suchmaske","Wikipedia-Artikel Textsuche","Wikipedia-Seite zu 'String-Matching-Algorithmen'","Wikipedia-Seite zu 'String-Matching-Algorithmus'","Wikipedia: String Searching Algorithm","Wikipedia: String Searching Algorithm Website thumb","Wikipedia: String searching","Wikipedia: String searching algorithm","Wikipedia: String wyszukiwania","Wikipedia: String-Matching-Algorithmen","Wikipedia: string searching algorithm","Wikipediaで「文字列探索」を調べる","Wikipediaで「文字列検索アルゴリズム」を調べる","Zeichenfolge Suchalgorithmen","aktuální algoritmus","algorithme de recherche de sous-chaîne","algoritma brute force","algoritma pencarian string","algoritma pencarian string wikipedia bahasa indonesia","algoritma yang ada","algoritmi di ricerca di stringa","algoritmi esistenti","algoritmo de búsqueda de cadenas","algoritmo de reales","algoritmo di ricerca di stringhe","algoritmo effettivo","algoritmos de búsqueda de cadena","algoritmos existentes","algoritmos más de lujo","any of several","bestehenden Algorithmen","cautare string in string","ciąg metod przeszukiwania","concordancia con el modelo y la forma en","cualquiera de varios","các thuật toán hiện có","de Wikipedia-entry voor string zoeken algoritmen","de.wikipedia.org/wiki/String-Matching-Algorithmus","des algorithmes existants","deterministic finite automata string search","die Wikipedia-Eintrag für Streichorchester Suchalgorithmen","dowolny z kilku","een van meerdere","eine von mehreren","en af flere","en.wikipedia.org/...String_searching_algorithm","en.wikipedia.org/wiki/String_searching_algorithm","exact string matching","existing algorithms","fa:الگوریتم جستجوی رشته","fa:تطابق رشتهها","fancier algorithms","hledání řetězce algoritmů","hodowca algorytmy","http://cs.wikipedia.org/wiki/Algoritmy_pro_vyhled%C3%A1v","http://de.wikipedia.org/wiki/St ring-Matching","http://de.wikipedia.org/wiki/String-...ng-Algorithmen","http://de.wikipedia.org/wiki/String-...ng-Algorithmus","http://de.wikipedia.org/wiki/String-Matc","http://de.wikipedia.org/wiki/String-Matching-Algorithmen","http://de.wikipedia.org/wiki/String-Matching-Algorithmus","http://de.wikipedia.org/wiki/String-Matc…","http://de.wikipedia.org/wiki/Suchmaske","http://en.wikipedia....ching_algorithm","http://en.wikipedia.org/wiki/String matching","http://en.wikipedia.org/wiki/String%5Fsearching%5Falgorithm","http://en.wikipedia.org/wiki/String_...et_of_patterns","http://en.wikipedia.org/wiki/String_matching","http://en.wikipedia.org/wiki/String_sear","http://en.wikipedia.org/wiki/String_search_algorithm","http://en.wikipedia.org/wiki/String_searching","http://en.wikipedia.org/wiki/String_searching...","http://en.wikipedia.org/wiki/String_searching_algorith","http://en.wikipedia.org/wiki/String_searching_algorithm","http://en.wikipedia.org/wiki/String_searching_algorithm#Algorithms_using_finite_set_of_patterns","http://en.wikipedia.org/wiki/String_searching_algorithm#Na.C3","http://en.wikipedia.org/wiki/String_searching_algorithm#Na.EFve_string_search","http://en.wikipedia.org/wiki/String_searching_algorithm.","http://en.wikipedia.org/wiki/String_sear…","http://fr.wikipedia.org/wiki/Algorit...us-cha","http://fr.wikipedia.org/wiki/Algorithme_de_recherche_de_sous(...)","http://fr.wikipedia.org/wiki/Algorithme_de_recherche_de_sous-cha%C3","http://fr.wikipedia.org/wiki/Algorithme_de_recherche_de_sous-chaîne","http://id.wikipedia.org/wiki/Algoritma_pencarian_string","http://id.wikipedia.org/wiki/Algoritma_pencarian_string#Algoritma_brute_force_dalam_pencarian_string","http://ja.wikipedia.org/wiki/文字列検索アルゴリズム","http://jv.wikipedia.org/wiki/Algoritma_panggol%C3%A8kan_string","http://ru.wikipedia.org/wiki/Поис...троки","http://ru.wikipedia.org/wiki/Поиск_подстроки","http://tr.wikipedia.org/wiki/Dizi_arama_algoritmas%C4%B1","id:Algoritma pencarian string","inding resource (s) strings","ja:文字列探索","jv.wikipedia.org/wiki/Algoritma_panggol%C3%A8kan_string","jv:Algoritma panggolèkan string","la entrada de Wikipedia para la búsqueda de","liefhebber algoritmes","mere kostbare algoritmer","mhtiroglA gnihcraeS gnirtS :aidepikiW","multiple algorithms","multiple pattern search","naive search","naive string matching algorithm","některý z několika","one of resulted in Wikipedia","patroonherkenning, en hoe dat werkt","pattern matching and how that works","pattern matching e di come funziona","ru:Поиск подстроки","rzeczywistych algorytm","search alogorithms","selve algoritmen","smarter algorithm","standard search algorithms","streng søge algoritme","strengen søge-algoritmer","string matching","string matching alg.","string matching algorithm","string matching algorithms","string search","string search algorithm","string search algorithms","string searches algorithms","string searching","string searching algorithm","string searching algorithms","string searching algorithms using a finite set of","string searching problem","string zoeken algoritmen","string-matching","strängmatchningar","substring matching algorithm","substring search","tatsächlichen Algorithmus","tekenreeks zoeken algoritme","text search","text searching","the Wikipedia entry for string searching algorithms","tr:Dizi arama algoritması","uk:Алгоритм пошуку рядка","une chaîne donnée se trouve dans un autre","une question que beaucoup de monde s'est","useful pages","van een van een aantal","voce di Wikipedia per la ricerca di algoritmi","vstupu Wikipedia vyhledávání řetězce algoritmů","vyhľávanie","werkelijke algoritme","wikipedia calls it Naïve string search","wpis w Wikipedii na ciąg algorytmów wyszukiwania","İngilizce Vikipedi'deki 17.09.2009 tarihli String searching","łańcucha algorytm wyszukiwania","řetězce vyhledávání algoritmus","Алгоритм пошуку рядка","Алгоритмы поиска","Википедии статью Поиск подстроки","Поиск подстроки","Строка алгоритм поиска","Строка поиска алгоритма","алгоритмам поиска подстроки в строке","алгоритмы поиска подстроки","задачу знаходження розташування рядка в тексті","любителей алгоритмы","любой из нескольких","один из приведенных в википедии","поиск подстроки","поиска подстроки в строке","пошуку рядка","статью Википедии для струнного алгоритмы поиска","строки поиска алгоритма","строку поиска алгоритмов","существующих алгоритмов","фактического алгоритм","шаблону и как это работает","الگوریتم جستجوی رشته","الگوریتم جستجوی رشته - ویکیپدیا","تطابق رشته ها","تطابق رشتهها در ویکی پدیای انگلیسی","تطابق رشتهها در ویکیپدیای انگلیسی","कई के किसी भी","कई में से किसी","वास्तविक एल्गोरिथ्म","स्ट्रिंग खोज एल्गोरिथ्म","กลไก ที่ มี อยู่","จับ คู่ String","สตริง ขั้น ตอน วิธี การ ค้นหา","、どのようにその作品のパターンマッチング","いくつかのいずれかを","ウィキペディアの記事 文字列探索","ウィキペディアの記事 文字列検索アルゴリズム","几任","字串搜尋演算法","字串搜尋算法","字符串匹配","字符串搜索算法","字符串查找算法","实际的算法","文字列の一致","文字列の探索","文字列探索","文字列探索 - Wikipedia","文字列探索 -wikipedia","文字列探索-wikipedia","文字列検索","文字列検索アルゴリズム","文字列検索アルゴリズム - Wikipedia","文字列検索アルゴリズムを","文字列検索ｱﾙｺﾞﾘｽﾞﾑ-wikipedia","既存のアルゴリズム","现有的算法","現有的算法","的字符串搜索","的字符串搜索算法","票友算法","維基百科的文章“ 字串搜尋演算法”","维基百科条目的搜索算法进行字符串","维基百科的文章“ 字串搜尋演算法”","维基百科：搜索","기존의 알고리즘에서.","문자열 검색 알고리즘.","일치하는 문자열"],"name":"String searching algorithm","categories":["All articles needing additional references","Articles needing additional references from July 2013","String matching algorithms"],"tag_line":"In computer science, string searching algorithms, sometimes called string matching algorithms, are an important class of string algorithms that try to find a place where one or several strings (also called patterns) are found within a larger string or text."}}
,{"_index":"throwtable","_type":"algorithm","_id":"soundex","_score":0,"_source":{"description":"Soundex is a phonetic algorithm for indexing names by sound, as pronounced in English. The goal is for homophones to be encoded to the same representation so that they can be matched despite minor differences in spelling. The algorithm mainly encodes consonants; a vowel will not be encoded unless it is the first letter. Soundex is the most widely known of all phonetic algorithms (in part because it is a standard feature of popular database software such as DB2, PostgreSQL, MySQL, Ingres, MS SQL Server and Oracle) and is often used (incorrectly) as a synonym for \"phonetic algorithm\". Improvements to Soundex are the basis for many modern phonetic algorithms.","alt_names":["Soundex","'soundex' routine","(phonetischer Vergleich)","(what's Soundex?)","- Soundex :","-> Read more about Soundex","...Wikipedia Soundex","...mehr auf Wikipedia über Soundex","...more on Wikipedia about Soundex","20 строк кода","<font color=#0000ff size=3>http://en.wikipedia","Abschnitt „Kritik an dem Verfahren“ des Wikipedia-Soundex","Algorithmus von SOUNDEX","Classic soundex","FaceEx","Fonetisk søgning","General description of Soundex in Wikipedia","Learn about Soundex>>>","More about SoundEx","Relevant 1","Rule numbers on Wikipedia","SOUNDEX","SOUNDEX @ Wikipedia","SOUNDEX @ Википедии","SOUNDEX @ วิ กิ พี เดีย","SOUNDEX algorithm","SOUNDEX()","SOUNDEX() function","SOUNDEX,","SOUNDEX-Algorithmus","SOUNDEX.","SOUNDEX?","Search info on Soundex at Wikipedia","Soudex indexing","Sound Ex","SoundEX","SoundEx","SoundEx Algorithmus","SoundEx algorithm","SoundEx-Algorithmus","Sounddex from wikipedia","Soundex (Wikipedia)","Soundex - Vikipedi","Soundex - Wikipedia","Soundex - Wikipedia, la enciclopedia libre","Soundex - Wikipedia, the free encyclopedia","Soundex - Wikipédia","Soundex ? Wikipedia","Soundex @ Wikipedia","Soundex Algorithm","Soundex Algorithmus","Soundex Code System","Soundex Info","Soundex Matching","Soundex Search","Soundex Suche","Soundex Wiki","Soundex alghoritm","Soundex algorithm","Soundex algorithm.","Soundex at Wikipedia","Soundex bei Wikipedia","Soundex code","Soundex durchsucht","Soundex en Wikipedia","Soundex encoding","Soundex in Wikipedia","Soundex matched","Soundex on Wikipedia","Soundex on wikipedia.org","Soundex pencarian,","Soundex phonetic searching","Soundex search","Soundex system","Soundex tìm kiếm,","Soundex variants","Soundex vyhledávání","Soundex |","Soundex â€“ Wikipedia","Soundex метрике","Soundex поиска","Soundex поиски","Soundex – Wikipedia","Soundex – Wikipedia, wolna encyklopedia","Soundex — Википедия","Soundex's","Soundex,","Soundex-Algorithmus","Soundex-Algorithmus-Programm","Soundex-Code","Soundex-Prinzip","Soundex-Suche","Soundex-Wert","Soundex-algoritmen","Soundex.","Soundex; it is used under the","Soundex?","Soundexの","Soundexの検索","Soundexは","Soundexを","Soundexを検索","Soundex算法","Soundex语音","Soundex语音搜索","Soundex가","Soundex는","Soundex를","Soundex을","Soundex의","Source Wikipedia.org Arcticle - Soundex","The Soundex Algorithm","These encoding rules are available from NARA, upon","Vikipedi'deki Soundex","Wiki Soundex","Wiki on the soundex() function","Wikipedia Soundex","Wikipedia Soundex Entry","Wikipedia Soundex Page","Wikipedia article ''Soundex''","Wikipedia article Soundex","Wikipedia article on Soundex","Wikipedia article on the Soundex algorithm","Wikipedia article סאונדקס","Wikipedia entry for Soundex","Wikipedia on Soundex","Wikipedia —","Wikipedia — Soundex","Wikipedia-Artikel Soundex","Wikipedia-Seite zu 'Soundex'","Wikipedia: Soundex","Wikipedia:Soundex","algorithm to find phonetic spell mistakes in English","algoritma soundex","algoritmo Soundex","algoritmo Soundex?","algoritmo soundex?","algortimo Soundex","artículo de Wikipedia Soundex","búsqueda Soundex","búsqueda Soundex,","búsquedas soundex","d'algorithme soundex?","de.wikipedia.org/wiki/Soundex","de:Soundex","ein SoundEx Lösung","eine SoundEx-Lösung zu implementieren","en.wikipedia.org/Soundex","en.wikipedia.org/wiki/Soundex","es.wikipedia.org/Soundex","es.wikipedia.org/wiki/Soundex","es:Soundex","explicación en ingles del algoritmo","fonetische algoritme Soundex","fr:Soundex","gleichen Hashwerten für völlig unterschiedliche Wörter","he:סאונדקס","http://de.wikipedia.org/wiki/Soundex","http://de.wikipedia.org/wiki/Soundex..._dem_Verfahren","http://en.wikipedia.org/wiki/Sounde","http://en.wikipedia.org/wiki/Soundex","http://en.wikipedia.org/wiki/Soundex )","http://en.wikipedia.org/wiki/Soundex#History","http://en.wikipedia.org/wiki/Soundex#Rules","http://en.wikipedia.org/wiki/Soundex.","http://en.wikipedia.org/wiki/Soundex;","http://en.wikipedia.org/wiki/Soundex>","http://en.wikipedia.org/wiki/Soundex에","http://es.wikipedia.org/wiki/Soundex","http://fr.wikipedia.org/wiki/Soundex","http://pl.wikipedia.org/wiki/Soundex","http://ru.wikipedia.org/wiki/Soundex","http://tr.wikipedia.org/wiki/Soundex","http://uk.wikipedia.org/wiki/Soundex","http://vi.wikipedia.org/wiki/Soundex","http://wikipedia.org/wiki/Soundex","http://zh.wikipedia.org/wiki/Soundex","http://zh.wikipedia.org/zh-hant/Soundex","implement a SoundEx solution","implementar uma solução SoundEx","implementar una solución Soundex","implementare una soluzione SoundEx","implementare una soluzione Soundex","implementere en Soundex solution","kritische beispiel","l'article de Wikipédia Soundex","menerapkan solusi SoundEx","mettre en œuvre une solution SoundEx","nl:Soundex","oplossing te implementeren een Soundex","originele algoritme","pencarian soundex","pesquisa Soundex,","phonetic search","pl:Soundex","recherche Soundex,","recherches Soundex","ricerca Soundex","ricerca Soundex,","ru.wikipedia.org/wiki/Soundex","ru:Soundex","search Soundex,","sound similar enough","soundex","soundex @ 위키백과","soundex algorithm","soundex algorithm here on wikipedia","soundex algoritmo?","soundex algoritmus","soundex based solution","soundex code","soundex durchsucht","soundex metric","soundex metrycznych","soundex na wikipedia","soundex pesquisas","soundex ricerche","soundex search","soundex searches","soundex søgninger","soundex wyszukiwania","soundex zoekopdrachten","soundex खोजों","soundex 검색","soundex 검색에","soundex 솔루션을 구현할","soundex 알고리즘을","soundex()","soundex,","soundex.","soundex?","soundexed","soundex에서","soundex의","soundex처럼","the SOUNDEX","the Soundex","thuật toán Soundex?","thực hiện một giải pháp Soundex","tr:Soundex","tìm kiếm Soundex","uk:Саундекс","unexcellent matching applications","vi:Soundex","wdrożyć rozwiązanie Soundex","www.wikipedia.org/wiki/Soundex","wyszukiwania Soundex","zh:Soundex","|http://en.wikipedia.org/wiki/Soundex, acessado em","Википедии статью Soundex","О SOUNDEX в Википедии","О иид ЛЛ Кл д Кгж Лл ЛЫгйв","Саундекс","Саундэкс","Саундэкс поиска,","Саундэкс.","осуществлять SoundEx решение","реализовать решение Саундэкс","схоже звучат","хттп://ен.википедиа.орг/вики/Соундек","ויקיפדיה - 'סאונדקס'","סאונדקס","סאונדקס – ויקיפדיה","درباره Soundex","การ ค้นหา Soundex","การค้นหา soundex","ขั้น ตอน วิธี soundex?","ใช้ วิธี SoundEx","“Soundex”","がSoundex","にSoundex","のSOUNDEX","のSOUNDEX @ウィキペディア","のSoundex","のSoundex。","のsoundex","のsoundexアルゴリズムの","のsoundexソリューションを実装","のsoundexメトリック","のsoundex検索","を検索します。","到探测","在这个人员","在这个人员搜查","在這個人員","在這個人員搜查","实现一个","家谱图表","實現一個soundex解決","执行一个探测法解决方案，","探测法","探测法搜索","探測法","探測法搜索","的SOUNDEX","的SOUNDEX。","的SOUNDEX，","的soundex","的soundex搜索","的soundex？","維基百科的SOUNDEX @","維基百科的文章“ Soundex ”","维基百科的SOUNDEX @","维基百科的文章“ Soundex ”","这个人员","這個人員"],"name":"Soundex","categories":["All articles with unsourced statements","Articles with unsourced statements from August 2007","Phonetic algorithms"],"tag_line":"Soundex is a phonetic algorithm for indexing names by sound, as pronounced in English."}}
,{"_index":"throwtable","_type":"algorithm","_id":"redos","_score":0,"_source":{"description":"The regular expression denial of service (ReDoS) is an algorithmic complexity attack that produces a denial-of-service by providing a regular expression that takes a very long time to evaluate. The attack exploits the fact that most regular expression implementations have exponential time worst case complexity: the time taken can grow exponentially in relation to input size. An attacker can thus cause a program to spend an effectively infinite amount of time processing by providing such a regular expression, either slowing down or becoming unresponsive.","alt_names":["- Regular expression Denial of Service - ReDoS :","AAA ca exista regular expression denial of service","Expresión regular Negación de Servicio","ReDoS","ReDoS (Regular Expression Denial of Service) - Wikipedia, the","ReDoS - Wikipedia, the free encyclopedia","ReDoS Wikipedia the free encyclopedia","ReDoS on wikipedia.org","Read More redos wikipedia the free encyclopedia","Regex Denial of Service (ReDoS)","Regular Expression can be vulnerable to external Denial","Regular expression Denial of Service","Regular expression Denial of Service - ReDoS","Serangan Layer Aplikasi","The regular expression denial of service","Wikipedia article Regular expression Denial of Service","Wikipedia article Regular expression Denial of Service - ReDoS","en.wikipedia.org/wiki/ReDoS","en:Regular expression Denial of Service – ReDoS","http: / / en.wikipedia.org / wiki / ReDoS","http://en.wikipedia.org/wiki/ReDoS","http://en.wikipedia.org/wiki/ReDoS#Evil_regexes","http://en.wikipedia.org/wiki/Regular_expression_Denial_of_Service_-_ReDoS","regex DDOS","regular expression DoS","regular expression denial of service (ReDoS)","“ReDoS - Wikipedia, the free encyclopedia”, en.wikipedia.org"],"name":"ReDoS","categories":["Algorithmic complexity attacks","Denial-of-service attacks","Pattern matching","Regular expressions"],"tag_line":"The regular expression denial of service (ReDoS) is an algorithmic complexity attack that produces a denial-of-service by providing a regular expression that takes a very long time to evaluate."}}
,{"_index":"throwtable","_type":"algorithm","_id":"tree-rearrangement","_score":0,"_source":{"description":"Tree rearrangements are used in heuristic algorithms devoted to searching for an optimal tree structure. They can be applied to any set of data that are naturally arranged into a tree, but have most applications in computational phylogenetics, especially in maximum parsimony and maximum likelihood searches of phylogenetic trees, which seek to identify one among many possible trees that best explains the evolutionary history of a particular gene or species.","alt_names":["Tree rearrangement","Tree rearrangement - Wikipedia, the free encyclopedia","What is a Tree rearrangement","Wikipedia article Tree rearrangement","Wikipedia entry for Tree rearrangement","http://en.wikipedia.org/wiki/Tree_rearra","http://en.wikipedia.org/wiki/Tree_rearrangement","tree rearrangement","yago-res:Tree rearrangement"],"name":"Tree rearrangement","categories":["Optimization algorithms and methods","Phylogenetics","Trees (data structures)"],"tag_line":"Tree rearrangements are used in heuristic algorithms devoted to searching for an optimal tree structure."}}
,{"_index":"throwtable","_type":"algorithm","_id":"truncated-newton-method","_score":0,"_source":{"description":"Truncated Newton methods, also known as Hessian-free optimization, are a family of optimization algorithms designed for optimizing non-linear function with large numbers of variables. A truncated Newton method consists of repeated application of an iterative optimization algorithm to approximately solve Newton's equations, to determine an update to the function's parameters. The inner solver is truncated, i.e., run for only a limited number of iterations. It follows that, for truncated Newton methods to work, the inner solver needs to produce a good approximation in a few number of iterations; conjugate gradient has been suggested and evaluated as a candidate inner loop. Another prerequisite is good preconditioning for the inner algorithm.","alt_names":[],"name":"Truncated Newton method","categories":["All stub articles","Mathematics stubs","Optimization algorithms and methods"],"tag_line":"Truncated Newton methods, also known as Hessian-free optimization, are a family of optimization algorithms designed for optimizing non-linear function with large numbers of variables."}}
,{"_index":"throwtable","_type":"algorithm","_id":"daitch–mokotoff-soundex","_score":0,"_source":{"description":"Daitch–Mokotoff Soundex (D–M Soundex) is a phonetic algorithm invented in 1985 by Jewish genealogists Gary Mokotoff and Randy Daitch. It is a refinement of the Russell and American Soundex algorithms designed to allow greater accuracy in matching of Slavic and Yiddish surnames with similar pronunciation but differences in spelling.\nDaitch–Mokotoff Soundex is sometimes referred to as \"Jewish Soundex\" and \"Eastern European Soundex\", although the authors discourage use of these nicknames for the algorithm because the algorithm itself is independent of the fact the motivation for creating the new system was the poor results of predecessor systems when dealing with Slavic and Yiddish surnames.\n\n","alt_names":[],"name":"Daitch–Mokotoff Soundex","categories":["Genealogy","Phonetic algorithms"],"tag_line":"Daitch–Mokotoff Soundex (D–M Soundex) is a phonetic algorithm invented in 1985 by Jewish genealogists Gary Mokotoff and Randy Daitch."}}
,{"_index":"throwtable","_type":"algorithm","_id":"reteoo","_score":0,"_source":{"description":"ReteOO is an improved version of the Rete algorithm.\nRete supports only boolean, first order logic. \n\n","alt_names":[],"name":"ReteOO","categories":["Algorithms and data structures stubs","All orphaned articles","All stub articles","Computer science stubs","Expert systems","Orphaned articles from February 2013","Pattern matching"],"tag_line":"ReteOO is an improved version of the Rete algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bitap-algorithm","_score":0,"_source":{"description":"The bitap algorithm (also known as the shift-or, shift-and or Baeza-Yates–Gonnet algorithm) is an approximate string matching algorithm. The algorithm tells whether a given text contains a substring which is \"approximately equal\" to a given pattern, where approximate equality is defined in terms of Levenshtein distance — if the substring and pattern are within a given distance k of each other, then the algorithm considers them equal. The algorithm begins by precomputing a set of bitmasks containing one bit for each element of the pattern. Then it is able to do most of the work with bitwise operations, which are extremely fast.\nThe bitap algorithm is perhaps best known as one of the underlying algorithms of the Unix utility agrep, written by Udi Manber, Sun Wu, and Burra Gopal. Manber and Wu's original paper gives extensions of the algorithm to deal with fuzzy matching of general regular expressions.\nDue to the data structures required by the algorithm, it performs best on patterns less than a constant length (typically the word length of the machine in question), and also prefers inputs over a small alphabet. Once it has been implemented for a given alphabet and word length m, however, its running time is completely predictable — it runs in O(mn) operations, no matter the structure of the text or the pattern.\nThe bitap algorithm for exact string searching was invented by Bálint Dömölki in 1964[1][2] and extended by R. K. Shyamasundar in 1977[3], before being reinvented in the context of fuzzy string searching by Manber and Wu in 1991[4][5] based on work done by Ricardo Baeza-Yates and Gaston Gonnet[6]. The algorithm was improved by Baeza-Yates and Navarro in 1996[7] and later by Gene Myers for long patterns in 1998[8].","alt_names":["Baeza-Yates-Gonnet-Algorithmus","- Bitap algorithm :","- Shift Or Algorithm :","...mehr auf Wikipedia über Baeza-Yates-Gonnet-Algorithmus","...more on Wikipedia about Bitap algorithm","Algorytm Bitap","Baeza-Yates-Gonnet-Algorithmus - Wikipedia (http://de.wikipedia","Baeza-Yates-Gonnet-Algorithmus – Wikipedia","Bitap","Bitap Algorithm","Bitap Algorithmus","Bitap Algoritme","Bitap Algoritmus","Bitap algorithm","Bitap algorithm - Wikipedia","Bitap algorithm - Wikipedia :: The free encyclopedia","Bitap algorithm - Wikipedia, the free encyclopedia","Bitap algorithm.","Bitap algorithm; it is used under the","Bitap algoritmo","Bitap Алгоритм","Bitap एल्गोरिथ्म","Bitapアルゴリズムは、","Bitap算法","Learn about Bitap algorithm>>>","Read More bitap algorithm wikipedia the free encyclopedia","Shift Or Algorithm","Shift-Or","The bitap algorithm","Wikipedia article ''Bitap algorithm''","Wikipedia article Bitap algorithm","Wikipedia article Shift Or Algorithm","Wikipedia article on Bitap algorithm","Wikipedia entry for Bitap algorithm","Wikipedia-Artikel Baeza-Yates-Gonnet-Algorithmus","Wikipedia-Artikel Shift-And-Algorithmus","Wikipedia-Artikel Shift-Or-Algorithmus","algorithme Bitap","algoritma Bitap","algoritmo BITAP","algoritmo Bitap","algoritmo de Bitap","bitap","bitap algorithm","bitap algorithm according to Wikipedia","bitap algorithm wikipedia the free encyclopedia","bitapの","bitap의","de:Baeza-Yates-Gonnet-Algorithmus","en.wikipedia.org/...Bitap_algorithm","en.wikipedia.org/wiki/Bitap_algorithm","http://de.wikipedia.org/wiki/Baeza-Y...et","http://de.wikipedia.org/wiki/Baeza-Yates","http://de.wikipedia.org/wiki/Baeza-Yates-Gonnet","http://de.wikipedia.org/wiki/Shift-Or-Algorithmus","http://en.wikipedia.org/wiki/Bitap_algor","http://en.wikipedia.org/wiki/Bitap_algorithm","http://en.wikipedia.org/wiki/Bitap_algor…","http://en.wikipedia.org/wiki/Shift_Or_Algorithm","thuật toán Bitap","Хорошее описание Shift-Or c модификациями Wu-Manber","алгоритма Bitap","ขั้นตอนวิธี Bitap","ようにはgrep（","알고리즘을 문자열"],"name":"Bitap algorithm","categories":["Articles with example C code","String matching algorithms"],"tag_line":"The bitap algorithm (also known as the shift-or, shift-and or Baeza-Yates–Gonnet algorithm) is an approximate string matching algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pseudo-polynomial-time","_score":0,"_source":{"description":"In computational complexity theory, a numeric algorithm runs in pseudo-polynomial time if its running time is polynomial in the numeric value of the input, but is exponential in the length of the input – the number of bits required to represent it.\nAn NP-complete problem with known pseudo-polynomial time algorithms is called weakly NP-complete. An NP-complete problem is called strongly NP-complete if it is proven that it cannot be solved by a pseudo-polynomial time algorithm unless P=NP. The strong/weak kinds of NP-hardness are defined analogously.","alt_names":["More on this topic","- Pseudo-polynomial time :","...Wikipedia Algorytm pseudowielomianowy","...more on Wikipedia about Pseudo-polynomial time","Algorytm pseudowielomianowy – Wikipedia, wolna encyklopedia","Dass eine gegebene Zahl n eine Primzahl ist","Generalizing to non-numeric problems","Pseudo Polynomial Time","Pseudo polynomial time","Pseudo-polynomial time","Pseudo-polynomial time - Wikipedia, the free encyclopedia","Pseudo-polynomial-time","Pseudo-polynomial_time","Pseudopolynomiell","Pseudopolynomiell - Wikipedia","Pseudopolynomiell bei der wikipedia","What is the example of Pseudo-polynomial-time","Wikipedia (Pseudo-polynomial time)","Wikipedia article ''Pseudo-polynomial time''","Wikipedia article Pseudo-polynomial time","Wikipedia article Pseudopolynomiell","Wikipedia article on Pseudo-polynomial time","Wikipedia entry for Pseudo-polynomial time","Wikipedia-Artikel Pseudopolynomiell","Wikipedia-Seite zu 'Pseudopolynomiell'","algorytm pseudowielomianowy","en.wikipedia.org/wiki/Pseudo-polynomial_time","http://de.wikipedia.org/wiki/Pseudopolyn","http://de.wikipedia.org/wiki/Pseudopolynomiell","http://en.wikipedia.org/wiki/Pseudo-poly","http://en.wikipedia.org/wiki/Pseudo-polynomial_time","http://en.wikipedia.org/wiki/Pseudo-polynomial_time.","http://pl.wikipedia.org/wiki/Algorytm_pseudowielomianowy","http://ru.wikipedia.org/wiki/Псевдополиномиальный_алгоритм","il tempo polinomiale algoritmi pseudo-","not polynomial in the length of the input","polinomio tiempo algoritmos pseudo-","pseudo linear","pseudo poynomial time","pseudo-plynominal time","pseudo-polinomial","pseudo-polynomial","pseudo-polynomial time","pseudo-polynomial time algorithm","pseudo-polynomial time algorithms","pseudo-polynomial-time","pseudo-polynomiel tid algoritmer","pseudo-wielomian algorytmów czas","pseudopolynomial","pseudopolynomial time","pseudopolynomiality","pseudopolynomiell","wen:Pseudo-polynomial time","wp:Pseudo-polynomial time","yago-res:Pseudo-polynomial time","Википедии статью Псевдополиномиальный алгоритм","Псевдополиномиальный алгоритм","псевдо-полиномиальные алгоритмы время","псевдополиномиальный алгоритм","псевдополиномиальным","擬似多項式時間のアルゴリズムは、"],"name":"Pseudo-polynomial time","categories":["Analysis of algorithms","Complexity classes","Computational complexity theory","Pseudo-polynomial time algorithms"],"tag_line":"In computational complexity theory, a numeric algorithm runs in pseudo-polynomial time if its running time is polynomial in the numeric value of the input, but is exponential in the length of the input – the number of bits required to represent it."}}
,{"_index":"throwtable","_type":"algorithm","_id":"boyer–moore-string-search-algorithm","_score":0,"_source":{"description":"In computer science, the Boyer–Moore string search algorithm is an efficient string searching algorithm that is the standard benchmark for practical string search literature. It was developed by Robert S. Boyer and J Strother Moore in 1977. The algorithm preprocesses the string being searched for (the pattern), but not the string being searched in (the text). It is thus well-suited for applications in which the pattern is much shorter than the text or where it persists across multiple searches. The Boyer-Moore algorithm uses information gathered during the preprocess step to skip sections of the text, resulting in a lower constant factor than many other string algorithms. In general, the algorithm runs faster as the pattern length increases. The key features of the algorithm are to match on the tail of the pattern rather than the head, and to skip along the text in jumps of multiple characters rather than searching every single character in the text.\n\n","alt_names":[],"name":"Boyer–Moore string search algorithm","categories":["Algorithms on strings","Articles with example C code","Articles with example Java code","Articles with example Python code","String matching algorithms"],"tag_line":"In computer science, the Boyer–Moore string search algorithm is an efficient string searching algorithm that is the standard benchmark for practical string search literature."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hidden-subgroup-problem","_score":0,"_source":{"description":"The hidden subgroup problem (HSP) is a topic of research in mathematics and theoretical computer science. The framework captures problems like factoring, graph isomorphism, and the shortest vector problem. This makes it especially important in the theory of quantum computing because Shor's quantum algorithm for factoring is essentially equivalent to the hidden subgroup problem for finite Abelian groups, while the other problems correspond to finite groups that are not Abelian.","alt_names":["Hidden Subgroup Problem","Hidden subgroup problem","Hidden subgroup problem - Wikipedia, the free encyclopedia","Hidden subgroup problem by Wikipedia","What are algorithms of Hidden subgroup problem","Wikipedia article on Hidden subgroup problem","Wikipedia entry for Hidden subgroup problem","en.wikipedia.org/wiki/Hidden_subgroup_problem","hidden subgroup problem","http://en.wikipedia.org/wiki/Hidden_subg","http://en.wikipedia.org/wiki/Hidden_subgroup_problem","the hidden subgroup problem","yago-res:Hidden subgroup problem","поиска скрытых подгрупп"],"name":"Hidden subgroup problem","categories":["Group theory","Quantum algorithms"],"tag_line":"The hidden subgroup problem (HSP) is a topic of research in mathematics and theoretical computer science."}}
,{"_index":"throwtable","_type":"algorithm","_id":"boyer–moore–horspool-algorithm","_score":0,"_source":{"description":"In computer science, the Boyer–Moore–Horspool algorithm or Horspool's algorithm is an algorithm for finding substrings in strings. It was published by Nigel Horspool in 1980.\nIt is a simplification of the Boyer–Moore string search algorithm which is related to the Knuth–Morris–Pratt algorithm. The algorithm trades space for time in order to obtain an average-case complexity of O(N) on random text, although it has O(MN) in the worst case, where the length of the pattern is M and the length of the search string is N.\n\n","alt_names":[],"name":"Boyer–Moore–Horspool algorithm","categories":["All accuracy disputes","All articles needing additional references","All articles to be merged","Articles needing additional references from October 2015","Articles to be merged from March 2015","Articles with disputed statements from June 2015","Articles with example C code","Pages using citations with accessdate and no URL","String matching algorithms"],"tag_line":"In computer science, the Boyer–Moore–Horspool algorithm or Horspool's algorithm is an algorithm for finding substrings in strings."}}
,{"_index":"throwtable","_type":"algorithm","_id":"amplitude-amplification","_score":0,"_source":{"description":"Amplitude amplification is a technique in quantum computing which generalizes the idea behind the Grover's search algorithm, and gives rise to a family of quantum algorithms. It was discovered by Gilles Brassard and Peter Høyer in 1997,  and independently rediscovered by Lov Grover in 1998. \nIn a quantum computer, amplitude amplification can be used to obtain a quadratic speedup over several classical algorithms.","alt_names":["Amplitude Amplification","Amplitude amplification","Amplitude amplification - Wikipedia :: The free encyclopedia","Amplitude amplification - Wikipedia, the free encyclopedia","Read More amplitude amplification wikipedia the free encyclopedia","What is algorithm of Amplitude amplification","Wikipedia article Amplitude amplification","amplitude amplificatie","amplitude amplification","amplitude_amplification","en:Amplitude amplification","en:amplitude amplification","http://en.wikipedia.org/wiki/Amplitude_amplification","yago-res:Amplitude amplification"],"name":"Amplitude amplification","categories":["Quantum algorithms","Search algorithms"],"tag_line":"Amplitude amplification is a technique in quantum computing which generalizes the idea behind the Grover's search algorithm, and gives rise to a family of quantum algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rational-sieve","_score":0,"_source":{"description":"In mathematics, the rational sieve is a general algorithm for factoring integers into prime factors. It is essentially a special case of the general number field sieve, and while it is far less efficient than the general algorithm, it is conceptually far simpler. So while it is rather useless as a practical factoring algorithm, it is a helpful first step for those trying to understand how the general number field sieve works.\n\n","alt_names":["...more on Wikipedia about Rational sieve","Limitations of the algorithm","Metoda sita liczbowego","Metoda sita liczbowego – Wikipedia, wolna encyklopedia","Rational Sieve","Rational sieve","Rational sieve - Wikipedia","Rational sieve - Wikipedia :: The free encyclopedia","Rational sieve - Wikipedia, the free encyclopedia","What is Rational sieve's example","What is the example of Rational sieve?","Wikipedia article ''Rational sieve''","Wikipedia article Rational sieve","Wikipedia article on Rational sieve","Wikipedia entry for Rational sieve","http://en.Liarpedia.org/wiki/Rational_sieve","http://en.wikipedia.org/wiki/Rational_sieve","http://en.wikipedia.org/wiki/Rational_sieve#Method","http://pl.wikipedia.org/wiki/Metoda_sita_liczbowego","pl:Metoda sita liczbowego","rational sieve","yago-res:Rational sieve","z = ∏ p i &Element; P p i a"],"name":"Rational sieve","categories":["Integer factorization algorithms"],"tag_line":"In mathematics, the rational sieve is a general algorithm for factoring integers into prime factors."}}
,{"_index":"throwtable","_type":"algorithm","_id":"subclu","_score":0,"_source":{"description":"SUBCLU is an algorithm for clustering high-dimensional data by Karin Kailing, Hans-Peter Kriegel and Peer Kröger. It is a subspace clustering algorithm that builds on the density-based clustering algorithm DBSCAN. SUBCLU can find clusters in axis-parallel subspaces, and uses a bottom-up, greedy strategy to remain efficient.","alt_names":["611025ecd473742015fee49a197d82 ...","SUBCLU","SUBCLU - Wikipedia, the free encyclopedia","SUBCLU Related Content:","SUBCLU by Wikipedia","SUBCLU |","Wikipedia article SUBCLU","Wikipedia entry for SUBCLU","http://en.wikipedia.org/wiki/SUBCLU","yago-res:SUBCLU"],"name":"SUBCLU","categories":["All articles needing additional references","All articles needing expert attention","Articles needing additional references from February 2010","Articles needing expert attention from February 2010","Articles needing expert attention with no reason or talk parameter","Data clustering algorithms","Statistics articles needing expert attention"],"tag_line":"SUBCLU is an algorithm for clustering high-dimensional data by Karin Kailing, Hans-Peter Kriegel and Peer Kröger."}}
,{"_index":"throwtable","_type":"algorithm","_id":"boosting-(machine-learning)","_score":0,"_source":{"description":"Boosting is a machine learning ensemble meta-algorithm for primarily reducing bias, and also variance in supervised learning, and a family of machine learning algorithms which convert weak learners to strong ones. Boosting is based on the question posed by Kearns and Valiant (1988, 1989): Can a set of weak learners create a single strong learner? A weak learner is defined to be a classifier which is only slightly correlated with the true classification (it can label examples better than random guessing). In contrast, a strong learner is a classifier that is arbitrarily well-correlated with the true classification.\nRobert Schapire's affirmative answer in a 1990 paper to the question of Kearns and Valiant has had significant ramifications in machine learning and statistics, most notably leading to the development of boosting.\nWhen first introduced, the hypothesis boosting problem simply referred to the process of turning a weak learner into a strong learner. \"Informally, [the hypothesis boosting] problem asks whether an efficient learning algorithm […] that outputs a hypothesis whose performance is only slightly better than random guessing [i.e. a weak learner] implies the existence of an efficient algorithm that outputs a hypothesis of arbitrary accuracy [i.e. a strong learner].\" Algorithms that achieve hypothesis boosting quickly became simply known as \"boosting\". Freund and Schapire's arcing (Adapt[at]ive Resampling and Combining), as a general technique, is more or less synonymous with boosting.\n^ Leo Breiman (1996). \"BIAS, VARIANCE, AND ARCING CLASSIFIERS\" (PDF). TECHNICAL REPORT. Retrieved 19 January 2015. Arcing [Boosting] is more successful than bagging in variance reduction \n^ Zhou Zhi-Hua (2012). Ensemble Methods: Foundations and Algorithms. Chapman and Hall/CRC. p. 23. ISBN 978-1439830031. The term boosting refers to a family of algorithms that are able to convert weak learners to strong learners \n^ a b Michael Kearns(1988); Thoughts on Hypothesis Boosting, Unpublished manuscript (Machine Learning class project, December 1988)\n^ Michael Kearns; Leslie Valiant (1989). \"Crytographic limitations on learning Boolean formulae and finite automata\". Symposium on Theory of computing (ACM) 21: 433–444. doi:10.1145/73007.73049. Retrieved 18 January 2015. \n^ Schapire, Robert E. (1990). \"The Strength of Weak Learnability\" (PDF). Machine Learning (Boston, MA: Kluwer Academic Publishers) 5 (2): 197–227. doi:10.1007/bf00116037. CiteSeerX: 10.1.1.20.723. \n^ Leo Breiman (1998). \"Arcing classifier (with discussion and a rejoinder by the author)\". Ann. Statist. 26 (3): 801–849. doi:10.1214/aos/1024691079. Retrieved 2015-11-17. Schapire (1990) proved that boosting is possible. (Page 823) \n^ Yoav Freund and Robert E. Schapire (1997); A Decision-Theoretic Generalization of On-Line Learning and an Application to Boosting, Journal of Computer and System Sciences, 55(1):119-139\n^ Leo Breiman (1998); Arcing Classifier (with Discussion and a Rejoinder by the Author), Annals of Statistics, vol. 26, no. 3, pp. 801-849: \"The concept of weak learning was introduced by Kearns and Valiant (1988, 1989), who left open the question of whether weak and strong learnability are equivalent. The question was termed the boosting problem since [a solution must] boost the low accuracy of a weak learner to the high accuracy of a strong learner. Schapire (1990) proved that boosting is possible. A boosting algorithm is a method that takes a weak learner and converts it into a strong learner. Freund and Schapire (1997) proved that an algorithm similar to arc-fs is boosting.","alt_names":[],"name":"Boosting (machine learning)","categories":["All articles to be expanded","All articles to be merged","Articles to be expanded from December 2009","Articles to be merged from December 2012","Classification algorithms","Ensemble learning"],"tag_line":"Boosting is a machine learning ensemble meta-algorithm for primarily reducing bias, and also variance in supervised learning, and a family of machine learning algorithms which convert weak learners to strong ones."}}
,{"_index":"throwtable","_type":"algorithm","_id":"write-ahead-logging","_score":0,"_source":{"description":"In computer science, write-ahead logging (WAL) is a family of techniques for providing atomicity and durability (two of the ACID properties) in database systems.\nIn a system using WAL, all modifications are written to a log before they are applied. Usually both redo and undo information is stored in the log.\nThe purpose of this can be illustrated by an example. Imagine a program that is in the middle of performing some operation when the machine it is running on loses power. Upon restart, that program might well need to know whether the operation it was performing succeeded, half-succeeded, or failed. If a write-ahead log is used, the program can check this log and compare what it was supposed to be doing when it unexpectedly lost power to what was actually done. On the basis of this comparison, the program could decide to undo what it had started, complete what it had started, or keep things as they are.\nWAL allows updates of a database to be done in-place. Another way to implement atomic updates is with shadow paging, which is not in-place. The main advantage of doing updates in-place is that it reduces the need to modify indexes and block lists.\nARIES is a popular algorithm in the WAL family.\nFile systems typically use a variant of WAL for at least file system metadata called journaling.","alt_names":["- Aheadをログ書き込み","- Write ahead logging :","Database Stores Records MongoDB","For more general information about the concept of","Skriv-Ahead-log","Viết-trước các bản ghi","WAL (Write-Ahead Log)","WAL-Prinzip","WAL-Prinzip - Wikipedia","Wikipedia article Write ahead log","Wikipedia article Write ahead logging","Wikipedia article Write-ahead log","Wikipedia article Write-ahead logging","Wikipedia article on Write ahead logging","Wikipedia entry for Write-ahead logging","Wikipedia-Artikel WAL-Prinzip","Wikipedia-Seite zu 'WAL-Prinzip'","Wikipedia: Write ahead logging","Wikipediaで「ログ先行書き込み」を調べる","Wikipediaで「先行書き込みログ」を調べる","Write Ahead Log (WAL)","Write Ahead Logging","Write Ahead Logging.","Write ahead log","Write ahead logging","Write ahead logging - Wikipedia, the free encyclopedia","Write-Ahead Log","Write-Ahead Log (WAL)","Write-Ahead Logging","Write-Ahead journaux","Write-Ahead protokolování","Write-Ahead-Log","Write-Ahead-Logging","Write-Ahead-Logs","Write-Ahead-журнала","Write-ahead logging","Write-ahead logging - Wikipedia :: The free encyclopedia","Write-ahead logging - Wikipedia, the free encyclopedia","Write-ahead logging - Wikipedia, the free encyclopedia ...","Write-ahead logs","Write-depan kayu","Write-หน้า ล็อก","de:WAL-Prinzip","en.wikipedia.org/wiki/Write-ahead_logging","en.wikipedia.org/wiki/Write_ahead_logging","escritura anticipada de los registros","escritura anticipada-Log","http://de.wikipedia.org/wiki/WAL-Prinzip","http://en.wikipedia.org/wiki/Write-ahead_logg...","http://en.wikipedia.org/wiki/Write-ahead_logging","http://en.wikipedia.org/wiki/Write_ahead","http://en.wikipedia.org/wiki/Write_ahead_log","http://en.wikipedia.org/wiki/Write_ahead_logging","ja:ログ先行書き込み","log di write-ahead","registro de escritura anticipada","registro prematuro de transacciones","uses&nbsp;","w:Write ahead logging","write ahead","write ahead log","write ahead logging","write ahead logs","write-ahead log","write-ahead logging","write-ahead registrazione","write-ahead-logging","Напиши вперед журналы","लिखें - आगे के प्रवेश","を書く","ログ先行書き込み","ログ先行書き込み - Wikipedia","先行書き込みログ","需要预写式","預寫日誌","预写式登陆","작성이"],"name":"Write-ahead logging","categories":["All stub articles","Database algorithms","Database stubs"],"tag_line":"In computer science, write-ahead logging (WAL) is a family of techniques for providing atomicity and durability (two of the ACID properties) in database systems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"group-method-of-data-handling","_score":0,"_source":{"description":"Group method of data handling (GMDH) is a family of inductive algorithms for computer-based mathematical modeling of multi-parametric datasets that features fully automatic structural and parametric optimization of models.\nGMDH is used in such fields as data mining, knowledge discovery, prediction, complex systems modeling, optimization and pattern recognition.\nGMDH algorithms are characterized by inductive procedure that performs sorting-out of gradually complicated polynomial models and selecting the best solution by means of the so-called external criterion.\nA GMDH model with multiple inputs and one output is a subset of components of the base function (1):\n\nwhere f are elementary functions dependent on different sets of inputs, a are coefficients and m is the number of the base function components.\nIn order to find the best solution GMDH algorithms consider various component subsets of the base function (1) called partial models. Coefficients of these models are estimated by the least squares method. GMDH algorithms gradually increase the number of partial model components and find a model structure with optimal complexity indicated by the minimum value of an external criterion. This process is called self-organization of models.\nThe most popular base function used in GMDH is the gradually complicated Kolmogorov-Gabor polynomial (2):\n\nThe resulting models are also known as polynomial neural networks. Jürgen Schmidhuber cites GDMH as one of the earliest deep learning methods, remarking that it was used to train eight-layer neural nets as early as 1971.\n^ Schmidhuber, Jürgen (2015). \"Deep learning in neural networks: An overview\". Neural Networks 61: 85–117. arXiv:1404.7828.","alt_names":["Combinatorial GMDH","External criteria","GMDH","GMDH-type","GMDH-type neural networks","Group Method Of Data Handling","Group Method of Data Handling","Group Method of Data Handling (GMDH)","Group method of data handling","Group method of data handling - Wikipedia :: The free","Group method of data handling - Wikipedia, the free","Group method of data handling by Wikipedia","Group_method_of_data_handling","Method of the group registration of arguments","What is the history of Group Method of","Wikipedia article GMDH","Wikipedia article Group method of data handling","Wikipedia entry for Group method of data handling","Y ( x 1 , &ctdot; , x n ) = a 0","en.wikipedia.o...f_data_handling","en.wikipedia.org/...d_of_data_handling","en.wikipedia.org/wiki/GMDH","en.wikipedia.org/wiki/Group_method_of_data_handling","http://en.wikipedia.org/wiki/GMDH","http://en.wikipedia.org/wiki/Group_Method_of_Data_Handling","http://en.wikipedia.org/wiki/Group_m..._data_handling","http://en.wikipedia.org/wiki/Group_metho","http://en.wikipedia.org/wiki/Group_method_of_data_handling","http://ru.wikipedia.org/wiki/Метод_группового_учета_аргументов","ru.wikipedia.o...%82%D0%BE%D0%B2","Википедии статью МГУА","Википедии статью Мгуа","Метод группового учёта аргументов","Список программ МГУА в википедии."],"name":"Group method of data handling","categories":["All articles with failed verification","Articles with failed verification from July 2015","Artificial neural networks","Classification algorithms","Computational statistics","Regression variable selection"],"tag_line":"Group method of data handling (GMDH) is a family of inductive algorithms for computer-based mathematical modeling of multi-parametric datasets that features fully automatic structural and parametric optimization of models."}}
,{"_index":"throwtable","_type":"algorithm","_id":"chase-(algorithm)","_score":0,"_source":{"description":"The Chase is a simple fixed-point algorithm testing and enforcing implication of data dependencies in database systems. It plays important roles in database theory as well as in practice. It is used, directly or indirectly, on an everyday basis by people who design databases, and it is used in commercial systems to reason about the consistency and correctness of a data design. New applications of the chase in meta-data management and data exchange are still being discovered.\nThe Chase has its origins in two seminal papers, one by Alfred V. Aho, Catriel Beeri, and Jeffrey D. Ullman and the other by David Maier, Alberto O. Mendelzon, and Yehoshua Sagiv.\nIn its simplest application the chase is used for testing whether the projection of a relation schema constrained by some functional dependencies onto a given decomposition can be recovered by rejoining the projections. Let t be a tuple in  where R is a relation and F is a set of functional dependencies (FD). If tuples in R are represented as t1, ..., tk, the join of the projections of each ti should agree with t on  where i = 1, 2, ..., k. If ti is not on , the value is unknown.\nThe chase can be done by drawing a tableau (which is the same formalism used in tableau query). Suppose R has attributes A, B, ... and components of t are a, b, .... For ti use the same letter as t in the components that are in Si but subscript the letter with i if the component is not in i. Then, ti will agree with t if it is in Si and will have a unique value otherwise.\nThe chase process is confluent.","alt_names":["Chase (Algorithm)","Chase (algorithm)","Chase (algorithm) - Wikipedia, the free encyclopedia","Chase (algorithm) - Wikipedia, the free encyclopedia ...","Chase (algorithm); it is used under the","Chase algorithm","Wikipedia article Chase (algorithm)","Wikipedia article about Chase (algorithm)","Wikipedia entry for Chase (algorithm)","http://en.wikipedia.org/wiki/Chase (algorithm)","http://en.wikipedia.org/wiki/Chase_%28algorithm%29","http://en.wikipedia.org/wiki/Chase_(algorithm)"],"name":"Chase (algorithm)","categories":["All articles with unsourced statements","Articles with unsourced statements from November 2012","Database algorithms","Database theory"],"tag_line":"The Chase is a simple fixed-point algorithm testing and enforcing implication of data dependencies in database systems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"types-of-artificial-neural-networks","_score":0,"_source":{"description":"There are many types of artificial neural networks (ANN).\nArtificial neural networks are computational models inspired by biological neural networks, and are used to approximate functions that are generally unknown. Particularly, they are inspired by the behaviour of neurons and the electrical signals they convey between input (such as from the eyes or nerve endings in the hand), processing, and output from the brain (such as reacting to light, touch, or heat). The way neurons semantically communicate is an area of ongoing research. Most artificial neural networks bear only some resemblance to their more complex biological counterparts, but are very effective at their intended tasks (e.g. classification or segmentation).\nSome ANNs are adaptive systems and are used for example to model populations and environments, which constantly change.\nNeural networks can be hardware- (neurons are represented by physical components) or software-based (computer models), and can use a variety of topologies and learning algorithms.","alt_names":["Types of artificial neural networks","Types of artificial neural networks - Wikipedia, the free","Types of artificial neural networks Wikipedia the free","associative neural networks","http://en.wikipedia.org/wiki/Types of artificial","http://en.wikipedia.org/wiki/Types_of_artificial_neural_networks","types of artificial neural networks","yago-res:Types of artificial neural networks"],"name":"Types of artificial neural networks","categories":["All articles with unsourced statements","All copied and pasted articles and sections","Articles with unsourced statements from October 2008","Artificial neural networks","Classification algorithms","Computational neuroscience","Computational statistics","Copied and pasted articles and sections with url provided from November 2014"],"tag_line":"There are many types of artificial neural networks (ANN)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"large-margin-nearest-neighbor","_score":0,"_source":{"description":"Large margin nearest neighbor (LMNN) classification is a statistical machine learning algorithm. It learns a Pseudometric designed for k-nearest neighbor classification. The algorithm is based on semidefinite programming, a sub-class of convex optimization.\nThe goal of supervised learning (more specifically classification) is to learn a decision rule that can categorize data instances into pre-defined classes. The k-nearest neighbor rule assumes a training data set of labeled instances (i.e. the classes are known). It classifies a new data instance with the class obtained from the majority vote of the k closest (labeled) training instances. Closeness is measured with a pre-defined metric. Large Margin Nearest Neighbors is an algorithm that learns this global (pseudo-)metric in a supervised fashion to improve the classification accuracy of the k-nearest neighbor rule.","alt_names":["IMG_3825_2","Large Margin Nearest Neighbor","Large Margin Nearest Neighbor - Wikipedia, the free encyclopedia","Large Margin Nearest Neighbor; it is used under","Large margin nearest neighbor","Large margin nearest neighbor - Wikipedia, the free encyclopedia","en:Large_Margin_Nearest_Neighbor","http://en.wikipedia.org/wiki/Large_margin_nearest_neighbor"],"name":"Large margin nearest neighbor","categories":["Classification algorithms","Machine learning"],"tag_line":"Large margin nearest neighbor (LMNN) classification is a statistical machine learning algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"multiclass-classification","_score":0,"_source":{"description":"Not to be confused with multi-label classification.\nIn machine learning, multiclass or multinomial classification is the problem of classifying instances into one of the more than two classes (classifying instances into one of the two classes is called binary classification).\nWhile some classification algorithms naturally permit the use of more than two classes, others are by nature binary algorithms; these can, however, be turned into multinomial classifiers by a variety of strategies.\nMulticlass classification should not be confused with multi-label classification, where multiple labels are to be predicted for each instance.","alt_names":[],"name":"Multiclass classification","categories":["All stub articles","Artificial intelligence stubs","Classification algorithms","Statistical classification"],"tag_line":"Not to be confused with multi-label classification."}}
,{"_index":"throwtable","_type":"algorithm","_id":"winepi","_score":0,"_source":{"description":"In data mining, the WINEPI algorithm is an influential algorithm for episode mining, which helps discover the knowledge hidden in an event sequence.\nWINEPI derives part of its name from the fact that it uses a sliding window to go through the event sequence.\nThe outcome of the algorithm are episode rules describe temporal relationships between events and form an extension of association rules.","alt_names":[],"name":"WINEPI","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Data mining algorithms"],"tag_line":"In data mining, the WINEPI algorithm is an influential algorithm for episode mining, which helps discover the knowledge hidden in an event sequence."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fast-fourier-transform","_score":0,"_source":{"description":"A fast Fourier transform (FFT) algorithm computes the discrete Fourier transform (DFT) of a sequence, or its inverse. Fourier analysis converts a signal from its original domain (often time or space) to a representation in the frequency domain and vice versa. An FFT rapidly computes such transformations by factorizing the DFT matrix into a product of sparse (mostly zero) factors. As a result, it manages to reduce the complexity of computing the DFT from , which arises if one simply applies the definition of DFT, to , where  is the data size.\nFast Fourier transforms are widely used for many applications in engineering, science, and mathematics. The basic ideas were popularized in 1965, but some algorithms had been derived as early as 1805. In 1994 Gilbert Strang described the FFT as \"the most important numerical algorithm of our lifetime\" and it was included in Top 10 Algorithms of 20th Century by the IEEE journal Computing in Science & Engineering.\n\n","alt_names":["fast Fourier transform algorithm","FFT","БПФ","Schnelle_Fourier-Transformation","快速傅里叶变换","Fast Fourier Transform","FFTs","Transformada rápida de Fourier","fft","Fast Fourier Transforms","Fast Fourier transform","fast Fourier transform","'fast Fourier transform'","(Fast Fourier Transform)","(Fast-)Fourier-","(Read More) Spectral music (or spectralism) is a",") should be used, but for completeness I provided","**FFT","- FFT :","- Fast Fourier Transform :","- Fast Fourier transform :","- libraries FFT","--> Wer oder Was sind *FFTs* ?","-> l'algo qui se cache derriere <-","-perpustakaan FFT","-ライブラリ。","... _k + e ^ {...","... a wide variety of applications, from digital signal","...Wikipedia FFT","...Wikipedia Szybka transformata Fouriera","...Wikipedia Transformada rápida de Fourier","...Wikipedia Transformée de Fourier rapide","...Wikipedia Trasformata di Fourier veloce","...mehr auf Wikipedia über Schnelle Fourier-Transformation","...more on Wikipedia about Fast Fourier transform","1 Definition and speed","1 Formulation mathématique","1 The Cooley-Tukey algorithm","1 一般的简化理论","1 쿨리-튜키 알고리즘","1.1 원리에 관한 간단한 설명","1965: Fast Fourier Transform","2 Computational issues","2 Cooley-Tukey algorithm","2 L'algorithme de Cooley-Tukey","2 Other FFT algorithms","2 快速傅里叶变换乘法量的计算","2 그 외의 알고리즘","2.1 Bounds on complexity and operation counts","2.1 Cooley–Tukey algorithm","2.2 Accuracy and approximations","2.2 Other FFT algorithms","2.3 FFT algorithms specialized for real and/or","220px-Fftwsquare.png","3 Autres algorithmes","3 Computational issues","3 Cooley-Tukey算法","3 FFT algorithms specialized for real and/or","3 Other FFT algorithms","3.1 Bounds on complexity and operation counts","3.1 Cooley–Tukey algorithm","3.1 FFT algorithms specialized for real and/or","3.1 设计思想","3.2 Accuracy and approximations","3.2 Other FFT algorithms","3.3 FFT algorithms specialized for real and/or","4 Accuracy and approximations","4 Algorithmes spécialisés dans le traitement de données","4 Bounds on complexity and operation counts","4 Multidimensional FFTs","4 其他算法","5 Accuracy and approximations","5 Multidimensional FFT algorithms","5 Other generalizations","5 Problèmes numériques et approximations","5 实数或对称资料专用的算法","6 Multidimensional FFT algorithms","6 Multidimensional FFTs","6 复杂度以及运算量的极限","7 Other generalizations","8. Fast Fourier Transform",": multidimensional FFTs)","A fast Fourier transform (FFT) is an efficient","Accuracy and approximations","Algoritmo de la Transformada Rápida de Fourier","Análisis FFT (Fast Fourier Transform)","Bounds on complexity and operation counts","Brza Furijeova transformacija - ??????????","Click Here To View Full Details","Computational issues","Cooley-Tukey型FFTアルゴリズム","Definicja na angielskiej wikipedii","Definition and speed","FAST AND FOURIER TRANSFORM","FFT (Fast Fourier Transform","FFT (Fast Fourier Transform)","FFT (Fast Fourier Transformation)","FFT (Fast Fourier transform)","FFT (Wikipedia)","FFT (fast Fourier transform)","FFT (transformée de Fourier rapide)","FFT - Fast Fourier Transform","FFT - 도서관","FFT @wikipedia","FFT Algorithm","FFT Analyse","FFT Analysis","FFT Fast Fourier Transform","FFT Wiki","FFT Wikipedia","FFT algorithms","FFT analysis","FFT at Wikipedia","FFT bzw. SFT","FFT data","FFT feature","FFT filtering","FFT in Wikipedia Nederland zoeken","FFT plot","FFT size","FFT trên Wikipedia","FFT wiki","FFT's","FFT(高速フーリエ変換)","FFT,","FFT, Fast Fourier Transform, trasformata rapida di Fourier","FFT, transformation rapide de Fourrier","FFT-Algorithmus","FFT-Analyse","FFT-Bibliotheken","FFT-Daten","FFT-based","FFT-bibliotecas","FFT-libraries","FFT-librerie","FFT-thư viện","FFT/DFT","FFT; it is used under the","FFT?","FFT@wikipedia","FFTed","FFTfollows","FFTs on Wikipedia","FFTの","FFTの説明","FFTを","FFT演算","FFT的","FFT的图书馆","FFT的圖書館","FFT解析","FFT와","FFT（Fast Fourier Transforms）","FFT（高速フーリエ変換）","FFTｱﾅﾗｲｻﾞ-wikipedia","FUCKING CORE ANALYSIS CROW PARSIMONIOUS","Fancy math","Fast (discrete) Fourier Transform","Fast Fourier","Fast Fourier Algorithm","Fast Fourier Tranform","Fast Fourier Trans","Fast Fourier Transfor","Fast Fourier Transform (FFT)","Fast Fourier Transform (FFT).","Fast Fourier Transform (Trasformata rapida di Fourier)","Fast Fourier Transform (Wikipedia)","Fast Fourier Transform (fft)","Fast Fourier Transform (fft) analysis","Fast Fourier Transform - Wikipedia, den ...","Fast Fourier Transform - Wikipedia, den frie encyklopædi","Fast Fourier Transform ?","Fast Fourier Transform Algorithm","Fast Fourier Transform Wiki","Fast Fourier Transform Wiki notes","Fast Fourier Transform at Wikipedia","Fast Fourier Transform i","Fast Fourier Transform,","Fast Fourier Transform, FFT","Fast Fourier Transform, Wikipedia","Fast Fourier Transform.","Fast Fourier Transform; it is used under the","Fast Fourier Transformatie","Fast Fourier Transformation","Fast Fourier Transformation (FFT)","Fast Fourier Transformationen","Fast Fourier Transformationen (FFTs)","Fast Fourier Transformations","Fast Fourier Transforming","Fast Fourier Transformm Theory on Wikipedia.org.","Fast Fourier Transforms en.wikipedia.org/wiki/Fast_Fourier_transform","Fast Fourier Transform、FFT","Fast Fourier transform (FFT)","Fast Fourier transform (FFT).","Fast Fourier transform (Wikipedia)","Fast Fourier transform (wikipedia)","Fast Fourier transform - Wikipedia","Fast Fourier transform - Wikipedia :: The free encyclopedia","Fast Fourier transform - Wikipedia, the free encyclo...","Fast Fourier transform - Wikipedia, the free encyclopedia","Fast Fourier transform - Wikipedia, the free encyclopedia ...","Fast Fourier transform - Wikipedia,...","Fast Fourier transform -...","Fast Fourier transform @ Wikipedia","Fast Fourier transform Wikipedia","Fast Fourier transform Wikipedia the free encyclopedia","Fast Fourier transform at wikipedia","Fast Fourier transform by Wikipedia","Fast Fourier transform#Bounds on complexity and operation","Fast Fourier transform#Bounds on complexity and operation counts","Fast Fourier transform(ffts)","Fast Fourier transform,","Fast Fourier transform: Other generalizations","Fast Fourier transform; it is used under the","Fast Fourier transformation","Fast Fourier transformationer","Fast Fourier transforms","Fast Fourier-Transformation","Fast Fouriertransformation","Fast Fourrier Transformation","Fast fourier transform","Fast fourier transforms","Fast ฟู ริ เย ร์ transform","Fast-Fourier Transforms","Fast-Fourier-Transform","Fast-Fourier-Transformation","Fast_Fourier_Transform","Fast_Fourier_transform","Fast_Fourier_transform [Wikipedia]","Fft","Fourier '(FFT)","Fourier Fast Transform","Fouriereva transformacija (FFT)","Fourierova transfomace","H?zl? Fourier d?n???m? - Vikipedi","Here's the Wikipedia article for step one of","Hızlı Fourier Dönüşümü","Hızlı Fourier dönüşümü","IFFT","Informazioni generali fft","Keep in mind that you'll have to","Kiirteisenduse","Learn about Fast Fourier transform>>>","Let the fight begin","Mabilis Fourier Transforms","Mabilis Fourier-ibang-anyo","Multidimensional FFTs","Musterimplementation","Nhanh chóng biến đổi Fourier","Other FFT algorithms","Pesquisar FFT na Wikipedia Portugal","Please learn to search.","Read More fast fourier transform wikipedia the free","Rychl? Fourierova transformace - Wikipedie","Rychle Fourier převádí","Rychlá Fourierova transformace","Rychlá Fourierova transformace - Wikipedie","Rychlá Fourierova transformace - Wikipedie, otevřená encyklopedie","Rychlé Fourierovy transformace","Rápida de Fourier","Schelle Fourier-Transformation","Schnelle Fourier Transformation","Schnelle Fourier-Transformation","Schnelle Fourier-Transformation - Wikipedia","Schnelle Fourier-Transformation ? Wikipedia","Schnelle Fourier-Transformation Wikipedia","Schnelle Fourier-Transformation â€“ Wikipedia","Schnelle Fourier-Transformation – Wikipedia","Schnelle Fouriertransformation","Schnelle_Fourier-Transformation in der Wikipedia mit einigen Programmen","Schnelle_Fouriertransformation","Schnellen Fourier-Transformation","Snabb fouriertransform","Snabb fouriertransform - Wikipedia","Snelle Fouriertransformatie","Suggested: fast fourier transform","Survey and history of FFT algorithms from Wikipedia","Szybka transformacja Fouriera","Szybka transformacja Fouriera ? Wikipedia, wolna encyklopedia","Szybka transformacja Fouriera – Wikipedia, wolna encyklopedia","Szybkiej transformacji Fouriera","Szybkiej transformaty Fouriera","Szybką","Szybką transformatę Fouriera","Sök FFT på Wikipedia Sverige","The Fast Fourier Transform","The Fast Fourier Transform (FFT)","Thumbnail of screenshot of Fast Fourier Transforms","Transform?e de Fourier rapide - Wikip?dia","Transformaciones rápidas de Fourier","Transformada Rapida de Fourier","Transformada Rápida de Fourier","Transformada Rápida de Fourier (FFT)","Transformada r?pida de Fourier - Wikipedia, la enciclopedia","Transformada rapida de Fourier","Transformada rápida de Fourier (FFT)","Transformada rápida de Fourier - Wikipedia, la enciclopedia libre","Transformada rápida de Fourier - Wikipédia, a enciclopédia livre","Transformada rápida de Fourier – Wikipédia, a enciclopédia livre","Transformada rápida de Fourier;","Transformasi Fourier cepat","Transformasi Fourier cepat (FFT)","Transformasi Fourier cepat - Wikipedia bahasa Indonesia ...","Transformasi Fourier cepat :: Wikipedia Bahasa Indonesia","Transformation de Fourier rapide (abondante bibliographie)","Transformation)","Transforme de Fourier rapide","Transformée de Fourier Rapide","Transformée de Fourier Rapide (FFT)","Transformée de Fourier rapide","Transformée de Fourier rapide - Wikipédia","Transformée de Fourier rapide - Wikipédia, l'encyclopédie libre","Transformée de Fourrier Rapide","Transformée rapide de Fourier (FFT)","Transformări rapide Fourier","Trasformata di Fourier veloce","Trasformata di Fourier veloce - Wikipedia","Trasformata di Fourier veloce su Wikipedia.org","Trasformate di Fourier veloci","What are algorithms of FFT","What are algorithms of FFT?","Wiki: FFT","WikiPedia on FFT","WikiPedia:Fast_Fourier_transform","Wikipeda:FFT","Wikipedia FFT","Wikipedia article Fast Fourier Transform","Wikipedia article Fast Fourier transform","Wikipedia article Fast fourier transform","Wikipedia article Schnelle Fourier-Transformation","Wikipedia article Transformada Ràpida de Fourier","Wikipedia article Transformada rápida de Fourier","Wikipedia article Transformasi Fourier cepat","Wikipedia article about FFT","Wikipedia article on FFT","Wikipedia article on Fast Fourier Transform","Wikipedia article on Fast Fourier transform","Wikipedia article on Transformada rápida de Fourier","Wikipedia article Быстрое преобразование Фурье","Wikipedia article Швидке перетворення Фур'є","Wikipedia article त्वरित फुरिअर रूपान्तर","Wikipedia artikel FFT","Wikipedia artikel Fast Fourier Transform","Wikipedia artikel Fast Fourier transform","Wikipedia entry for Fast Fourier transform","Wikipedia entry on the Fast Fourier Transform","Wikipedia l'articolo Fast Fourier Transform","Wikipedia on FFT","Wikipedia sur Transformée rapide de Fourier","Wikipedia-Artikel Fast-Fourier-Transformation","Wikipedia-Artikel Schnelle Fourier-Transformation","Wikipedia-Artikel Schnelle Fouriertransformation","Wikipedia-Artikel über die FFT","Wikipedia-Seite zu 'Fast-Fourier-Transformation'","Wikipedia-Seite zu 'Schnelle Fourier-Transformation'","Wikipedia-Seite zu 'Schnelle Fouriertransformation'","Wikipedia: FFT","Wikipedia: Fast Fourier Transform","Wikipedia: Fast Fourier transform","Wikipedia:FFT","Wikipedia:Fast Fourier Transform","Wikipedia:Schnelle Fourier-Transformation","Wikipediaで「IFFT」を調べる","Wikipediaで「高速フーリエ変換」を調べる","Wikipedia日本語版 - 高速フーリエ変換","Wikipedia英語版 - FFT","Wikipedia（高速フーリエ変換）","Wikipédia artigo FFT","Wikipédia artigo Fft","Wikipédia artigo Transformada rápida de fourier","_Fouriera","a Fast Fourier Transfor","a8f2aeebe7a355be7c9184633d33 ...","algorithme de Cooley-Tukey","algoritmo FFT","an FFT","anliegt","ar.wikipedia.org/wiki/تحويل_فوريي_السريع","ar:تحويل فوريي السريع","artigo da Wikipédia Transformada rápida de Fourier","artículo de Wikipedia Transformada Rápida de Fourier","artículo de Wikipedia Transformada rapida de Fourier","artículo de Wikipedia Transformada rápida de Fourier","ast Fourier Transform","b77833e86607cafe263d974f798ac ...","bibliotecas FFT","bibliothèques FFT","biến đổi Fourier nhanh","brza","brza Fourierova transformacija","ca:Transformada Ràpida de Fourier","can get pretty intimidating","ci sono posti migliori","click here - FFT","coefficient representation to point representation","cs:Rychlá Fourierova transformace","da:Fast Fourier Transform","de.wikipedia.org/wiki/Schnelle_Fourier-Transformation","de.wikipedia.org/wiki/Schnelle_Fourier-Transformation#Anwendung","de.wikipedia.org/wiki/Schnelle_Fourier-Transformation#Formelle_Beschreibung_des_Algorithmus_.28Cooley_und_Tukey","de:Schnelle Fourier-Transformation","de:Schnelle_Fourier-Transformation","e - 2 π i / N","eal inputs","effective method for taking Fourier transforms","eine FFT","en FFT","en allant sur la FFT","en.wikipedia.org - Fast Fourier transform","en.wikipedia.org/...Fast_Fourier_transform","en.wikipedia.org/...urier_transform","en.wikipedia.org/wiki/FFT","en.wikipedia.org/wiki/Fast_Fourier_Tr...","en.wikipedia.org/wiki/Fast_Fourier_tr...","en.wikipedia.org/wiki/Fast_Fourier_transform","en.wikipedia.org/wiki/Fast_Fouri…","en.wikipedia.org/…rier_transform","es.wikipedia.org/wiki/Transformada_r%C3%A1pida_de_Fourier","es:Transformada rápida de Fourier","es:Transformada_rápida_de_Fourier","fa:تبدیل سریع فوریه","fast Fourier","fast Fourier Transform","fast Fourier transfor","fast Fourier transform (FFT)","fast Fourier transform,","fast Fourier transformation","fast Fourier transforms","fast fourier transform","fast fourier transform filter","fast fourier transformaties","fast fourier transformation","fast fourier transforms","fast-Fourier transform","fast-Fourier-transform methods","fast-fourier transforms","fast-fourier-transform","fasto Fourier transform","fft alogorithm","fft~","fourierovej transformacie","fr:Transformée de Fourier rapide","greitoji Fourier transformacija (FFT)","gyors Fourier-transzformáció (FFT)","hi:त्वरित फुरिअर रूपान्तर","http//de.wikipedia.org/wiki/Schnelle_Fourier-Transformation","http://ca.wikipedia.org/wiki/FFT","http://ca.wikipedia.org/wiki/Transformada_r%C3%A0pida_de_Fourier","http://cs.wikipedia.org/wiki/Rychl%C3%A1_Fourierova_transformace","http://de.wikipedia.org/wiki/Schnell...8Pseudocode.29","http://de.wikipedia.org/wiki/Schnell...Transformation","http://de.wikipedia.org/wiki/Schnell..._PC-Soundkarte","http://de.wikipedia.org/wiki/Schnell...er_Algorithmus","http://de.wikipedia.org/wiki/Schnell...tion#Anwendung","http://de.wikipedia.org/wiki/Schnell...y_und_Tukey.29","http://de.wikipedia.org/wiki/Schnelle_F ... sformation","http://de.wikipedia.org/wiki/Schnelle_Four...-Transformation","http://de.wikipedia.org/wiki/Schnelle_Fourier-Tran sformation","http://de.wikipedia.org/wiki/Schnelle_Fourier-Tran...","http://de.wikipedia.org/wiki/Schnelle_Fourier-Transf...","http://de.wikipedia.org/wiki/Schnelle_Fourier-Transformatio","http://de.wikipedia.org/wiki/Schnelle_Fourier-Transformation","http://de.wikipedia.org/wiki/Schnelle_Fourier-Transformation#...","http://de.wikipedia.org/wiki/Schnelle_Fourier-Transformation#Anwendung","http://de.wikipedia.org/wiki/Schnelle_Fourier-Transformation#Die_inverse_FFT","http://de.wikipedia.org/wiki/Schnelle_Fourier-Transformation#FFT","http://de.wikipedia.org/wiki/Schnelle_Fourier-Transformation#Formelle_Beschreibung_des_Algorithmus_","http://de.wikipedia.org/wiki/Schnelle_Fourier-Transformation#Implementierung_","http://de.wikipedia.org/wiki/Schnelle_Fourier-Transformation#Implementierung_als_rekursiver_Algorithmus_","http://de.wikipedia.org/wiki/Schnelle_Fourier-Transformation#Radix","http://de.wikipedia.org/wiki/Schnelle_Fourier-Transformation.","http://de.wikipedia.org/wiki/Schnelle_Fourier−Transformation#Formelle_Beschreibung_des_Algorithmus_","http://de.wikipedia.org/wiki/Schnelle_Fo…","http://diminua.me/ZoR","http://en.wikipedia.org/w.i/Fast_Fourier_transform","http://en.wikipedia.org/wiki/FFT","http://en.wikipedia.org/wiki/FFT#Cooley.E2","http://en.wikipedia.org/wiki/Fast Fourier transform","http://en.wikipedia.org/wiki/Fast_F","http://en.wikipedia.org/wiki/Fast_Fo...FFT_algorithms","http://en.wikipedia.org/wiki/Fast_Fourie","http://en.wikipedia.org/wiki/Fast_Fourie r_transform","http://en.wikipedia.org/wiki/Fast_Fourie...","http://en.wikipedia.org/wiki/Fast_Fourier","http://en.wikipedia.org/wiki/Fast_Fourier_","http://en.wikipedia.org/wiki/Fast_Fourier_Tr","http://en.wikipedia.org/wiki/Fast_Fourier_Transform","http://en.wikipedia.org/wiki/Fast_Fourier_tra...","http://en.wikipedia.org/wiki/Fast_Fourier_transfor","http://en.wikipedia.org/wiki/Fast_Fourier_transfor m","http://en.wikipedia.org/wiki/Fast_Fourier_transfor...","http://en.wikipedia.org/wiki/Fast_Fourier_transform","http://en.wikipedia.org/wiki/Fast_Fourier_transform →","http://en.wikipedia.org/wiki/Fast_Fourier_transform#Cooley.E2","http://en.wikipedia.org/wiki/Fast_Fourier_transform#Definition_and_speed.","http://en.wikipedia.org/wiki/Fast_Fourier_transform#Other_generalizations","http://en.wikipedia.org/wiki/Fast_Fourier_transform~~V","http://en.wikipedia.org/wiki/Fast_Fourie…","http://en.wikipedia.org/wiki/Fast_fourier_tra...","http://en.wikipedia.org/wiki/Fast_fourier_transform","http://en.wikipedia.org/wiki/Fast_fourier_transform)","http://en.wikipedia.org/wi​ki/Fast_Fourier_transform","http://es.wikipedia....wiki/Transforma ... de_Fourier","http://es.wikipedia.org/wiki/Transfo...ida_de_Fourier","http://es.wikipedia.org/wiki/Transforma ... de_Fourier","http://es.wikipedia.org/wiki/Transformada rápida de","http://es.wikipedia.org/wiki/Transformada_r%C3%A1p","http://es.wikipedia.org/wiki/Transformada_r%C3%A1pida_de_Fourier","http://es.wikipedia.org/wiki/Transformada_rápida_de_Fourier","http://fr.wikipedia.org/wiki/Transf..._Fourier_rapide","http://fr.wikipedia.org/wiki/Transfo...Fourier_rapide","http://fr.wikipedia.org/wiki/Transform% ... ier_rapide","http://fr.wikipedia.org/wiki/Transform%C3%..._Fourier_rapide","http://fr.wikipedia.org/wiki/Transform%C3%A9e_de_Fourier_rapide","http://fr.wikipedia.org/wiki/Transform%C3%A9e_rapide_de_Fourier","http://fr.wikipedia.org/wiki/Transformée_de_Fourier_rapide","http://it.wikipedia...._Fourier_veloce","http://it.wikipedia.org/wiki/Fast_Fourier_Transform","http://it.wikipedia.org/wiki/Trasfor...Fourier_veloce","http://it.wikipedia.org/wiki/Trasformat ... ier_veloce","http://it.wikipedia.org/wiki/Trasformata_di_Fourier_veloce","http://ja.wikipedia.org/wiki/%E9%AB%...AA","http://ja.wikipedia.org/wiki/高速フーリエ変換","http://ko.wikipedia.org/wiki/FFT","http://nl.wikipedia.org/wiki/FFT","http://nl.wikipedia.org/wiki/Fast_Fourier_transfor","http://nl.wikipedia.org/wiki/Fast_Fourier_transform","http://pl.wikipedia.org/wiki/Szybka_tra ... a_Fouriera","http://pl.wikipedia.org/wiki/Szybka_transformacja_Fouriera","http://pl.wikipedia.org/wiki/Szybka_transformata_F ouriera","http://pl.wikipedia.org/wiki/Szybka_transformata_Fouriera","http://pt.wikipedia.org/wiki/Transformada_r%C3%A1pida_de_Fourier","http://ru.wikipedia.org/wiki/FFT","http://ru.wikipedia.org/wiki/БПФ","http://ru.wikipedia.org/wiki/Быстрое...азование_Фурье","http://ru.wikipedia.org/wiki/Быстрое_пре...","http://ru.wikipedia.org/wiki/Быстрое_преобразование_Фурье","http://sv.wikipedia.org/wiki/Snabb_fouriertransform","http://zh.wikipedia.org/wiki/%E5%BF...%8F","hurtige Fourier transformation","hurtige Fourier transformation (FFT)","hızlı Fourier (FFT) dönüşümü","id:Transformasi Fourier cepat","in algorithms are the harmonic","it:Trasformata di Fourier veloce","ja:高速フーリエ変換","kezd itt","ko:고속 푸리에 변환","la FFT","la transformación rápida de Fourier","link Fast Fourier Transform","mathematics behind FFT","metodo spettrale","metodo spettrale,","multidimensional FFT algorithms","multidimensional FFTs","nl:Fast Fourier transform","nopea Fourier-muunnoksen (FFT)","o FFT","pa nvem če bi se strinjov.","phép biến đổi nhanh Fourier","pl.wikipedia.org/wiki/FFT","pl.wikipedia.org/wiki/Szybka_transformacja_Fouriera","pl:Szybka transformacja Fouriera","pro rychlou Fourierovu transformaci","pt:Transformada rápida de Fourier","rayitas","read more on fast Fourier transforms","real FFT","real inputs","ru.wikipedia.org/...разование_Фурье","ru.wikipedia.org/wiki/FFT","ru.wikipedia.org/…разование_Фурье","ru:Быстрое преобразование Фурье","rychlou Fourierovu transformaci","rychlá Fourierova transformace","rychlá Fourierova transformace (FFT)","rychlé Fourierovy transformace","s FFT","schnelle Fourier-Transformation","schnelle Fouriertransformation","schnellen Fourier Transformation","schnellen Fourier-Transformation","schnellen Fourier-Transformation (FFT)","schnellen fourier-transformation","schneller Fourier-Transformation","sine transformation","smrofsnarT reiruoF tsaF","snelle Fourier Transformatie","snelle Fourier-transformatie","sparčioji Furjė transformacija (FFT)","sr:Брза Фуријеова трансформација","survey and history of FFT algorithms","sv:Snabb fouriertransform","sv:Snabb_fouriertransform","szybka kwantowa transformata Fouriera","szybka transformacja Fouriera","szybkiej transformacji Fouriera","szybkiej transformaty Fouriera","szybką transformatę Fouriera","ta:ஃபாஸ்ட் ஃபோரியர் மாற்றம்","ta:விரைவு ஃபூரியே உருமாற்றம்","te druga wersje","the FFT algorithm","the Fast Fourier Transform","tp://en.wikipedia.org/wiki/Fast Fourier transform","tr:Hızlı Fourier dönüşümü","transformaciones rápidas de Fourier","transformación rápida de Fourier","transformación rápida de Fourier (FFT)","transformada de Fourier rápida","transformada rapida de fourier","transformada ràpida de Fourier","transformada rápida","transformada rápida de Fourier","transformada rápida de Furrie","transformadas rápidas de Fourier","transforman (FFT)","transformare rapidă Fourier (FFT)","transformasi Fourier cepat","transformation de Fourier rapide","transformation de Fourrier rapide","transformée de Fourier (FFT)","transformée de Fourier rapide","transformée de Fourier rapide (FFT)","transformée de fourrier rapide","transformées de Fourier rapides","trasforma (FFT)","trasformata di Fourier veloce","trasformata veloce di Fourier","trasformata veloce di Fourier (FFT)","tę drugą wersję","uk:Швидке перетворення Фур'є","w:Fast Fourier Transform","wandelt um (FFT),","was Wiki an dieser Stelle vorschlägt","was Wiki an dieser Stelle vorschlägt.","wikipedia FFT entry","wikipedia/FFT","wikipedia:Fast Fourier Transform","wikipedia:Fast Fourier transform","wikipediaseite zur FFT","zh:快速傅里叶变换","| Fast Fourier Transformm Theory on Wikipedia.org.","über einen Schmetterlingsgraph","Τριτοτομίτες;","ταχύ μετασχηματισμού Fourier (FFT)","БПФ,","БПФ-библиотеки","Быстрое Преобразование Фурье","Быстрое преобраÐ·оÐ²аÐ½ие Фурье — Википедия","Быстрое преобразование Фурье","Быстрое преобразование Фурье — Википедия","Быстрое преобразование фурье","Быстрое_преобразование_Фурье FFT","Википедии статью FFT","Википедии статью БПФ","Застосовується","Перетворення Фур'є · Дискретне","Тpaнсфopмэpи paпидe Фoуpиep","Фаст Фоуриер Трансформ (ФФТ)","Швидке перетворення Фур'є","Швидке перетворення Фур'є — Вікіпедія","Швидке_перетворення_Фур'є","алгоритмы быстрых преобразований Фурье","бързо преобразуване на Фурие (FFT)","быстрого преобразования Фурье","быстрого преобразования Фурье (FFT)","быстрое преобразование Фурье","быстрое преобразование Фурье.","быстрое преобразование фурье","быстрому преобразованию Фурье","быстрый","математические выкладки","непосредственно пример программы","обратного преобразования Фурье","прямого преобразования Фурье","что ты имел ввиду LevelLeft/f ???","швидкого перетворення Фур'є (ШПФ)","התמרת פורייה המהירה","تبدیل سریع فوریه","تبدیل سریع فوریه - ویکیپدیا","تبدیل فوریه سریع (FFT) تبدیل","تبدیل و انتقال سریع","تحويل فوريي السريع","تحويل فورييه السريع (الاتحاد الفرنسي للتنس)","وتحويل فوريي السريع","त्वरित फुरिअर रूपान्तर","फास्ट फूरियर परिवरतित","फास्ट फूरियर रूपांतरण","फूरियर परिवरतित तेज","में तुलना में तेजी","รวดเร็ว แปลง ฟู ริ เย ร์","แบบการแปลง","「IFFT」をWikipediaで調べる","「高速フーリエ変換」をWikipediaで調べる","その他のアルゴリズム","のFFT","わけがわからない","ウィキペディアの記事 IFFT","ウィキペディアの記事 高速フーリエ変換","下载地址23","使用快速傅里叶","傅里叶变换(FFT)","実数および対称的な入力への最適化","快速傅立叶变换","快速傅立叶变换(FFT)","快速傅立葉變換","快速傅立葉轉換","快速傅立葉轉換- 維基百科,自由的百科全書","快速傅立葉轉換演算法","快速傅裏葉變换","快速傅裏葉變換","快速傅里叶变•- 维基百科，自由的百科全书","快速傅里叶变换 - 维基百科,自由的百科全书","快速傅里叶变换(FFT)","快速傅里叶变换- 维基百科","快速傅里叶变换- 维基百科，自由的百科全书","快速傅里叶变换算法","快速傅里葉變換- 維基百科，自由的百科全書","快速傅里葉變換（FFT）","的FFT","的快速傅立叶变换","真正的FFT","維基百科的文章“ 快速傅立叶变换”","維基百科的文章“ 快速傅里叶变换”","维基百科的文章“ 快速傅立叶变换”","维基百科的文章“ 快速傅里叶变换”","维基百科：快速傅立葉轉換","読んだだけではさっぱり分からない","采取FFT","高速フーリエ変換","高速フーリエ変換 - Wikipedia","高速フーリエ変換WIKI","高速フーリエ変換は変換","高速フーリエ変換を","高速フーリエ変換（FFT）","高速フーリエ変換（Fast Fourier Transform）","고속 푸리에","고속 푸리에 변환","고속 푸리에 변환 - 위키백과, 우리 모두의 백과사전","위키 피 디아 문서 FFT","위키 피 디아 문서 고속 푸리에 변환"],"name":"Fast Fourier transform","categories":["All articles needing additional references","Articles needing additional references from June 2015","Digital signal processing","Discrete transforms","FFT algorithms","Unsolved problems in computer science"],"tag_line":"A fast Fourier transform (FFT) algorithm computes the discrete Fourier transform (DFT) of a sequence, or its inverse."}}
,{"_index":"throwtable","_type":"algorithm","_id":"block-nested-loop","_score":0,"_source":{"description":"A block-nested loop (BNL) is an algorithm used to join two relations in a relational database.\nThis algorithm is a variation on the simple nested loop join used to join two relations  and  (the \"outer\" and \"inner\" join operands, respectively). Suppose . In a traditional nested loop join,  will be scanned once for every tuple of . If there are many qualifying  tuples, and particularly if there is no applicable index for the join key on , this operation will be very expensive.\nThe block nested loop join algorithm improves on the simple nested loop join by only scanning  once for every group of  tuples. For example, one variant of the block nested loop join reads an entire page of  tuples into memory and loads them into a hash table. It then scans , and probes the hash table to find  tuples that match any of the tuples in the current page of . This reduces the number of scans of  that are necessary.\nA more aggressive variant of this algorithm loads as many pages of  as can be fit in the available memory, loading all such tuples into a hash table, and then repeatedly scans . This further reduces the number of scans of  that are necessary. In fact, this algorithm is essentially a special-case of the classic hash join algorithm.\nThe block nested loop runs in  I/Os where  is the number of available pages of internal memory and  and  is size of  and  respectively in pages. Note that block nested loop runs in  I/Os if  fits in the available internal memory.","alt_names":["Block Nested Loops","Block nested loop","Block nested loop - Wikipedia, the free encyclopedia","Block nested loop - Wikipedia, the free encyclopedia ...","Blocked Nested Loop (BNL)","Wikipedia article Block nested loop","Wikipedia entry for Block nested loop","block nested loops","block-nested loop","en.wikipedia.org/...Block_nested_loop","en.wikipedia.org/wiki/Block_nested_loop","http://en.wikipedia.org/wiki/Block_neste","http://en.wikipedia.org/wiki/Block_nested_loop","http://en.wikipedia.org/wiki/Block_nested_loop.","yago-res:Block nested loop"],"name":"Block nested loop","categories":["All articles with unsourced statements","Articles with unsourced statements from August 2015","Join algorithms"],"tag_line":"A block-nested loop (BNL) is an algorithm used to join two relations in a relational database."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bcjr-algorithm","_score":0,"_source":{"description":"The BCJR algorithm is an algorithm for maximum a posteriori decoding of error correcting codes defined on trellises (principally convolutional codes). The algorithm is named after its inventors: Bahl, Cocke, Jelinek and Raviv. This algorithm is critical to modern iteratively-decoded error-correcting codes including turbo codes and low-density parity-check codes.","alt_names":["BCJR","BCJR Algorithm","BCJR Algorithm Wikipedia provides information on this algorithm","BCJR Equalizer","BCJR algorithm","BCJR algorithm - Wikipedia, the free encyclopedia","BCJR algorithm on wikipedia.org","BCJR algoritmus","BCJR алгоритм","BCJR алгоритм — Википедия","BCJR-Algorithmus","BCJR-Algorithmus – Wikipedia","BCJR; it is used under the","BCJR?????? - Wikipedia","BCJR_algorithm","BCJRアルゴリズム","BCJRアルゴリズム - Wikipedia","BCJRｱﾙｺﾞﾘｽﾞﾑ-wikipedia","Steps involved","What are variations of BCJR algorithm","Wikipedia : BCJRアルゴリズム","Wikipedia article BCJR","Wikipedia article BCJR algorithm","Wikipedia article on BCJR","Wikipedia entry for BCJR algorithm","Wikipedia-Artikel BCJR-Algorithmus","bcjr algorithm wikipedia the free encyclopedia","de:BCJR-Algorithmus","http://de.wikipedia.org/wiki/BCJR-Algori","http://en.wikipedia.org/wiki/BCJR","http://en.wikipedia.org/wiki/BCJR_algori","http://en.wikipedia.org/wiki/BCJR_algorithm","http://ja.wikipedia.org/wiki/BCJR%E3%82","ja:BCJRアルゴリズム","ru:BCJR алгоритм","Википедии статью BCJR алгоритм","ウィキペディアの記事 BCJRアルゴリズム"],"name":"BCJR algorithm","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Error detection and correction"],"tag_line":"The BCJR algorithm is an algorithm for maximum a posteriori decoding of error correcting codes defined on trellises (principally convolutional codes)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hash-join","_score":0,"_source":{"description":"The hash join is an example of a join algorithm and is used in the implementation of a relational database management system.\nThe task of a join algorithm is to find, for each distinct value of the join attribute, the set of tuples in each relation which have that value.\nHash joins require an equijoin predicate (a predicate comparing values from one table with values from the other table using the equals operator '=').","alt_names":["-> Read the article about 'Hash join'","...more on Wikipedia about Hash Join","Hash Join","Hash Join (Wikipedia)","Hash Join - Wikipedia, The Free Encyclopedia","Hash join","Hash join - Wikipedia, the free encyclopedia","Hash join Wikipedia the free encyclopedia","Hash-Join","Hash-Join-","Hash_join","Junção hash","The Hash join is an example of a","Wikipedia article Hash Join","Wikipedia article Hash join","Wikipedia article Junção hash","Wikipedia entry for Hash join","en.wikipedia.org/wiki/Hash_join","hash join","hash join - Wikipedia, the free encyclopedia","hash slutte","hash spojit","http://en.wikipedia.org/wiki/Hash_Join","http://en.wikipedia.org/wiki/Hash_join","http://en.wikipedia.org/wiki/Hash_join#Grace_hash_join","http://en.wikipedia.org/wiki/Hash_join#Hash_s...","http://en.wikipedia.org/wiki/Hash_join#Hash_semi-join","http://en.wikipedia.org/wiki/Hash_join#_note-1","http://ru.wikipedia.org/wiki/Алгоритм_соединения_хэшированием","quick and efficient algorithm","Алгоритм соединения хэшированием","хэш-соединение","के साथ जुड़ें हैश","ハッシュ結合は","ハッシュ結合を","哈希联接"],"name":"Hash join","categories":["Hashing","Join algorithms"],"tag_line":"The hash join is an example of a join algorithm and is used in the implementation of a relational database management system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"nested-loop-join","_score":0,"_source":{"description":"A nested loop join is a naive algorithm that joins two sets by using two nested loops. Join operations are important to database management.\n\n","alt_names":["Nested Loop Join","Nested Loop Join (Wikipedia)","Nested loop join","Nested loop join - Wikipedia, the free encyclopedia","Nested loop joins","Nested-Loop-Join","Nested_loop_join","Schlaufe verbinden","Wikipedia entry for Nested loop join","en.wikipedia.org/...Nested_loop_join","http://en.Liarpedia.org/wiki/Nested_loop_join","http://en.wikipedia.org/wiki/Nested_loop","http://en.wikipedia.org/wiki/Nested_loop_join","http://ru.wikipedia.org/wiki/Алгоритм_соединения_вложенными_циклами","loop join","løkke deltage","nested Loops","nested loop","nested loop join","nested loops join","smyčky připojit","verschachtelte Schleifen","yago-res:Nested loop join","zagnieżdżonych pętli","Алгоритм соединения вложенными циклами","цикла соединения","नेस्टेड लूप्स","ネストされたループ","ループ結合","循环联接"],"name":"Nested loop join","categories":["All articles lacking sources","All articles needing expert attention","All stub articles","Articles lacking sources from January 2010","Articles needing expert attention from March 2011","Articles needing expert attention with no reason or talk parameter","Computer science stubs","Join algorithms","Mathematics articles needing expert attention"],"tag_line":"A nested loop join is a naive algorithm that joins two sets by using two nested loops."}}
,{"_index":"throwtable","_type":"algorithm","_id":"firefly-algorithm","_score":0,"_source":{"description":"The firefly algorithm (FA) is a metaheuristic algorithm, inspired by the flashing behaviour of fireflies. The primary purpose for a firefly's flash is to act as a signal system to attract other fireflies. Xin-She Yang formulated this firefly algorithm by assuming:\nAll fireflies are unisexual, so that any individual firefly will be attracted to all other fireflies;\nAttractiveness is proportional to their brightness, and for any two fireflies, the less bright one will be attracted by (and thus move towards) the brighter one; however, the intensity (apparent brightness) decrease as their mutual distance increases;\nIf there are no fireflies brighter than a given firefly, it will move randomly.\nThe brightness should be associated with the objective function.\nFirefly algorithm is a nature-inspired metaheuristic optimization algorithm.","alt_names":["- Firefly algorithm :","Firefly Algorithm","Firefly algorithm","Firefly algorithm - Wikipedia :: The free encyclopedia","Firefly algorithm - Wikipedia, the free encyclopedia","Firefly algorithm Wikipedia, the free ...","Firefly algorithm; it is used under the","Firefly_algorithm","Wikipedia article Firefly algorithm","Wikipedia article about Firefly algorithm","Wikipedia article on Firefly algorithm","Wikipedia entry for Firefly algorithm","en.wikipedia.org/wiki/Firefly_algorit...","firefly algorithm","http://en.wikipedia.org/wiki/Firefly_algorithm","yago-res:Firefly algorithm"],"name":"Firefly algorithm","categories":["Evolutionary algorithms","Image processing","Metaheuristic","Optimization algorithms and methods","Swarm Intelligence"],"tag_line":"The firefly algorithm (FA) is a metaheuristic algorithm, inspired by the flashing behaviour of fireflies."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ramer–douglas–peucker-algorithm","_score":0,"_source":{"description":"The Ramer–Douglas–Peucker algorithm (RDP) is an algorithm for reducing the number of points in a curve that is approximated by a series of points. The initial form of the algorithm was independently suggested in 1972 by Urs Ramer and 1973 by David Douglas and Thomas Peucker and several others in the following decade. This algorithm is also known under the names Douglas–Peucker algorithm, iterative end-point fit algorithm and split-and-merge algorithm.","alt_names":[],"name":"Ramer–Douglas–Peucker algorithm","categories":["Articles with example pseudocode","Computer graphics algorithms","Digital signal processing","Geometric algorithms"],"tag_line":"The Ramer–Douglas–Peucker algorithm (RDP) is an algorithm for reducing the number of points in a curve that is approximated by a series of points."}}
,{"_index":"throwtable","_type":"algorithm","_id":"huang's-algorithm","_score":0,"_source":{"description":"Huang's algorithm is an algorithm for detecting termination in a distributed system. The algorithm was proposed by Shing-Tsaan Huang in 1989 in the Journal of Computers.","alt_names":["Huang's algorithm","- Huang's algorithm :","Huang's Algorithm","Huang's algorithm - Wikipedia :: The free encyclopedia","Huang's algorithm - Wikipedia, the free encyclopedia","What is Haung's Algorithm?","What is algorithm of Huang's algorithm","Wikipedia article Huang's Algorithm","Wikipedia article Huang's algorithm","http://en.wikipedia.org/wiki/Huang%27s_Algorithm","http://en.wikipedia.org/wiki/Huang%27s_algorithm"],"name":"Huang's algorithm","categories":["All articles lacking sources","Articles lacking sources from December 2009","Termination algorithms"],"tag_line":"Huang's algorithm is an algorithm for detecting termination in a distributed system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sweep-line-algorithm","_score":0,"_source":{"description":"In computational geometry, a sweep line algorithm or plane sweep algorithm is a type of algorithm that uses a conceptual sweep line or sweep surface to solve various problems in Euclidean space. It is one of the key techniques in computational geometry.\nThe idea behind algorithms of this type is to imagine that a line (often a vertical line) is swept or moved across the plane, stopping at some points. Geometric operations are restricted to geometric objects that either intersect or are in the immediate vicinity of the sweep line whenever it stops, and the complete solution is available once the line has passed over all objects.","alt_names":["sweep line algorithm","- Sweep line :","- Sweep line algorithm :","- Sweepline :","Algorithme de sweep line","Algorithmus von Line-Scan","Algorithmus, der Scan-line","Algorytm line sweep","Plane Sweep","Plane Sweep Algorithm","Plane sweep","Plane-Sweep-Algorithmus","Sweep (Informatik)","Sweep (Informatik) – Wikipedia","Sweep Line Algo","Sweep Line Algorithm","Sweep Line algorithm","Sweep Linea Algo","Sweep Linje Algo","Sweep algorytm line","Sweep line","Sweep line (or Sweep&Prune)","Sweep line algorithm","Sweep line algorithm - Wikipedia :: The free encyclopedia","Sweep line algorithm - Wikipedia, the free encyclopedia","Sweep line algorithm; it is used under the","Sweep line algorithms","Sweep line-algoritme","Sweep line; it is used under the","Sweep linje","Sweep linka Algo","Sweep-Line","Sweep-Line Algorithmus","SweepLine","SweepLineの","Sweep_(Informatik) bei der wikipedia","Sweep_line","Sweep_line_algorithm","Sweepline","Sweepline algorithm","What is the history of Sweep line algorithm","Wikipedia article Algorithme de sweep line","Wikipedia article Plane sweep","Wikipedia article Sweep (Informatik)","Wikipedia article Sweep line","Wikipedia article Sweep line algorithm","Wikipedia article Sweepline","Wikipedia article on Plane sweep","Wikipedia article on Sweep line","Wikipedia entry for Sweep line algorithm","Wikipedia-Artikel Sweep (Informatik)","Wikipedia-Seite zu 'Sweep (Informatik)'","Wikipedia: Sweep (Informatik)","Zamést line algoritmus","algorithme de balayage linéaire","algorithme, la ligne de balayage","algoritme van line-scan","algoritme, de scan lijn","algoritmo de la línea de barrido","algoritmo de linha de varredura","algoritmo di line-scan","algoritmo sweep line","baleiere","dreptei de baleiere","dòng quét","en.wikipedia.org/wiki/Sweep_line_algorithm","feje linje algoritme","garis menyapu","general plane sweep algorithm","http://de.wikipedia.org/wiki/Sweep_%28Informatik%29","http://de.wikipedia.org/wiki/Sweep_(Informatik)","http://en.wikipedia.org/wiki/Sweep_line","http://en.wikipedia.org/wiki/Sweep_line_","http://en.wikipedia.org/wiki/Sweep_line_algorithm","http://en.wikipedia.org/wiki/Sweepline","ligne de balayage","line sweep","linea di spazzare","linea di sweep","linha de varredura","linii zamiatać","línea de algoritmo de barrido","línea de barrido","sweep line","sweep line algoritme","sweep line-algoritme","sweep linie algoritme","sweeping algorithm","sweepline","utilizing plane sweeping algorithm","zametania","zatáčku line algoritmus","Линии алгоритм развертки","алгоритм линии сканирования","развертки линии","झाडू लाइन एल्गोरिथ्म","स्वीप रेखा algo","สายกวาด","スイープラインのアルゴリズムは、","スイープラインアルゴは","ラインアルゴリズム","扫描线算法","掃引ラインアルゴリズムを","掃描線(sweep line)法：","算法的线扫描","走査線アルゴリズムを","스위프 라인"],"name":"Sweep line algorithm","categories":["All articles with unsourced statements","Articles with unsourced statements from May 2009","Geometric algorithms"],"tag_line":"In computational geometry, a sweep line algorithm or plane sweep algorithm is a type of algorithm that uses a conceptual sweep line or sweep surface to solve various problems in Euclidean space."}}
,{"_index":"throwtable","_type":"algorithm","_id":"genetic-representation","_score":0,"_source":{"description":"In computer programming, genetic representation is a way of representing solutions/individuals in evolutionary computation methods. Genetic representation can encode appearance, behavior, physical qualities of individuals. Designing a good genetic representation that is expressive and evolvable is a hard problem in evolutionary computation. Difference in genetic representations is one of the major criteria drawing a line between known classes of evolutionary computation.\nGenetic algorithms use linear binary representations. The most standard one is an array of bits. Arrays of other types and structures can be used in essentially the same way. The main property that makes these genetic representations convenient is that their parts are easily aligned due to their fixed size. This facilitates simple crossover operation. Variable length representations were also explored in Genetic algorithms, but crossover implementation is more complex in this case.\nEvolution strategy uses linear real-valued representations, e.g. an array of real values. It uses mostly gaussian mutation and blending/averaging crossover.\nGenetic programming (GP) pioneered tree-like representations and developed genetic operators suitable for such representations. Tree-like representations are used in GP to represent and evolve functional programs with desired properties.\nHuman-based genetic algorithm (HBGA) offers a way to avoid solving hard representation problems by outsourcing all genetic operators to outside agents, in this case, humans. The algorithm has no need for knowledge of a particular fixed genetic representation as long as there are enough external agents capable of handling those representations, allowing for free-form and evolving genetic representations.\n\n","alt_names":["genetic representation","- Genetic representation :","Genetic Representation","Genetic representation","Genetic representation - Wikipedia, the free encyclopedia","Source Wikipedia.org Arcticle - Genetic representation","Wikipedia (Genetic representation)","Wikipedia article about Genetic representation","Wikipedia entry for Genetic representation","genetic representatio","http://en.wikipedia.org/wiki/Genetic_rep","http://en.wikipedia.org/wiki/Genetic_representation","yago-res:Genetic representation"],"name":"Genetic representation","categories":["All articles needing additional references","Articles needing additional references from December 2009","Evolutionary algorithms"],"tag_line":"In computer programming, genetic representation is a way of representing solutions/individuals in evolutionary computation methods."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bounding-sphere","_score":0,"_source":{"description":"In mathematics, given a non-empty set of objects of finite extension in n-dimensional space, for example a set of points, a bounding sphere, enclosing sphere or enclosing ball for that set is an n-dimensional solid sphere containing all of these objects.\nIn the plane the terms bounding or enclosing circle are used.\nUsed in computer graphics and computational geometry, a bounding sphere is a special type of bounding volume. There are several fast and simple bounding sphere construction algorithms with a high practical value in real-time computer graphics applications.\nIn statistics and operations research, the objects are typically points, and generally the sphere of interest is the minimal bounding sphere, that is, the sphere with minimal radius among all bounding spheres. It may be proven that such a sphere is unique: If there are two of them, then the objects in question lie within their intersection. But an intersection of two non-coinciding spheres of equal radius is contained in a sphere of smaller radius.\nThe problem of computing the center of a minimal bounding sphere is also known as the \"unweighted Euclidean 1-center problem\".","alt_names":["minimum bounding circle","- Bounding sphere :","-> Read more about Bounding sphere","...Wikipedia Sphère englobante","...more on Wikipedia about Bounding sphere","Bounding Sphere","Bounding sphere","Bounding sphere - Wikipedia, the free encyclopedia","Bounding sphere problem","BoundingSphere","Bounding_sphere","Learn about Bounding sphere>>>","Minimum bounding circle","Minimum bounding circle - Wikipedia, the free encyclopedia","Smallest bounding circle","Smallest bounding sphere","Smallest enclosing ball","Smallest enclosing sphere","Sphère englobante","Wikipedia article Bounding sphere","Wikipedia article Minimum bounding circle","Wikipedia article Smallest bounding circle","Wikipedia article Smallest enclosing ball","Wikipedia article Smallest enclosing sphere","Wikipedia article on Bounding sphere","Wikipedia article Ограничивающая сфера","Wikipedia entry for Bounding sphere","bounding circles","bounding sphere","bounding spheres","en:Bounding sphere","enclosing sphere","fr:Sphère englobante","http://en.wikipedia.org/wiki/Bounding_sp","http://en.wikipedia.org/wiki/Bounding_sphere","http://en.wikipedia.org/wiki/Bounding_sphere.","http://en.wikipedia.org/wiki/Minimum_bounding_circle","http://en.wikipedia.org/wiki/Smallest_en…","minimal bounding circle/sphere (2D/3D)","ru:Ограничивающая сфера","smallest enclosing sphere","Ограничивающая сфера","ограничивающей сферы"],"name":"Bounding sphere","categories":["All articles with unsourced statements","Articles with unsourced statements from November 2015","Geometric algorithms"],"tag_line":"In mathematics, given a non-empty set of objects of finite extension in n-dimensional space, for example a set of points, a bounding sphere, enclosing sphere or enclosing ball for that set is an n-dimensional solid sphere containing all of these objects."}}
,{"_index":"throwtable","_type":"algorithm","_id":"line-segment-intersection","_score":0,"_source":{"description":"In computational geometry, the line segment intersection problem supplies a list of line segments in the Euclidean plane and asks whether any two of them intersect, or cross.\nSimple algorithms examine each pair of segments. However, if a large number of possibly intersecting segments are to be checked, this becomes increasingly inefficient since most pairs of segments are not close to one another in a typical input sequence. The most common, more efficient way to solve this problem for a high number of segments is to use a sweep line algorithm, where we imagine a line sliding across the line segments and we track which line segments it intersects at each point in time using a dynamic data structure based on binary search trees. The Shamos–Hoey algorithm applies this principle to solve the line segment intersection detection problem, as stated above, of determining whether or not a set of line segments has an intersection; the Bentley–Ottmann algorithm works by the same principle to list all intersections in logarithmic time per intersection.","alt_names":["- Line segment intersection :","...more on Wikipedia about Line segment intersection","Line Segment Intersection","Line Segment Intersection Article","Line segment intersection","Line segment intersection - Wikipedia, the free encyclopedia","Line segment intersection - Wikipedia, the free encyclopedia ...","Line segment intersection Wikipedia the free encyclopedia","Line segment intersection Wikipedia the free encyclopedia - result","Line_segment_intersection","Wikipedia (Line segment intersection)","Wikipedia article Line segment intersection","Wikipedia article on line segment intersection","Wikipedia entry for Line segment intersection","Wikipedia's current (May 2006) article","crossings in a set of line segments","detecting whether two sets of lines intersect","en.wikipedia.org/...Line_segment_intersection","http://en.wikipedia.org/wiki/Line_segment_intersection","http://en.wikipedia.org/wiki/Line_segment_intersection.","http://en.wikipedia.org/wiki/Line_segment_intersectionを","http://en.wikipedia.org/wiki/Line_segment_intersection보기","line arrangement intersection","line segment intersection","line segment intersection problem","line segment intersections","self-intersecting polygon detection","ttp://en.wikipedia.org/wiki/Line_segment_intersection","Čiary a ich priesečníky"],"name":"Line segment intersection","categories":["Algorithms and data structures stubs","All stub articles","CS1 errors: chapter ignored","Computer science stubs","Geometric algorithms"],"tag_line":"In computational geometry, the line segment intersection problem supplies a list of line segments in the Euclidean plane and asks whether any two of them intersect, or cross."}}
,{"_index":"throwtable","_type":"algorithm","_id":"memetic-algorithm","_score":0,"_source":{"description":"Memetic algorithms (MA) represent one of the recent growing areas of research in evolutionary computation. The term MA is now widely used as a synergy of evolutionary or any population-based approach with separate individual learning or local improvement procedures for problem search. Quite often, MA are also referred to in the literature as Baldwinian evolutionary algorithms (EA), Lamarckian EAs, cultural algorithms, or genetic local search.","alt_names":["their research","- Memetic algorithm :","2 The development of MAs","2.1 1st generation","Algoritmi Memetici","Hybrid genetic algorithm","Memetic Algorithm","Memetic Algorithms","Memetic algorithm","Memetic algorithm (","Memetic algorithm (Wikipedia)","Memetic algorithm - Wikipedia :: The free encyclopedia","Memetic algorithm - Wikipedia, the free encyclopedia","Memetic algorithm @ Wikipedia","Memetic algorithm Wikipedia the free encyclopedia","Memetic algorithms","Memetischer Algorithmus","Memetischer Algorithmus – Wikipedia","Memetischer_Algorithmus","Recent Activities in Memetic Algorithms","Source Wikipedia.org Arcticle - Memetic algorithm","Swarm Intelligence Ant Colony Optimization Memetic Algorithms","The development of MAs","Wikipedia article Memetic algorithm","Wikipedia article Memetic algorithms","Wikipedia article on Memetic algorithm","Wikipedia entry for Memetic algorithm","Wikipedia-Artikel Memetischer Algorithmus","algorithmes mémétiques","algoritmo memetica","en.wikipedia.org/...Memetic_algorithm","en.wikipedia.org/wiki/Memetic_algorithm","http://de.wikipedia.org/wiki/Memetischer","http://de.wikipedia.org/wiki/Memetischer_Algorithmus","http://en.wikipedia.org/wiki/Memetic algorithm","http://en.wikipedia.org/wiki/Memetic_alg","http://en.wikipedia.org/wiki/Memetic_algorithm","http://en.wikipedia.org/wiki/Memetic_algorithms","http://en.wikipedia.org/wiki/Memetic_alg…","hybrid Genetic Algorithm","hybrid genetic algorithm","memetic algorithm","memetic algorithms","memetic algorithms,","memetic एल्गोरिथ्म","memetischen Algorithmus","memetyczną algorytm","starter class","the memetic algorithm","меметической алгоритм","미미틱 알고리즘"],"name":"Memetic algorithm","categories":["All Wikipedia articles needing context","All articles with unsourced statements","All pages needing cleanup","Articles with unsourced statements from September 2014","CS1 errors: invisible characters","Evolutionary algorithms","Wikipedia articles needing context from February 2011","Wikipedia introduction cleanup from February 2011"],"tag_line":"Memetic algorithms (MA) represent one of the recent growing areas of research in evolutionary computation."}}
,{"_index":"throwtable","_type":"algorithm","_id":"computer-automated-design","_score":0,"_source":{"description":"Design Automation usually refers to electronic design automation, or Design Automation which is a Product configurator. Extending Computer-Aided Design (CAD), automated design and Computer-Automated Design (CAutoD)  are more concerned with a broader range of applications, such as automotive engineering, civil engineering, composite material design, control engineering, dynamic system identification, financial systems, industrial equipment, mechatronic systems, steel construction, structural optimisation, and the invention of novel systems.\nThe concept of CAutoD perhaps first appeared in 1963, in the IBM Journal of Research and Development [1], where a computer program was written (1) to search for logic circuits having certain constraints on hardware design and (2) to evaluate these logics in terms of their discriminating ability over samples of the character set they are expected to recognize. More recently, traditional CAD simulation is seen to be transformed to CAutoD by biologically-inspired machine learning or search techniques such as evolutionary computation, including swarm intelligence algorithms[3].","alt_names":["- Computer-automated design :","CAutoD","Computer-Automated Control System Design","Computer-Automated Design","Computer-automated design","Computer-automated design - Wikipedia, the ...","Computer-automated design - Wikipedia, the free ...","Computer-automated design - Wikipedia, the free encyclopedia","Computer-automated_design","Wikipedia article 计算机自动设计","Wikipedia entry for Computer-automated design","automatizzati progettazione al computer","computer-automated design","en.wikipedia.org/...Computer-automated_design","http://en.wikipedia.org/wiki/Computer-automated_design","yago-res:Computer-automated design","zh:计算机自动设计","计算机自动设计"],"name":"Computer-automated design","categories":["Computer-aided design","Design","Evolutionary algorithms","Evolutionary computation"],"tag_line":"Design Automation usually refers to electronic design automation, or Design Automation which is a Product configurator."}}
,{"_index":"throwtable","_type":"algorithm","_id":"gilbert–johnson–keerthi-distance-algorithm","_score":0,"_source":{"description":"The Gilbert–Johnson–Keerthi distance algorithm is a method of determining the minimum distance between two convex sets. Unlike many other distance algorithms, it does not require that the geometry data be stored in any specific format, but instead relies solely on a support function to iteratively generate closer simplices to the correct answer using the Minkowski sum (CSO) of two convex shapes.\n\"Enhanced GJK\" algorithms use edge information to speed up the algorithm by following edges when looking for the next simplex. This improves performance substantially for polytopes with large numbers of vertices.\nGJK algorithms are often used incrementally in simulation systems and video games. In this mode, the final simplex from a previous solution is used as the initial guess in the next iteration, or \"frame\". If the positions in the new frame are close to those in the old frame, the algorithm will converge in one or two iterations. This yields collision detection systems which operate in near-constant time.\nThe algorithm's stability, speed, and small storage footprint make it popular for realtime collision detection, especially in physics engines for video games.","alt_names":[],"name":"Gilbert–Johnson–Keerthi distance algorithm","categories":["All stub articles","Applied mathematics stubs","Convex geometry","Geometric algorithms"],"tag_line":"The Gilbert–Johnson–Keerthi distance algorithm is a method of determining the minimum distance between two convex sets."}}
,{"_index":"throwtable","_type":"algorithm","_id":"meta-optimization","_score":0,"_source":{"description":"In numerical optimization, meta-optimization is the use of one optimization method to tune another optimization method. Meta-optimization is reported to have been used as early as in the late 1970s by Mercer and Sampson  for finding optimal parameter settings of a genetic algorithm. Meta-optimization is also known in the literature as meta-evolution, super-optimization, automated parameter calibration, hyper-heuristics, etc.\n\n","alt_names":["- Meta-optimization :","Meta Optimization","Meta- Optimization","Meta-Optimization","Meta-optimization","Meta-optimization - Wikipedia, the free encyclopedia","Metaoptimization Wikipedia the free encyclopedia","View Meta-optimization on Wikipedia","Wikipedia article Meta-optimization","Wikipedia article about Meta-optimization","http://en.wikipedia.org/wiki/Meta-optimization","meta-optimization"],"name":"Meta-optimization","categories":["Evolutionary algorithms","Heuristics","Mathematical optimization","Optimization algorithms and methods"],"tag_line":"In numerical optimization, meta-optimization is the use of one optimization method to tune another optimization method."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bresenham's-line-algorithm","_score":0,"_source":{"description":"Bresenham's line algorithm is an algorithm that determines the points of an n-dimensional raster that should be selected in order to form a close approximation to a straight line between two points. It is commonly used to draw lines on a computer screen, as it uses only integer addition, subtraction and bit shifting, all of which are very cheap operations in standard computer architectures. It is one of the earliest algorithms developed in the field of computer graphics. An extension to the original algorithm may be used for drawing circles.\nWhile algorithms such as Wu's algorithm are also frequently used in modern computer graphics because they can support antialiasing, the speed and simplicity of Bresenham's line algorithm means that it is still important. The algorithm is used in hardware such as plotters and in the graphics chips of modern graphics cards. It can also be found in many software graphics libraries. Because the algorithm is very simple, it is often implemented in either the firmware or the graphics hardware of modern graphics cards.\nThe label \"Bresenham\" is used today for a family of algorithms extending or modifying Bresenham's original algorithm.","alt_names":["Bresenham line drawing algorithm","Bresenham algorithm","Bresenham","en.wikipedia.org/wiki/Bresenham's_line_algorithm","Bresenham's Algorithm","line-drawing algorithm","bresenham","Bresenham's","Bresenham's line algorithm","http://en.wikipedia.org/wiki/Bresenham's_line_algorithm","Bresenham's algorithm","Bresenham-Algorithmus","'line drawing algorithm'","(html, wikipedia)","-> Read the article about 'Bresenham's line algorithm'","...Wikipedia Algorithme de tracé de segment de Bresenham","...Wikipedia Algoritmo della linea di Bresenham","...Wikipedia Algorytmy Bresenhama","...mehr auf Wikipedia über Bresenham-Algorithmus","...more on Wikipedia about Bresenham's line algorithm","2 Generalisation","4 Different approach to the algorithm","4.1 Generalized version for this approach","5 Circle Variant","5.1 Drawing incomplete octants","5.2 Ellipses","7 Similar Algorithms","Algorithme de tracé de segment de Bresenham","Algorithme de tracé de segment de Bresenham - Wikipédia","Algorithmus von Bresenham","Algoritm o de Bre s e n-","Algoritmo de Bresenham","Algoritmo de Bresenham - Vikipedio","Algoritmo de Bresenham - Wikipedia, la enciclopedia libre","Algoritmo de Bresenham – Wikipédia, a enciclopédia livre","Algoritmo della linea di Bresenham","Algoritmo della linea di Bresenham - Wikipedia","Algorytm Bresenham'a","Algorytm Bresenhama","Algorytm Bresenhama – Wikipedia, wolna encyklopedia","Algorytm rysowania linii Bresenhama","Bersenham's line algorithm","Besengam's algorithm","Breneham's line algorithm","Brensenham","Bresenham Algo","Bresenham Algorithm","Bresenham Algorithmus","Bresenham Algorithmus Linie","Bresenham Algortihmus","Bresenham Algorythm","Bresenham Line Algorithm","Bresenham Line Algoritme","Bresenham Line algorithm","Bresenham Line algoritmus","Bresenham Lineアルゴリズム","Bresenham Linien Algorithmus (J. Bresenham, IBM, 1969)","Bresenham Midpoint","Bresenham Strichzeichnung","Bresenham Wiki","Bresenham algorithms","Bresenham algoritmo de linha","Bresenham algoritmo di linea","Bresenham de lijn algoritme","Bresenham féle vonal rajzolási algoritmus","Bresenham ligne de l'algorithme","Bresenham lijn algoritme","Bresenham line","Bresenham line algorithm","Bresenham line algoritme","Bresenham line algoritmus","Bresenham line draw algorithm","Bresenham line drawing","Bresenham line's algorithm","Bresenham line-Algorithmus","Bresenham line-drawing algorithm","Bresenham lines","Bresenham linje algoritme","Bresenham s line algorithm","Bresenham s line algorithm - Wikipedia, the free encyclopedia","Bresenham s line algorithm Wikipedia the free encyclopedia","Bresenham stregtegning","Bresenham sur Wikipédia","Bresenham линии алгоритма","Bresenham линия Алгоритм","Bresenham's Line Algorithm","Bresenham's Line Algorithm (wikipedia)","Bresenham's Line Algorithm ›","Bresenham's Line Algorithm.","Bresenham's Line Drawing Algorithm","Bresenham's Line-Algorithm","Bresenham's Strichzeichnung Algorithmus","Bresenham's algorithm,","Bresenham's algorithms","Bresenham's algormithm","Bresenham's famous line drawing algorigthm","Bresenham's lijntekening algoritme","Bresenham's line","Bresenham's line alg","Bresenham's line algorithim","Bresenham's line algorithm (Wikipedia)","Bresenham's line algorithm (englische Wikipedia)","Bresenham's line algorithm - Wikipedia :: The free encyclopedia","Bresenham's line algorithm - Wikipedia, the ...","Bresenham's line algorithm - Wikipedia, the free encyclopedi...","Bresenham's line algorithm - Wikipedia, the free encyclopedia","Bresenham's line algorithm - Wikipedia, the free encyclopedia (en","Bresenham's line algorithm -wikipedia","Bresenham's line algorithm @wikipedia","Bresenham's line algorithm from Wikipedia","Bresenham's line algorithm on Wikipedia","Bresenham's line algorithm.","Bresenham's line algorithm（ブレゼンハムの直線アルゴリズム）","Bresenham's line drawing","Bresenham's line drawing algorithm","Bresenham's line optimization","Bresenham's line-drawing algorithm","Bresenham's lines","Bresenham's magical algorithm","Bresenham's scan conversion","Bresenham's stregtegning algoritme","Bresenham's_algorithm","Bresenham's_line_algorithm","Bresenham'ın line algorithm - Wikipedia","Bresenham'ın çizgi algoritması","Bresenham'ın çizgi algoritması - Vikipedi","Bresenham'ın çizgi algoritması - Wikipedia","Bresenham-Algorithmus (deutsche Wikipedia)","Bresenham-Algorithmus ? Wikipedia","Bresenham-Algorithmus C-Implementierung","Bresenham-Algorithmus Line","Bresenham-Algorithmus in","Bresenham-Algorithmus – Wikipedia","Bresenham-Algorithums","Bresenham-Linie Algorithmus","Bresenham-Linienalgorithmus","Bresenham-algoritme","Bresenham-linier","Bresenham.","Bresenham?","Bresenhama","Bresenhama Line Algorytm","Bresenhamin algoritmi","Bresenhamin algoritmi Wikipedia","Bresenhamin algoritmiin","Bresenhamin algoritmilla","Bresenhamin algoritmillä","Bresenhamin algoritmin","Bresenhamm","Bresenhamo","Bresenhamov algoritam","Bresenhamov algoritem za krog","Bresenhams","Bresenhams Algorithmus","Bresenhams Linie alogirthm","Bresenhams Strichzeichnung Algorithmus","Bresenhams algorithm","Bresenhams algoritmo","Bresenhams alogirthm línea","Bresenhams lijn alogirthm","Bresenhams line algorithm","Bresenhams line algorithm Wikipedia the free encyclopedia","Bresenhams line algorithm.","Bresenhams line alogirthm","Bresenhams line drawing algorithm","Bresenhams linea alogirthm","Bresenhams linje alogirthm","Bresenhams stregtegning algoritme","Bresenhams алгоритм рисования линии","Bresenhams लाइन alogirthm","Bresenhams's line drawing algorithm","Bresenhamsラインalogirthm","Bresenhamsラインの描画アルゴリズム","Bresenhams线alogirthm","Bresenhams线绘制算法","Bresenhamův algoritmus","Bresenhamのオンラインアルゴリズム","Bresenhamのラインアルゴリズムが","Bresenhamのラインアルゴリズムは","Bresenham画的在线算法","Bresenham画的画线算法","Bresenham画的线算法","Bresenham画线","Bresenham画线算法","Bresenham直線演算法","Bresenham直线算法","Bresenham线算法","Breshenham","Breshenham-Algorithmus","Bressenham","Bressenham's line drawing algorithm","Bressenhams algorithm","Der Bresenham-Algorithmus","Deutscher Wikipediaartikel zum Bresenham-Algorithmus","Gii thut Bresenham v on thng Wikipedia ting","Giải thuật Bresenham - Wikipedia tiếng Việt","Giải thuật Bresenham vẽ đoạn thẳng","Giải thuật vẽ đoạn thẳng Bresenham","Giải thuật vẽ đoạn thẳng Bresenham – Wikipedia tiếng","Giải thuật vẽ đường thẳng Bresenham – Wikipedia tiếng","Grundlage der neuen Schussverteilung","Implementierung dort in C","Kreisvariante","L'algorithme de Bresenham","La línea de algoritmo Bresenham","Line Algorithms","MIDPOINT","Midpoint Line Drawing","Reading 1: Bresenham's (wikipedia)","Scankonvertierung Bresenham's","The bresenham's line algorithm","Tracé de segment","Tracé de segments de Bresenham","View Bresenham's line algorithm on Wikipedia","Vikipedi'deki Bresenham'ın çizgi algoritması","What is the history of Bresenham line algorithm","Wiki Bresenhams line algorithm page","Wiki: Алгоритм Брезенхэма для рисования линии","Wikipedia - Bresenham Line Drawing","Wikipedia Algoritmo di Bresenham","Wikipedia article Algoritmo de Bresenham","Wikipedia article Bresenham's algorithm","Wikipedia article Bresenham's line algorithm","Wikipedia article on Bresenham algorithm","Wikipedia article Алгоритм Брезенхэма","Wikipedia article ბრეზენჰემის ალგორითმი","Wikipedia has a more detailed article","Wikipedia page on Bresenham's Line Algorithm","Wikipedia(en):Bresenham's line algorithm","Wikipedia-Artikel Bresenham-Algorithmus","Wikipedia-Artikel über den Bresenham-Algorithmus","Wikipedia-Seite zu 'Bresenham-Algorithmus'","Wikipedia: Bresenham Line Algorithm","Wikipedia: Bresenham's line algorithm","Wikipedia: Bresenham-Algorithmus","Wikipedia: Bresenham-algorithm","Wikipedia:Bresenham's line algorithm","Wikipedia:Bresenham-Algorithmus","[[:ru:Алгоритм Брезенхэма]]","a Algoritmo","algorithm@wikipedia","algorithme de Bresenham","algoritmo de Bresenham","algoritmo de Bressenham","algoritmo de línea Bresenham","algoritmo de línea de Bresenham","algoritmo di disegno al tratto Bresenhams","algoritmo per rasterizzare linee","algorytm Bresenhama linii","algorytm Bresenhams rysowanie linii","algorytmu Besengam","algorytmu Bresenhama","algorítmo de Bresenham","alogirthm Bresenhams line","ar:خوارزمية بريزنهام لرسم مستقيم","ar:خوارزمية مستقيم بريزنهام","bresenham algorithm","bresenham line algorithm","bresenham's","bresenham's algorithm","bresenham's line algorithm","bresenham's line algorithm wikipedia the free encyclopedia","classic algorithm of Bresenham","de.wikipedia.org/wik...resenham-Algorithmus","de:Bresenham-Algorithmus","deutscher Wikipediaartikel zum Bresenham-Algorithmus","draw a line on a computer screen matrix","en.wikipedia.org/...Bresenham's_line_algorithm","en.wikipedia.org/wiki/Brese...","en.wikipedia.org/wiki/Bresenham%27s_line_algorithm","en.wikipedia.org/wiki/Bresenham%27s_line_algorithm#Optimization","en.wikipedia.org/wiki/Bresenham_algorithm","en:Bresenham's line algorithm","eo:Algoritmo de Bresenham","es:Algoritmo de Bresenham","fi:Bresenhamin algoritmi","fr:Algorithme de tracé de segment de Bresenham","http://de.wikipedia.org/wiki/Br esenham-Algorithmus","http://de.wikipedia.org/wiki/Bresenh...es_Algorithmus","http://de.wikipedia.org/wiki/Bresenham-A","http://de.wikipedia.org/wiki/Bresenham-A...mentierung","http://de.wikipedia.org/wiki/Bresenham-Algorithmus","http://de.wikipedia.org/wiki/Bresenham-Algorithmus#Ansatz","http://de.wikipedia.org/wiki/Bresenham-Algorithmus#C","http://de.wikipedia.org/wiki/Bresenham-Algorithmus#Kompakte_Variante","http://de.wikipedia.org/wiki/Bresenham-Algorithmus#Kreisvariante_des_Algorithmus","http://de.wikipedia.org/wiki/Bresenham-Algorithmus...","http://de.wikipedia.org/wiki/Bresenham-A…ndiger_Oktanten","http://de.wikipedia.org/wiki/Bresenham−Algorithmus","http://de.wikipedia.org/wiki/Bresenham−Algorithmus> i","http://en.wikipedia....#Generalisation","http://en.wikipedia...ham's_line_algorithm","http://en.wikipedia.org/w..._line_algorithm","http://en.wikipedia.org/wiki/Bresen..._line_algorithm","http://en.wikipedia.org/wiki/Bresen...hm#Optimization","http://en.wikipedia.org/wiki/Bresenh...Generalization","http://en.wikipedia.org/wiki/Bresenh...line_algorithm","http://en.wikipedia.org/wiki/Bresenh...m#Optimisation","http://en.wikipedia.org/wiki/Bresenham 's_line_algorithm","http://en.wikipedia.org/wiki/Bresenham s_line_algorithm","http://en.wikipedia.org/wiki/Bresenham% ... _algorithm","http://en.wikipedia.org/wiki/Bresenham% ... ralization","http://en.wikipedia.org/wiki/Bresenham%27s_algorithm","http://en.wikipedia.org/wiki/Bresenham%27s_algorithm>","http://en.wikipedia.org/wiki/Bresenham%27s_li...","http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm","http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm#Circle_Variant","http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm#Ge","http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm#Generalisation","http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm#Generalization","http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm#Optimisation","http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm#Optimization","http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)","http://en.wikipedia.org/wiki/Bresenham%2…","http://en.wikipedia.org/wiki/Bresenham& ... _algorithm","http://en.wikipedia.org/wiki/Bresenham's...","http://en.wikipedia.org/wiki/Bresenham's_algorithm","http://en.wikipedia.org/wiki/Bresenham's_line_algo...","http://en.wikipedia.org/wiki/Bresenham's_line_algorith","http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Optimization","http://en.wikipedia.org/wiki/Bresenham's…","http://en.wikipedia.org/wiki/Bresenham\\'s_line_algorithm","http://en.wikipedia.org/wiki/Bresenham_algorithm","http://eo.wikipedia.org/wiki/Algoritmo_de_Bresenham","http://es.wikipedia.org/wiki/Algoritmo_de_Bresenham","http://fi.wikipedia.org/wiki/Bresenhamin_algoritmi","http://fi.wikipedia.org/wiki/​Bresenhamin_algoritmi","http://fr.wikipedia.org/wiki/Algorit...t_de_Bresenham","http://fr.wikipedia.org/wiki/Algorithme_de...nt_de_Bresenham","http://fr.wikipedia.org/wiki/Algorithme_de_trac%C3","http://fr.wikipedia.org/wiki/Algorithme_de_trac%C3%A9_de_segment_de_Bresenham","http://fr.wikipedia.org/wiki/Algorithme_de_tracé_de_segment_de_Bresenham","http://it.wikipedia.org/wiki/Algoritmo_d..._Bresenham","http://it.wikipedia.org/wiki/Algoritmo_della_linea_di_Bresenham","http://nl.wikipedia.org/wiki/Bresenham-algoritme","http://pl.wikipedia....rytm_Bresenhama","http://pl.wikipedia.org/wiki/Algorytm_Bresenhama","http://pl.wikipedia.org/wiki/Algorytmy_Bresenhama","http://pt.wikipedia.org/wiki/Algoritmo_de_Bresenham","http://ru.wikipedia.org/wiki/Алгоритм_Брезенхема","http://ru.wikipedia.org/wiki/Алгоритм_Брезенхэма","http://tr.wikipedia.org/w/index.php?title","http://tr.wikipedia.org/wiki/Bresenh...goritmas%C4","invented already","it:Algoritmo della linea di Bresenham","jollain hienolla viiva-algoritmilla","ka:ბრეზენჰამის სეგმენტის აგების ალგორითმი","ka:ბრეზენჰემის ალგორითმი","kreslení linie Bresenhams algoritmus","l'Algorithme de tracé de segment de Bresenham","l'algo de Bresenham","l'algorithme de Bresenham","l'algoritmo di Bresenham","la línea de algoritmo Bresenham","la línea de algoritmo de dibujo Bresenhams","la page de Wikipedia consacrée à cette méthode","lijn Bresenham algoritme","line algorithm","line algorytmu Bresenhama","line rasterization","linea algoritmo Bresenham","linea algoritmo di Bresenham","linea di Bresenham Algoritmo","linii Bresenhama rysunek","linii algorytm Bresenhama","linku algoritmus Bresenham","là, wikipedia","línea de algoritmo Bresenham","línea de dibujo Bresenham","m. http://en.wikipedia.org/wiki/Bresenham's_line_","make each dot by hand","nl:Bresenham-algoritme","page en Anglais","page en Français, avec une version que je","pl.wikipedia.org/wiki/Algorytm_Bresenhama","pl:Algorytm Bresenhama","pt:Algoritmo de Bresenham","resenhams algorithm","ru.wikipedia.org/wiki/Алгоритм_Брезенхэма","ru:Алгоритм Брезенхэма","scanconversie Bresenham's","similar algo, extended to account for the width","skanowanie konwersji Bresenhama's","the Bresenham line algorithm","this algo by Mr. Bresenham","to draw the line with","tr:Bresenham'ın çizgi algoritması","très intéressant","ttp://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm","uk:Алгоритм Брезенхейма","vi:Giải thuật Bresenham vẽ đoạn thẳng","vi:Giải thuật vẽ đoạn thẳng Bresenham","vi:Giải thuật vẽ đường thẳng Bresenham","w:en:Bresenham's line algorithm","wikipedia -> bresenham line algorithm","wikipedia article on Bresenham","wikipedia's pseudocode for Bresenham's line algorithm","wikipedia.org/../Bresenham's line algorithm","wikipedia:Bresenham","y - y 0 = y 1 - y 0 x","zh:布雷森漢姆直線演算法","Ð°Ð»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼ Ð'Ñ","Алгоритм Брезенхейма","Алгоритм Брезенхема","Алгоритм Брезенхема для рисования линий","Алгоритм Брезенхэма","Алгоритм Брезенхэма //Википедия","Алгоритм Брезенхэма на wikipedia.ru","Алгоритм_Брезенхэма","Алгоритму Брезенхэма","Брезенхамовог алгоритма","Брезенхема","Брезенхэма","Википедия знакома","Думаю рабочий алгоритм","алгоритм Брезенхайма","алгоритм Брезенхема","алгоритм Брезенхема (Bresenham)","алгоритм Брезенхэма","алгоритм Брезенхэма для рисования окружностей","алгоритма Брезенхэма","алгоритму Брезенхейма","алгоритму Брезенхема","алгоритмы Брезенхема","в Википедии, например","иид ЛЛ вКл д Кгж Л","линии алгоритм Bresenham в","линии алгоритм Bresenham's","по брезенхейму","простой и известный","растеризация без антиалиасинга","рисунок Bresenham линии","теореме Брезенхема","אלגוריתם הקו של ברזנהם","خوارزمية بريزنهام لرسم مستقيم","ბრეზენჰემის ალგორითმი","ブレゼンハム","ブレゼンハムさん","ブレゼンハムの線のアルゴリズムは、","ブレゼンハムの線分アルゴリズム","ブレゼンハム・アルゴリズム","一般的教程","布雷森汉姆直线算法- 维基百科，自由的百科全书","布雷森漢姆直線演算法","布雷森漢姆直線演算法- 维基百科，自由的百科全书","阅读这篇文章"],"name":"Bresenham's line algorithm","categories":["All articles needing additional references","All articles to be expanded","All articles with unsourced statements","Articles needing additional references from August 2012","Articles to be expanded from September 2011","Articles with example pseudocode","Articles with unsourced statements from December 2010","Commons category with local link same as on Wikidata","Computer graphics algorithms","Digital geometry"],"tag_line":"Bresenham's line algorithm is an algorithm that determines the points of an n-dimensional raster that should be selected in order to form a close approximation to a straight line between two points."}}
,{"_index":"throwtable","_type":"algorithm","_id":"flood-fill","_score":0,"_source":{"description":"Flood fill, also called seed fill, is an algorithm that determines the area connected to a given node in a multi-dimensional array. It is used in the \"bucket\" fill tool of paint programs to fill connected, similarly-colored areas with a different color, and in games such as Go and Minesweeper for determining which pieces are cleared. When applied on an image to fill a particular bounded area with color, it is also known as boundary fill.","alt_names":["- Flood fill :","-> Read more about Flood fill","-recursive alluvione non compilare","...Wikipedia Algoritmo flood fill","...Wikipedia Flood fill","...mehr auf Wikipedia über Floodfill","...more on Wikipedia about Flood fill","1.1 Alternative implementations","2 Fixed memory method (right-hand fill method","212px-Smiley_fill.gif","3 Scanline fill","4 Vector implementations","4-way recursive flood fill","5 Large scale behaviour","Algorithme Flood fill","Algorithme de remplissage par diffusion","Algorithme de remplissage par diffusion - Wikipédia","Algoritmo de relleno por difusi?n - Wikipedia, la","Algoritmo de relleno por difusión","Algoritmo de relleno por difusión - Wikipedia, la enciclopedia","Algoritmo flood fill","Algoritmo flood fill - Wikipedia","Banjir Isi","Banjir Isi Algoritma","Der Floodfill-Algorithmus, evtl. als Ansportn für die","FLOOD FILL","Farbfüllung","Fixed memory method (right-hand fill method)","Flood & Fill","Flood Fill","Flood Fill - Wikipedia, The Free Encyclopedia","Flood Fill Algorithm","Flood Fill Algoritme","Flood Fill algorithm","Flood Fill from Wikipedia","Flood Fill na Wikipedia","Flood Fill-Algorithmus","Flood Fills on wikipedia","Flood can have more than one meaning","Flood fill","Flood fill - Wikipedia :: The free encyclopedia","Flood fill - Wikipedia, the free encyclopedia","Flood fill from Wikipedia","Flood fill on Wikipedia","Flood fill page","Flood fill.","Flood fill; it is used under the","Flood filling algorithm","Flood füllen","Flood-Fill","Flood-Fill Algorithmus","Flood-fill","Flood-fill algorithm","Flood-fill from Wikipedia","Flood-fill “خوارزمية الملء الفيضاني”","FloodFill","FloodFill Algorithmus","FloodFill Algorithmus.","Flood_fill","Floodfill","Floodfill Algorithm","Floodfill Algorithm for drawing filled polygons","Floodfill algoritmi (Wikipedia)","Floodfill mit 4 und 8 Pixeln","Floodfill-Algorithmus","Floodfill-algoritme","Floodfill-algoritme - Wikipedia","Floodfillalgorithmus","Flutfüllung","How to make a paint bucket","Large scale behaviour","Learn about Flood fill>>>","Link to nice Wiki entry on Flood Fill","Llene el algoritmo de inundación","Polygon Fill","Preenchimento","Preenchimento do algoritmo","Queue-based non-recursive approach","Recursive_Flood_Fill_4_(aka).gif","Recursive_Flood_Fill_8_(aka).gif","Rellenar","Rellene el algoritmo de inundación","Riempimento","Rozrost ziarna","Rozrost ziarna – Wikipedia, wolna encyklopedia","Référence générale","Scanline Fill","Scanline fill","Scanline fill; it is used under the","Schau dir das mal an...","Taşırma algoritması","Vector implementations","Vlakvulling","Výplň","Wiki: Построчная заливка с затравкой","Wikipedia - Flood Fill","Wikipedia article Algorithme de remplissage par diffusion","Wikipedia article Flood Fill","Wikipedia article Flood fill","Wikipedia article Rozrost ziarna","Wikipedia article Scanline fill","Wikipedia article on Algoritmo de relleno por difusión","Wikipedia article on Flood Fill","Wikipedia article on Flood fill","Wikipedia article on Scanline fill","Wikipedia article on flood fill","Wikipedia article ملء فيضاني","Wikipedia artikel Floodfill","Wikipedia entry for Flood fill","Wikipedia's page on floodfill","Wikipedia-Artikel Floodfill","Wikipedia-Artikel Flutfüllung","Wikipedia: Flood fill algorithm","WikiのQueue-basedのスードーコード","Wypełnienia","a modified version of flood fill","algemene verwijzing","algo de remplissage par diffusion","algorithme de FloodFill.","algorithme de remplissage","algorithme de remplissage par diffusion","algorithme remplissage","algoritma floodfill.","algoritmo FLOODFILL.","algoritmo FloodFill.","algoritmo de FloodFill.","algoritmo di Flood Fill","allgemeiner Hinweis","alluvione di riempimento","alternate implementations section","ang paksa.","ar:ملء فيضاني","artículo de Wikipedia Algoritmo de relleno por difusion","artículo de Wikipedia Algoritmo de relleno por difusión","banale link","banjir mengisi","boundary fill","chủ đề.","de inundación llenar","de referencia general","de.wikipedia.org/wiki/Floodfill","de:Floodfill","de:Flutfüllung","decent primer","des inondations remplir","diluvio di riempimento","el tema.","en.wikipedia.org/Flood_fill","en.wikipedia.org/wiki/Flood_fill","es:Algoritmo de relleno por difusión","external image Recursive_Flood_Fill_4_%28aka%29.gif","flood fill","flood fill @ wiki","flood fill algorithm","flood fill algorithms","flood fill algoritmen","flood fill algoritmus","flood fill on Wikipedia","flood fill wikipedia","flood fill.","flood filling","flood fillom","flood-fill","flood-fill algorithm","floodfill","floodfill algorithm","floodfill алгоритма.","floodfill 알고리즘을","floodfill-algoritme","floodfillアルゴリズム","floodfill算法","flooding/flood-fill","fr:Algorithme de remplissage par diffusion","füllalgorithmen","fülle","generale di riferimento","http://de.wikipedia.org/wiki/Floodfill","http://de.wikipedia.org/wiki/Floodfill][/url","http://en.wikipedia....l#Scanline_fill","http://en.wikipedia....wiki/Flood_fill","http://en.wikipedia.org/wi ki/Flood_fill","http://en.wikipedia.org/wiki/Flood_f...mplementations","http://en.wikipedia.org/wiki/Flood_fil","http://en.wikipedia.org/wiki/Flood_fill","http://en.wikipedia.org/wiki/Flood_fill (","http://en.wikipedia.org/wiki/Flood_fill If you","http://en.wikipedia.org/wiki/Flood_fill#Alternative_implementations","http://en.wikipedia.org/wiki/Flood_fill#Fixed_memory_method_.28right","http://en.wikipedia.org/wiki/Flood_fill#Scanline_fill","http://en.wikipedia.org/wiki/Flood_fill#See_also","http://en.wikipedia.org/wiki/Flood_fill#The_algorithm","http://en.wikipedia.org/wiki/Flood_fill.","http://en.wikipedia.org/wiki/Flood_fill:","http://en.wikipedia.org/wiki/Flood_fill~~V","http://es.wikipedia.org/wiki/Algoritmo_de_relleno_por_difusi%C3%B3n","http://fr.wikipedia.org/wiki/Algorit..._par_diffusion","http://fr.wikipedia.org/wiki/Algorithm [...] par_diffusion","http://fr.wikipedia.org/wiki/Algorithme … _diffusion","http://fr.wikipedia.org/wiki/Algorithme_de_remplissage_par_d...","http://fr.wikipedia.org/wiki/Algorithme_de_remplissage_par_diffusion","http://fr.wikipedia.org/wiki/Flood_fill","http://it.wikipedia.org/wiki/Algoritmo_flood_fill","http://ko.wikipedia.org/wiki/Flood_fill","http://nl.wikipedia.org/wiki/Floodfill","http://nl.wikipedia.org/wiki/Floodfill-algoritme","http://pl.wikipedia.org/wiki/Rozrost_ziarna","inondations de remplir","it:Algoritmo flood fill","ko:Flood fill","ko:플러드 필","le sujet.","les noeuds que l'on peut rejoindre","lũ điền","lũ điền vào","nichtrekursiven fuell","nl:Floodfill-algoritme","non-recursive flood fill","nói chung tham khảo","o tema.","ottima pagina di Wikipedia","pl:Rozrost ziarna","quick fill","referensi umum","referência geral","region filling","relleno de inundación","remplissage algorithme d'inondation","remplissage par diffusion","ru:Заливка","scanline fill","see a starting article in wikipedia on flood","solid color-filled","standard flood fill algorithms","technique de la queue","terraplén de la inundación","this flood fill algoritm","thuật toán floodfill.","topik.","tr:Taşırma algoritması","ttp://en.wikipedia.org/wiki/Flood_fill","vanilla wiki too","very common computer science problem","vul","y'a des algos pour cela","Điền lũ Algorithm","Заливка","Заливка алгоритма","Наводнение заполнить","Сплошная заливка","заливки","наводнения заполнить","нерекурсивна заливки","общие ссылки","отличий алгоритма заливки MSPaint от Photoshop","ملء فيضاني","يغمر الجوريتمو يملأ","के माध्यम","बाढ़ भरण","बाढ़ भरें","ขั้น ตอน วิธี floodfill.","น้ำท่วมกรอก","น้ำท่วมเติม","หัวข้อ.","อ้างอิง ทั่วไป","เติมน้ำท่วม","„Flood Fill”","を埋めるビット","フラッドフィル","一般参考","一般參考","一般的なリファレンス","入力アルゴリズム","入力グループ","塗りつぶし","塗りつぶしを","塗りつぶしアルゴリズム","洪水の塗り","洪水をして","洪水填充","洪水填满","洪水填滿","洪水算法","的主題","这个专题的","위키 피 디아 문서 Flood fill","일반 참조","주제는 여기에있다.","주제에","채우기 알고리즘","채우기의","채워 홍수를","플러드 필","플러드 필 위키백과, 우리 모두의백과사전","홍수 채우기","홍수가 기입","：http://en.wikipedia.org/wiki/Flood_fill"],"name":"Flood fill","categories":["All articles lacking sources","Articles lacking sources from August 2009","Articles with example pseudocode","Computer graphics algorithms"],"tag_line":"Flood fill, also called seed fill, is an algorithm that determines the area connected to a given node in a multi-dimensional array."}}
,{"_index":"throwtable","_type":"algorithm","_id":"matthew-t.-dickerson","_score":0,"_source":{"description":"Matthew T. Dickerson is a professor of computer science at Middlebury College in Vermont, a scholar of the fiction of J. R. R. Tolkien and the Inklings, a novelist, a blues musician and historian of music, a fly fisherman, a maple sugar farmer, and a beekeeper.\nDickerson received an A.B. from Dartmouth College in 1985, and a Ph.D. in Computer Science from Cornell University, under the supervision of Dexter Kozen, in 1989. His Ph.D. research was in symbolic computation, but since then he has worked primarily in computational geometry; his most frequently cited computer science papers concern k-nearest neighbor algorithms and minimum-weight triangulation. He has been on the Middlebury faculty since receiving his Ph.D.\nHe is also the author of six non-technical books, most of them about fantasy fiction. His 2003 book Following Gandalf: Epic Battles and Moral Victory in The Lord of the Rings (Brazos Press, 2003, ISBN 978-1-58743-085-5), a study of the moral and Christian values expressed by Tolkien's works, highlights the contrasts between moral and physical victories, and between heroism and violence; it points out the necessity of having free will in order to make moral choices. It was shortlisted for the Mythopoeic Society's 2004 and 2005 Mythopoeic Scholarship Awards. He has also written a pair of books on Tolkien, C. S. Lewis, and environmentalism, Ents, Elves, and Eriador: The Environmental Vision of J.R.R. Tolkien (with Jonathan Evans, The University Press of Kentucky, 2006, ISBN 978-0-8131-2418-6) and Narnia and the Fields of Arbol: The Environmental Vision of C. S. Lewis (with David L. O'Hara, The University Press of Kentucky, 2009, ISBN 978-0-8131-2522-0). Despite giving the first of these two books an overall negative review, reviewer Patrick Curry writes that it is \"a major new contribution to the subject of Tolkien's work\". His other books include The Finnsburg Encounter (Crossway Books, 1991, ISBN 978-0-89107-604-9), a work of historical fiction, translated into German as Licht uber Friesland (Verlag Schulte & Gerth, 1996, ISBN 3-89437-422-5), Hammers and Nails: The Life and Music of Mark Heard (Cornerstone Press, 2003, ISBN 978-0-940895-49-2), a biography of musician Mark Heard, and From Homer to Harry Potter: A Handbook on Myth and Fantasy (with David L. O'Hara, Brazos Press, 2006, ISBN 978-1-58743-133-3).\nFrom 1997 to 2001 Dickerson published a biweekly column on fishing and the outdoors in the Addison Independent, a local newspaper. Since 2002 he has been the director of the New England Young Writers Conference, an annual four-day conference for high school students in Bread Loaf, Vermont that is associated with Middlebury College. He is also the founding director of the Vermont Conference on Christianity and the Arts. He plays bass in a Vermont-based blues band, Deep Freyed.","alt_names":["- Matthew T. Dickerson :","Dickerson, Matthew","Dickerson, Matthew T.","Matthew Dickerson","Matthew Dickerson; it is used under the","Matthew T Dickerson","Matthew T. Dickers","Matthew T. Dickerson","Matthew T. Dickerson - Wikipedia, the free encyclopedia","Matthew T. Dickerson - Wikipedia, the free encyclopedia wikipedia","Matthew T. Dickerson - Wikipédia","Matthew T. Dickerson; it is used under the","Matthew_T._Dickerson","Who is Matthew T. Dickerson","Wikipedia article on Matthew Dickerson","Wikipedia entry for Matthew T. Dickerson","en.wikipedia.org/wiki/Matthew_Dickerson","en.wikipedia.org/wiki/Matthew_T._Dickerson","http://en.wikipedia.org/wiki/Matthew_T._Dickerson","yago-res:Matthew T. Dickerson"],"name":"Matthew T. Dickerson","categories":["American computer scientists","Cornell University alumni","Dartmouth College alumni","Living people","Middlebury College faculty","Researchers in geometric algorithms","Tolkien studies","Year of birth missing (living people)"],"tag_line":"Matthew T. Dickerson is a professor of computer science at Middlebury College in Vermont, a scholar of the fiction of J. R. R. Tolkien and the Inklings, a novelist, a blues musician and historian of music, a fly fisherman, a maple sugar farmer, and a beekeeper."}}
,{"_index":"throwtable","_type":"algorithm","_id":"geomipmapping","_score":0,"_source":{"description":"Geomipmapping or geometrical mipmapping is a real-time block-based terrain rendering algorithm developed by W.H. de Boer in 2000 that aims to reduce CPU processing time which is a common bottleneck in level of detail approaches to terrain rendering. [1]\nPrior to geomipmapping, techniques such as quadtree rendering were used to divide the terrain into square tiles created by binary division with quadratically diminishing size. The subdivision step is typically performed on the CPU which creates a bottleneck as geometry commands are buffered to the GPU. Unlike quadtrees which send 1x1 polygon units to the GPU, to reduce the CPU processing time geomipmapping divides the terrain into grid-based tiles which are themselves regularly subdivided. Typically, a fixed number of vertex buffer objects (VBOs) are stored on the GPU at different grid resolutions, such as 10x10 and 20x20, and then placed at major terrain regions selectively chosen by the CPU. A vertex shader is then used to reposition the vertices for a given VBO, all on the GPU. Overall, this results in a major reduction in CPU processing, and reduced CPU-to-GPU bandwidth as the GPU then performs most of the work. Geoclipmaps and GPU raycasting are two other modern alternatives to geomipmapping for interactive rendering of terrain.","alt_names":["Geomipmapping","- Geomipmapping :","Geomipmapping - Wikipedia, the free encyclopedia","Geomipmapping on wikipedia.org","Geomipmapping; it is used under the","Wikipedia article Geomipmapping","Wikipedia article on Geomipmapping","Wikipedia entry for Geomipmapping","geomipmapping","http://en.wikipedia.org/wiki/Geomipmapping"],"name":"Geomipmapping","categories":["All stub articles","Computer graphics algorithms","Computer graphics stubs"],"tag_line":"Geomipmapping or geometrical mipmapping is a real-time block-based terrain rendering algorithm developed by W.H."}}
,{"_index":"throwtable","_type":"algorithm","_id":"joseph-o'rourke-(professor)","_score":0,"_source":{"description":"Joseph O'Rourke is the Olin Professor of Computer Science at Smith College and the founding chair of the Smith computer science department. His main research interest is computational geometry.\nO'Rourke was the first person to publish an algorithm to determine the minimum bounding box of a point set in three dimensions.\nIn 1985, O'Rourke was the program chair of the first annual Symposium on Computational Geometry. He was formerly the arXiv moderator for computational geometry and discrete mathematics.\nIn 2012 O'Rourke was named a fellow of the Association for Computing Machinery.","alt_names":["J. O'Rourke","- Joseph O'Rourke (professor) :","Joseph O'Rourke (professor)","Joseph O'Rourke (professor) - Wikipedia :: The free encyclopedia","Joseph O'Rourke (professor) - Wikipedia, the free encyclopedia","Joseph O'Rourke professor","O'Rouke, J.","O'Rourke, J.","O'Rourke, Joseph","Wikipedia - Joseph_O'Rourke_(professor)","Wikipedia article Joseph O'Rourke (professor)","check Joseph O'Rourke (professor)","http://en.Liarpedia.org/wiki/Joseph_O%27Rourke_(professor","http://en.wikipedia.org/wiki/Joseph_O%27Rourke_(professor","http://en.wikipedia.org/wiki/Joseph_O'Rourke_(professor"],"name":"Joseph O'Rourke (professor)","categories":["All stub articles","American computer scientists","BLP articles lacking sources from December 2012","Computer scientist stubs","Fellows of the Association for Computing Machinery","Guggenheim Fellows","Living people","Researchers in geometric algorithms","Smith College faculty","Wikipedia articles with BNF identifiers","Wikipedia articles with ISNI identifiers","Wikipedia articles with VIAF identifiers","Year of birth missing (living people)"],"tag_line":"Joseph O'Rourke is the Olin Professor of Computer Science at Smith College and the founding chair of the Smith computer science department."}}
,{"_index":"throwtable","_type":"algorithm","_id":"even–odd-rule","_score":0,"_source":{"description":"The even–odd rule is an algorithm implemented in vector-based graphic software, like the PostScript language and Scalable Vector Graphics (SVG), which determines how a graphical shape with more than one closed outline will be filled. Unlike the nonzero-rule algorithm, this algorithm will alternatively color and leave uncolored shapes defined by nested closed paths irrespective of their winding.\nThe SVG specification says: \"This rule determines the \"insideness\" of a point on the canvas by drawing a ray from that point to infinity in any direction and counting the number of path segments from the given shape that the ray crosses. If this number is odd, the point is inside; if even, the point is outside.\"\nThe rule can be seen in effect in many vector graphic programs (like Freehand or Illustrator), where a crossing of an outline with itself causes shapes to fill in strange ways.\nOn a simple curve, the even–odd rule reduces to a decision algorithm for the point in polygon problem.\n\n","alt_names":[],"name":"Even–odd rule","categories":["All stub articles","Computer graphics algorithms","Computer programming stubs","Parity (mathematics)"],"tag_line":"The even–odd rule is an algorithm implemented in vector-based graphic software, like the PostScript language and Scalable Vector Graphics (SVG), which determines how a graphical shape with more than one closed outline will be filled."}}
,{"_index":"throwtable","_type":"algorithm","_id":"jörg-rüdiger-sack","_score":0,"_source":{"description":"Jörg-Rüdiger Wolfgang Sack (born in Duisburg, Germany) is a professor of computer science at Carleton University, where he holds the SUN–NSERC chair in Applied Parallel Computing. Sack received a masters degree from the University of Bonn in 1979 and a Ph.D. in 1984 from McGill University, under the supervision of Godfried Toussaint. He is co-editor-in-chief of the journals Computational Geometry: Theory and Applications and the Journal of Spatial Information Science, co-editor of the Handbook of Computational Geometry (Elsevier, 2000, ISBN 978-0-444-82537-7), and co-editor of the proceedings of the biennial Algorithms and Data Structures Symposium (WADS). Sack's research interests include computational geometry, parallel algorithms, and geographic information systems.","alt_names":[],"name":"Jörg-Rüdiger Sack","categories":["All stub articles","Canadian computer scientists","Canadian computer specialist stubs","Canadian people stubs","Carleton University faculty","Computer scientist stubs","German computer scientists","Living people","McGill University alumni","Researchers in geometric algorithms","University of Bonn alumni","Year of birth missing (living people)"],"tag_line":"Jörg-Rüdiger Wolfgang Sack (born in Duisburg, Germany) is a professor of computer science at Carleton University, where he holds the SUN–NSERC chair in Applied Parallel Computing."}}
,{"_index":"throwtable","_type":"algorithm","_id":"david-g.-kirkpatrick","_score":0,"_source":{"description":"David Galer Kirkpatrick is a professor of computer science at the University of British Columbia. He is known for the Kirkpatrick–Seidel algorithm and his work on polygon triangulation, and for co-inventing α-shapes and the β-skeleton. He received his PhD from the University of Toronto in 1974.","alt_names":["- David G. Kirkpatrick :","David G Kirkpatrick","David G. Kirkpatrick","David G. Kirkpatrick - Wikipedia, the free encyclopedia","David G. Kirkpatrick - Wikipedia, the free encyclopedia wikipedia","David G. Kirkpatrick; it is used under the","David Galer Kirkpatrick","David Galer Kirkpatrick – Wikipedia","David_G._Kirkpatrick","Kirkpatrick, David","Kirkpatrick, David G.","Who is David G. Kirkpatrick","Wikipedia article David G. Kirkpatrick","http://de.wikipedia.org/wiki/David_Galer_Kirkpatrick","http://en.wikipedia.org/wiki/David G. Kirkpatrick","http://en.wikipedia.org/wiki/David_G._Kirkpatrick","yago-res:David G. Kirkpatrick"],"name":"David G. Kirkpatrick","categories":["All stub articles","Canadian computer scientists","Canadian computer specialist stubs","Canadian people stubs","Fellows of the Royal Society of Canada","Living people","Researchers in geometric algorithms","University of British Columbia faculty","University of Toronto alumni","Wikipedia articles with VIAF identifiers","Year of birth missing (living people)"],"tag_line":"David Galer Kirkpatrick is a professor of computer science at the University of British Columbia."}}
,{"_index":"throwtable","_type":"algorithm","_id":"reinforcement-learning","_score":0,"_source":{"description":"Reinforcement learning is an area of machine learning inspired by behaviorist psychology, concerned with how software agents ought to take actions in an environment so as to maximize some notion of cumulative reward. The problem, due to its generality, is studied in many other disciplines, such as game theory, control theory, operations research, information theory, simulation-based optimization, multi-agent systems, swarm intelligence, statistics, and genetic algorithms. In the operations research and control literature, the field where reinforcement learning methods are studied is called approximate dynamic programming. The problem has been studied in the theory of optimal control, though most studies are concerned with the existence of optimal solutions and their characterization, and not with the learning or approximation aspects. In economics and game theory, reinforcement learning may be used to explain how equilibrium may arise under bounded rationality.\nIn machine learning, the environment is typically formulated as a Markov decision process (MDP) as many reinforcement learning algorithms for this context utilize dynamic programming techniques. The main difference between the classical techniques and reinforcement learning algorithms is that the latter do not need knowledge about the MDP and they target large MDPs where exact methods become infeasible.\nReinforcement learning differs from standard supervised learning in that correct input/output pairs are never presented, nor sub-optimal actions explicitly corrected. Further, there is a focus on on-line performance, which involves finding a balance between exploration (of uncharted territory) and exploitation (of current knowledge). The exploration vs. exploitation trade-off in reinforcement learning has been most thoroughly studied through the multi-armed bandit problem and in finite MDPs.","alt_names":["reinforcement learning","Reinforcement learning","'policy'","- Reinforcement learning :","-> Read the article about 'Reinforcement learning'","...Wikipedia Apprendimento per rinforzo","...mehr auf Wikipedia über Bestärkendes Lernen","...more on Wikipedia about Reinforcement learning","88bd17ac76426100de5b15e1aeec47 ...",">reinforcement learning<","Apprendimento con rinforzo","Apprendimento per Rinforzo","Apprendimento per rinforzo","Apprendimento per rinforzo - Wikipedia","Apprentissage par renforcement","Apprentissage par renforcement - Wikip?dia","Apprentissage par renforcement - WikipÃŠdia","Apprentissage par renforcement - Wikipédia","Best?rkendes Lernen ? Wikipedia","Bestärkendes Lernen","Bestärkendes Lernen – Wikipedia","Bestärkendes_Lernen","Forsterkende læring","How is the Actor critic model's current research","Học tăng cường","Introduction to Reinforcement Learning","Learn about Reinforcement learning>>>","Machine learning methods started to integrate these capabilities","RL article on Wikipedia","Read Reinforcement learning Wikipedia the free encyclopedia","Reinforced Learning","Reinforced learning algorithm","Reinforcement Learning","Reinforcement Learning (RL)","Reinforcement Learning (wikipedia)","Reinforcement Learning - Wikipedia page","Reinforcement Learning - Wikipedia, the free encyclopedia","Reinforcement Learning Background","Reinforcement Learning Definition","Reinforcement Learning Wikipedia The Free Encyclopedia","Reinforcement Learning de Wikipedia","Reinforcement Learning from Wikipeadia","Reinforcement Learning on Wikipedia","Reinforcement Learning: Wikipedia","Reinforcement learning - Wikipedia","Reinforcement learning - Wikipedia, the free ...","Reinforcement learning - Wikipedia, the free encyclopedia","Reinforcement learning Wiki","Reinforcement learning Wikipedia the free encyclopedia","Reinforcement learning by Wikipedia","Reinforcement learning →","Reinforcement learning.","Reinforcement learning; it is used under the","Reinforcement_Learning","Reinforcement_learning","Reward function","Strona wikipedii o RL","Sutton 1998","Vahvistusoppiminen","What are implementations of Actor critic model","What is reinforcement learning?","Wiki, Reinforcement Learning","WikiPedia:Reinforcement_learning","Wikipedia : Reinforcement learning","Wikipedia article Apprentissage par renforcement","Wikipedia article Reinforcement Learning","Wikipedia article Reinforcement learning","Wikipedia article on reinforcement learning","Wikipedia entry for Reinforcement learning","Wikipedia l'articolo Apprendimento per rinforzo","Wikipedia-Artikel Bestärkendes Lernen","Wikipedia-Artikel Reinforcement Learning","Wikipedia-Seite zu 'Bestärkendes Lernen'","Wikipedia-Seite zu 'Reinforcement Learning'","Wikipedia.jp:強化学習","Wikipedia: Reinforcement Learning","Wikipedia: Reinforcement learning","Wikipedia: Reinforcement_learning","Wikipedia:Reinforcement learning","Wikipedia:Reinforcement_learning","Wikipedia:reinforcement learning","Wikipediaで「強化学習」を調べる","[2] http://en.wikipedia.org/wiki/Reinforcement_learning","apprendimento per rinforzo","apprendimento per rinforzo)","apprentissage par renforcement","apprentissage par renforcement (Reinforcement Learning, RL)","aprendizagem por reforço","bestärkendem Lernen","bg:Обучение с утвърждение","d'apprentissage automatique par renforcement","de:Bestärkendes Lernen","employed in any of those","en.wikipedia.o...cement_learning","en.wikipedia.org/...Reinforcement_Learning","en.wikipedia.org/...Reinforcement_learning","en.wikipedia.org/wiki/Reinforcement_Learning","en.wikipedia.org/wiki/Reinforcement_learning","en:reinforcement learning","fi:Vahvistusoppiminen","fr:Apprentissage par renforcement","he:למידת חיזוק","http://de.wikipedia.org/wiki/Best%C3%A4rkendes_Lernen","http://de.wikipedia.org/wiki/Bestärkendes_Lernen","http://de.wikipedia.org/wiki/Reinforcement_Learning","http://en.wikiped...learning","http://en.wikipedia....cement_learning","http://en.wikipedia.org/wiki/R....t_learning","http://en.wikipedia.org/wiki/Reinfo...","http://en.wikipedia.org/wiki/Reinforcement_","http://en.wikipedia.org/wiki/Reinforcement_Learning","http://en.wikipedia.org/wiki/Reinforcement_learning","http://en.wikipedia.org/wiki/Reinforcement_learning#Direct_policy_search","http://en.wikipedia.org/wiki/Reinforcement_learning#Implementations","http://en.wikipedia.org/wiki/Reinforcement_learning#refSutton1998","http://fi.wikipedia.org/wiki/Vahvistusoppiminen","http://fr.wikipedia.org/wiki/Apprentiss ... nforcement","http://fr.wikipedia.org/wiki/Apprentissage_par_renforcement","http://it.wikipedia.org/wiki/Apprendimento_per_rinforzo","http://ja.wikipedia.org/wiki/強化学習","http://ru.wikipedia.org/wiki/Обучение_с_подкреплением","học tăng cường","it:Apprendimento per rinforzo","ja.wikipedia.org/wiki/強化学習","ja:強化学習","ko:강화 학습","kritikerledd inlärning","l'article de Wikipédia Apprentissage Par Renforcement","l'article de Wikipédia Apprentissage par renforcement","learning from feedback","naive RL","no:Forsterkende læring","on-line učení zesílení","online Reinforcement Learning","online reinforcement learning","online-forstærkning læring","oбучение с подкреплением","oбучения с подкреплением","policy'","posílení vzdělávání","prediction error","refuerzo de aprendizaje en línea","reinforced learning","reinforcement learner","reinforcement learnin","reinforcement learning >","reinforcement learning wikipedia the free encyclopedia","reinforcement learning,","reinforcement-learning","reinforcement_learning","reinforcementlearning","reinforcment learning","reward function","ru:Обучение с подкреплением","self-learning algorithm","som modell","ttp://en.wikipedia.org/wiki/Reinforcement_learning","vi:Học tăng cường","wiki reinf learning","wikipedia article (computational RL)","wp:reinforcement learning","wzmocnienie uczenia się","wzmocnienie uczenia się online","zelf-lerend algoritme","zh:强化学习","«обучение с подкреплением»","Википедии статью Обучение с подкреплением","Обучение с подкреплением","Обучение с подкреплением — Википедия","Обучение с утвърждение","обучение с подкреплением","обучению с подкреплением","обучения с подкреплением","самообучающююся систему","למידת חיזוק – ויקיפדיה","يادگيرى تقويتى","「強化学習」","「強化学習」をWikipediaで調べる","ウィキペディアの記事 強化学習","奖励学习","強化学習","強化学習 - Wikipedia","強化学習(Reinforcement Learning)","強化学習(Wikipedia)","強化学習(reinforcement learning)","強化学習-wikipedia","強化学習:(reinforcement learning)","強化學習- 維基百科，自由的百科全書","强化学习","强化学习在线","獎勵學習","経験によって学習していくプログラム（強化学習プログラム","維基百科的文章“ 奖励学习”","강화 학습","위키 피 디아 문서 강화 학습"],"name":"Reinforcement learning","categories":["All articles lacking in-text citations","Articles lacking in-text citations from November 2015","Belief revision","CS1 errors: missing author or editor","Machine learning algorithms","Markov models","Pages containing cite templates with deprecated parameters"],"tag_line":"Reinforcement learning is an area of machine learning inspired by behaviorist psychology, concerned with how software agents ought to take actions in an environment so as to maximize some notion of cumulative reward."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cache-algorithms","_score":0,"_source":{"description":"In computing, cache algorithms (also frequently called cache replacement algorithms or cache replacement policies) are optimizing instructions—​or algorithms—​that a computer program or a hardware-maintained structure can follow in order to manage a cache of information stored on the computer. When the cache is full, the algorithm must choose which items to discard to make room for the new ones.","alt_names":["Least Recently Used","least recently used","LRU cache","Lru","% 5Falgorithms http://en.wikipedia.org/wiki/Cache","% Http://en.wikipedia.org/wiki/Cache 5Falgorithms","(в Wiki - алгоритмы кэширования)","- Cache algorithms :","- LRU algorithm :","...mehr auf Wikipedia über Cache-Algorithmus","...more on Wikipedia about Cache algorithms","5Falgorithms http://en.wikipedia.org/wiki/Cache%","5Falgorithms% http://en.wikipedia.org/wiki/Cache","<b>Cache b> algorithms - Wikipedia, the free encyclopedia","Algorithme LRU","Algorithmes de remplacement des lignes de cache","Algorithmes de remplacement des lignes de cache - Wikip","Algorithmes de remplacement des lignes de cache - Wikipédia","Belady's Min","Cache Algorithms","Cache Algorithms Wikipedia The Free Encyclopedia","Cache Algorithms.","Cache algorithm","Cache algorithms","Cache algorithms - Wikipedia :: The free encyclopedia","Cache algorithms - Wikipedia, the ...","Cache algorithms - Wikipedia, the free encyclopedia","Cache algorithms - Wikipedia, the free encyclopedia The practical","Cache algorithms Wikipedia the free encyclopedia","Cache algorithms from Wikipedia","Cache algorithms in Wikipedia","Cache algorithms: Least Recently Used (LRU)","Cache algorithms; it is used under the","Cache algoritma","Cache algoritmen","Cache algoritmer","Cache algoritmi","Cache algorytmów","Cache methodes","Cache replacement algorithms","Cache thuật toán","Cache-Algorithmen","Cache-Algorithmus","Cache-Algorithmus bei der wikipedia","Cache-Algorithmus – Wikipedia","Cache_algorithms","Cachestrategien","Cacheは、アルゴリズムの","Caching algorithm","Caching-Algorithmen","Encyclopedia: Cache algorithms","LFU (least frequently used)","LFU (least frequently used) cache","LRU (e non solo)","LRU (least recently used)","LRU (least recently used) cache","LRU (least recently used) cache algorithm","LRU (least recently used).","LRU Cache","LRU algorithm","LRU caches","LRU manner","LRU strategy","LRU sur wikipédia","LRU 快取演算法","LRU 算法","LRU 캐시에","LRU, LFU","LRU-Cache","LRU-Cache-Strategy","LRU.Query cache","LRU/MRU","LRUキャッシュ","LRU算法","LRU緩存","LRU缓存","LRU高速","Last Recently Used algorithm","Learn about Cache algorithms>>>","Least Recently Used (LRU)","Least Recently Used (LRU) Cache","Least Recently Used - Wikipedia Indonesia, ensiklopedia bebas ...","Least Recently Used - Wikipedia bahasa Indonesia, ensiklopedia bebas","Least Recently Used algorithm","Least Recently Used cache","Least Recently Used caching algorithms at Wikipedia","Least Recently Used policy","Least Recently Used-Cache","Least recently used","Least-Recently Used (LRU)","Least-Recently Used algorithm","Least_recently_used [Wikipedia]","MRU cache","Random Replacement, Least Recently Used, Most Recently Used","Read More cache algorithms wikipedia the free encyclopedia","Rob Hudson: Cache algorithms - Wikipedia, the free encyclopedia","The problem of cache management","This information may help you with that.","Two common algorithms","Vyrovnávací algoritmy","What are some examples of Cache algorithm?","What are some examples of LRU algorithm?","What are some examples of Least recently used","Wikipedia (Cache algorithms)","Wikipedia : キャッシュアルゴリズム","Wikipedia article Cache algorithms","Wikipedia article LRU algorithm","Wikipedia article Least Recently Used","Wikipedia article about cache algorithms","Wikipedia article on Cache algorithms","Wikipedia article on LRU algorithm","Wikipedia entry for Cache algorithms","Wikipedia-Artikel Cache-Algorithmus","Wikipedia: Cache algorithms","[11] Cache algorithms","[12] LRU algorithm","[9] LRU","ache Algorithms an","algorithmes de cache","algoritmi di Cache","algoritmi di caching","algoritmos de cache","algoritmos de caché","bộ nhớ cache LRU","cache LRU","cache algorithm","cache algorithms","cache algorithms page on Wikipedia. That's about it","cache expiration algorithms","cache replacement algorithm","cache replacement algorithms","cache strategy","caching algorithm","caching algorithms","caching-algoritmen","caché LRU,","caché menos usados ​​recientemente","d'algorithmes de cache","de:Cache-Algorithmus","dense body of thought","en.wikipedia.org/...Cache_algorithms","en.wikipedia.org/wiki/Cache_algorithms","fr:Algorithmes de remplacement des lignes de cache","fr:Algorithmes_de_remplacement_des_lignes_de_cache","gesegmenteerde LRU cache","http://de.wikipedia.org/wiki/Cache-Algor","http://de.wikipedia.org/wiki/Cache-Algorithmus","http://en.wikipedia....ache_algorithms","http://en.wikipedia.org/wiki/Cache 5Falgorithms ٪","http://en.wikipedia.org/wiki/Cache algorithms","http://en.wikipedia.org/wiki/Cache% 5Falgorithms","http://en.wikipedia.org/wiki/Cache%5Falgorithms","http://en.wikipedia.org/wiki/Cache_a...#Segmented_LRU","http://en.wikipedia.org/wiki/Cache_a..._Recently_Used","http://en.wikipedia.org/wiki/Cache_a...requently_Used","http://en.wikipedia.org/wiki/Cache_algo … ently_Used","http://en.wikipedia.org/wiki/Cache_algor","http://en.wikipedia.org/wiki/Cache_algor...ently_Used","http://en.wikipedia.org/wiki/Cache_algorithms","http://en.wikipedia.org/wiki/Cache_algorithms (about LRU","http://en.wikipedia.org/wiki/Cache_algorithms#2-Way_Set_Associative","http://en.wikipedia.org/wiki/Cache_algorithms#Leas...","http://en.wikipedia.org/wiki/Cache_algorithms#Least-Frequently_Used","http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently _Used","http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently...","http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used","http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used>","http://en.wikipedia.org/wiki/Cache_algorithms#Least−Frequently_Used","http://en.wikipedia.org/wiki/Cache_algorithms#Most_Recently_Used","http://en.wikipedia.org/wiki/Cache_algorithms#Pseudo-LRU","http://en.wikipedia.org/wiki/Cache_algorithms...","http://en.wikipedia.org/wiki/LRU_algorithm","http://en.wikipedia.org/wiki/Least_recently_used","http://en.wikipedia.org/wiki/cache_**algorithms","http://ru.wikipedia.org/wiki/LRU#Least_Recently_Used_.28","http://ru.wikipedia.org/wiki/Алгоритмы_кэширования","http://tr.wikipedia.org/wiki/%C3%96nbellek_algoritmalar%C4","id:Least Recently Used","intelligent strategy","ja:キャッシュアルゴリズム","las políticas de sustitución","least recently use","least recently used (LRU)","least recently used (LRU) strategy","least recently used caching algorithm","least-recently-used","least-recently-used (LRU) algorithm","les différents algorithmes de remplacement des lignes de","lfu","many more complicated cache replacement algorithms","meno utilizzato di recente","menos usados recientemente","menos usados ​​recientemente","menos utilizado recentemente","mindst nylig brugte","mindst nyligt brugte cache","minst recent gebruikte","moins récemment utilisé","najdawniej używany","nejméně nedávno používal","os algoritmos de cache","p://en.wikipedia.org/wiki/Cache_algorithms","politique de remplacement des lignes de cache","recente utilizzato meno cache","replacement algorithm","replacement poli","replacement policies","replacement strategy","rich research literature","ru:Алгоритмы кэширования","slimmer","standard LRU algorithm","stratégies d'éviction des caches","the Wiki article on Cache Algorithms","tr:Önbellek algoritmaları","udskiftning politikker","un algorithme type LFU","used least recently","vervanging van het beleid","zh:快取文件置換機制","zijn minst recent gebruikte","zuletzt verwendeten","Önbellek algoritmaları","Önbellek algoritmaları - Vikipedi","İngilizce Vikipedi'deki aynı adlı madde","İngilizce Vikipedideki aynı adlı madde","Алгоритмы кэширования","Алгоритмы_кэширования","Кэш LRU","Кэш алгоритмами","Кэш алгоритмов","Кэш алгоритмы","Минимума Белади","РђР»РіРѕСЂРёС‚РјС‹ РєСЌС€РёСЂРѕРІР°РЅРёСЏ вЂ” Р","алгоритма замещения страниц","алгоритмов кэширования","мере недавно использованных","механизм LRU","наиболее давним использованием","наиболее давним использованием кэша","наименее используемый","янз бүрийн алгоритм","कैश एल्गोरिदम","อั ลก อริ Cache","แคช LRU","、少なくとも最近使用","『キャッシュアルゴリズム』の解説","のLRU","のキャッシュアルゴリズムを","キャッシュアルゴリズム","キャッシュアルゴリズム - Wikipedia","キャッシュアルゴリズム- Wikipedia","キャッシュアルゴリズムを","使用される最も最近","快取文件置換機制","快取文件置換機制- 維基百科，自由的百科全書","快取文件置換機制- 维基百科，自由的百科全书","最小は、最近使用した","最近最少使用","維基百科的文章“ 快取文件置換機制”","緩存算法","维基百科的文章“ 快取文件置換機制”","缓存算法","高速緩存文件置換機制","캐시 알고리즘을"],"name":"Cache algorithms","categories":["Cache (computing)","Memory management algorithms","Use dmy dates from August 2012"],"tag_line":"In computing, cache algorithms (also frequently called cache replacement algorithms or cache replacement policies) are optimizing instructions—​or algorithms—​that a computer program or a hardware-maintained structure can follow in order to manage a cache of information stored on the computer."}}
,{"_index":"throwtable","_type":"algorithm","_id":"temporal-difference-learning","_score":0,"_source":{"description":"Temporal difference (TD) learning is a prediction-based machine learning method. It has primarily been used for the reinforcement learning problem, and is said to be \"a combination of Monte Carlo ideas and dynamic programming (DP) ideas.\" TD resembles a Monte Carlo method because it learns by sampling the environment according to some policy, and is related to dynamic programming techniques as it approximates its current estimate based on previously learned estimates (a process known as bootstrapping). The TD learning algorithm is related to the temporal difference model of animal learning.\nAs a prediction method, TD learning considers that subsequent predictions are often correlated in some sense. In standard supervised predictive learning, one learns only from actually observed values: A prediction is made, and when the observation is available, the prediction is adjusted to better match the observation. As elucidated by Richard Sutton, the core idea of TD learning is that one adjusts predictions to match other, more accurate, predictions about the future. This procedure is a form of bootstrapping, as illustrated with the following example:\n\"Suppose you wishes to predict the weather for Saturday, and you have some model that predicts Saturday's weather, given the weather of each day in the week. In the standard case, you would wait until Saturday and then adjust all your models. However, when it is, for example, Friday, you should have a pretty good idea of what the weather would be on Saturday - and thus be able to change, say, Monday's model before Saturday arrives.\"\nMathematically speaking, both in a standard and a TD approach, one would try to optimize some cost function, related to the error in our predictions of the expectation of some random variable, E[z]. However, while in the standard approach one in some sense assumes E[z] = z (the actual observed value), in the TD approach we use a model. For the particular case of reinforcement learning, which is the major application of TD methods, z is the total return and E[z] is given by the Bellman equation of the return.","alt_names":["temporal differences","- Temporal difference learning :","- Temporal-difference learning :","...more on Wikipedia about Temporal difference learning","Diferencia temporal de aprendizaje","Differenza temporale di apprendimento","Différence temporelle d'apprentissage","Perbedaan temporal belajar","Read Temporal difference learning Wikipedia the free encyclopedia","TD Learning","TD algorithm in neuroscience","TD(0)","TD-Lamda from Wikipedia","TD-Learning","TD-aprendizaje","TD-learning","TD-लर्निंग","Temporal Difference","Temporal Difference Learning","Temporal Difference Learning - Wikipedia, The Free Encyclopedia","Temporal Difference Learning Background","Temporal Difference Learning from Wikipeadia","Temporal diferença de aprendizagem","Temporal difference","Temporal difference learning","Temporal difference learning - Wikipedia, the free encyclopedia","Temporal difference learning - Wikipedia, the free encyclopedia ...","Temporal difference learning background information","Temporal difference learning by Wikipedia","Temporal difference learning; it is used under the","Temporal differences","Temporal differences (TD)","Temporal khác biệt học tập","Temporal-difference learning","Temporal_difference_learning","Wikipedia article Temporal difference learning","Wikipedia article Temporal_difference_learning","Wikipedia article on Temporal Difference Learning","Wikipedia article on Temporal difference learning","Wikipedia entry for Temporal difference learning","Wikipedia:Temporal difference learning","Zeitliche Differenz Lernen","diferencias temporales","diferencias temporales de aprendizaje","en.wikipedia.org/wiki/Temporal_difference_learning","fa8bd3ce6939bca62d49938d2a2a ...","http://en.Liarpedia.org/wiki/Temporal_difference_learning","http://en.wikipedia.org/wiki/Tempora...rence_learning","http://en.wikipedia.org/wiki/Temporal_di","http://en.wikipedia.org/wiki/Temporal_difference_l earning","http://en.wikipedia.org/wiki/Temporal_difference_learning","http://en.wikipedia.org/wiki/Temporal_difference_learning#TD_algorithm_in_neuroscience","http://en.wikipedia.org/wiki/Temporal_dif…","reward-prediction","temporal difference","temporal difference learner","temporal difference learning","temporal difference prediction errors","temporal difference technique","temporal differencing","temporal-difference learning","temporal-difference reinforcement learning","temporal-differences (TD) algorithm","temporal–difference reinforcement learning","that kind of policy learning","Временные разницы обучения","обучения с временными воздействиями","แตก ต่าง ขมับ เรียน รู้","のTD -ラーニング","学习时空差异","學習時空差異","時間差学習","运输署学习","시간적 차이가 학습"],"name":"Temporal difference learning","categories":["Computational neuroscience","Machine learning algorithms"],"tag_line":"Temporal difference (TD) learning is a prediction-based machine learning method."}}
,{"_index":"throwtable","_type":"algorithm","_id":"michael-ian-shamos","_score":0,"_source":{"description":"Michael Ian \"Mike\" Shamos (born April 21, 1947) is an American mathematician, attorney, book author, journal editor, consultant and company director. He is (with Franco P. Preparata) the author of Computational Geometry (Springer-Verlag, 1985), which was for many years the standard textbook in computational geometry, and is known for the Shamos–Hoey sweep line algorithm for line segment intersection detection and for the rotating calipers technique for finding the width and diameter of a geometric figure. His publications also include works on electronic voting, the game of billiards, and intellectual property law in the digital age.\nHe was a fellow of Sigma Xi (1974–83), had an IBM Fellowship at Yale University (1974–75), was SIAM National Lecturer (1977–78), distinguished lecturer in computer science at the University of Rochester (1978), visited McGill University (1979), and belonged to the Duquesne University Law Review (1980–81). He won the first annual Black & White Scotch Achiever’s Award in 1991 for contributions to bagpipe musicography, and the Industry Service Award of the Billiard and Bowling Institute of America, 1996, for contributions to billiard history. Since 2001 he is a Billiard Worldcup Association official referee.\nHe has been editor in chief of the Journal of Privacy Technology (2003–2006), a member of the editorial boards of Electronic Commerce Research Journal and the Pittsburgh Journal of Technology, Law and Policy, and a contributing editor of Billiards Digest magazine.\nShamos is the author of The New Illustrated Encyclopedia of Billiards (Lyons, 1999) among other related works, and is the curator of the Billiards Museum and Archive.\nMichael Shamos is the Director of the MS in IT eBusiness Technology program at Carnegie Mellon University.","alt_names":["- Michael Ian Shamos :","By Mike Shamos","M. I. Shamos","Michael Ian Shamos","Michael Ian Shamos - Wikipedia, the free encyclopedia","Michael Ian Shamos - Wikipedia, the free encyclopedia ...","Michael Ian Shamos; it is used under the","Michael Shamos","Michael Shamos in Wikipedia","Michael_Shamos","Mike Shamos","Shamos","Shamos, M. I.","Shamos, Michael Ian","Shamos, Mike","Who is Michael Ian Shamos","Wikipedia article Michael Ian Shamos","Wikipedia article Michael Shamos","Wikipedia article Mike Shamos","Wikipedia article on Michael Ian Shamos","Wikipedia article on Michael Shamos","Wikipedia article on Mike Shamos","Wikipedia entry for Michael Ian Shamos","http://en.wikipedia.org/wiki/Michael_Ian_Shamos","“Michael Ian Shamos - Wikipedia, the free encyclopedia”, en"],"name":"Michael Ian Shamos","categories":["1947 births","20th-century American mathematicians","21st-century American mathematicians","Cue sports writers and broadcasters","Duquesne University faculty","Living people","Researchers in geometric algorithms","University of Rochester faculty","Voting theorists","Wikipedia articles with BNF identifiers","Wikipedia articles with ISNI identifiers","Wikipedia articles with VIAF identifiers"],"tag_line":"Michael Ian \"Mike\" Shamos (born April 21, 1947) is an American mathematician, attorney, book author, journal editor, consultant and company director."}}
,{"_index":"throwtable","_type":"algorithm","_id":"quickprop","_score":0,"_source":{"description":"Quickprop is an iterative method for determining the minimum of the loss function of an artificial neural network, following an algorithm inspired by the Newton's method. Sometimes, the algorithm is classified to the group of the second order learning methods. It follows a quadratic approximation of the previous gradient step and the current gradient, which is expected to be closed to the minimum of the loss function, under the assumption that the loss function is locally approximately square, trying to describe it by means of an upwardly open parabola. The minimum is sought in the vertex of the parabola. The procedure requires only local information of the artificial neuron to which it is applied. The k-th approximation step is given by:\n\nBeing  the neuron j weight of its i input and E is the loss function.\nThe Quickprop algorithm is an implementation of the error backpropagation algorithm, but the network can behave chaotically during the learning phase due to large step sizes.","alt_names":[],"name":"Quickprop","categories":["Artificial neural networks","Computational neuroscience","Machine learning algorithms"],"tag_line":"Quickprop is an iterative method for determining the minimum of the loss function of an artificial neural network, following an algorithm inspired by the Newton's method."}}
,{"_index":"throwtable","_type":"algorithm","_id":"constructing-skill-trees","_score":0,"_source":{"description":"Constructing skill trees (CST) is a hierarchical reinforcement learning algorithm which can build skill trees from a set of sample solution trajectories obtained from demonstration. CST uses an incremental MAP(maximum a posteriori ) change point detection algorithm to segment each demonstration trajectory into skills and integrate the results into a skill tree. CST was introduced by George Konidaris, Scott Kuindersma, Andrew Barto and Roderic Grupen in 2010.","alt_names":[],"name":"Constructing skill trees","categories":["All articles needing additional references","Articles needing additional references from January 2012","CS1 errors: missing author or editor","Machine learning algorithms"],"tag_line":"Constructing skill trees (CST) is a hierarchical reinforcement learning algorithm which can build skill trees from a set of sample solution trajectories obtained from demonstration."}}
,{"_index":"throwtable","_type":"algorithm","_id":"generec","_score":0,"_source":{"description":"GeneRec is a generalization of the Recirculation algorithm, and approximates Almeida-Pineda recurrent backpropagation. It is used as part of the Leabra algorithm for error-driven learning.\nThe symmetric, midpoint version of GeneRec is equivalent to the contrastive Hebbian learning algorithm (CHL).","alt_names":["- GeneRec :","GeneRec","GeneRec - Wikipedia, the free encyclopedia","GeneRec by Wikipedia","http://en.wikipedia.org/wiki/GeneRec"],"name":"GeneRec","categories":["All stub articles","Machine learning algorithms","Neuroscience","Neuroscience stubs"],"tag_line":"GeneRec is a generalization of the Recirculation algorithm, and approximates Almeida-Pineda recurrent backpropagation."}}
,{"_index":"throwtable","_type":"algorithm","_id":"page-replacement-algorithm","_score":0,"_source":{"description":"In a computer operating system that uses paging for virtual memory management, page replacement algorithms decide which memory pages to page out (swap out, write to disk) when a page of memory needs to be allocated. Paging happens when a page fault occurs and a free page cannot be used to satisfy the allocation, either because there are none, or because the number of free pages is lower than some threshold.\nWhen the page that was selected for replacement and paged out is referenced again it has to be paged in (read in from disk), and this involves waiting for I/O completion. This determines the quality of the page replacement algorithm: the less time waiting for page-ins, the better the algorithm. A page replacement algorithm looks at the limited information about accesses to the pages provided by hardware, and tries to guess which pages should be replaced to minimize the total number of page misses, while balancing this with the costs (primary storage and processor time) of the algorithm itself.\nThe page replacing problem is a typical online problem from the competitive analysis perspective in the sense that the optimal deterministic algorithm is known.","alt_names":["replacement policy","page replacement algorithm","page replacement algorithms","(Page Replacement Algorithms)","- Page replacement algorithm :","-> Read more about Page replacement algorithm","...Wikipedia Algoritmos de reemplazo de páginas","...Wikipedia Least Recently Used","...more on Wikipedia about Page replacement algorithms","6] Page replacement algorithm","Algoritmi di rimpiazzamento delle pagine","Algoritmos de reemplazo de paginas","Algoritmos de reemplazo de páginas","Algoritmos de reemplazo de páginas - Wikipedia, la ...","Algoritmos de reemplazo de páginas - Wikipedia, la enciclopedia","Anticipatory paging","Clock algorithm","First In First Out Page Replacement","From LRU to LIRS","LRU や NFU","LRUアルゴリズム","Least Recently Used - Wikipedia","Least Recently Used - Wikipedia, wolna encyklopedia","Least Recently Used Page Replacement","Least Recently Usedとは？ (Wikipediaへのリンク)","Least_Recently_Used-wikipedia","Local vs. global replacement","Not Used Recently Page Replacement","OPTIMAL","Optimal page replacement algorithm","Orriak ordezkatzeko algoritmoak","Orriak ordezkatzeko algoritmoak - Wikipedia, entziklopedia askea.","Page Replacement","Page Replacement Algorithm","Page Replacement Algorithm Wikipedia The Free Encyclopedia","Page Replacement Algorithms","Page replacement","Page replacement Algorithms","Page replacement algorithm","Page replacement algorithm - Simple English Wikipedia, the ...","Page replacement algorithm - Simple English Wikipedia, the free","Page replacement algorithm - Wikipedia :: The free encyclopedia","Page replacement algorithm - Wikipedia, the free ...","Page replacement algorithm - Wikipedia, the free encyclopedia","Page replacement algorithm - Wikipedia, the free encyclopedia ...","Page replacement algorithm Simple English Wikipedia the free","Page replacement algorithm Wikipedia the free encyclopedia","Page replacement algorithm; it is used under the","Page replacement algorithms","Page replacement algorithms - Wikipedia, the free encyclopedia","Page_replacement_algorithm","Page_replacement_algorithms","Paging Problem","Precleaning","Primera en entrar, primera en salir (FIFO, First","Random Page Replacement","Read More About page replacement algorithm wikipedia the","Read More page replacement algorithm simple english wikipedia","Read More page replacement algorithm wikipedia the free","Sayfa yer değiştirme algoritması","Sayfa yer değiştirme algoritması - Vikipedi","Second-chance","Second-chance algorithm","Seite Ersatz-Algorithmus","The same way it knows to page out","This is the best description I can find","VM replacement algorithm","WSClock","Wikipedia (Page replacement algorithm)","Wikipedia : ページ置換アルゴリズム","Wikipedia Algoritmos de reemplazo de páginas","Wikipedia article Page replacement algorithm","Wikipedia article Page replacement algorithms","Wikipedia article on Algoritmos de reemplazo de páginas","Wikipedia article on Page replacement algorithm","Wikipedia article on Page replacement algorithms","Wikipedia article Задача заміщення сторінок","Wikipedia entry for Page replacement algorithm","Wikipedia: Page Replacement Algorithm","Wikipedia: Page replacement algorithm (least recently used)","Wikipedia: Paging algorithm","Wikipediaで「LRU」を調べる","Wikipediaで「Least Recently Used」を調べる","Wikipediaで「ページ置換アルゴリズム」を調べる","[11] FIFO algorithm","[13] Second chance algorithm","[13]Second chance algorithm","[17] Page replacement algorithm","[17] Page replacement algorithm:","[6] Page replacement algorithm","[7] Least recently used algorithm","a family of caching algorithms","algoritmo de reemplazo de páginas","algoritmo de segunda oportunidad","algoritmo di seconda chance","algoritmo di sostituzione delle pagine","algoritmos de reemplazo de páginas","algoritmos de remplazo de páginas","algoritmos de substituição de página","anticipatory paging","ar:تبديل الصفحات","artículo de Wikipedia Algoritmos de reemplazo de paginas","artículo de Wikipedia Algoritmos de reemplazo de páginas","clock algorithm","clock based algorithm","clock page replacement algorithm","druhou šanci algoritmus","efer to http://en.wikipedia.org/wiki/","el menos recientemente usado / LRU","en.wikipedia.org/...Page_replacement_algorithm","en.wikipedia.org/wiki/Page_...","en.wikipedia.org/wiki/Page_replacement_algorithm","en:Page replacement algorithm","es:Algoritmos de reemplazo de páginas","eu:Orriak ordezkatzeko algoritmoak","gestiona la memo las páginas","http://bit.ly/iRyj91","http://en.wikipedia....ement_algorithm","http://en.wikipedia.org/ wiki/ Page_replacement_algorithms","http://en.wikipedia.org/wiki/Page replacement algorithm","http://en.wikipedia.org/wiki/Page_re...#Second-chance","http://en.wikipedia.org/wiki/Page_re...ent_algorithms","http://en.wikipedia.org/wiki/Page_re...ment_algorithm","http://en.wikipedia.org/wiki/Page_rep...","http://en.wikipedia.org/wiki/Page_repla ... ond-Chance","http://en.wikipedia.org/wiki/Page_repla … algorithms","http://en.wikipedia.org/wiki/Page_repla … hm#Ageing","http://en.wikipedia.org/wiki/Page_replac","http://en.wikipedia.org/wiki/Page_replacem...lgorithm#Random","http://en.wikipedia.org/wiki/Page_replacem...t_recently_used","http://en.wikipedia.org/wiki/Page_replacement...","http://en.wikipedia.org/wiki/Page_replacement_algorithm","http://en.wikipedia.org/wiki/Page_replacement_algorithm#Ageing:","http://en.wikipedia.org/wiki/Page_replacement_algorithm#Clock","http://en.wikipedia.org/wiki/Page_replacement_algorithm#Least_recently_used","http://en.wikipedia.org/wiki/Page_replacement_algorithm#Not_recently_used","http://en.wikipedia.org/wiki/Page_replacement_algorithm#Page_replacement_algorithms","http://en.wikipedia.org/wiki/Page_replacement_algorithm#Random","http://en.wikipedia.org/wiki/Page_replacement_algorithm#Second-chance","http://en.wikipedia.org/wiki/Page_replacement_algorithm#The_theoretically_o","http://en.wikipedia.org/wiki/Page_replacement_algorithm#The_theoretically_o=","http://en.wikipedia.org/wiki/Page_replacement_algorithm#The_theoretically_optimal_page_replacement_algorithm","http://en.wikipedia.org/wiki/Page_replacement_algorithm#Variants_on_LRU","http://en.wikipedia.org/wiki/Page_replacement_algorithms","http://en.wikipedia.org/wiki/Page_replacement_algorithms#Aging","http://en.wikipedia.org/wiki/Page_replacement_algorithms#Least_Recentl y_Used","http://en.wikipedia.org/wiki/Page_replacement_algorithms#Least_Recently_Used","http://en.wikipedia.org/wiki/Page_replac…","http://es.wikipedia.org/wiki/Algorit...e_p%C3","http://es.wikipedia.org/wiki/Algorit...e_páginas","http://es.wikipedia.org/wiki/Algoritmos_de_reemplazo_de_p%C3%A1ginas","http://es.wikipedia.org/wiki/Algoritmos_de_reemplazo_de_páginas","http://j.mp/l9HwaW","http://ja.wikipedia.org/wiki/LRU","http://ja.wikipedia.org/wiki/Least_Recently_Used","http://pl.wikipedia.org/wiki/Least_Recently_Used","ja:ページ置換アルゴリズム","ko:페이지 교체 알고리즘","l&#39;algorithme dédié","l'algorithme dédié","many different cache replacement algorithms","mengde teknikker","możliwość sekund algorytmu","not recently used","ny chance algoritme","page replacement","page replacement techniques","page-replacement","page-replacement algorithm","page-replacement algorithms","perfect replacement policy","reemplazo","replacement algorithms","second chance algorithm","side udskiftning algoritme","simple:Page replacement algorithm","some good references","the Wikipedia page for page replacement algorithm","the clairvoyant algorithm","the clairvoyant algorithm.","uk:Задача заміщення сторінок","uma família de algoritmos de cache","virtual memory applications","wikipedia page replacement algorithms","wikipedia:”ページ置換アルゴリズム”","Задача заміщення сторінок","алгоритмы замещения страниц","задача замещения страниц в кэш-мапяти","задача замещения страниц в кэш-памяти","оптимальную стратегию вытеснения","страницу алгоритм замены","تبديل الصفحات","تبديل الصفحات - ويكيبيديا، الموسوعة الحرة","पृष्ठ प्रतिस्थापन एल्गोरिथ्म","「LRU」をWikipediaで調べる","ウィキペディアの記事 LRU","ウィキペディアの記事 Least Recently Used","ウィキペディアの記事 ページ置換アルゴリズム","ページ置き換えアルゴリズム","ページ置換アルゴリズム","ページ置換アルゴリズム - Wikipedia","二度目のチャンスアルゴリズムは","仮想メモリのページ置換アルゴリズム","的页面置换","第二次机会算法","頁面置換算法","页面置换算法","위키 피 디아 문서 페이지 교체 알고리즘","페이지 교체 알고리즘","페이지 대체 알고리즘","ＬＲＵアルゴリズム","ﾍﾟｰｼﾞ置換ｱﾙｺﾞﾘｽﾞﾑ","ﾍﾟｰｼﾞ置換ｱﾙｺﾞﾘｽﾞﾑ-wikipedia"],"name":"Page replacement algorithm","categories":["All Wikipedia articles needing clarification","All articles with unsourced statements","Articles with unsourced statements from June 2008","Memory management algorithms","Online algorithms","Use dmy dates from August 2012","Virtual memory","Wikipedia articles needing clarification from August 2011","Wikipedia articles needing clarification from January 2014"],"tag_line":"In a computer operating system that uses paging for virtual memory management, page replacement algorithms decide which memory pages to page out (swap out, write to disk) when a page of memory needs to be allocated."}}
,{"_index":"throwtable","_type":"algorithm","_id":"generic-cell-rate-algorithm","_score":0,"_source":{"description":"The generic cell rate algorithm (GCRA) is a leaky bucket-type scheduling algorithm for the network scheduler that is used in Asynchronous Transfer Mode (ATM) networks. It is used to measure the timing of cells on virtual channels (VCs) and or Virtual Paths (VPs) against bandwidth and jitter limits contained in a traffic contract for the VC or VP to which the cells belong. Cells that do not conform to the limits given by the traffic contract may then be re-timed (delayed) in traffic shaping, or may be dropped (discarded) or reduced in priority (demoted) in traffic policing. Nonconforming cells that are reduced in priority may then be dropped, in preference to higher priority cells, by downstream components in the network that are experiencing congestion. Alternatively they may reach their destination (VC or VP termination) if there is enough capacity for them, despite them being excess cells as far as the contract is concerned: see priority control.\nThe GCRA is given as the reference for checking the traffic on connections in the network, i.e. usage/network parameter control (UPC/NPC) at user–network interfaces (UNI) or inter-network interfaces or network-network interfaces (INI/NNI) . It is also given as the reference for the timing of cells transmitted (ATM PDU Data_Requests) onto an ATM network by a network interface card (NIC) in a host, i.e. on the user side of the UNI . This ensures that cells are not then discarded by UPC/NCP in the network, i.e. on the network side of the UNI. However, as the GCRA is only given as a reference, the network providers and users may use any other algorithm that gives the same result.\n\n","alt_names":["- GCRA :","-> Read the article about 'Generic cell rate algorithm","...more on Wikipedia about Generic cell rate algorithm","Dual Leaky Bucket Controller","Formal definition of the GCRA","GCRA","Generic Cell Rate Algorithm","Generic cell rate algorithm","Generic cell rate algorithm - Wikipedia :: The free encyclopedia","Generic cell rate algorithm - Wikipedia, the free encyclopedia","Generic cell rate algorithm: Formal definition of the","Generic cell rate algorithm: How does the algorithm","Generic cell rate algorithm: What is the GCRA","Generic_cell_rate_algorithm","How does the algorithm work?","What is the GCRA used for?","Wikipedia article GCRA","Wikipedia article Generic Cell Rate Algorithm","Wikipedia article Generic cell rate algorithm","Wikipedia entry for Generic cell rate algorithm","e Dual Leaky Bucket Controller.","en.wikipedia.org/wiki/Generic_cell_rate_algorithm","generic cell rate algorithm","http://en.wikipedia.org/wiki/Generic...Rate_Algorithm","http://en.wikipedia.org/wiki/Generic_cel","http://en.wikipedia.org/wiki/Generic_cell_rate_algorithm"],"name":"Generic cell rate algorithm","categories":["Network scheduling algorithms","Networking algorithms","Teletraffic"],"tag_line":"The generic cell rate algorithm (GCRA) is a leaky bucket-type scheduling algorithm for the network scheduler that is used in Asynchronous Transfer Mode (ATM) networks."}}
,{"_index":"throwtable","_type":"algorithm","_id":"max-min-fairness","_score":0,"_source":{"description":"In communication networks, multiplexing and the division of scarce resources, max-min fairness is said to be achieved by an allocation if and only if the allocation is feasible and an attempt to increase the allocation of any participant necessarily results in the decrease in the allocation of some other participant with an equal or smaller allocation.\nIn best-effort statistical multiplexing, a first-come first-served (FCFS) scheduling policy is often used. The advantage with max-min fairness over FCFS is that it results in traffic shaping, meaning that an ill-behaved flow, consisting of large data packets or bursts of many packets, will only punish itself and not other flows. Network congestion is consequently to some extent avoided.\nFair queuing is an example of a max-min fair packet scheduling algorithm for statistical multiplexing and best effort packet-switched networks, since it gives scheduling priority to users that have achieved lowest data rate since they became active. In case of equally sized data packets, round-robin scheduling is max-min fair.","alt_names":["- Max-min fair :","- Max-min fairness :","Max min fairness","Max min fairness Wikipedia the free encyclopedia","Max min fairness Wikipedia the free encyclopedia - result","Max min fairness Wikipedia, the free ...","Max-Min Fairness","Max-min fair","Max-min fair scheduling","Max-min fair; it is used under the","Max-min fairness","Max-min fairness - Wikipedia, the free encyclopedia","Max-min fairness - Wikipedia, the free encyclopedia ...","Max-min fairness @ Wikipedia","Max-min_fair","Maxmin fairness","The advantage with max-min fairness over FCFS","Wikipedia article Max-min fair","Wikipedia article Max-min fair scheduling","Wikipedia article Max-min fairness","Wikipedia article on Max-min fair","Wikipedia entry for Max-min fairness","en.wikipedia.org/wiki/Max-min_fairness","http://en.wikipedia.org/wiki/Max-min_fai","http://en.wikipedia.org/wiki/Max-min_fair","http://en.wikipedia.org/wiki/Max-min_fairness","max-","max-min","max-min fair","max-min fair allocation","max-min fairness"],"name":"Max-min fairness","categories":["Network scheduling algorithms","Routing algorithms","Wikipedia articles needing clarification from November 2012"],"tag_line":"In communication networks, multiplexing and the division of scarce resources, max-min fairness is said to be achieved by an allocation if and only if the allocation is feasible and an attempt to increase the allocation of any participant necessarily results in the decrease in the allocation of some other participant with an equal or smaller allocation."}}
,{"_index":"throwtable","_type":"algorithm","_id":"karn's-algorithm","_score":0,"_source":{"description":"Karn's algorithm addresses the problem of getting accurate estimates of the round-trip time for messages when using the Transmission Control Protocol (TCP) in computer networking. The algorithm was proposed by Phil Karn in 1987.\nAccurate round trip estimates in TCP can be difficult to calculate because of an ambiguity created by retransmitted segments. The round trip time is estimated as the difference between the time that a segment was sent and the time that its acknowledgment was returned to the sender, but when packets are re-transmitted there is an ambiguity: the acknowledgment may be a response to the first transmission of the segment or to a subsequent re-transmission.\nKarn's Algorithm ignores retransmitted segments when updating the round trip time estimate. Round trip time estimation is based only on unambiguous acknowledgments, which are acknowledgments for segments that were sent only once.\nThis simplistic implementation of Karn's algorithm can lead to problems as well. Consider what happens when TCP sends a segment after a sharp increase in delay. Using the prior round trip time estimate, TCP computes a timeout and retransmits a segment. If TCP ignores the round trip time of all retransmitted packets, the round trip estimate will never be updated, and TCP will continue retransmitting every segment, never adjusting to the increased delay.\nA solution to this problem is to incorporate transmission timeouts with a timer backoff strategy. The timer backoff strategy computes an initial timeout. If the timer expires and causes a retransmission, TCP increases the timeout generally by a factor of 2. This algorithm has proven to be extremely effective in networks with high packet loss.","alt_names":[],"name":"Karn's algorithm","categories":["Networking algorithms","Transmission Control Protocol","Wikipedia articles needing page number citations from March 2015"],"tag_line":"Karn's algorithm addresses the problem of getting accurate estimates of the round-trip time for messages when using the Transmission Control Protocol (TCP) in computer networking."}}
,{"_index":"throwtable","_type":"algorithm","_id":"network-scheduler","_score":0,"_source":{"description":"On a node in packet switching communication network, a network scheduler, also called packet scheduler, is an arbiter program that manages the sequence of network packets in the transmit and receive queues of the network interface controller, which is a circular data buffer. There are several network schedulers available for the different operating system kernels, that implement many of the existing network scheduling algorithms.\nThe network scheduler logic decides, in a way similar to statistical multiplexers, which network packet to forward next from the buffer. The buffer works as a queuing system, storing the network packets temporarily until they are transmitted. The buffer space may be divided into different queues, with each of them holding the packets of one flow according to configured packet classification rules; for example, packets can be divided into flows by their source and destination IP addresses. Network scheduling algorithms and their associated settings determine how the network scheduler manages the buffer.\nAlso, network schedulers are enabling accomplishment of the active queue management and traffic shaping.","alt_names":[],"name":"Network scheduler","categories":["All articles with unsourced statements","All pages needing cleanup","Articles needing cleanup from September 2014","Articles with sections that need to be turned into prose from September 2014","Articles with unsourced statements from September 2014","Linux kernel features","Network performance","Network scheduling algorithms","Network theory","Wikipedia articles needing clarification from June 2014"],"tag_line":"On a node in packet switching communication network, a network scheduler, also called packet scheduler, is an arbiter program that manages the sequence of network packets in the transmit and receive queues of the network interface controller, which is a circular data buffer."}}
,{"_index":"throwtable","_type":"algorithm","_id":"proportionally-fair","_score":0,"_source":{"description":"Proportional fair is a compromise-based scheduling algorithm. It is based upon maintaining a balance between two competing interests: Trying to maximize total [wired/wireless network] throughput while at the same time allowing all users at least a minimal level of service. This is done by assigning each data flow a data rate or a scheduling priority (depending on the implementation) that is inversely proportional to its anticipated resource consumption.","alt_names":["- Proportional fairness :","Proportional fair","Proportional fairness","Proportionally Fair","Proportionally fair","Proportionally fair - Wikipedia, the free encyclopedia","Proportionally fair scheduling","Proportionally fair; it is used under the","Wikipedia (Proportionally fair)","Wikipedia article Proportional fair","Wikipedia article Proportional fairness","Wikipedia article Proportionally fair","Wikipedia article on Proportional fairness","Wikipedia article on Proportionally fair","Wikipedia entry for Proportionally fair","feria proporcional","http://en.wikipedia.org/wiki/Proportional_fairness","http://en.wikipedia.org/wiki/Proportionally_fair","proportional fair","proportional fair allocation","proportional fairness","proportionally fair","proportionally fair - Wikipedia, the free encyclopedia"],"name":"Proportionally fair","categories":["Mobile telecommunications","Network scheduling algorithms","Pages containing cite templates with deprecated parameters","Pages using citations with accessdate and no URL","Radio resource management","Use dmy dates from September 2010","Use dmy dates from September 2013","Wireless"],"tag_line":"Proportional fair is a compromise-based scheduling algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"least-frequently-used","_score":0,"_source":{"description":"Least Frequently Used (LFU) is a type of cache algorithm used to manage memory within a computer. The standard characteristics of this method involve the system keeping track of the number of times a block is referenced in memory. When the cache is full and requires more room the system will purge the item with the lowest reference frequency.\nLFU is sometimes combined with a Least Recently Used algorithm and called LRFU.","alt_names":["...mehr auf Wikipedia über Least frequently used","LFU cache","LFU-Aging","Least Frequently Used","Least Frequently Used; it is used under the","Least frequently used","Least frequently used - Wikipedia","Least frequently used - Wikipedia, the free encyclopedia","Least frequently used ? Wikipedia","Least frequently used Wikipedia the free encyclopedia","Least frequently used cache algorithm","Least frequently used cache algorithm.","Least frequently used – Wikipedia","Least_frequently_used","Least_frequently_used bei der wikipedia","What variations does Least Frequently Used have","Wikipedia article Least Frequently Used","Wikipedia article Least frequently used","Wikipedia article on Least Frequently Used","Wikipedia entry for Least frequently used","Wikipedia-Artikel Least frequently used","Wikipedia-Seite zu 'Least frequently used'","de.wikipedia.org/wiki/Least_frequentl...","http://de.wikipedia.org/wiki/Least_frequ","http://de.wikipedia.org/wiki/Least_frequently_used","http://en.wikipedia.org/wiki/Least_Frequently_Used","http://en.wikipedia.org/wiki/Least_frequently_used","least frequently used"],"name":"Least frequently used","categories":["Memory management algorithms","Online algorithms","Use dmy dates from August 2012","Virtual memory"],"tag_line":"Least Frequently Used (LFU) is a type of cache algorithm used to manage memory within a computer."}}
,{"_index":"throwtable","_type":"algorithm","_id":"geographic-routing","_score":0,"_source":{"description":"Geographic routing (also called georouting or position-based routing) is a routing principle that relies on geographic position information. It is mainly proposed for wireless networks and based on the idea that the source sends a message to the geographic location of the destination instead of using the network address. The idea of using position information for routing was first proposed in the 1980s in the area of packet radio networks  and interconnection networks. Geographic routing requires that each node can determine its own location and that the source is aware of the location of the destination. With this information a message can be routed to the destination without knowledge of the network topology or a prior route discovery.\nThere are various approaches, such as single-path, multi-path and flooding-based strategies (see  for a survey). Most single-path strategies rely on two techniques: greedy forwarding and face routing. Greedy forwarding tries to bring the message closer to the destination in each step using only local information. Thus, each node forwards the message to the neighbor that is most suitable from a local point of view. The most suitable neighbor can be the one who minimizes the distance to the destination in each step (Greedy). Alternatively, one can consider another notion of progress, namely the projected distance on the source-destination-line (MFR, NFP), or the minimum angle between neighbor and destination (Compass Routing). Not all of these strategies are loop-free, i.e. a message can circulate among nodes in a certain constellation. It is known that the basic greedy strategy and MFR are loop free, while NFP and Compass Routing are not .\n\nGreedy forwarding can lead into a dead end, where there is no neighbor closer to the destination. Then, face routing helps to recover from that situation and find a path to another node, where greedy forwarding can be resumed. A recovery strategy such as face routing is necessary to assure that a message can be delivered to the destination. The combination of greedy forwarding and face routing was first proposed in 1999 under the name GFG (Greedy-Face-Greedy). It guarantees delivery in the so-called unit disk graph network model. Various variants, which were proposed later  , also for non-unit disk graphs, are based on the principles of GFG .\nAlthough originally developed as a routing scheme that uses the physical positions of each node, geographic routing algorithms have also been applied to networks in which each node is associated with a point in a virtual space, unrelated to its physical position. The process of finding a set of virtual positions for the nodes of a network such that geographic routing using these positions is guaranteed to succeed is called greedy embedding.\n^ Takagi, H.; Kleinrock, L. (March 1984). \"Optimal transmission ranges for randomly distributed packet radio terminals\". IEEE Transactions on Communications 32 (3): 246–257. doi:10.1109/TCOM.1984.1096061. \n^ Finn, Gregory G. (March 1987). \"Routing and Addressing Problems in Large Metropolitan-Scale Internetworks\" (PDF). University of Southern California, ISI/RR-87-180. \n^ Stojmenovic, Ivan (2002). \"Position based routing in ad hoc networks\". IEEE Communications Magazine 40 (7): 128–134. doi:10.1109/MCOM.2002.1018018. \n^ Stojmenovic, Ivan; Lin, Xu (2001). \"Loop-free hybrid single-path/flooding routing algorithms with guaranteed delivery for wireless networks\". IEEE Transactions on Parallel and Distributed Systems 12 (10): 1023–1032. doi:10.1109/71.963415. \n^ Bose, P.; Morin, P.; Stojmenovic, I.; Urrutia, J. (1999). \"Routing with guaranteed delivery in ad hoc wireless networks\". Proc. of the 3rd international workshop on discrete algorithms and methods for mobile computing and communications (DIALM '99). pp. 48–55. doi:10.1145/313239.313282.  \n^ Djenouri, Djamel; Balasingham, Ilangko (2011). \"Traffic-Differentiation-Based Modular QoS Localized Routing for Wireless Sensor Networks\". IEEE Transactions on Mobile Computing 10 (06): 797–809. doi:10.1109/TMC.2010.212. \n^ Ruehrup, Stefan (2009). \"Theory and Practice of Geographic Routing\". In Liu, Chu, Leung. (PDF). Ad Hoc and Sensor Wireless Networks: Architectures, Algorithms and Protocols. Bentham Science http://archive.cone.informatik.uni-freiburg.de/people/ruehrup/georouting-chapter-draft.pdf.  \n^ Rao, Ananth; Ratnasamy, Sylvia; Papadimitriou, Christos H.; Shenker, Scott; Stoica, Ion (2003), \"Geographic routing without location information\", Proc. 9th ACM Mobile Computing and Networking (MobiCom), pp. 96–108 .","alt_names":["- Geographic routing :","Geographic Routing","Geographic routing","Geographic routing - Wikipedia, the free encyclopedia","Geographic routing - Wikipedia, the free encyclopedia wikipedia.org","Geographic routing Wikipedia the free encyclopedia","Geographic_routing","Position based routing","Position-based routing","Wikipedia article Geographic routing","Wikipedia article Position-based routing","Wikipedia article on Position-based routing","Wikipedia entry for Geographic routing","en:Geographic routing","geographic routing","greedy forward","http://en.wikipedia.org/wiki/Geographic_routing","position-based routing"],"name":"Geographic routing","categories":["All stub articles","Computer network stubs","Pages containing cite templates with deprecated parameters","Pages with citations having bare URLs","Pages with citations lacking titles","Routing algorithms","Routing protocols","Wireless networking"],"tag_line":"Geographic routing (also called georouting or position-based routing) is a routing principle that relies on geographic position information."}}
,{"_index":"throwtable","_type":"algorithm","_id":"metropolis-light-transport","_score":0,"_source":{"description":"The Metropolis light transport (MLT) is an application of a variant of the Monte Carlo method called the Metropolis-Hastings algorithm to the rendering equation for generating images from detailed physical descriptions of three-dimensional scenes.\nThe procedure constructs paths from the eye to a light source using bidirectional path tracing, then constructs slight modifications to the path. Some careful statistical calculation (the Metropolis algorithm) is used to compute the appropriate distribution of brightness over the image. This procedure has the advantage, relative to bidirectional path tracing, that once a path has been found from light to eye, the algorithm can then explore nearby paths; thus difficult-to-find light paths can be explored more thoroughly with the same number of simulated photons. In short, the algorithm generates a path and stores the path's 'nodes' in a list. It can then modify the path by adding extra nodes and creating a new light path. While creating this new path, the algorithm decides how many new 'nodes' to add and whether or not these new nodes will actually create a new path.\nMetropolis Light Transport is an unbiased method that, in some cases (but not always), converges to a solution of the rendering equation faster than other unbiased algorithms such as path tracing or bidirectional path tracing.\n\n","alt_names":["-> Read the article about 'Metropolis light transport'","...more on Wikipedia about Metropolis light transport","MLT (Metropolis Light Transport)","Metropolis Light Transport","Metropolis Light Transport (MLT)","Metropolis light transport","Metropolis light transport - Wikipedia, the free encyclopedia","Metropolis light transport - Wikipedia, the free encyclopedia ...","Metropolis light transport en la wikipedia","Metropolis-Light- Transport-Algorithmus","Metropolis_light_transport","Source Wikipedia.org Arcticle - Metropolis light transport","Wikipedia (Metropolis light transport)","Wikipedia article Metropolis light transport","Wikipedia article about Metropolis light transport","Wikipedia entry for Metropolis light transport","en:Metropolis light transport","http://en.Liarpedia.org/wiki/Metropolis_light_transport","http://en.wikipedia.org/wiki/Metropolis_light_transport","metropolis light transport","phương pháp truyền tải ánh sáng Metropolis"],"name":"Metropolis light transport","categories":["All articles lacking in-text citations","All articles with unsourced statements","All stub articles","Articles lacking in-text citations from February 2014","Articles with unsourced statements from July 2010","Computing stubs","Global illumination algorithms","Monte Carlo methods"],"tag_line":"The Metropolis light transport (MLT) is an application of a variant of the Monte Carlo method called the Metropolis-Hastings algorithm to the rendering equation for generating images from detailed physical descriptions of three-dimensional scenes."}}
,{"_index":"throwtable","_type":"algorithm","_id":"successive-linear-programming","_score":0,"_source":{"description":"Successive Linear Programming (SLP), also known as Sequential Linear Programming, is an optimization technique for approximately solving nonlinear optimization problems.\nStarting at some estimate of the optimal solution, the method is based on solving a sequence of first-order approximations (i.e. linearizations) of the model. The linearizations are linear programming problems, which can be solved efficiently. As the linearizations need not be bounded, trust regions or similar techniques are needed to ensure convergence in theory. \nSLP has been used widely in the petrochemical industry since the 1970s.\n^ Nocedal, Jorge; Wright J., Stephen (October 1999), \"Numerical Optimization\", Springer Series in Operations Research  Chapter 15.1, Categorizing Optimization Algorithms\n^ Bazaraa, Mokhtar S.; Sheraly, Hanif D.; Shetty, C.M. (1993), Nonlinear Programming, Theory and Applications (2nd ed.), John Wiley & Sons, p. 432, ISBN 0-471-55793-5 .\n^ Palacios-Gomez, F.; Lasdon, L.; Enquist, M. (October 1982), \"Nonlinear Optimization by Successive Linear Programming\", Management Science 28 (10), doi:10.1287/mnsc.28.10.1106","alt_names":["Sequential linear programming","Successive Linear Programming","Successive linear programming","Successive linear programming - Wikipedia, the free ...","Successive linear programming - Wikipedia, the free encyclopedia","Successive linear programming - Wikipedia, the free encyclopedia ...","Successive_linear_programming","Wikipedia (Successive linear programming)","Wikipedia article Sequential linear programming","Wikipedia article Successive Linear Programming","Wikipedia entry for Successive linear programming","http://en.wikipedia.org/wiki/Successive_linear_programming","sequential programs","successive linear programming"],"name":"Successive linear programming","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Mathematical optimization"],"tag_line":"Successive Linear Programming (SLP), also known as Sequential Linear Programming, is an optimization technique for approximately solving nonlinear optimization problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"odds-algorithm","_score":0,"_source":{"description":"The odds-algorithm is a mathematical method for computing optimal strategies for a class of problems that belong to the domain of optimal stopping problems. Their solution follows from the odds-strategy, and the importance of the odds-strategy lies in its optimality, as explained below. This was used to devise betting strategies called martingales.\nThe odds-algorithm applies to a class of problems called last-success-problems. Formally, the objective in these problems is to maximize the probability of identifying in a sequence of sequentially observed independent events the last event satisfying a specific criterion (a \"specific event\"). This identification must be done at the time of observation. No revisiting of preceding observations is permitted. Usually, a specific event is defined by the decision maker as an event that is of true interest in the view of \"stopping\" to take a well-defined action. Such problems are encountered in several situations.","alt_names":["- Odds algorithm :","6285f81adb9b968c52d5123350947 ...","Learn about Odds algorithm>>>","Odd's algorithm","Odds Algorithm","Odds algorithm","Odds algorithm - Wikipedia :: The free encyclopedia","Odds algorithm - Wikipedia, the free encyclopedia","Odds algorithm), and then quantified methods may play","Odds algorithm; it is used under the","Odds_algorithm","Odds算法","What are the definitions of Odds algorithm","Wikipedia article Odd's algorithm","Wikipedia article Odds algorithm","Wikipedia entry for Odds algorithm","Wikipedia:Odds algorithm","en.wikipedia.org/...Odds_algorithm","en:Odds algorithm","http://en.wikipedia.org/wiki/Odds_algorithm","odds algorithm","yago-res:Odds algorithm","“Odds algorithm - Wikipedia, the free encyclopedia”, en.wikipedia"],"name":"Odds algorithm","categories":["Mathematical optimization","Optimal decisions","Statistical algorithms"],"tag_line":"The odds-algorithm is a mathematical method for computing optimal strategies for a class of problems that belong to the domain of optimal stopping problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"flooding-(computer-networking)","_score":0,"_source":{"description":"Flooding is a simple computer network routing algorithm in which every incoming packet is sent through every outgoing link except the one it arrived on.\nFlooding is used in bridging and in systems such as Usenet and peer-to-peer file sharing and as part of some routing protocols, including OSPF, DVMRP, and those used in ad-hoc wireless networks.\n^ A. Tanenbaum; D. Wetherall (23 March 2010). Computer Networks, 5th Edition. Pearson. p. 368-370. ISBN 978-0-13-212695-3. \n^ A. Rahman, W. Olesinski and P. Gburzynski. \"Controlled Flooding in Wireless Ad-hoc Networks\" (PDF). senserf.com. Retrieved 2015-10-15.","alt_names":["packet flooding","Flooding (computer networking)","Flooding (computer networking) - Wikipedia, the free encyclopedia","Flooding (computer networking) - Wikipedia, the free encyclopedia ...","Flooding (computer networking); it is used under the","Flooding (routing)","Flooding computer networking","Flooding_(computer_networking)","What are advantages of Flooding?","Wikipedia article Flooding (computer networking)","Wikipedia entry for Flooding (computer networking)","en.wikipedia.org/...Flooding_(computer_networking)","flood is a type of exploit","http://en.wikipedia.org/wiki/Flooding_(computer_networking)","packet flood","yago-res:Flooding_(computer_networking)"],"name":"Flooding (computer networking)","categories":["All articles needing additional references","All articles with unsourced statements","Articles needing additional references from October 2015","Articles with unsourced statements from January 2012","Routing algorithms"],"tag_line":"Flooding is a simple computer network routing algorithm in which every incoming packet is sent through every outgoing link except the one it arrived on."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ternary-search","_score":0,"_source":{"description":"A ternary search algorithm is a technique in computer science for finding the minimum or maximum of a unimodal function. A ternary search determines either that the minimum or maximum cannot be in the first third of the domain or that it cannot be in the last third of the domain, then repeats on the remaining two-thirds. A ternary search is an example of a divide and conquer algorithm (see search algorithm).","alt_names":["5Fsearch http://en.wikipedia.org/wiki/Ternary%","5Fsearch% http://en.wikipedia.org/wiki/Ternary","Ternary Search","Ternary Search(터너리 서치)","Ternary search","Ternary search - Wikipedia, the free encyclopedia","Ternary_search","Trinary search","Wikipedia article Ternary search","Wikipedia article Ternary_search","Wikipedia article Trinary search","Wikipedia article about Ternary search","Wikipedia article on Ternary search","Wikipedia article Троичный поиск","Wikipedia entry for Ternary search","cautare ternara","http://en.Liarpedia.org/wiki/Ternary_search","http://en.wikipedia.org/wiki/Ternary 5Fsearch%","http://en.wikipedia.org/wiki/Ternary% 5Fsearch","http://en.wikipedia.org/wiki/Ternary%5Fsearch","http://en.wikipedia.org/wiki/Ternary_sea","http://en.wikipedia.org/wiki/Ternary_search","http://en.wikipedia.org/wiki/Ternary％5Fsearch","http://en.wikipedia.org/wiki/Ternary％の5Fsearch","ternary search","ternary search.","ternary searches","yago-res:Ternary search","Википедии статью Троичный поиск","Троичный поиск","Троичный поиск на Википедии","터너리서치"],"name":"Ternary search","categories":["All articles lacking sources","Articles lacking sources from May 2007","Mathematical optimization","Search algorithms"],"tag_line":"A ternary search algorithm is a technique in computer science for finding the minimum or maximum of a unimodal function."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lehmer's-gcd-algorithm","_score":0,"_source":{"description":"Lehmer's GCD algorithm, named after Derrick Henry Lehmer, is a fast GCD algorithm, an improvement on the simpler but slower Euclidean algorithm. It is mainly used for big integers that have a representation as a string of digits relative to some chosen numeral system base, say β = 1000 or β = 232.\n\n","alt_names":["Lehmer's GCD algorithm","A B x C D y","Lehmer&#39;s GCD algorithm - Wikipedia, the free","Lehmer's","Lehmer's GCD algorithm - Wikipedia :: The free encyclopedia","Wikipedia article Lehmer GCD algorithm","Wikipedia article Lehmer's GCD algorithm","Wikipedia article Lehmer's algorithm","en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm","http://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm"],"name":"Lehmer's GCD algorithm","categories":["Number theoretic algorithms"],"tag_line":"Lehmer's GCD algorithm, named after Derrick Henry Lehmer, is a fast GCD algorithm, an improvement on the simpler but slower Euclidean algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cornacchia's-algorithm","_score":0,"_source":{"description":"In computational number theory, Cornacchia's algorithm is an algorithm for solving the Diophantine equation , where  and d and m are coprime. The algorithm was described in 1908 by Giuseppe Cornacchia.","alt_names":["Cornacchia's algorithm","- Cornacchia's algorithm :","Cornacchia's algorithm - Wikipedia, the free encyclopedia","Cornacchia's algorithm -...","cf6cd7c67029bca5df96e749c3c9 ...","http://en.wikipedia.org/wiki/Cornacchia %27s_algorithm","http://en.wikipedia.org/wiki/Cornacchia%27s_algorithm","http://en.wikipedia.org/wiki/Cornacchia's_algorithm"],"name":"Cornacchia's algorithm","categories":["Number theoretic algorithms"],"tag_line":"In computational number theory, Cornacchia's algorithm is an algorithm for solving the Diophantine equation , where  and d and m are coprime."}}
,{"_index":"throwtable","_type":"algorithm","_id":"root-finding-algorithm","_score":0,"_source":{"description":"A root-finding algorithm is a numerical method, or algorithm, for finding a value x such that f(x) = 0, for a given function f. Such an x is called a root of the function f.\nThis article is concerned with finding scalar, real or complex roots, approximated as floating point numbers. Finding integer roots or exact algebraic roots are separate problems, whose algorithms have little in common with those discussed here. (See: Diophantine equation for integer roots)\nFinding a root of f(x) − g(x) = 0 is the same as solving the equation f(x) = g(x). Here, x is called the unknown in the equation. Conversely, any equation can take the canonical form f(x) = 0, so equation solving is the same thing as computing (or finding) a root of a function.\nNumerical root-finding methods use iteration, producing a sequence of numbers that hopefully converge towards a limit, which is a root. The first values of this series are initial guesses. Many methods computes subsequent values by evaluating an auxiliary function on the preceding values. The limit is thus a fixed point of the auxiliary function, which is chosen for having the roots of the original equation as fixed points.\nThe behaviour of root-finding algorithms is studied in numerical analysis. Algorithms perform best when they take advantage of known characteristics of the given function. Thus an algorithm to find isolated real roots of a low-degree polynomial in one variable may bear little resemblance to an algorithm for complex roots of a \"black-box\" function which is not even known to be differentiable. Questions include ability to separate close roots, robustness against failures of continuity and differentiability, reliability despite inevitable numerical errors, and rate of convergence.","alt_names":["Finding roots","- Root finding :","- Root-finding algorithm :","-> Read the article about 'Root-finding algorithm'","...Wikipedia Algorithme de recherche d'un zéro d","...Wikipedia Metodi di approssimazione per la soluzione di","...more on Wikipedia about Root-finding algorithm","1 Specific algorithms","2 Finding roots of polynomials","3 Finding multiple roots of polynomials","3.1 Algorithm","3.3 Direct algorithm for multiple root elimination","Algorithme de recherche d'un z?ro d","Algorithme de recherche d'un zéro d'une","Algoritmo de búsqueda de raíces","Búsqueda de raíces","Calcolo di uno zero di una funzione","Finding multiple ...","Finding multiple roots","Finding multiple roots of polynomials","Finding roots of ...","Finding roots of polynomials","Forschung folgenden","Kök bulma algoritmaları","Kök bulma algoritması","ROOT FINDING ALGORITHM","Recherche des zéros d'une fonction","Resoluci?n num?rica de ecuaciones no lineales","Resolucin numrica de ecuaciones no lineales - Wikipedia, la","Resolución numérica de ecuaciones no lineales","Resolución numérica de ecuaciones no lineales - Wikipedia, la","Root Finding","Root Finding Algorithm","Root Finding Algorithms","Root Finding on Wikipedia","Root finding","Root finding algorithm","Root finding algorithm Wikipedia the free encyclopedia","Root finding algorithm Wikipedia the free encyclopedia - result","Root finding; it is used under the","Root-Finding Algorithms","Root-finding","Root-finding algorithm","Root-finding algorithm - Wikipedia :: The free encyclopedia","Root-finding algorithm - Wikipedia, the free encycloped...","Root-finding algorithm - Wikipedia, the free encyclopedia","Root-finding algorithm - Wikipedia, the free encyclopedia ...","Root-finding algorithm - Wikipedia, the free encyclopedia wikipedia","Root-finding algorithm from Wikipedia","Root-finding algorithm; it is used under the","Root-finding algorithms","Root-finding algorithms(翻译成开方法我认为不妥，应叫做寻根法)","Root-finding method","Root-finding_algorithm","Root-seeking Algorithmus","Rootfinding algorithm Wikipedia the free encyclopedia","Specific algorithms","Vikipedi'deki Kök-bulma Algoritması","WIKIPEDIA: ROOT FINDING ALGORITHM","Wikipedia (Root finding)","Wikipedia - Root-finding algorithm","Wikipedia Resolución numérica de ecuaciones no lineales","Wikipedia article Algorithme de recherche d'un zéro","Wikipedia article Resolución numérica de ecuaciones no lineales","Wikipedia article Root finding","Wikipedia article Root-finding algorithm","Wikipedia article on Algoritmo de búsqueda de raíces","Wikipedia article on Root finding","Wikipedia article मूल निकालने की विधियाँ","Wikipedia article 勘根定理","Wikipedia entry for Root-finding algorithm","Wikipedia hledání kořenů","Wikipedia on rootfinders","Wikipedia over root-finding algorithms","Wikipedia page on root-finding algorithms","Wikipedia rod finde","Wikipedia root finding","Wikipedia root vinden","Wikipedia: Root-finding algorithm","Wikipedia:Metodi_di_approssimazione_per_la_soluzione_di_equazioni","Wurzel-Finding","Zéros de fonctions non linéaires","a bisection method, the secant method","a root finding algorithm","a root-finding algorith","a root-finding algorithm","akar-menemukan","algorithme de recherche d'un zéro d'une","algorithme de recherche de racines","algorithme de recherche de racines,","algoritma menemukan akar","algoritmo de búsqueda de la raíz","algoritmo de búsqueda de raíces","algoritmo de raiz descoberta,","algoritmo di ricerca di radici","algoritmo di ricerca di root","alternative root-finding algorithm","approximation for the roots of a polynomial","approximation of the roots","artículo de Wikipedia Algoritmo de búsqueda de raíces","artículo de Wikipedia Resolución numérica de ecuaciones no","búsqueda de raíces","calcolare uno zero della funzione","de búsqueda de raíces","de búsqueda de raíces Wikipedia","de investigação seguintes","de recherche d'un zéro d'une fonction","de recherche suivants","di ricerca seguente","en.wikipedia.org/...Root-finding_algorithm","en.wikipedia.org/wiki/Root-finding_algorithm","en.wikipedia.org/wiki/Root-finding_algorithm . (The aim","en.wikipedia.org/wiki/Root_finding","encontrar los ceros","encontrar-raiz","es.wikipedia.org/wiki/Resoluci%C3%B3n_num%C3","es:Resolución numérica de ecuaciones no lineales","find roots","finding roots","finding the root","hi:मूल निकालने की विधियाँ","http://en.wikipedia....nding_algorithm","http://en.wikipedia.org/wiki/Root-findin","http://en.wikipedia.org/wiki/Root-finding_alg...","http://en.wikipedia.org/wiki/Root-finding_algorithm","http://en.wikipedia.org/wiki/Root-finding_algorithm#Finding_roots_of_polynomials","http://en.wikipedia.org/wiki/Root-finding_algorithm#Specific_algorithms","http://en.wikipedia.org/wiki/Root-findin…","http://en.wikipedia.org/wiki/Root_finding","http://en.wikipedia.org/wiki/Rootfinding_algorithm","http://en.wikipedia.org/wiki/Root−finding_algorithm","http://en.wikipedia.org/wiki/Root−finding_algorithm w","http://en.wikipedia.org/wiki/Root−finding_algorithm#Finding_roots_of_polynomials","http://es.wikipedia.org/wiki/Resoluc...es_no_lineales","http://es.wikipedia.org/wiki/Resoluci%C3%B3n_num","http://fr.wikipedia.org/wiki/Algor [...] e_fonction","http://fr.wikipedia.org/wiki/Algori...7une_f onction","http://fr.wikipedia.org/wiki/Algorit...27une_fonction","http://fr.wikipedia.org/wiki/Algorithme ... e_fonction","http://fr.wikipedia.org/wiki/Algorithme_de_recherche_d%27un_z%C3","http://fr.wikipedia.org/wiki/Algorithme_de_recherche_d'un_z%C3","http://it.wikipedia.org/wiki/Calcolo_di_uno_zero_di_una_funzione","http://it.wikipedia.org/wiki/Metodi_...e_di_equazioni","ja:求根アルゴリズム","korzeni znalezienia","kořen-nalezení","l'article de Wikipédia Algorithme de recherche d","la racine d'enquête","metodi per una risoluzione approssimata","named root finding algorithm","newton method","numerical root-finding methods","numerical solution of nonlinear equations","polynomial root-finding numerics","raíz de investigación","recherche d'un zéro d'une fonction","recherche des zéros d'une équation polynomiale","resolución numérica de ecuaciones no lineales","resuelve numéricamente","robust algorithm","rod-finding","rod-søger algoritme","root finder","root finding","root finding algorithm","root finding algorithms","root poszukiwania algorytmu","root-Algorithmus zu finden,","root-finding","root-finding algorith","root-finding algorithm","root-finding algorithms","root-finding algortithms","root-finding method","root-seeking algorithm","root-trovare","rootfinder","rootfinding algorithm wikipedia the free encyclopedia","the root of an equation","thuật toán tìm gốc","tr:Kök bulma algoritması","trovare gli zeri","trovare radice Wikipedia","uk:Методи розв'язання нелінійних рівнянь","việc tìm kiếm-root","w:Root-finding algorithm","wikipedia:”Root-finding algorithm”","wortel-finding","zh:勘根定理","znalezienie root Wikipedia","» Root-finding algorithms 1","še cel kup drugih","Материал из Википедии корень нахождения","Методи розв'язання нелінійних рівнянь","исследования следующих","корневой ищет алгоритм","корневой поиска","корневую Алгоритм поиска","การหา - root","ราก หา ขั้น ตอน วิธี","、以下の研究","ウィキペディアのルートの発見は、","ウィキペディアの記事 求根アルゴリズム","ルート求めるアルゴリズムを","ルート発見","ルート発見の","勘根定理","求根","求根アルゴリズム","求根アルゴリズム - Wikipedia","求根アルゴリズム -wikipedia","求根算法","求根ｱﾙｺﾞﾘｽﾞﾑ-wikipedia","研究以下","維基百科的文章“ 勘根定理”","维基百科寻根","维基百科的文章“ 勘根定理”","루트 찾기"],"name":"Root-finding algorithm","categories":["Root-finding algorithms","Vague or ambiguous time from February 2014"],"tag_line":"A root-finding algorithm is a numerical method, or algorithm, for finding a value x such that f(x) = 0, for a given function f. Such an x is called a root of the function f.\nThis article is concerned with finding scalar, real or complex roots, approximated as floating point numbers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fast-inverse-square-root","_score":0,"_source":{"description":"Fast inverse square root (sometimes referred to as Fast InvSqrt() or by the hexadecimal constant 0x5f3759df) is a method of calculating x−½, the reciprocal (or multiplicative inverse) of a square root for a 32-bit floating point number in IEEE 754 floating point format. The algorithm was probably developed at Silicon Graphics in the early 1990s, and an implementation appeared in 1999 in the Quake III Arena source code, but the method did not appear on public forums such as Usenet until 2002 or 2003. (There is a discussion on the Chinese developer forum CSDN back in 2000) At the time, the primary advantage of the algorithm came from avoiding computationally expensive floating point operations in favor of integer operations. Inverse square roots are used to compute angles of incidence and reflection for lighting and shading in computer graphics.\nThe algorithm accepts a 32-bit floating point number as the input and stores a halved value for later use. Then, treating the bits representing the floating point number as a 32-bit integer, a logical shift right of one bit is performed and the result subtracted from the magic number 0x5f3759df. This is the first approximation of the inverse square root of the input. Treating the bits again as floating point it runs one iteration of Newton's method to return a more precise approximation. This computes an approximation of the inverse square root of a floating point number approximately four times faster than floating point division.\nThe algorithm was originally attributed to John Carmack, but an investigation showed that the code had deeper roots in both the hardware and software side of computer graphics. Adjustments and alterations passed through both Silicon Graphics and 3dfx Interactive, with Gary Tarolli's implementation for the SGI Indigo as the earliest known use. It is not known how the constant was originally derived, though investigation has shed some light on possible methods.","alt_names":["Fast inverse square root","fast inverse square root","'Quake III Magical Inverse Square Root Implementation'","'s Fast Кармак InvSqrt","0x5f3759df is fucking magic","0x5f375a86","300px-OpenArena-Rocket.jpg","A need for fast 3D computer graphics","Carmack Fast InvSqrt","Carmack Inverse Square Root code.","Carmack फास्ट InvSqrt","Carmack's Fast InvSqrt","Carmack's Inverse Sqrt()","Carmack's inverse","Carmack's inverse sqrt trick","Carmack's root","Carmackさん高速 InvSqrt","Fast Carmack InvSqrt","Fast InvSqrt()","Fast Inverse Square Root","Fast Inverse Square Root funtion","Fast Inverse Square root","Fast Inverse Square root method","Fast Inverse Squareroot","Fast invSqrt","Fast inverse sqrt","Fast inverse squ root Wikipedia the free encyclopedia","Fast inverse square","Fast inverse square root - Wikipedia, the fre...","Fast inverse square root - Wikipedia, the free ...","Fast inverse square root - Wikipedia, the free encyclopedia","Fast inverse square root Wikipedia the free encyclopedia","Fast inverse square root algorithm","Fast inverse square root on Wikipedia","Fast reciprocal square root","Fast sqrt","FastInvSqrt","Fast_inverse_square_root","Fast_inverse_square_root [Wikipedia]","Finding an inverse square root using black magic","Hacker News: Fast inverse square root","Here's a real world example","History and investigation","John Carmark's fast square root","MAGICAL SQUARE ROOTS!","Magiczny kod Johna Carmacka - funkcja 1/sqrt(x","Overview of the code","Q_rsqrt","Quake Fast Inverse Square Root","Quake algorithm","RuPedia:Быстрый_инверсный_квадратный_корень","The fast inverse square root (wikipedia)","Wikipedia entry for Fast inverse square root","Wikipedia has all the details.","Wikipedia page is a good start","Wikipedia: Fast inverse square root","Wikipedia:Fast inverse square root","a very readable article","approximate the sqrt function","bit-mangling voo-doo","carmac","continue reading http://en.wikipedia.org/wiki/Fast_inverse_square_root","de rápido Carmack InvSqrt","despite the history","di Carmack","en.wikipedia.org/...Fast_inverse_square_root","en.wikipedia.org/wiki/Fast_inverse_square_root","en:Fast inverse square root","en:fast inverse square root","famous inverse square root algorithm","fast InvSqrt() function","fast inverse square root algorithm","fast inverse square root code to compute angles","fast inverse square root function","fast inverse square root method","fast inverse square root routine","fast reciprocal square root","faster to compute an inverse square root","gåtfull","http://en.wikipedia....rse_square_root","http://en.wikipedia.org/wiki/0x5f375a86#History_and_investigation","http://en.wikipedia.org/wiki/F...quare_root","http://en.wikipedia.org/wiki/Fast_","http://en.wikipedia.org/wiki/Fast_i...","http://en.wikipedia.org/wiki/Fast_in...int_to_integer","http://en.wikipedia.org/wiki/Fast_invers...f_the_code","http://en.wikipedia.org/wiki/Fast_inverse_squ...","http://en.wikipedia.org/wiki/Fast_inverse_square_root","http://en.wikipedia.org/wiki/Fast_inverse_square_root#Histor...","http://en.wikipedia.org/wiki/Fast_inverse_square_root#History_and_investigation","http://en.wikipedia.org/wiki/Fast_inverse_square_root#Newton.27s_method","http://en.wikipedia.org/wiki/Fast_inverse_square_root#Overview_of_the_code","http://en.wikipedia.org/wiki/Fast_inverse_square_root#The_.22magic_number","http://en.wikipedia.org/wiki/F…..quare_root","http://en.wikipedia.org/wi​ki/Fast_inverse_square_roo​t","invented special number","inverse square root hack","inverse square root magic number","lighting in Quake 3 by Gary Tarolli","magical Quake III function","numero magico di Carmack","pure black magic","quake inverse square root","reciprocal square roots","solve problems that no one else can","still immensely confusing","the fast inverse square root function","the fast reciprocal-of-square-root code example","this jewel","unknown from SGI","unless you are John Carmack","you need to know what you're doing","Быстрый инверсный квадратный корень","Быстрый инверсный квадратный корень — Википедия","быстрым инверсным квадратным корнем","волшебную константу","его автор доподлинно неизвестен","особо извращенным методам","продуктовый код","फास्ट व्युत्क्रम स्क्वायर रूट","卡马克的快速 InvSqrt","快速平方根倒数算法"],"name":"Fast inverse square root","categories":["All articles with unsourced statements","Articles with unsourced statements from April 2012","Good articles","Quake (series)","Root-finding algorithms","Source code"],"tag_line":"Fast inverse square root (sometimes referred to as Fast InvSqrt() or by the hexadecimal constant 0x5f3759df) is a method of calculating x−½, the reciprocal (or multiplicative inverse) of a square root for a 32-bit floating point number in IEEE 754 floating point format."}}
,{"_index":"throwtable","_type":"algorithm","_id":"vegas-algorithm","_score":0,"_source":{"description":"The VEGAS algorithm, due to G. P. Lepage, is a method for reducing error in Monte Carlo simulations by using a known or approximate probability distribution function to concentrate the search in those areas of the integrand that make the greatest contribution to the final integral.\nThe VEGAS algorithm is based on importance sampling. It samples points from the probability distribution described by the function , so that the points are concentrated in the regions that make the largest contribution to the integral.\nIn general, if the Monte Carlo integral of  is sampled with points distributed according to a probability distribution described by the function , we obtain an estimate ,\n.\nThe variance of the new estimate is then\n\nwhere  is the variance of the original estimate, .\nIf the probability distribution is chosen as  then it can be shown that the variance  vanishes, and the error in the estimate will be zero. In practice it is not possible to sample from the exact distribution g for an arbitrary function, so importance sampling algorithms aim to produce efficient approximations to the desired distribution.\nThe VEGAS algorithm approximates the exact distribution by making a number of passes over the integration region while histogramming the function f. Each histogram is used to define a sampling distribution for the next pass. Asymptotically this procedure converges to the desired distribution. In order to avoid the number of histogram bins growing like  with dimension d the probability distribution is approximated by a separable function:  so that the number of bins required is only Kd. This is equivalent to locating the peaks of the function from the projections of the integrand onto the coordinate axes. The efficiency of VEGAS depends on the validity of this assumption. It is most efficient when the peaks of the integrand are well-localized. If an integrand can be rewritten in a form which is approximately separable this will increase the efficiency of integration with VEGAS.","alt_names":["- VEGAS algorithm :","...more on Wikipedia about VEGAS algorithm","E g ( f ; N ) = E ( f / g ; N","VEGAS a","VEGAS algorithm","VEGAS algorithm - Wikipedia :: The free encyclopedia","VEGAS algorithm - Wikipedia, the free encyclopedia","VEGAS algorithm; it is used under the","Vegas Algorithm","Wikipedia article ''VEGAS algorithm''","Wikipedia article VEGAS algorithm","Wikipedia article VEGAS_algorithm","Wikipedia entry for VEGAS algorithm","http://en.wikipedia.org/wiki/VEGAS_algor","http://en.wikipedia.org/wiki/VEGAS_algorithm","http://en.wikipedia.org/wiki/VEGAS_algorithm is o","yago-res:VEGAS algorithm"],"name":"VEGAS algorithm","categories":["Computational physics","Monte Carlo methods","Statistical algorithms","Variance reduction"],"tag_line":"The VEGAS algorithm, due to G. P. Lepage, is a method for reducing error in Monte Carlo simulations by using a known or approximate probability distribution function to concentrate the search in those areas of the integrand that make the greatest contribution to the final integral."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bairstow's-method","_score":0,"_source":{"description":"In numerical analysis, Bairstow's method is an efficient algorithm for finding the roots of a real polynomial of arbitrary degree. The algorithm first appeared in the appendix of the 1920 book \"Applied Aerodynamics\" by Leonard Bairstow. The algorithm finds the roots in complex conjugate pairs using only real arithmetic.\nSee root-finding algorithm for other algorithms.","alt_names":["Bairstow's method","Bairstow's method - Wikipedia, the free encyclopedia","...mehr auf Wikipedia über Bairstow-Verfahren","...more on Wikipedia about Bairstow's method","Bairstow 2","Bairstow's Method","Bairstow's Method. From Wikipedia, the free encyclopedia","Bairstow-Verfahren","Bairstow-Verfahren - Wikipedia","Bairstow-Verfahren – Wikipedia","M?todo de Bairstow - Wikipedia, la enciclopedia libre","Método de Bairstow","Método de Bairstow - Wikipedia, la enciclopedia libre","Referencia No.1","What is Bairstow method's example","What is the example of Bairstow method?","Wikipedia-Artikel Bairstow-Verfahren","artículo de Wikipedia Metodo de Bairstow","en.wikipedia.org/wiki/Bairstow%27s_method","en:Bairstow's method","http://de.wikipedia.org/wiki/Ba irstow-Verfahren","http://de.wikipedia.org/wiki/Bairstow-Ve","http://de.wikipedia.org/wiki/Bairstow-Verfahren","http://en.wikipedia.org/wiki/Bairstow%27s_method","http://en.wikipedia.org/wiki/Bairstow%27…","http://en.wikipedia.org/wiki/Bairstow's_method","http://en.wikipedia.org/wiki/Bairstow's_…","http://es.wikipedia.org/wiki/M%C3%A9todo_de_Bairstow","http://www.de.wikipedia.org/wiki/Bairstow-Verfahren","method of bairstow","metoda lui Bairstow","método de Bairstow","ベアストウ法"],"name":"Bairstow's method","categories":["Root-finding algorithms"],"tag_line":"In numerical analysis, Bairstow's method is an efficient algorithm for finding the roots of a real polynomial of arbitrary degree."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pantelides-algorithm","_score":0,"_source":{"description":"Pantelides algorithm gives a systematic method for reducing high-index systems of differential-algebraic equations to lower index, by selectively adding differentiated forms of the equations already present in the system. It is possible for the algorithm to fail in some instances.\nPantelides algorithm is implemented in several significant equation-based simulation programs such as gPROMS, Modelica and EMSO.","alt_names":["Pantelides algorithm","Pantelides algorithm - Wikipedia, the free encyclopedia","Pantelides algorithm by Wikipedia","Wikipedia article Pantelides algorithm","Wikipedia article about Pantelides algorithm","http://en.wikipedia.org/wiki/Pantelides_algorithm"],"name":"Pantelides algorithm","categories":["Algorithms and data structures stubs","All Wikipedia articles needing context","All articles covered by WikiProject Wikify","All articles with too few wikilinks","All pages needing cleanup","All stub articles","Articles covered by WikiProject Wikify from December 2015","Articles with too few wikilinks from December 2015","Computer science stubs","Numerical differential equations","Wikipedia articles needing context from August 2010","Wikipedia introduction cleanup from August 2010"],"tag_line":"Pantelides algorithm gives a systematic method for reducing high-index systems of differential-algebraic equations to lower index, by selectively adding differentiated forms of the equations already present in the system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"aberth-method","_score":0,"_source":{"description":"The Aberth method, or Aberth–Ehrlich method, named after Oliver Aberth and Louis W. Ehrlich, is a root-finding algorithm for simultaneous approximation of all the roots of a univariate polynomial.\nThe fundamental theorem of algebra states that for each polynomial with complex coefficients there are as many roots as the degree of the polynomial. This method converges cubically, an improvement over the Weierstrass–(Durand–Kerner) method, another numerical algorithm that approximates all roots at once, which converges quadratically. (However, both algorithms converge linearly at multiple zeros.)","alt_names":["Aberth","Aberth method","Aberth method - Wikipedia, the free encyclopedia","Aberth method Wikipedia the free encyclopedia","Aberth's method","Ehrlich-Aberth method","The Aberth-method","What is the description of Aberth method","Wikipedia article Aberth method","Wikipedia article about Aberth method","Wikipedia entry for Aberth method","e9dc4de46936b9640f3983bba38c76 ...","en.wikipedia.org/wiki/Aberth_method","en:Aberth method","http://en.wikipedia.org/wiki/Aberth_meth","http://en.wikipedia.org/wiki/Aberth_method","p ( x ) = p n x n + p n","yago-res:Aberth method"],"name":"Aberth method","categories":["Root-finding algorithms"],"tag_line":"The Aberth method, or Aberth–Ehrlich method, named after Oliver Aberth and Louis W. Ehrlich, is a root-finding algorithm for simultaneous approximation of all the roots of a univariate polynomial."}}
,{"_index":"throwtable","_type":"algorithm","_id":"block-lanczos-algorithm","_score":0,"_source":{"description":"In computer science, the block Lanczos algorithm is an algorithm for finding the nullspace of a matrix over a finite field, using only multiplication of the matrix by long, thin matrices. Such matrices are considered as vectors of tuples of finite-field entries, and so tend to be called 'vectors' in descriptions of the algorithm.\nThe block Lanczos algorithm is amongst the most efficient methods known for finding nullspaces, which is the final stage in integer factorization algorithms such as the quadratic sieve and number field sieve, and its development has been entirely driven by this application.","alt_names":[],"name":"Block Lanczos algorithm","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Linear algebra stubs","Numerical linear algebra"],"tag_line":"In computer science, the block Lanczos algorithm is an algorithm for finding the nullspace of a matrix over a finite field, using only multiplication of the matrix by long, thin matrices."}}
,{"_index":"throwtable","_type":"algorithm","_id":"nth-root-algorithm","_score":0,"_source":{"description":"The principal nth root  of a positive real number A, is the positive real solution of the equation\n\n(for integer n there are n distinct complex solutions to this equation if , but only one is positive and real).\nThere is a very fast-converging nth root algorithm for finding :\nMake an initial guess \nSet . In practice we do .\nRepeat step 2 until the desired precision is reached, i.e.  .\nA special case is the familiar square-root algorithm. By setting n = 2, the iteration rule in step 2 becomes the square root iteration rule:\n\nSeveral different derivations of this algorithm are possible. One derivation shows it is a special case of Newton's method (also called the Newton-Raphson method) for finding zeros of a function  beginning with an initial guess. Although Newton's method is iterative, meaning it approaches the solution through a series of increasingly accurate guesses, it converges very quickly. The rate of convergence is quadratic, meaning roughly that the number of bits of accuracy doubles on each iteration (so improving a guess from 1 bit to 64 bits of precision requires only 6 iterations). For this reason, this algorithm is often used in computers as a very fast method to calculate square roots.\nFor large n, the nth root algorithm is somewhat less efficient since it requires the computation of  at each step, but can be efficiently implemented with a good exponentiation algorithm.","alt_names":["-> Read the article about 'Nth root algorithm'","...Wikipedia Algorithme de calcul de la racine n","...more on Wikipedia about N-th root algorithm","3078170f7aedde3f7a90dcfb305c ...","Algorithme de calcul de la racine n-ième","Algorytm obliczania pierwiastka n-tego stopnia","Algorytm obliczania pierwiastka n-tego stopnia – Wikipedia ...","Algorytm obliczania pierwiastka n-tego stopnia – Wikipedia, wolna","Algorytm z Wikipedii","Algorytm_obliczania_pierwiastka_n-tego_stopnia","N-th root algorithm","N-th root algorithm - Wikipedia, the free encyclopedia","Newton's iterative convergence algorithm in Wikipedia","Nth Root Algorithm","Nth Root Algorithm.","Nth root - Rosetta Code","Nth root algorithm","Nth root algorithm - Wikipedia, the free encyclopedia","The n-th root algorithm","Wikipedia article N-th root algorithm","Wikipedia article Nth root algorithm","Wikipedia entry for Nth root algorithm","Wikipedia's entry for the nth root algorithm","[ n ] A","algoritmo de raíz enésima","c6c33a5650ff22b1d76b2584d63 ...","en viss algoritm","en.wikipedia.org/wiki/N-th_root_algorithm","en.wikipedia.org/wiki/Nth_root_algori...","en.wikipedia.org/wiki/Nth_root_algorithm","en:Nth root algorithm","fr:Algorithme de calcul de la racine n","http://en.Liarpedia.org/wiki/Nth_root_algorithm","http://en.wikipedia...._root_algorithm","http://en.wikipedia.org/wiki/N th_root_algorithm","http://en.wikipedia.org/wiki/N-th_root_algorithm","http://en.wikipedia.org/wiki/Nth_root_al","http://en.wikipedia.org/wiki/Nth_root_algorithm","http://en.wikipedia.org/wiki/Nth_root_algorithm~~V","http://en.wikipedia.org/wiki/Nth_root_al…","http://en.wikipedia.org/wiki/N−th_root_algorithm","http://fr.wikipedia.org/wiki/Algor [...] -i%C3","http://fr.wikipedia.org/wiki/Algorit...ne_n-i","http://fr.wikipedia.org/wiki/Algorithme_de_calcul_de_la_racine_n-i%C3","http://pl.wikipedia.org/w..._n-tego_stopnia","http://pl.wikipedia.org/wiki/A[...]nia_pierwiastka_n-tego_stopnia","http://pl.wikipedia.org/wiki/Algoryt...n-tego_stopnia","http://pl.wikipedia.org/wiki/Algorytm_o ... go_stopnia","http://pl.wikipedia.org/wiki/Algorytm_ob...go_stopnia","http://pl.wikipedia.org/wiki/Algorytm_obliczania_pierwiastka_n-tego_stopnia","n th root of a number","n'te rod algoritme","n-de wortel-algoritme","n-te Wurzel Algorithmus","n-tego algorytmu głównego","n-th root algorithm","n-tou root algoritmus","nth root algorithm","nth root algorithm - Wikipedia :: The free encyclopedia","nth root algorithm - Wikipedia, the free encyclopedia","nth root algorithm - Wikipedia, the free encyclopedia ...","nth root algorithm wikipedia the free encyclopedia","nth root algorthim","nth रूट एल्गोरिथ्म","nth_root_algorithm","pierwiastek n-tego stopnia","pl:Algorytm obliczania pierwiastka n-tego stopnia","straightforward iterative algorithm","takovýto","wikipedia article on the algorithm","wikipedia:N_th root algorithm.","го алгоритма корень","نيوتن للتقريب"],"name":"Nth root algorithm","categories":["Root-finding algorithms"],"tag_line":"The principal nth root  of a positive real number A, is the positive real solution of the equation\n\n(for integer n there are n distinct complex solutions to this equation if , but only one is positive and real)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"column-generation","_score":0,"_source":{"description":"Column generation or delayed column generation is an efficient algorithm for solving larger linear programs.\nThe overarching idea is that many linear programs are too large to consider all the variables explicitly. Since most of the variables will be non-basic and assume a value of zero in the optimal solution, only a subset of variables need to be considered in theory when solving the problem. Column generation leverages this idea to generate only the variables which have the potential to improve the objective function—that is, to find variables with negative reduced cost (assuming without loss of generality that the problem is a minimization problem).\nThe problem being solved is split into two problems: the master problem and the subproblem. The master problem is the original problem with only a subset of variables being considered. The subproblem is a new problem created to identify a new variable. The objective function of the subproblem is the reduced cost of the new variable with respect to the current dual variables, and the constraints require that the variable obey the naturally occurring constraints.\nThe process works as follows. The master problem is solved—from this solution, we are able to obtain dual prices for each of the constraints in the master problem. This information is then utilized in the objective function of the subproblem. The subproblem is solved. If the objective value of the subproblem is negative, a variable with negative reduced cost has been identified. This variable is then added to the master problem, and the master problem is re-solved. Re-solving the master problem will generate a new set of dual values, and the process is repeated until no negative reduced cost variables are identified. The subproblem returns a solution with non-negative reduced cost, we can conclude that the solution to the master problem is optimal.\nIn many cases, this allows large linear programs that had been previously considered intractable to be solved. The classical example of a problem where this is successfully used is the cutting stock problem. One particular technique in linear programming which uses this kind of approach is the Dantzig–Wolfe decomposition algorithm. Additionally, column generation has been applied to many problems such as crew scheduling, vehicle routing, and the capacitated p-median problem.","alt_names":[],"name":"Column generation","categories":["All stub articles","Applied mathematics stubs","Optimization algorithms and methods"],"tag_line":"Column generation or delayed column generation is an efficient algorithm for solving larger linear programs."}}
,{"_index":"throwtable","_type":"algorithm","_id":"broyden–fletcher–goldfarb–shanno-algorithm","_score":0,"_source":{"description":"In numerical optimization, the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm is an iterative method for solving unconstrained nonlinear optimization problems.\nThe BFGS method approximates Newton's method, a class of hill-climbing optimization techniques that seeks a stationary point of a (preferably twice continuously differentiable) function. For such problems, a necessary condition for optimality is that the gradient be zero. Newton's method and the BFGS methods are not guaranteed to converge unless the function has a quadratic Taylor expansion near an optimum. These methods use both the first and second derivatives of the function. However, BFGS has proven to have good performance even for non-smooth optimizations.\nIn quasi-Newton methods, the Hessian matrix of second derivatives doesn't need to be evaluated directly. Instead, the Hessian matrix is approximated using rank-one updates specified by gradient evaluations (or approximate gradient evaluations). Quasi-Newton methods are generalizations of the secant method to find the root of the first derivative for multidimensional problems. In multi-dimensional problems, the secant equation does not specify a unique solution, and quasi-Newton methods differ in how they constrain the solution. The BFGS method is one of the most popular members of this class. Also in common use is L-BFGS, which is a limited-memory version of BFGS that is particularly suited to problems with very large numbers of variables (e.g., >1000). The BFGS-B variant handles simple box constraints.","alt_names":[],"name":"Broyden–Fletcher–Goldfarb–Shanno algorithm","categories":["Optimization algorithms and methods"],"tag_line":"In numerical optimization, the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm is an iterative method for solving unconstrained nonlinear optimization problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"householder's-method","_score":0,"_source":{"description":"In mathematics, and more specifically in numerical analysis, Householder's methods are a class of root-finding algorithms that are used for functions of one real variable with continuous derivatives up to some order d+1. Each of these methods is characterized by the number d, which is known as the order of the method. The algorithm is iterative and has an rate of convergence of d+1.\nThese methods are named after the American mathematician Alston Scott Householder.\n\n","alt_names":["Householder's method","( 1 / f ) ' ( x ) = - f ' ( x ) f ( x ) 2","- Householder's method :","6f85ec5f8ba40098a08561b506e0e ...","HouseHolder","Householder method","Householder s methods","Householder%27s_method","Householder's Method","Householder's method - Wikipedia, the free ...","Householder's method - Wikipedia, the free encyclopedia","Householder's method from Wikipedia","Householder's methods","Householder-Verfahren","Householder-Verfahren - Wikipedia","Householder-Verfahren – Wikipedia","It?ration de Householder - Wikip?dia","Itération de Householder - Wikipédia","Méthode de Householder - Wikipédia","Wikipedia article Householder's method","Wikipedia sur Itération de Householder","Wikipedia sur Méthode de Householder","begin{array}{rl} x_{n+1} =& x_n","de:Householder-Verfahren","en.wikipedia.org/wiki/Householder's_method","http://de.wikipedia.org/wiki/Householder-Verfahren","http://en.wikipedia.org/wiki/Householder%27s_method","http://en.wikipedia.org/wiki/Householder's_method","http://fr.wikipedia.org/wiki/Itération_de_Householder","http://fr.wikipedia.org/wiki/M%C3%A9thode_de_Householder","itération de Householder","of Householder's method","x n + 1 = x n + d 1 / f"],"name":"Householder's method","categories":["All articles needing additional references","Articles needing additional references from November 2013","Root-finding algorithms"],"tag_line":"In mathematics, and more specifically in numerical analysis, Householder's methods are a class of root-finding algorithms that are used for functions of one real variable with continuous derivatives up to some order d+1."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ridders'-method","_score":0,"_source":{"description":"In numerical analysis, Ridders' method is a root-finding algorithm based on the false position method and the use of an exponential function to successively approximate a root of a function f. The method is due to C. Ridders.\nRidders' method is simpler than Muller's method or Brent's method but with similar performance. The formula below converges quadratically when the function is well-behaved, which implies that the number of additional significant digits found at each step approximately doubles; but the function has to be evaluated twice for each step, so the overall order of convergence of the method is √2. If the function is not well-behaved, the root remains bracketed and the length of the bracketing interval at least halves on each iteration, so convergence is guaranteed. The algorithm also makes use of square roots, which are slower than basic floating point operations.","alt_names":["Ridder's Step","Ridder's method","Ridders method","Ridders' Method","Ridders' method","Ridders' method - Wikipedia, the free encyclopedia","Ridderの方法","Wikipedia article Ridder's method","Wikipedia article Ridders' method","http://en.wikipedia.org/wiki/Ridders%27_method","http://en.wikipedia.org/wiki/Ridders'_method","http://en.wikipedia.org/wiki/Ridders'_me…","p ( x ) = A + B · e x p ( C"],"name":"Ridders' method","categories":["All stub articles","Applied mathematics stubs","Root-finding algorithms"],"tag_line":"In numerical analysis, Ridders' method is a root-finding algorithm based on the false position method and the use of an exponential function to successively approximate a root of a function f. The method is due to C. Ridders."}}
,{"_index":"throwtable","_type":"algorithm","_id":"adaptive-coordinate-descent","_score":0,"_source":{"description":"Adaptive coordinate descent is an extension of the coordinate descent algorithm to non-separable optimization. The adaptive coordinate descent approach gradually builds a transformation of the coordinate system such that the new coordinates are as decorrelated as possible with respect to the objective function. The adaptive coordinate descent was shown to be competitive to the state-of-the-art evolutionary algorithms and has the following invariance properties:\nInvariance with respect to monotonous transformations of the function (scaling)\nInvariance with respect to orthogonal transformations of the search space (rotation).\nCMA-like Adaptive Encoding Update (b) mostly based on principal component analysis (a) is used to extend the coordinate descent method (c) to the optimization of non-separable problems (d).\n\nThe adaptation of an appropriate coordinate system allows adaptive coordinate descent to outperform coordinate descent on non-separable functions. The following figure illustrates the convergence of both algorithms on 2-dimensional Rosenbrock function up to a target function value , starting from the initial point .\n\nThe adaptive coordinate descent method reaches the target value after only 325 function evaluations (about 70 times faster than coordinate descent), that is comparable to gradient-based methods. The algorithm has linear time complexity if update coordinate system every D iterations, it is also suitable for large-scale (D>>100) non-linear optimization.","alt_names":[],"name":"Adaptive coordinate descent","categories":["Optimization algorithms and methods"],"tag_line":"Adaptive coordinate descent is an extension of the coordinate descent algorithm to non-separable optimization."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cobyla","_score":0,"_source":{"description":"Constrained optimization by linear approximation (COBYLA) is a numerical optimization method for constrained problems where the derivative of the objective function is not known, invented by Michael J. D. Powell. That is, COBYLA can find the vector  with  that has the minimal (or maximal)  without knowing the gradient of . COBYLA is also the name of Powell's software implementation of the algorithm in Fortran.\nPowell invented COBYLA while working for Westland Helicopters.\nIt works by iteratively approximating the actual constrained optimization problem with linear programming problems. During an iteration, an approximating linear programming problem is solved to obtain a candidate for the optimal solution. The candidate solution is evaluated using the original objective and constraint functions, yielding a new data point in the optimization space. This information is used to improve the approximating linear programming problem used for the next iteration of the algorithm. When the solution cannot be improved anymore, the step size is reduced, refining the search. When the step size becomes sufficiently small, the algorithm finishes.\nThe COBYLA software is distributed under The GNU Lesser General Public License (LGPL).","alt_names":[],"name":"COBYLA","categories":["All stub articles","Applied mathematics stubs","Optimization algorithms and methods"],"tag_line":"Constrained optimization by linear approximation (COBYLA) is a numerical optimization method for constrained problems where the derivative of the objective function is not known, invented by Michael J. D. Powell."}}
,{"_index":"throwtable","_type":"algorithm","_id":"muller's-method","_score":0,"_source":{"description":"Muller's method is a root-finding algorithm, a numerical method for solving equations of the form f(x) = 0. It was first presented by David E. Muller in 1956.\nMuller's method is based on the secant method, which constructs at every iteration a line through two points on the graph of f. Instead, Muller's method uses three points, constructs the parabola through these three points, and takes the intersection of the x-axis with the parabola to be the next approximation.","alt_names":[],"name":"Muller's method","categories":["Root-finding algorithms"],"tag_line":"Muller's method is a root-finding algorithm, a numerical method for solving equations of the form f(x) = 0."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hill-climbing","_score":0,"_source":{"description":"In computer science, hill climbing is a mathematical optimization technique which belongs to the family of local search. It is an iterative algorithm that starts with an arbitrary solution to a problem, then attempts to find a better solution by incrementally changing a single element of the solution. If the change produces a better solution, an incremental change is made to the new solution, repeating until no further improvements can be found.\nFor example, hill climbing can be applied to the travelling salesman problem. It is easy to find an initial solution that visits all the cities but will be very poor compared to the optimal solution. The algorithm starts with such a solution and makes small improvements to it, such as switching the order in which two cities are visited. Eventually, a much shorter route is likely to be obtained.\nHill climbing is good for finding a local optimum (a solution that cannot be improved by considering a neighbouring configuration) but it is not necessarily guaranteed to find the best possible solution (the global optimum) out of all possible solutions (the search space). In convex problems, hill-climbing is optimal. Examples of algorithms that solve convex problems by hill-climbing include the simplex algorithm for linear programming and binary search.\nThe characteristic that only local optima are guaranteed can be cured by using restarts (repeated local search), or more complex schemes based on iterations, like iterated local search, on memory, like reactive search optimization and tabu search, or memory-less stochastic modifications, like simulated annealing.\nThe relative simplicity of the algorithm makes it a popular first choice amongst optimizing algorithms. It is used widely in artificial intelligence, for reaching a goal state from a starting node. Choice of next node and starting node can be varied to give a list of related algorithms. Although more advanced algorithms such as simulated annealing or tabu search may give better results, in some situations hill climbing works just as well. Hill climbing can often produce a better result than other algorithms when the amount of time available to perform a search is limited, such as with real-time systems. It is an anytime algorithm: it can return a valid solution even if it's interrupted at any time before it ends.","alt_names":["hill climber","hill-climbing","hill climbing","Hill Climbing","(http://en.wikipedia.org/wiki/Hill_climbing","- Hill climbing :","- Hill-climbing algorithm :","...mehr auf Wikipedia über Bergsteigeralgorithmus","...mehr auf Wikipedia über Hillclimbing","...more on Wikipedia about Hill climbing","...more on Wikipedia about Random-restart hill climbing","190px-Ridge.png","Bergrennen Algorithmus","Bergsteiger-Algorithmus","Bergsteigeralgorithmus","Bergsteigeralgorithmus - Wikipedia","Bergsteigeralgorithmus ? Wikipedia","Bergsteigeralgorithmus – Wikipedia","Hill Clibing","Hill Climbing Algorithm at Wikipedia","Hill Climbing Algorithmus","Hill Climbing algolrithms","Hill Climbing algorithm","Hill Climbing: Not a genetic algorithm, but another","Hill climb algorithms","Hill climbing","Hill climbing - Wikipedia","Hill climbing - Wikipedia, the free encyclopedia","Hill climbing - Wikipedia, the free encyclopediaIn computer","Hill climbing Wikipedia the free encyclopedia","Hill climbing Wikipedia the free encyclopedia - result","Hill climbing from Wikipedia","Hill climbing – Wikipedia, the free encyclopedia","Hill climbing.","Hill climbing; it is used under the","Hill-Climbing","Hill-Climbing Ansatz","Hill-Climbing Probleme.","Hill-climbing","Hill-climbing algorithm","Hill-climbing with random restart","HillClimber","HillClimbing","Hill_Climbing","Hill_climbing","Hillclimber","Hillclimbing ? Wikipedia","Hillclimbing in","Hillclimbing – Wikipedia","Hügel klettern.","Kukkulakiipeily","Lubeligrämam","Random Restart Hill Climbing","Random-r","Random-restart hill climbing","The hill-climbing problem","What Causes Random Reboot / Restart - BlackBerry Forums at","Wiki that for you","Wikipedia - Hillclimbing","Wikipedia article Hill climbing","Wikipedia article Hill-climbing","Wikipedia article Hill-climbing algorithm","Wikipedia article Random-restart hill climbing","Wikipedia article on Hill climbing","Wikipedia entry for Hill climbing","Wikipedia hill climbing","Wikipedia-Artikel Bergsteiger-Algorithmus","Wikipedia-Artikel Bergsteigeralgorithmus","Wikipedia-Artikel Hill Climbing","Wikipedia-Artikel Hillclimbing","Wikipedia-Seite zu 'Bergsteigeralgorithmus'","Wikipedia-Seite zu 'Hillclimbing'","Wikipedia::Hill_climbing","Wikipediaで「山登り法」を調べる","a.k.a Hill Climbing","algoritmo de la escalada","approccio hill climbing","bakke-klatring","burol akyat.","climbing a hill","cs:Hill-climbing","de.wikipedia.org/wiki/Bergsteigeralgorithmus","de:Bergsteigeralgorithmus","en escalada","en.wikipedia.org/...Hill_climbing","en.wikipedia.org/wiki/Hill_climbing","en:Random-restart hill climbing","get stuck in local maxima","greedy hill climbing","heuvel beklimmen","heuvel beklimmen aanpak","heuvel beklimmen algoritme","hil climbing","hill climbing (mathematical/programming term, not the sport","hill climbing algorithm","hill climbing algorytm","hill climbing approach","hill climbing optimization","hill climbing podejście","hill climbing search","hill climbing's local maxima","hill climbing.","hill-climber","hill-climbing algorithm","hill-climbing optimization","hill-climbing problems","hill-climbing problèmes.","hill-climbing search","hill-climbing strategy","hill-climbing strategy,","http://cs.wikipedia.org/wiki/Hill-climbing","http://de.wikipedia.org/wiki/Bergsteigeralgorithmus","http://de.wikipedia.org/wiki/Hillclimbin","http://de.wikipedia.org/wiki/Hillclimbing","http://en.wikipedia....i/Hill_climbing","http://en.wikipedia.org/wiki/Hil...i/Hill","http://en.wikipedia.org/wiki/Hill-climbing","http://en.wikipedia.org/wiki/Hill-climbing#Local_maxima","http://en.wikipedia.org/wiki/Hill-climbing_algorithm","http://en.wikipedia.org/wiki/Hill-climbing_algorithm#Local_maxima","http://en.wikipedia.org/wiki/Hill_","http://en.wikipedia.org/wiki/Hill_climbi","http://en.wikipedia.org/wiki/Hill_climbing","http://en.wikipedia.org/wiki/Hill_climbing#Local_maxima","http://en.wikipedia.org/wiki/Hill_climbing#Problems","http://en.wikipedia.org/wiki/Hill_climbing.","http://en.wikipedia.org/wiki/Hill_climbing~~V","http://en.wikipedia.org/wiki/Hill_climbingは、","http://en.wikipedia.org/wiki/Hill_climbi…","http://en.wikipedia.org/wiki/Random-restart_hill_climbing","http://ja.wikipedia.org/wiki/山登り法","ill climbing","ill climbs","in salita","ja:山登り法","kopec-lézt na","la colina escalada problemas.","la escalada.","local maximality","lokalne optimizacije","mendaki bukit-masalah.","mendaki bukit.","pokonywania wzniesień","problemi Hill-climbing.","queescalam problemas.","random hill climbing algoritm","random restart","random-restart","random-restart hill climbing","remonte de colinas","shotgun hill climbing","steepest ascent hill climbing","stochastic hill climbing algorithm","subidas.","the Hill-Climbing problem","vo:Lubeligrämam","w:Hill climbing","zh:爬山算法","| Hill Climbing","đồi leo núi.","đồi-leo vấn đề.","подход к преодолению подъема","преодолению подъема","преодолению подъема алгоритм","холм Скалолазание проблем.","холма восхождения","טיפוס הגבעה","الگوریتم تپه نوردی","الگوریتم تپهنوردی - ویکیپدیا","चाहिए पहाड़ी चढ़ाई","ปี น เขา-ปัญหา.","เขา ปี น เขา.","“hill climbing” problem","丘の問題を登っ","丘はクライミング","丘を登る","山登り法","山登り法 - Wikipedia","山登り法 -Wikipedia-","山登り法 hill climbing","山登り法-wikipedia","梯度算法","爬坡的方法","爬山","爬山法","爬山演算法","爬山的問題","爬山的问题","爬山算法","언덕 등반이라고합니다.","언덕에 - 문제가 등반"],"name":"Hill climbing","categories":["All articles that may contain original research","Articles that may contain original research from September 2007","Optimization algorithms and methods","Search algorithms"],"tag_line":"In computer science, hill climbing is a mathematical optimization technique which belongs to the family of local search."}}
,{"_index":"throwtable","_type":"algorithm","_id":"nonlinear-conjugate-gradient-method","_score":0,"_source":{"description":"In numerical optimization, the nonlinear conjugate gradient method generalizes the conjugate gradient method to nonlinear optimization. For a quadratic function :\n\nThe minimum of  is obtained when the gradient is 0:\n\n.\n\nWhereas linear conjugate gradient seeks a solution to the linear equation , the nonlinear conjugate gradient method is generally used to find the local minimum of a nonlinear function using its gradient  alone. It works when the function is approximately quadratic near the minimum, which is the case when the function is twice differentiable at the minimum.\nGiven a function  of  variables to minimize, its gradient  indicates the direction of maximum increase. One simply starts in the opposite (steepest descent) direction:\n\nwith an adjustable step length  and performs a line search in this direction until it reaches the minimum of :\n\n,\n\nAfter this first iteration in the steepest direction , the following steps constitute one iteration of moving along a subsequent conjugate direction , where :\nCalculate the steepest direction: ,\nCompute  according to one of the formulas below,\nUpdate the conjugate direction: \nPerform a line search: optimize ,\nUpdate the position: ,\nWith a pure quadratic function the minimum is reached within N iterations (excepting roundoff error), but a non-quadratic function will make slower progress. Subsequent search directions lose conjugacy requiring the search direction to be reset to the steepest descent direction at least every N iterations, or sooner if progress stops. However, resetting every iteration turns the method into steepest descent. The algorithm stops when it finds the minimum, determined when no progress is made after a direction reset (i.e. in the steepest descent direction), or when some tolerance criterion is reached.\nWithin a linear approximation, the parameters  and  are the same as in the linear conjugate gradient method but have been obtained with line searches. The conjugate gradient method can follow narrow (ill-conditioned) valleys where the steepest descent method slows down and follows a criss-cross pattern.\nFour of the best known formulas for  are named after their developers and are given by the following formulas:\nFletcher–Reeves:\n\nPolak–Ribière:\n\nHestenes-Stiefel:\n\nDai–Yuan:\n\n.\n\nThese formulas are equivalent for a quadratic function, but for nonlinear optimization the preferred formula is a matter of heuristics or taste. A popular choice is  which provides a direction reset automatically.\nNewton based methods - Newton-Raphson Algorithm, Quasi-Newton methods (e.g., BFGS method) - tend to converge in fewer iterations, although each iteration typically requires more computation than a conjugate gradient iteration as Newton-like methods require computing the Hessian (matrix of second derivatives) in addition to the gradient. Quasi-Newton methods also require more memory to operate (see also the limited memory L-BFGS method).","alt_names":["- Nonlinear conjugate gradient method :","CG 也可以用于最优化非线性函数(无约束)","Http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method","Nlinear cjugate gradient method","Nonlinear CG","Nonlinear Conjugate Gradients","Nonlinear Conjugate gradient method - Wikipedia, the free ...","Nonlinear conjugate gradient","Nonlinear conjugate gradient method","Nonlinear conjugate gradient method - Wikipedia :: The free encyclopedia","Nonlinear conjugate gradient method - Wikipedia, the free ...","Nonlinear conjugate gradient method - Wikipedia, the free encyclopedia","Polak–Ribière","Wikipedia article Nonlinear conjugate gradient method","conjugate gradient v2,","d533bd95f0f8cfec1d9ea4339fae91 ...","en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method","en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method. Inside my application","http://en.wikipedia.org/wiki/Nonlinear_c","http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient","http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient.","http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method","http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method...","nonlinear conjugate gradient","nonlinear conjugate gradient fitting method (Wikipedia)","nonlinear conjugate gradient method","nonlinear conjugate gradient methods"],"name":"Nonlinear conjugate gradient method","categories":["All articles needing additional references","All articles with unsourced statements","Articles needing additional references from December 2015","Articles with unsourced statements from December 2015","Gradient methods","Optimization algorithms and methods"],"tag_line":"In numerical optimization, the nonlinear conjugate gradient method generalizes the conjugate gradient method to nonlinear optimization."}}
,{"_index":"throwtable","_type":"algorithm","_id":"killer-heuristic","_score":0,"_source":{"description":"In competitive two-player games, the killer heuristic is a technique for improving the efficiency of alpha-beta pruning, which in turn improves the efficiency of the minimax algorithm. This algorithm has an exponential search time to find the optimal next move, so general methods for speeding it up are very useful.\nAlpha-beta pruning works best when the best moves are considered first. This is because the best moves are the ones most likely to produce a cutoff, a condition where the game playing program knows that the position it is considering could not possibly have resulted from best play by both sides and so need not be considered further. I.e. the game playing program will always make its best available move for each position. It only needs to consider the other player's possible responses to that best move, and can skip evaluation of responses to (worse) moves it will not make.\nThe killer heuristic attempts to produce a cutoff by assuming that a move that produced a cutoff in another branch of the game tree at the same depth is likely to produce a cutoff in the present position, that is to say that a move that was a very good move from a different (but possibly similar) position might also be a good move in the present position. By trying the killer move before other moves, a game playing program can often produce an early cutoff, saving itself the effort of considering or even generating all legal moves from a position.\nIn practical implementation, game playing programs frequently keep track of two killer moves for each depth of the game tree (greater than depth of 1) and see if either of these moves, if legal, produces a cutoff before the program generates and considers the rest of the possible moves. If a non-killer move produces a cutoff, it replaces one of the two killer moves at its depth. This idea can be generalized into a set of refutation tables.\nA generalization of the killer heuristic is the history heuristic. The history heuristic can be implemented as a table that is indexed by some characteristic of the move, for example \"from\" and \"to\" squares or piece moving and the \"to\" square. When there is a cutoff, the appropriate entry in the table is incremented, such as by adding d² or 2d where d is the current search depth. This information is used when ordering moves.","alt_names":["-> Read the article about 'Killer heuristic'","...more on Wikipedia about Killer heuristic","Heuristic history","History Heuristics","Killer Heuristic","Killer Move Heuristic","Killer heuristic","Killer heuristic - Wikipedia, the free encyclopedia","Killer heuristic - Wikipedia, the free encyclopediaAlpha-beta","Killer heuristic from Wikipedia","Killer-Heuristik","Killer-move Heuristic","Wikipedia article ''Killer heuristic''","Wikipedia article Killer heuristic","Wikipedia article on Killer heuristic","Wikipedia entry for Killer heuristic","asesino heurística","assassino heurística","en.wikipedia.org/wiki/Killer_heuristic","heuristik pembunuh","history heuristics","http://en.wikipedia.org/wiki/Killer heuristic","http://en.wikipedia.org/wiki/Killer_heur","http://en.wikipedia.org/wiki/Killer_heuristic","http://en.wikipedia.org/wiki/Killer_heuristic.","hyuristiko mamamatay","killer euristico","killer heuristic","killer move heuristic","killer moves","kẻ giết người heuristic","tueur heuristique","убийца эвристического","“killer” heuristic","杀手启发","殺手啟發","범인을 추론"],"name":"Killer heuristic","categories":["All articles lacking sources","Articles lacking sources from October 2007","Game artificial intelligence","Heuristics","Optimization algorithms and methods"],"tag_line":"In competitive two-player games, the killer heuristic is a technique for improving the efficiency of alpha-beta pruning, which in turn improves the efficiency of the minimax algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"local-search-(optimization)","_score":0,"_source":{"description":"In computer science, local search is a metaheuristic method for solving computationally hard optimization problems. Local search can be used on problems that can be formulated as finding a solution maximizing a criterion among a number of candidate solutions. Local search algorithms move from solution to solution in the space of candidate solutions (the search space) by applying local changes, until a solution deemed optimal is found or a time bound is elapsed.\nLocal search algorithms are widely applied to numerous hard computational problems, including problems from computer science (particularly artificial intelligence), mathematics, operations research, engineering, and bioinformatics. Examples of local search algorithms are WalkSAT and the 2-opt algorithm for the Traveling Salesman Problem.","alt_names":["local search algorithm","recherche locale","חיפוש מקומי","local searches","局所探索","- Local search (optimization) :","-> Read the article about 'Local search (optimization)'","...more on Wikipedia about Local search (optimization)","411196815f64f2e201f212d ...","538a97bcd545de82f2ca5306e6d0c ...","K-opt","K-opt - Wikipedia, the free encyclopedia .","Local Search (Optimization)","Local Search (optimization) - Wikipedia, The Free Encyclopedia","Local Search (wiki page)","Local Search Optimization Wikipedia The Free Encyclopedia","Local Search Techniques","Local Search Visibility","Local Search:","Local earch optimization Wikipedia the free encyclopedia","Local search (optimization)","Local search (optimization) (wikipedia)","Local search (optimization) - Wikipedia, the free encyclo...","Local search (optimization) - Wikipedia, the free encycloped...","Local search (optimization) - Wikipedia, the free encyclopedia","Local search (optimization) from Wikipedia","Local search (optimization) – Wikipedia, the free encyclopedia","Local search optimization","Local search optimization Wikipedia the free encyclopedia - result","Lokale Suche","Lokale Suche - Wikipedia","Lokale Suche – Wikipedia","Lokale-Suche","Lokale_Suche","Read More about local search optimization wikipedia the","Read More local search optimization wikipedia the free","Recherche locale","Recherche locale - Wikipédia","Stochastic Local Search","Wikipedia (Local search (optimization))","Wikipedia article ''Local search (optimization)''","Wikipedia article K-opt","Wikipedia article Local search (optimization)","Wikipedia article on Local search (optimization)","Wikipedia entry for Local search (optimization)","Wikipedia-Artikel Lokale Suche","Wikipedia-Seite zu 'Lokale Suche'","article Recherche locale","de.wikipedia.org/wiki/Lokale_Suche","de:Lokale Suche","en.wikiped...imization)","en.wikipedia.org/ wiki/Local_search_(optimizati»","en.wikipedia.org/wiki/Local_search_(o...","en.wikipedia.org/wiki/Local_search_(optimization)","fr:Recherche locale","he:חיפוש מקומי","http://de.wikipedia.org/wiki/Lokale_Such","http://de.wikipedia.org/wiki/Lokale_Suche","http://en.wikipedia.org/wiki/K-opt","http://en.wikipedia.org/wiki/Local_search_%28optimization%29","http://en.wikipedia.org/wiki/Local_search_(optimizati","http://en.wikipedia.org/wiki/Local_search_(optimization)","http://en.wikipedia.org/wiki/Local_search_(optimization...","http://fr.wikipedia.org/wiki/Recherche_locale","ja:局所探索法","local or neighborhood","local or neighbourhood","local search (optimization)","local search algorithms","local search methods","local search problem","lokalen Suche","lokaler Suche","lokalt sök","n). http://en.wikipedia.org/","ocal search","ru:Локальный поиск (оптимизация)","search for and find a local optimum","stochastic local search (SLS)","stochastic local search algorithms","uk:Локальний пошук (оптимізація)","Википедии статью Локальный поиск (оптимизация)","Локальний пошук","Локальный поиск","Локальный поиск (оптимизация)","Локальный поиск (оптимизация...","локального поиска","ויקיפדיה - 'חיפוש מקומי'","חיפוש מקומי – ויקיפדיה","الگوریتم جستجوی محلی (بهینه سازی)","جستجوي محلي (Local Search)","ウィキペディアの記事 逐次改善法","區域搜尋法","局所探索-wikipedia","局所探索アルゴリズム","局所探索法","局所探索法 - Wikipedia","局所探索法 local search","局所探索法-wikipedia","국소탐색"],"name":"Local search (optimization)","categories":["All articles lacking in-text citations","Articles lacking in-text citations from May 2015","Optimization algorithms and methods"],"tag_line":"In computer science, local search is a metaheuristic method for solving computationally hard optimization problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lincoa","_score":0,"_source":{"description":"LINCOA (LINearly Constrained Optimization Algorithm) is a numerical optimization algorithm by Michael J. D. Powell. It is also the name of Powell's Fortran 77 implementation of the algorithm.\nLINCOA solves linearly constrained optimization problems without using derivatives of the objective function, which makes it a derivative-free algorithm. The algorithm solves the problem using a trust region method that forms quadratic models by interpolation. One new point is computed on each iteration, usually by solving a trust region subproblem subject to the linear constraints, or alternatively, by choosing a point to replace an interpolation point that may be too far away for reliability. In the second case, the new point may not satisfy the linear constraints.\nThe same as NEWUOA, LINCOA constructs the quadratic models by the least Frobenius norm updating  technique. A model function is determined by interpolating the objective function at  (an integer between  and ) points; the remaining freedom, if any, is taken up by minimizing the Frobenius norm of the change to the model's Hessian (with respect to the last iteration).\nLINCOA software was released on December 6, 2013. In the comment of the source code, it is said that LINCOA is not suitable for very large numbers of variables (which is typically true for algorithms not using derivatives), but \"a few calculations with 1000 variables, however, have been run successfully overnight, and the performance of LINCOA is satisfactory usually for small numbers of variables.\" It is also pointed out that the author's typical choices of  are  and , the latter \"being recommended for a start\", and \"larger values tend to be highly inefficent when the number of variables is substantial, due to the amount of work and extra difficulty of adjusting more points.\"\nThe trust region subproblem is solved by the truncated conjugate gradient method described in Powell's report, but Powell did not write a report on the other details of LINCOA.\nThe LINCOA software is distributed under The GNU Lesser General Public License (LGPL).","alt_names":[],"name":"LINCOA","categories":["All articles with links needing disambiguation","Articles with links needing disambiguation from April 2014","Optimization algorithms and methods"],"tag_line":"LINCOA (LINearly Constrained Optimization Algorithm) is a numerical optimization algorithm by Michael J. D. Powell."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pseven","_score":0,"_source":{"description":"pSeven is a design space exploration software platform developed by DATADVANCE LLC, extending design, simulation and analysis capabilities and assisting in smarter and faster design decisions. It provides a seamless integration with third party CAD and CAE software tools, powerful multi-objective and robust optimization algorithms, data mining and uncertainty management tools. pSeven comes under the notion of PIDO (Process Integration and Design Optimization) software. Design space exploration functionality is based on the mathematical algorithms of Macros software library, also developed by DATADVANCE. pSeven is used for the needs of predicting system behavior, analyzing the existing experimental data, estimating model uncertainties or performing multidisciplinary design optimization. pSeven implements DATADVANCE strategy to:\nEnable engineers to easily use mathematical algorithms thanks to “Smart Selection” technique, which automatically and adaptively selects the most suitable algorithm for a given problem from a pool of available methods;\nAddress complex industrial challenges: architecture trade-off, optimization using expensive simulations.\n\n","alt_names":[],"name":"PSeven","categories":["All articles needing style editing","Computer system optimization software","Mathematical optimization software","Optimization algorithms and methods","Wikipedia articles needing style editing from March 2015"],"tag_line":"pSeven is a design space exploration software platform developed by DATADVANCE LLC, extending design, simulation and analysis capabilities and assisting in smarter and faster design decisions."}}
,{"_index":"throwtable","_type":"algorithm","_id":"mcs-algorithm","_score":0,"_source":{"description":"Multilevel Coordinate Search (MCS) is an algorithm for bound constrained global optimization using function values only.\nTo do so, the n-dimensional search space is represented by a set of non-intersecting hypercubes (boxes). The boxes are then iteratively split along an axis plane according to the value of the function at a representative point of the box and the box's size. These two splitting criteria combine to form a global search by splitting large boxes and a local search by splitting areas for which the function value is good.\nAdditionally a local search combining a quadratic interpolant of the function and line searches can be used to augment performance of the algorithm.","alt_names":["...more on Wikipedia about MCS algorithm","MCS algorithm","MCS algorithm - Wikipedia, the free encyclopedia","MCS_algorithm","Wikipedia article MCS algorithm","Wikipedia entry for MCS algorithm","http://en.wikipedia.org/wiki/MCS_algorit","http://en.wikipedia.org/wiki/MCS_algorithm","yago-res:MCS algorithm"],"name":"MCS algorithm","categories":["All Wikipedia articles needing context","All articles lacking sources","All pages needing cleanup","All stub articles","Applied mathematics stubs","Articles lacking sources from July 2012","Optimization algorithms and methods","Wikipedia articles needing context from October 2009","Wikipedia introduction cleanup from October 2009"],"tag_line":"Multilevel Coordinate Search (MCS) is an algorithm for bound constrained global optimization using function values only."}}
,{"_index":"throwtable","_type":"algorithm","_id":"wang-and-landau-algorithm","_score":0,"_source":{"description":"The Wang and Landau algorithm, proposed by Fugao Wang and David P. Landau, is a Monte Carlo method designed to calculate the density of states of a system. The method performs a non-markovian random walk to build the density of states by quickly visiting all the available energy spectrum. The Wang and Landau algorithm is an important method to obtain the density of states required to perform a multicanonical simulation.\nThe Wang–Landau algorithm can be applied to any system which is characterized by a cost (or energy) function. For instance, it has been applied to the solution of numerical integrals and the folding of proteins. The Wang-Landau Sampling is related to the Metadynamics algorithm.","alt_names":["Landau algorithm","Wang and Landau algorithm","Wang and Landau algorithm - Wikipedia :: The free encyclopedia","Wang and Landau algorithm - Wikipedia, the free encyclopedia","Wang-Landau","Wang-Landau Algorithm article","What is algorithm of Wang and Landau algorithm","Wikipedia article Wang and Landau algorithm","Wikipedia article on Wang and Landau algorithm","Wikipedia entry for Wang and Landau algorithm","http://en.wikipedia.org/wiki/Wang_and_Landau_algorithm","p < min 1 , g ( E ) g ( E ' ) ,"],"name":"Wang and Landau algorithm","categories":["Articles with example Python code","Computational physics","Markov chain Monte Carlo","Statistical algorithms"],"tag_line":"The Wang and Landau algorithm, proposed by Fugao Wang and David P. Landau, is a Monte Carlo method designed to calculate the density of states of a system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"knuth–morris–pratt-algorithm","_score":0,"_source":{"description":"In computer science, the Knuth–Morris–Pratt string searching algorithm (or KMP algorithm) searches for occurrences of a \"word\" W within a main \"text string\" S by employing the observation that when a mismatch occurs, the word itself embodies sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters.\nThe algorithm was conceived in 1974 by Donald Knuth and Vaughan Pratt, and independently by James H. Morris. The three published it jointly in 1977.","alt_names":[],"name":"Knuth–Morris–Pratt algorithm","categories":["All articles needing additional references","Articles needing additional references from October 2009","Articles with example pseudocode","Donald Knuth","String matching algorithms"],"tag_line":"In computer science, the Knuth–Morris–Pratt string searching algorithm (or KMP algorithm) searches for occurrences of a \"word\" W within a main \"text string\" S by employing the observation that when a mismatch occurs, the word itself embodies sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters."}}
,{"_index":"throwtable","_type":"algorithm","_id":"master-theorem","_score":0,"_source":{"description":"In the analysis of algorithms, the master theorem provides a solution in asymptotic terms (using Big O notation) for recurrence relations of types that occur in the analysis of many divide and conquer algorithms. It was popularized by the canonical algorithms textbook Introduction to Algorithms by Cormen, Leiserson, Rivest, and Stein, in which it is both introduced and proved. Not all recurrence relations can be solved with the use of the master theorem; its generalizations include the Akra–Bazzi method.\n\n","alt_names":["% http://en.wikipedia.org/wiki/Master 5Ftheorem","- Master theorem :","-> Read more about Master theorem","-> Read the article about 'Master theorem'","...mehr auf Wikipedia über Master-Theorem","...more on Wikipedia about Master theorem","1 Generic Form","2 Case 1","2.1 Generic Form","3 Case 2","3.1 Generic Form","4 Case 3","4.1 Generic Form","5Ftheorem http://en.wikipedia.org/wiki/Master%","Application to popular algorithms","Das Master-Theorem für rekursive Funktionen","Generic form","Master Sætning","Master Theorem","Master Theorem (wikipédia)","Master Theorem [Wiki] - http://de.wikipedia.org/wiki","Master Theorem.","Master Theorem:","Master Theory","Master teorema,","Master teorema.","Master theorem","Master theorem - Wikipedia :: The free encyclopedia","Master theorem - Wikipedia on Ask.com","Master theorem - Wikipedia, th","Master theorem - Wikipedia, the free encyclop...","Master theorem - Wikipedia, the free encyclopedia","Master theorem - Wikipedie","Master theorem Wikipedia the free encyclopedia","Master twierdzenia","Master's theorem","Master's theorem.","Master-Methode,","Master-Theorem","Master-Theorem ? Wikipedia","Master-Theorem Wikipedia","Master-Theorem – Wikipedia","Master-Theorem,","Master-Theorem.","Masters theorem","Mastertheorem","Meester Stelling","Meistermethode","Mester-tétel","Método Mestre","O(n log n).","Qui định lý,","Source Wikipedia.org Arcticle - Master theorem","Teo Master","Teorema Maestro","Teorema Master","Teorema maestro","Teorema principale (informatica)","Teorema principale (informatica) - Wikipedia","Teorema principale informatica Wikipedia","The Master Theorem","The Master Theorem (algorithm).","Twierdzenie Master","Twierdzenie o rekurencji uniwersalnej","Twierdzenie o rekurencji uniwersalnej – Wikipedia, wolna ...","Wiki page on the Master Theorem","Wikipedia article Master Theorem","Wikipedia article Master theorem","Wikipedia article Mester-tétel","Wikipedia article about Master theorem","Wikipedia article on Twierdzenie o rekurencji uniwersalnej","Wikipedia article שיטת האב","Wikipedia entry for Master theorem","Wikipedia l'articolo Master theorem","Wikipedia zum Master-Theorem","Wikipedia-Artikel Master-Theorem","Wikipedia-Artikel Mastertheorem","Wikipedia-Seite zu 'Master-Theorem'","Wikipedia: Master theorem","Wikipedia:Master_theorem","Wikipedia:Metodo_dell'esperto","Wikipedia:Teorema_master","articolo tedesca,","artigo alemão,","artikel jerman,","artikulo Aleman,","artículo alemán,","bài viết tiếng Đức,","cs:Master theorem","de.wikipedia.org/wiki/Master-Theorem","description/discussion in Wikipedia","deutschen Artikel,","el teorema de","el teorema de maestro","el:Μάστερ Θεώρημα","en.wikipedia.org/...Master_theorem","es:Teorema maestro","es:Teorema_Maestro","fa:قضیه اصلی واکاوی الگوریتمها","http://cs.wikipedia.org/wiki/Master_theorem","http://de.wikipedia.org/wiki/Master-Theo","http://de.wikipedia.org/wiki/Master-Theorem","http://de.wikipedia.org/wiki/Mastertheorem","http://el.wikipedia.org/wiki/Master_theorem","http://el.wikipedia.org/wiki/Θεώρημα_Μάστερ","http://el.wikipedia.org/wiki/Μάστερ_Θεώρημα","http://en.wikipedia..../Master_theorem","http://en.wikipedia.org/wiki/Master theorem","http://en.wikipedia.org/wiki/Master% 5Ftheorem","http://en.wikipedia.org/wiki/Master%5Ftheorem","http://en.wikipedia.org/wiki/Master_Theorem","http://en.wikipedia.org/wiki/Master_the ... _equations","http://en.wikipedia.org/wiki/Master_theo","http://en.wikipedia.org/wiki/Master_theo rem","http://en.wikipedia.org/wiki/Master_theorem","http://en.wikipedia.org/wiki/Master_theorem#Case_2","http://en.wikipedia.org/wiki/Master_theorem#Case_3","http://en.wikipedia.org/wiki/Master_theorem#Example","http://en.wikipedia.org/wiki/Master_theorem#Generic_form","http://en.wikipedia.org/wiki/Master_theorem#Generic_form_3","http://en.wikipedia.org/wiki/Master_theorem.","http://en.wikipedia.org/wiki/Master_theo…","http://en.wikipedia.org/wiki/Master％5Ftheorem","http://es.wikipedia.org/wiki/Teorema_maestro","http://esudo apt-get install python-lxmln.wikipedia","http://it.wikipedia.org/wiki/Master_theorem","http://it.wikipedia.org/wiki/Master_theo…","http://it.wikipedia.org/wiki/Teorema_principale_(informatica)","http://it.wikipedia.org/wiki/Teorema_principale_(informatica)#Caso_2","http://pl.wikipedia.org/wiki/Twierdzeni ... iwersalnej","http://pl.wikipedia.org/wiki/Twierdzenie_o_rekurencji_uniwersalnej","hu:Mester-tétel","l'article allemand,","master method","master theorem","master theorem for recurrences","master theoremu","master therom","master-theorem","metode master","metodo dell'esperto","metodo di master","méthode de Maître","método maestro","método mestre","na Wikipédii pod heslom Master theorem","nl:Master theorem","paraan ng panginoon","phương pháp tổng thể","pl:Twierdzenie o rekurencji uniwersalnej","r http://de.wikipedia.org/wiki/Master−Theorem","recurrence relation of binary search is","teorama Master.","teorema Master","teorema Master,","teorema Mestre","teorema de Maestro","teorema de Master,","teorema de Mestre,","teorema del Master.","teorema mestre","the Master Theorem","the Master theorem,","théorème de Master","théorème de Maître,","théorème magique","twierdzenie o rekurencji uniwersalnej","wikipedia entry on the Master Theorem","~ de.wikipedia.org > Wiki > Master-Theorem","định lý Master","немецкой статье,","основной метод","теорема Мастер.","теореме мастер,","שיטת האב","שיטת האב – ויקיפדיה","قضیه اصلی (Master Theorem)","قضیه اصلی واکاوی الگوریتمها - ویکیپدیا","ทฤษฎีบท Master","ทฤษฎีบท Master.","บทความ ภาษา เยอรมัน","วิธี การ หลัก","、マスターの定理","ドイツ語の資料","マスターの定理","マスター法","主定理","德国的文章","德國的文章","掌握方法","支配定理（Master theorem）","독일어 문서에,","마스터 방법은","마스터 정리","마스터 정리에이","마스터정리(Master theorem)","위키 피 디아 문서 마스터 정리"],"name":"Master theorem","categories":["Analysis of algorithms","Asymptotic analysis","Recurrence relations","Theorems in computational complexity theory"],"tag_line":"In the analysis of algorithms, the master theorem provides a solution in asymptotic terms (using Big O notation) for recurrence relations of types that occur in the analysis of many divide and conquer algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dynamic-priority-scheduling","_score":0,"_source":{"description":"Definition: Dynamic scheduling is a method in which the hardware determines which instructions to execute, as opposed to a statically scheduled machine, in which the compiler determines the order of execution. In essence, the processor is executing instructions out of order\nA major driving force in the microprocessor industry is the never ending desire to miniaturize things. Smaller transistors require less voltage to operate and thus consume less power and produce less heat. Smaller interconnect distances also allow for faster clock speeds. Perhaps most important of all, smaller die areas lead to cheaper processors since more chips can fit in a single wafer. The first microprocessor made by Intel was the 4004, which had 2300 transistors. Today's chips, on the other hand, incorporate 5 to 20 million transistors. So what do they do with all those transistors?\nA major hog of real estate is, of course, caches. Caches, and any IC (integrated circuit) based memory device, must have many wires running to and from the read and write ports. For on-chip caches, the load/store unit in the CPU must be able to access every location in the cache from both the read and write ports. The situation is even worse when there are more than one load/store units. That's a lot of wires! In the Pentium Pro, for example, a single package includes both the CPU chip and a L2 cache chip; the CPU chip has about 5 million transistors, while the cache chip has about 15 million transistors.\nHowever, even accounting for caches, there is still a large increase in the number of transistors in today's chips compared to the 4004. Obviously, microprocessors are becoming increasingly more complex. We can understand this increasing complexity since chip designers want to create fast processors which are at the same time affordable. As process technology improved and more transistors could be fitted in the same die area, it became cost effective to add newer or improved features to the processor in an attempt to increase its effective speed. One of these improvements is dynamic scheduling.\nAs its name implies, is a method in which the hardware determines which instructions to execute, as opposed to a statically scheduled machine, in which the compiler determines the order of execution. In essence, the processor is executing instructions out of order. Dynamic scheduling is akin to a data flow machine, in which instructions don't execute based on the order in which they appear, but rather on the availability of the source operands. Of course, a real processor also has to take into account the limited amount of resources available. Thus instructions execute based on the availability of the source operands as well as the availability of the requested functional units.\nDynamically scheduled machines can take advantage of parallelism which would not be visible at compile time. They are also more versatile as code does not necessarily have to be recompiled to run efficiently since the hardware takes care of much of the scheduling. In a statically scheduled machine, code would have to be recompiled to take advantage of the machine's particular hardware. (All of this is assuming the machines use the same instruction set architecture. Of course, the code would have to be recompiled no matter what if the machines used different ISAs.)\nDynamic priority scheduling is a type of scheduling algorithm in which the priorities are calculated during the execution of the system. The goal of dynamic priority scheduling is to adapt to dynamically changing progress and form an optimal configuration in self-sustained manner. It can be very hard to produce well-defined policies to achieve the goal depending on the difficulty of a given problem.\nEarliest deadline first scheduling and Least slack time scheduling are examples of Dynamic priority scheduling algorithms.","alt_names":["- Dynamic priority scheduling :","Dynamic priority scheduling","Dynamic priority scheduling - Wikipedia, the free encyclopedia","Dynamic priority scheduling Wikipedia the free encyclopedia","Wikipedia article Dynamic priority scheduling","Wikipedia article about Dynamic priority scheduling","Wikipedia article on Dynamic priority scheduling","Wikipedia entry for Dynamic priority scheduling","http://en.wikipedia.org/wiki/Dynamic_pri","http://en.wikipedia.org/wiki/Dynamic_priority_scheduling","yago-res:Dynamic priority scheduling"],"name":"Dynamic priority scheduling","categories":["All articles lacking sources","All articles needing expert attention","All stub articles","Articles lacking sources from August 2009","Articles needing expert attention from February 2009","Articles needing expert attention with no reason or talk parameter","Computer science articles needing expert attention","Computer science stubs","Scheduling algorithms"],"tag_line":"Definition: Dynamic scheduling is a method in which the hardware determines which instructions to execute, as opposed to a statically scheduled machine, in which the compiler determines the order of execution."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rapidly-exploring-random-tree","_score":0,"_source":{"description":"A rapidly exploring random tree (RRT) is an algorithm designed to efficiently search nonconvex, high-dimensional spaces by randomly building a space-filling tree. The tree is constructed incrementally from samples drawn randomly from the search space and is inherently biased to grow towards large unsearched areas of the problem. RRTs were developed by Steven M. LaValle and James J. Kuffner Jr.  . They easily handle problems with obstacles and differential constraints (nonholonomic and kinodynamic) and have been widely used in autonomous robotic path planning.\nRRTs can be viewed as a technique to generate open-loop trajectories for nonlinear systems with state constraints. An RRT can also be considered as a Monte-Carlo method to bias search into the largest Voronoi regions of a graph in a configuration space. Some variations can even be considered stochastic fractals.\n^ LaValle, Steven M. (October 1998). \"Rapidly-exploring random trees: A new tool for path planning\" (PDF). Technical Report (Computer Science Department, Iowa State University) (TR 98-11). \n^ LaValle, Steven M.; Kuffner Jr., James J. (2001). \"Randomized Kinodynamic Planning\" (PDF). The International Journal of Robotics Research (IJRR) 20 (5). doi:10.1177/02783640122067453. \n^ http://msl.cs.uiuc.edu/rrt/about.html About RRTs, by Steve LaValle","alt_names":[],"name":"Rapidly exploring random tree","categories":["Probabilistic data structures","Robot control","Search algorithms"],"tag_line":"A rapidly exploring random tree (RRT) is an algorithm designed to efficiently search nonconvex, high-dimensional spaces by randomly building a space-filling tree."}}
,{"_index":"throwtable","_type":"algorithm","_id":"generalized-processor-sharing","_score":0,"_source":{"description":"Generalized processor sharing (GPS) is an ideal scheduling algorithm for network schedulers.\nIt is related to the Fair queuing principle, that groups the packets into classes, and share the service capacity between them. The GPS shares this capacity according to some fixed weights.\nIn processor scheduling, generalized processor sharing is \"an idealized scheduling algorithm that achieves perfect fairness. All practical schedulers approximate GPS and use it as a reference to measure fairness.\" Generalized processor sharing assumes that traffic is fluid (infinitesimal packet sizes), and can be arbitrarily split. There are several service disciplines which track the performance of GPS quite closely such as weighted fair queuing (WFQ), also known as packet-by-packet generalized processor sharing (PGPS).","alt_names":["Generalized processor sharing","Generalized Processor Sharing","Generalized Processor Sharing (GPS)","Generalized Processor sharing","Generalized processor sharing - Wikipedia, the free encyclopedia","Generalized processor sharing - Wikipedia, the free encyclopedia ...","Generalized_processor_sharing","Wikipedia article Generalized processor sharing","Wikipedia entry for Generalized processor sharing","generalized processor sharing","generalized processor sharing (GPS)","http://en.wikipedia.org/wiki/General...cessor_sharing","http://en.wikipedia.org/wiki/Generalized_Processor_Sharing","http://en.wikipedia.org/wiki/Generalized_processor_sharing","ttp://en.wikipedia.org/wiki/Generalized_processor_sharing"],"name":"Generalized processor sharing","categories":["Scheduling algorithms"],"tag_line":"Generalized processor sharing (GPS) is an ideal scheduling algorithm for network schedulers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"approximate-counting-algorithm","_score":0,"_source":{"description":"The approximate counting algorithm allows the counting of a large number of events using a small amount of memory. Invented in 1977 by Robert Morris (cryptographer) of Bell Labs, it uses probabilistic techniques to increment the counter. It was fully analyzed in the early 1980s by Philippe Flajolet of INRIA Rocquencourt, who coined the name Approximate Counting, and strongly contributed to its recognition among the research community. The algorithm is considered one of the precursors of streaming algorithms, and the more general problem of determining the frequency moments of a data stream has been central to the field.","alt_names":["Approximate Counting","Approximate counting algorithm","Approximate counting algorithm - Wikipedia :: The free encyclopedia","Approximate counting algorithm - Wikipedia, the ...","Approximate counting algorithm - Wikipedia, the free encyclopedia","Approximate counting algorithm - Wikipedia, the free encyclopedia ...","What are sources of Approximate counting algorithm","Wikipedia article Approximate counting algorithm","Wikipedia entry for Approximate counting algorithm","approximate counting algorithm","http://en.wikipedia.org/wiki/Approximate_counting_algorithm","yago-res:Approximate counting algorithm"],"name":"Approximate counting algorithm","categories":["Randomized algorithms"],"tag_line":"The approximate counting algorithm allows the counting of a large number of events using a small amount of memory."}}
,{"_index":"throwtable","_type":"algorithm","_id":"look-algorithm","_score":0,"_source":{"description":"LOOK is a disk scheduling algorithm used to determine the order in which new disk read and write requests are processed.\n\n","alt_names":["- LOOK algorithm :","C-LOOK","CLook Disk Scheduling","LOOK (Computer Science)","LOOK algorithm","LOOK algorithm - Wikipedia, the free encyclopedia","Look Algorithm","What is performance of LOOK algorithm","Wikipedia article LOOK algorithm","Wikipedia article on LOOK algorithm","Wikipedia entry for LOOK algorithm","http://en.wikipedia.org/wiki/LOOK_algori","http://en.wikipedia.org/wiki/LOOK_algorithm","yago-res:LOOK algorithm"],"name":"LOOK algorithm","categories":["All articles needing additional references","All articles that may contain original research","Articles needing additional references from April 2014","Articles that may contain original research from April 2014","Disk scheduling algorithms"],"tag_line":"LOOK is a disk scheduling algorithm used to determine the order in which new disk read and write requests are processed.\n\n"}}
,{"_index":"throwtable","_type":"algorithm","_id":"principle-of-deferred-decision","_score":0,"_source":{"description":"Principle of Deferred Decisions is a technique used in analysis of randomized algorithms.\n\n","alt_names":["Principle of Deferred Decisions","Principle of deferred decision","Principle of deferred decision - Wikipedia, the free encyclopedia","What is Principle of deferred decision","Wikipedia article Principle of deferred decision","Wikipedia article on Principle of deferred decision","Wikipedia entry for Principle of deferred decision","http://en.wikipedia.org/wiki/Principle_of_deferred_decision","yago-res:Principle of deferred decision"],"name":"Principle of deferred decision","categories":["Algorithms and data structures stubs","All articles covered by WikiProject Wikify","All articles with too few wikilinks","All orphaned articles","All stub articles","Articles covered by WikiProject Wikify from December 2013","Articles with too few wikilinks from December 2013","Computer science stubs","Orphaned articles from January 2009","Randomized algorithms"],"tag_line":"Principle of Deferred Decisions is a technique used in analysis of randomized algorithms.\n\n"}}
,{"_index":"throwtable","_type":"algorithm","_id":"expected-linear-time-mst-algorithm","_score":0,"_source":{"description":"A randomized algorithm for computing the minimum spanning forest of a weighted graph with no isolated vertices. It was developed by David Karger, Philip Klein, and Robert Tarjan. The algorithm relies on techniques from Borůvka's algorithm along with an algorithm for verifying a minimum spanning tree in linear time. It combines the design paradigms of divide and conquer algorithms, greedy algorithms, and randomized algorithms to achieve expected linear performance.\nDeterministic algorithms that find the minimum spanning tree include Prim's algorithm, Kruskal's algorithm, reverse-delete algorithm, and Borůvka's algorithm.","alt_names":[],"name":"Expected linear time MST algorithm","categories":["Randomized algorithms","Spanning tree"],"tag_line":"A randomized algorithm for computing the minimum spanning forest of a weighted graph with no isolated vertices."}}
,{"_index":"throwtable","_type":"algorithm","_id":"deutsch–jozsa-algorithm","_score":0,"_source":{"description":"The Deutsch–Jozsa algorithm is a quantum algorithm, proposed by David Deutsch and Richard Jozsa in 1992 with improvements by Richard Cleve, Artur Ekert, Chiara Macchiavello, and Michele Mosca in 1998. Although of little practical use, it is one of the first examples of a quantum algorithm that is exponentially faster than any possible deterministic classical algorithm. It is also a deterministic algorithm, meaning that it always produces an answer, and that answer is always correct.","alt_names":[],"name":"Deutsch–Jozsa algorithm","categories":["Quantum algorithms"],"tag_line":"The Deutsch–Jozsa algorithm is a quantum algorithm, proposed by David Deutsch and Richard Jozsa in 1992 with improvements by Richard Cleve, Artur Ekert, Chiara Macchiavello, and Michele Mosca in 1998."}}
,{"_index":"throwtable","_type":"algorithm","_id":"binary-search-algorithm","_score":0,"_source":{"description":"In computer science, a binary search or half-interval search algorithm finds the position of a target value within a sorted array. The binary search algorithm can be classified as a dichotomic divide-and-conquer search algorithm and executes in logarithmic time.\n\n","alt_names":["iterative implementation","ثنائي","的二进制搜索","binária","binært","द्विआधारी","binarny","ikili","binärt","binară","duuma","двоичный","binær","binární vyhledávání","binarna","busca binária","বাইনারি","binarel","binary search","binarno","Binary search","Binary Search","'ricerca binaria'",", तो","- Binary chop :","- Binary search :","- Binary search algorithm :","-> Read the article about 'Binary search algorithm'",". Binärsuche l","...Wikipedia Dichotomie","...Wikipedia Pesquisa binária","...Wikipedia Ricerca dicotomica","...Wikipedia Wyszukiwanie binarne","...mehr auf Wikipedia über Binäre Suche","2 ⌈ log 2 k ⌉","2.1 Number guessing game","2.2 Word lists","2.3 Applications to complexity theory","2.4 That it is fast","2.4.1 Average performance","2.4.2 Inserting and deleting elements","2.6.1 Exclusive or inclusive bounds","2.6.2 Deferred detection of equality","2.6.3 Midpoint and width","2分探索","3 Computer usage","3.1 The algorithm","3.1.1 Numerical difficulties","3.2 Implementations","3.2.1 Iterative","3.2.2 Recursive","4 Applications to complexity theory","5.http://ro.wikipedia.org/wiki/C%C4","90% of programmers get it wrong",": http://en.wikipedia.org/wiki/Binary_search","@ 이진 검색(위키피디아)","A binary sear","About Binary Search","Bently writes about it in Programming Pearls","Bin rn vyhled v n Wikipedie","Bin rne vyh ad vanie Wikip dia","Binaire Zoeken Stylee:","Binaire de recherche","Binaire zoek","Binairy search","Binarno iskanje","Binarno iskanje - Wikipedija, prosta enciklopedija","Binarno pretraživanje","Binarno pretraživanje - Wikipedia","Binary Cari","Binary Chop","Binary Search (Wikipedia)","Binary Search (wiki)","Binary Search (二分搜尋法)","Binary Search - a technique for finding a particular","Binary Search Algorithim","Binary Search Algorithm","Binary Search Algorithm - Wikipedia, The Free Encyclopedia","Binary Search Algorithm article on Wikipedia","Binary Search Algorithm:","Binary Search Algoritma mantığı","Binary Search Method","Binary Search algorithm","Binary Search algoritme","Binary Search on Wikipedia","Binary Search stylee:","Binary Search-algoritme","Binary Search.","Binary SearchBinary search algorithm(Wikipedia)","Binary Searchlist","Binary chop","Binary ricerca","Binary search (Wikipedia)","Binary search - Wikipedia, the free encyclopedia","Binary search algorithm","Binary search algorithm (From wikipedia)","Binary search algorithm - Wikipedia :: The free encyclopedia","Binary search algorithm - Wikipedia, the free ...","Binary search algorithm - Wikipedia, the free enc...","Binary search algorithm - Wikipedia, the free ency...","Binary search algorithm - Wikipedia, the free encyclopedia","Binary search algorithm - Wikipedia, the free encyclopedia ...","Binary search algorithm - Wikipedia, the free encyclopedia wikipedia","Binary search algorithm - Wikipedia, the free...","Binary search algorithm - Wikipedia, the free…","Binary search algorithm - Wikipedi…","Binary search algorithm - wiki","Binary search algorithm Wikipedia the free encyclopedia","Binary search algorithm at Wikipedia","Binary search algorithm to take in","Binary search algorithm →","Binary search algorithm: Locate the middle in one","Binary search algorithm; it is used under the","Binary search description","Binary search entry","Binary search:","Binary search: Wikipedia article on binary search (focus","Binary search; it is used under the","Binary stylee Ricerca:","Binary søgealgoritme","Binary zoek","BinarySearch","BinarySearch metodo","BinarySearch-algorithm","Binary_chop","Binary_search","Binary_search_algorithm","BinÃ¤re Suche â€“ Wikipedia","Bináris keresés","Binárne vyhľadáme","Binárne vyhľadávanie","Binární vyhledávání","Binární vyhledávání - Wikipedie","Binär-Benutzer.","Binär-Suche","Binäre Suche","Binäre Suche (vgl. Pseudocode)","Binäre Suche - Wikipedia","Binäre Suche ? Wikipedia","Binäre Suche @Wikipedia","Binäre Suche Algorithmus","Binäre Suche Wikipedia","Binäre Suche stylee:","Binäre Suche – Wikipedia","Binäre_Suche","Binären Suche","Binärer Suche","Binärsuche","Binärsökning","Binær søgning","Bsearch","Bsearch; it is used under the","Busca Binaria","Busca Binária","Busca Binária (ou Binary Search)","C utare binar Wikipedia","Click here to visit your second site.","Căutare binară","De busca binária","Dichotomie - Wikip?dia","Dichotomie - Wikipédia","Encyclopedia: Binary search algorithm","Entre autres","First-year computer science.","Gli errori software (chiamati in gergo 'bug')","In informatica, la ricerca dicotomica (o ricerca binaria","La dichotomie","La ricerca binaria","Learn about Bsearch>>>","Link#3","Makes perfect sense to me","Need more ???","Nhị phân tìm kiếm","Number Guessing Game","O(log n) binary search","Pencarian Biner","Pencarian Biner - Wikipedia Bahasa Indonesia, Ensiklopedia Bebas","Pencarian biner","Pencarian biner - Wikipedia bahasa Indonesia, ensiklopedia bebas","Pesquisa Binária","Pesquisa binria pdia a enciclopdia livre","Pesquisa binária","Pesquisa binária - Wikipédia, a enciclopédia livre","Pesquisa binária ? Wikipédia, a enciclopédia livre","Pesquisa binária – Wikipédia, a enciclopédia livre","Przeszukiwanie binarne","Puolitushaku","Recherche Dichotomique","Recherche dichotomique","Recursive Implementation","Ricerca Binaria","Ricerca Dicotomica","Ricerca binaria","Ricerca dicotomica","Ricerca dicotomica - Wikipedia","Searching algorithms","Suchschritte berechnung","Three-way comparison example","Thumbnail of screenshot of Binary search algorithm - Wikipedia","Vikipedi'deki İkili Arama","What are some examples of Binary search algorithm","Wiki : Binary Search","Wiki Binary search","Wiki: Binäre Suche","WikiPeja:二分探索","Wikipedia (Binary search algorithm)","Wikipedia (engels) voor binair zoeken","Wikipedia - Binary Search","Wikipedia - Binary Search Algorithm","Wikipedia - Căutare binară","Wikipedia Binary Search","Wikipedia Binary Search Algorithm","Wikipedia article Binary chop","Wikipedia article Binary search","Wikipedia article Binary search algorithm","Wikipedia article Binäre Suche","Wikipedia article Bsearch","Wikipedia article Pesquisa binária","Wikipedia article on Binary search","Wikipedia article on Bsearch","Wikipedia article on binary search","Wikipedia article Δυαδική αναζήτηση","Wikipedia article Двоичный поиск","Wikipedia article बाइनरि सर्च","Wikipedia binary search information","Wikipedia entry for Binary search algorithm","Wikipedia page on Binary Search Algorithm","Wikipedia, article on Binary Search","Wikipedia-Artikel Binäre Suche","Wikipedia-Artikel Binärsuche","Wikipedia-Artikel Boolesche Suche","Wikipedia-Artikel zur binär Suche","Wikipedia-Artikel über binäre Suche","Wikipedia-Dichotomie","Wikipedia-Seite zu 'Binäre Suche'","Wikipedia-Seite zu 'Binärsuche'","Wikipedia-Seite: Binäre Suche","Wikipedia-artikel om binær søgning","Wikipedia.ja:二分探索","Wikipedia: Algoritmo de Pesquisa Binária:","Wikipedia: Binary Search","Wikipedia: Binary Search Algorithm","Wikipedia: Binary Search Algorithm:","Wikipedia: Binary algorithme de recherche:","Wikipedia: Binary search algorithm","Wikipedia: Binary search algorithm.","Wikipedia: Binäre Suche:","Wikipedia: Tìm kiếm nhị phân Thuật toán:","Wikipedia: algoritmo de búsqueda binaria:","Wikipedia::Binary_search_algorithm","Wikipedia:Binary Search","Wikipedia:Ricerca_binaria","Wikipediaで「2分探索」を調べる","Wikipediaで「バイナリサーチ」を調べる","Wikipediaで「二分探索」を調べる","Wikipediaで「二分探索法」を調べる","Wikipédia \\ Dichotomie","Wikipédia artigo Busca Binária","Wikipédia artigo Pesquisa binária","Wyszukiwanie binarne","Wyszukiwanie binarne – Wikipedia, wolna encyklopedia","Wyszukiwanie binarne – Wikipedia, wolna…","Wyszukiwaniebinarne – Wikipedia, wolna encyklopedia","a binary search algorithm","a number based on a given name","algorithm from wikipedia","algorithme de recherche binaire","algorithme dichotomique","algoritma pencarian biner","algoritmo de búsqueda binaria","algoritmo de pesquisa binária","algoritmo di ricerca binaria","algorytm wyszukiwania binarnego","algorytmu Binary Search","algorytmu wyszukiwania binarnego","algunas sutilezas","all about binary search","ar:خوارزمية البحث الثنائي","article on binary search","artigo da Wikipédia Pesquisa binária","artykuł w Wikipedii wyszukiwanie binarne","artículo de wikipedia sobre la búsqueda binaria","avoid overflow","b5e802c9e84df78d4ec77e67144 ...","bianry search","binair zoekalgoritme","binair zoekt","binaire zoek","binaire zoekopdracht","binaires de recherche","binari di ricerca.","binario de búsqueda","binario di ricerca","binarios de búsqueda.","binarju","binarny algorytm wyszukiwania","binary Search","binary chop","binary paghahanap,","binary search (see wikipedia article)","binary search Stylee:","binary search algorithm","binary search algorithms","binary search algoritme","binary search at wikipedia","binary search in a sorted array","binary search instead.","binary search method","binary search on wikipedia.","binary search pattern","binary search,","binary search.","binary searched","binary searches","binary searching","binary sorts","binary vyhledávání","binary ค้นหา.","binary-search","binary-search algorithm","binary-zoek","binarysearch","binární hledání","binární vyhledávací algoritmus","binární-vyhledávání","binárního vyhledávání","binárního vyhledávání algoritmus","binárním vyhledávání","binäre Suchalgorithmus","binäre Suche","binäre Suche stylee:","binäre Suche,","binäre Suche-Algorithmus.","binäre Suche.","binären Suchalgorithmus","binären Suche","binären Suche,","binären suche","binärer Suche","binärsökning","binær søgealgoritme","binær søgning","binær søgning algoritme","binær-søgning","binærsøk","binêr","binārs","bitarra","bs:Binarno pretraživanje","bsearch","bsearch - Wikipedia, the free encyclopedia","bsearch()","bsearch,","busca binária,","busca binária.","búsqueda binaria,","búsqueda binaria.","cautarea binara","ci-après.","comment rechercher rapidement dans l'historique d'un","cs:Binární vyhledávání","de búsqueda binaria","de la búsqueda binaria","de pesquisa binária,","de recherche binaire","de.wikipedia.org/wiki/Bin%C3%A4re_Suche","de:Binäre Suche","decent strategy","deuaidd","di ricerca binaria","dichotomes","dichotomic divide and conquer search algorithm","dichotomie (sur Wikipedia®)","dichotomie.","dichotomique","dichotomiquement","dichotomiques","dichotomy algorithm","divide the set in half","el algoritmo de búsqueda binaria","el:Δυαδική αναζήτηση","emmer en de Medde pecke","en.wikipedia.org ---- Binary search algorithm - Wikipedia, the","en.wikipedia.org/...Binary_search","en.wikipedia.org/...Binary_search_algorithm","en.wikipedia.org/wiki/Binary_search","en.wikipedia.org/wiki/Binary_search#The_algorithm","en.wikipedia.org/wiki/Binary_search_algorithm","en.wikipedia.org/wiki/Binary_search_algorithm#Computer_usage","en.wikipedia.org/wiki/Binary_search_algorithm#Implementations","en.wikipedia.org/wiki/Binary_search_algorithm#The_algorithm","en.wikipedia.org/wiki/Bsearch","esquisa binária","example implementations","f binary","fa.wikipedia.org/wiki/الگوریتم_جستجوی_دودویی","fa:الگوریتم جستجوی دودویی","faster ways","fi:Puolitushaku","fr.wikipedia.org/wiki/Dichotomie","fr:Dichotomie","fácil de encontrar","halveringsmetoden","he:חיפוש בינארי","hi:द्विआधारी खोज प्रणाली (Binary search algorithm)","http://bs.wikipedia.org/wiki/Binarno_pretra%C5%BEivanje","http://cs.wikipedia.org/wiki/Binární_vyhledávání","http://de.wikipedia.org/wiki/Bi näre_Suche","http://de.wikipedia.org/wiki/Bin%C3%A4re_Suche","http://de.wikipedia.org/wiki/Bin%C3%A4rsuche","http://de.wikipedia.org/wiki/Binäre_Suche","http://de.wikipedia.org/wiki/Binärsuche","http://el.wikipedia.org/wiki/Δυαδική_αναζήτηση","http://en.wikipedia. : org/wiki/Binary_search","http://en.wikipedia. org/wiki/Binary_search","http://en.wikipedia....i/Binary_search","http://en.wikipedia.org/w...i/Binary_search_algorithm","http://en.wikipedia.org/wiki/Binary search","http://en.wikipedia.org/wiki/Binary_...Equal_elements","http://en.wikipedia.org/wiki/Binary_..._guessing_game","http://en.wikipedia.org/wiki/Binary_...mplementations","http://en.wikipedia.org/wiki/Binary_chop","http://en.wikipedia.org/wiki/Binary_sear...fficulties","http://en.wikipedia.org/wiki/Binary_searc...orithm","http://en.wikipedia.org/wiki/Binary_search","http://en.wikipedia.org/wiki/Binary_search .","http://en.wikipedia.org/wiki/Binary_search#Equal_elements","http://en.wikipedia.org/wiki/Binary_search#Examples","http://en.wikipedia.org/wiki/Binary_search#It...","http://en.wikipedia.org/wiki/Binary_search#Iterative","http://en.wikipedia.org/wiki/Binary_search#Numerical_difficulties","http://en.wikipedia.org/wiki/Binary_search#Recursive","http://en.wikipedia.org/wiki/Binary_search#Single_comparison_per_iteration","http://en.wikipedia.org/wiki/Binary_search#Syntax_difficulties","http://en.wikipedia.org/wiki/Binary_search#The_algorithm","http://en.wikipedia.org/wiki/Binary_search.","http://en.wikipedia.org/wiki/Binary_search...r_guessing_game","http://en.wikipedia.org/wiki/Binary_search_al...","http://en.wikipedia.org/wiki/Binary_search_algorit ...","http://en.wikipedia.org/wiki/Binary_search_algorit. . .","http://en.wikipedia.org/wiki/Binary_search_algorithm","http://en.wikipedia.org/wiki/Binary_search_algorithm # Average_performance","http://en.wikipedia.org/wiki/Binary_search_algorithm#Average_performance","http://en.wikipedia.org/wiki/Binary_search_algorithm#Implemen...","http://en.wikipedia.org/wiki/Binary_search_algorithm#Implementations","http://en.wikipedia.org/wiki/Binary_search_algorithm#Number_guessing_game","http://en.wikipedia.org/wiki/Binary_search_algorithm#Numerical_difficulties","http://en.wikipedia.org/wiki/Binary_search_algorithm#Recursive","http://en.wikipedia.org/wiki/Binary_search_algorithm#Single_comparison_per_iteration","http://en.wikipedia.org/wiki/Binary_search_algorithm#The_alg...","http://en.wikipedia.org/wiki/Binary_search_algorithm.","http://en.wikipedia.org/wiki/Binary_search_algorithmを","http://en.wikipedia.org/wiki/Binary_search_algorithm을","http://en.wikipedia.org/wiki/Binary_search_algorithm＃Average_performance","http://en.wikipedia.org/wiki/Bsearch","http://en.wikipedia.​org/wiki/Binary_sear​ch_algorithm","http://fi.wikipedia....ki/Puolitushaku","http://fi.wikipedia.org/wiki/Puolitushaku","http://fr.wikipedia....wiki/Dichotomie","http://fr.wikipedia.org/wiki/Dichotomie","http://fr.wikipedia.org/wiki/Dichotomie#Algorithme","http://fr.wikipedia.org/wiki/Dichotomie(...)","http://fr.wikipedia.org/wiki/Recherche_dichotomique","http://he.wikipedia....%90%D7%A8%D7%99","http://id.wikipedia.org/wiki/Pencarian_bin","http://id.wikipedia.org/wiki/Pencarian_biner","http://it.wikipedia.org/wiki/Ricerca_binaria","http://it.wikipedia.org/wiki/Ricerca_bin…","http://it.wikipedia.org/wiki/Ricerca_dicotomica","http://it.wikipedia.org/wiki/Ricerca_dic…","http://ja.wikipedia.org/wiki/二分探索","http://pl.wikipedia....kiwanie_binarne","http://pl.wikipedia.org/wiki/W[...]ne#Wyszukiwanie_interpolacyjne","http://pl.wikipedia.org/wiki/Wyszukiwanie_binarne","http://pl.wikipedia.org/wiki/Wyszukiwanie_binarne#Wyszukiwanie_interpolacyjne","http://pt.wikipedia....sa_bin%C3%A1ria","http://pt.wikipedia.org/wiki/Busca_Bin%C3%A1ria","http://pt.wikipedia.org/wiki/Busca_bin%C3%A1ria","http://pt.wikipedia.org/wiki/Pesquisa_bin%C3%A1ria","http://pt.wikipedia.org/wiki/Pesquisa_binÃ¡ria","http://pt.wikipedia.org/wiki/Pesquisa_binária","http://pt.wikipedia.org/wiki/Pesquisa_bi…","http://ru.wikipedia.org/wiki/Бинарный_по...","http://ru.wikipedia.org/wiki/Бинарный_поиск","http://ru.wikipedia.org/wiki/Двоичный_по...","http://ru.wikipedia.org/wiki/Двоичный_поиск","http://sk.wikipedia.org/wiki/Bin%C3%A1r","http://sk.wikipedia.org/wiki/Bin%C3%A1rne_vyh","http://sk.wikipedia.org/wiki/Binárne_vyhľadávanie","http://sv.wikipedia.org/wiki/Bin%C3%A4rs","http://tr.wikipedia.org/wiki/%C4%B0k...goritmas","http://tr.wikipedia.org/wiki/%C4%B0kili_Arama","i suck, too","id.wikipedia.org/wiki/Pencarian_biner","id:Pencarian biner","is assumed to be already sorted","it.wikipedia.org/wiki/Ricerca_dicotomica","it:Ricerca dicotomica","ja:二分探索","ko:이진 검색 알고리즘","kumu hoʻohui pālua","l'algorithme de recherche binaire","l'algoritmo di ricerca binaria","l'article de Wikipédia Dichotomie","la búsqueda binaria","la búsqueda binaria,","la recherche binaire,","la recherche binaire.","la recherche dichotomique","la ricerca binaria","la voce è presente anche su en.wiki","looking up something","m Wikipedia::Binary_search_algorithm","masser af information","mk:Бинарно пребарување","monde dichotomique,","método dicotómico","nakahalo sa dalawa","ne:बाइनरि सर्च","nhị phân tìm kiếm","no:Binærsøk","not to make a second test at all","o algoritmo de pesquisa binária","page Dichotomie de Wikipedia","pencarian biner","pencarian biner wikipedia bahasa indonesia ensiklopedia bebas","pencarian biner,","pencarian biner.","pesquisa (ou busca) binária","pesquisa binária","pesquisa binária,","pl.wikipedia.org/wiki/Wyszukiwanie_binarne","pl:Wyszukiwanie binarne","placering","proven one.","przeszukiwania binarnego","przeszukiwanie binarne","pt.wikipedia.org/wiki/Busca_bin%C3%A1ria","pt.wikipedia.org/wiki/Pesquisa_bin%C3%A1ria","pt.wikipedia.org/wiki/Pes…","pt:Pesquisa binária","puolitushaku","puolitushausta","půlení intervalu","půlením intervalu","recherche binaire","recherche binaire,","recherche binaire.","recherche dichotomique","recherche par dichotomie","recursive binary search algorithm","ricerca binaria","ricerca binaria (o dicotomica)","ricerca binaria stylee:","ricerca binaria,","ricerca binaria.","ricerca dicotomica","ro:Căutare binară","ru.wikipedia.org/wiki/Двоичный_поиск","ru:Двоичный поиск","s binary searc","s binary search","single comparison per iteration","sk:Binárne vyhľadávanie","sl:Binarno iskanje","stylee binarios de búsqueda:","stylee busca binária:","stylee recherche binaire:","stylee двоичного поиска:","sv:Binärsökning","the binary search","the binary search algorithm","the binary search.","the formula that I used","thuật toán tìm kiếm nhị phân","tr:İkili arama algoritması","tìm kiếm nhị phân","tìm kiếm nhị phân,","tìm kiếm nhị phân.","uk:Двійковий пошук","very efficient","w:2分探索","wikipedia article on binary search","wikipedia artikel over binair zoeken","wikipedia:binary search","wp:Binary search algorithm","wyszuka binarnie","wyszukiwania binarnego","wyszukiwanie binarne","wyszukiwaniem binarnym","zh-yue:對分檢索","zh:折半搜索算法","|Link to article on Wikipedia|","İkili Arama","İkili arama algoritması","İkili arama algoritması - Vikipedi","Δυαδική αναζήτηση","δυαδικής αναζήτησης","Алгоритм бинарного поиска","Бинарно пребарување","Бинарный поиск","Википедии статью Бинарный поиск","Википедии статью Двоичный поиск","Википедии: двоичный алгоритм поиска:","Двоиный поиск","Двоичный поиск","Двоичный_поиск","Двійковий пошук","алгоритм бинарного поиска","алгоритм двоичного поиска","алгоритма бинарного поиска","алгоритма двоичного поиска","бинарен","бинарно","бинарного поиска","бинарного поиска,","бинарном алгоритме поиска","бинарный поиск","бинарный поиск,","бинарный поиск.","бинарным поиском","бинпоиске","двайковага пошуку алгарытму","двайковы","двоично търсене","двоичного поиска","двоичного поиска,","двоичното търсене","двоичный поиск","двоичным поиском","двійковий","двійковий по-","двійковий пошук","двійкового пошуку","икеле","метод бинарного поиска","метод половинного деления","переделать метод под задачу","правильное решение","про описание алгоритма двоичного (бинарного) поиска ?","статью Википедии на бинарный поиск","это хорошо известно","אריה במדבר","ויקיפדיה - 'חיפוש בינארי'","חיפוש בינארי","חיפוש בינארי :","חיפוש בינארי – ויקיפדיה","חיפוש מהיר במערך ממויין","סיבוכיות של חיפוש בינארי","الگوریتم جستجوی دودویی - ویکیپدیا","جستجوی دودویی","अध्याय है","जानकारी का भार","द्विआधारी खोज","बाइनरि सर्च","बाइनरी खोज एल्गोरिथ्म","ದ್ವಿಮಾನ","ද්විමය","การ ค้นหา Binary.","การ ค้นหา แบบ ไบนารี","การค้นหาแบบไบนารี","ขั้น ตอน วิธี การ ค้นหา แบบ ไบนารี","ขั้นตอนวิธีการค้นหาแบบไบนารี","ค้นหา binary","ค้นหา binary.","ค้นหา ไบนารี","วิ กิ พี เดีย: Binary Search ขั้น ตอน","ប៊ីនែរ","“Wyszukiwanie binarne” na pl.wikipedia.org","「二分探索」をWikiで調べる","のバイナリ検索","アルゴリズムを。","バイナリの検索","バイナリサーチ","バイナリサーチは","バイナリサーチは、","バイナリサーチアルゴリズム","バイナリサーチ（二分探索）","バイナリ探索アルゴリズムの","バイナリ検索","バイナリ検索を","バイナリ検索アルゴリズム","バイナリ検索アルゴリズムを","二分取中查找算法","二分探索","二分探索 - Wikipedia","二分探索 – Wikipedia","二分探索(バイナリサーチ)","二分探索-wikipedia","二分探索-wikipedia-","二分探索stylee：","二分探索あるいはバイナリサーチ","二分探索法","二分搜尋法(binary search)","二分搜索（Binary Search","二分木検索","二分查找","二分検索","二叉查找","二进制搜索","二进制搜索stylee：","二进制搜索算法","二进制搜索维基百科条目上","二進制搜索","二進制搜索算法","折半搜索算法","検索バイナリ","的二进制搜索算法","的二進制搜索算法","維基百科：二進制搜索算法","검색 이진이","바이너리 검색(binary search)","바이너리 검색을","바이너리서치","바이너리서치(Binary Search)","이진 검색","이진 검색 알고리즘","이진 검색 알고리즘을","이진 검색,","이진 검색과","이진 검색을","이진 탐색","이진탐색기법","２分探索","２分探索法①","ﾊﾞｲﾅﾘｻｰﾁ","ﾊﾞｲﾅﾘｻｰﾁ-wikipedia"],"name":"Binary search algorithm","categories":["All articles needing cleanup","All articles with unsourced statements","Articles needing cleanup from April 2011","Articles with unsourced statements from August 2009","Articles with unsourced statements from October 2011","Cleanup tagged articles without a reason field from April 2011","Search algorithms","Wikipedia articles needing clarification from January 2015","Wikipedia pages needing cleanup from April 2011"],"tag_line":"In computer science, a binary search or half-interval search algorithm finds the position of a target value within a sorted array."}}
,{"_index":"throwtable","_type":"algorithm","_id":"best-first-search","_score":0,"_source":{"description":"Best-first search is a search algorithm which explores a graph by expanding the most promising node chosen according to a specified rule.\nJudea Pearl described best-first search as estimating the promise of node n by a \"heuristic evaluation function  which, in general, may depend on the description of n, the description of the goal, the information gathered by the search up to that point, and most important, on any extra knowledge about the problem domain.\"\nSome authors have used \"best-first search\" to refer specifically to a search with a heuristic that attempts to predict how close the end of a path is to a solution, so that paths which are judged to be closer to a solution are extended first. This specific type of search is called greedy best-first search or pure heuristic search.\nEfficient selection of the current best candidate for extension is typically implemented using a priority queue.\nThe A* search algorithm is an example of best-first search, as is B*. Best-first algorithms are often used for path finding in combinatorial search. (Note that neither A* nor B* is a greedy best-first search as they incorporate the distance from start in addition to estimated distances to the goal.)","alt_names":["- Best-first search :","-> Read the article about 'Best-first search'","...more on Wikipedia about Best-first search","1 Algorithm [3]","2 Greedy BFS","Algorithm [3]","BFS (Best-First Search)","Best First Search","Best first search","Best-","Best-First","Best-First Search","Best-eerste zoekopdracht","Best-first","Best-first Search","Best-first Search - Wikipedia, The Free Encyclopedia","Best-first Search - Wikipédia, a enciclopédia livre","Best-first Search – Wikipédia, a enciclopédia livre","Best-first Suche","Best-first search","Best-first search - Wikipedia","Best-first search - Wikipedia :: The free encyclopedia","Best-first search - Wikipedia, the free encyclopedia","Best-first search - Wikipedia, the free encyclopedia ...","Best-first search from Wikipedia","Best-first search; it is used under the","Best-first_search","Best-første søgning","Bestensuche","Greedy Alg.","Greedy BFS","Greedy best-first search","Greedy-Best-First-Search","Ricerca best-first","Tìm kiếm theo lựa chọn tốt nh...","Tìm kiếm theo lựa chọn tốt nhất","Tìm kiếm theo lựa chọn tốt nhất - Wikipedia","Wikipedia : Best-first Search","Wikipedia article Best first search","Wikipedia article Best-first search","Wikipedia article Greedy best-first search","Wikipedia article on Best-first search","Wikipedia entry for Best-first search","Wikipedia: Best-first search","Wikipediaで「最良優先探索」を調べる","Wikipédia artigo Best-first search","[ OPEN = [initial state] while OPEN is not empty","artigo da Wikipédia Best-first Search","best first","best first search","best-firs","best-first","best-first search","best-first search algorithm","chamtivý nejlepší první vyhledávací algoritmus","classical AI techniques","codicioso mejor algoritmo de búsqueda primero","de:Bestensuche","en.wikipedia.org/wiki/Best-first_sear...","en.wikipedia.org/wiki/Best-first_search","en:Best-first search","est-firs","est-first searc","gierigen beste erste Such-Algorithmus","goloso miglior primo algoritmo di ricerca","greedy best first search algorithm","greedy best-first","grådige bedste første søgealgoritme","http://de.wikipedia.org/wiki/Bestensuche","http://en.wikipedia.org/wiki/Best-first_","http://en.wikipedia.org/wiki/Best-first_search","http://en.wikipedia.org/wiki/Best-first_…","http://en.wikipedia.org/wiki/Best_first_search","http://it.wikipedia.org/wiki/Ricerca_best-first","ja:最良優先探索","najlepsze","najlepsze Przeszukiwanie","najlepszych chciwy pierwszy algorytm wyszukiwania","nejlepší-první hledání","prima ricerca-Best","primera búsqueda de mejor algoritmo codicioso","primero el mejor búsqueda","pt:Best-first Search","ru:Поиск по первому наилучшему совпадению","tìm kiếm theo lựa chọn tốt nhất","vi:Tìm kiếm theo lựa chọn tốt nhất","wikipedia's best-first","Лучшая первого поиска","Поиск по первому наилучшему совпадению","жадные лучший первый алгоритм поиска","жадных лучший первый алгоритм поиска","सर्वश्रेष्ठ","सर्वश्रेष्ठ पहली खोज","「最良優先探索」についてWikipediaで調査","ウィキペディアの記事 最良優先探索","最佳优先搜索","最良優先探索","最良優先探索 - Wikipedia","最良優先探索 -wikipedia","最良優先探索 best-first search","最良優先探索 とは","最良優先探索-wikipedia","最良優先探索は、","欲張り最良優先探索のアルゴリズムを","贪婪最佳优先搜索算法"],"name":"Best-first search","categories":["All articles with dead external links","Articles with dead external links from August 2014","Search algorithms"],"tag_line":"Best-first search is a search algorithm which explores a graph by expanding the most promising node chosen according to a specified rule."}}
,{"_index":"throwtable","_type":"algorithm","_id":"interpolation-search","_score":0,"_source":{"description":"Interpolation search (sometimes referred to as extrapolation search) is an algorithm for searching for a given key value in an indexed array that has been ordered by the values of the key. It parallels how humans search through a telephone book for a particular name, the key value by which the book's entries are ordered. In each search step it calculates where in the remaining search space the sought item might be, based on the key values at the bounds of the search space and the value of the sought key, usually via a linear interpolation. The key value actually found at this estimated position is then compared to the key value being sought. If it is not equal, then depending on the comparison, the remaining search space is reduced to the part before or after the estimated position. This method will only work if calculations on the size of differences between key values are sensible.\nBy comparison, the binary search always chooses the middle of the remaining search space, discarding one half or the other, again depending on the comparison between the key value found at the estimated position and the key value sought. The remaining search space is reduced to the part before or after the estimated position. The linear search uses equality only as it compares elements one-by-one from the start, ignoring any sorting.\nOn average the interpolation search makes about log(log(n)) comparisons (if the elements are uniformly distributed), where n is the number of elements to be searched. In the worst case (for instance where the numerical values of the keys increase exponentially) it can make up to O(n) comparisons.\nIn interpolation-sequential search, interpolation is used to find an item near the one being searched for, then linear search is used to find the exact item.","alt_names":["Interpolationssuche","-> Read the article about 'Interpolation search'","...mehr auf Wikipedia über Interpolationssuche","2 Adaptation to different datasets","3 Book-based searching","4 Sample implementation","Book-based searching","Busca por Interpolação","Find the kth smallest elements of 2 sorted","Interpolasjonssøk","Interpolati search","Interpolatie Zoeken","Interpolation Seach","Interpolation Search","Interpolation Søg","Interpolation search","Interpolation search - Wikipedia, the free encyclopedia","Interpolation search - il y a 1 mois","Interpolation search on wikipedia.org","Interpolation_search","Interpolationssuche ? Wikipedia","Interpolationssuche – Wikipedia","Intervallsuche","Jeremy Zawodny's linkblog: Interpolation search","Predictive search","Search Interpolacja","Suche Interpolation","What is performance of Interpolation search","What is performance of Interpolation search?","Wikipedia Interpolation Search","Wikipedia article Interpolation search","Wikipedia article about Interpolation search","Wikipedia article on Interpolation search","Wikipedia entry for Interpolation search","Wikipedia-Artikel Interpolationssuche","Wikipedia-Artikel Intervallsuche","Wikipedia-Seite zu 'Interpolationssuche'","búsqueda por interpolación","en.wikipedia.org/wiki/Interpolation_search","extrapolation search","fa.wikipedia.org/wiki/جستجوی_درونیابی","hledání interpolace","http://de.wikipedia.org/wiki/Interpolationssuche","http://en.wikipedia.org/wiki/Interpolation_se","http://en.wikipedia.org/wiki/Interpolation_search","http://ru.wikipedia.org/wiki/Интерполиру...","http://ru.wikipedia.org/wiki/Интерполирующий_поиск","interpolación de búsqueda","interpolasi pencarian","interpolation search","interpolative searc","interpolative search","la clé peut servir d'interpolation","pesquisa de interpolação","pure Interpolation search","recherche d'interpolation","ricerca per interpolazione","tìm kiếm nội suy","yago-res:Interpolation search","Википедии статью Интерполирующий поиск","Интерполирующий поиск","интерполяции Поиск","интерполяционный поиск","интерполяционным поиском","интерполяцию поиска","работающая за log(log(N))","جستجوی درونیابی - ویکیپدیا","प्रक्षेप खोज","การ ค้นหา การ แก้ไข","☞ Interpolation search","內插搜尋法(interpolation search)","插值搜索","補間の検索","보간 검색을"],"name":"Interpolation search","categories":["Search algorithms"],"tag_line":"Interpolation search (sometimes referred to as extrapolation search) is an algorithm for searching for a given key value in an indexed array that has been ordered by the values of the key."}}
,{"_index":"throwtable","_type":"algorithm","_id":"processor-affinity","_score":0,"_source":{"description":"Processor affinity, or CPU pinning enables the binding and unbinding of a process or a thread to a central processing unit (CPU) or a range of CPUs, so that the process or thread will execute only on the designated CPU or CPUs rather than any CPU. This can be viewed as a modification of the native central queue scheduling algorithm in a symmetric multiprocessing operating system. Each item in the queue has a tag indicating its kin processor. At the time of resource allocation, each task is allocated to its kin processor in preference to others.\nProcessor affinity takes advantage of the fact that some remnants of a process that was run on a given processor may remain in that processor's memory state (for example, data in the CPU cache) after another process is run on that CPU. Scheduling that process to execute on the same processor could result in an efficient use of process by reducing performance-degrading situations such as cache misses. A practical example of processor affinity is executing multiple instances of a non-threaded application, such as some graphics-rendering software.\nScheduling-algorithm implementations vary in adherence to processor affinity. Under certain circumstances, some implementations will allow a task to change to another processor if it results in higher efficiency. For example, when two processor-intensive tasks (A and B) have affinity to one processor while another processor remains unused, many schedulers will shift task B to the second processor in order to maximize processor use. Task B will then acquire affinity with the second processor, while task A will continue to have affinity with the original processor.","alt_names":["- CPU affinity :","- Processor affinity :","-> Read the article about 'Processor affinity'","CPU Affinity","CPU affinity","CPU-Affinität","Core affinity","Learn about Processor affinity>>>","More on Process Affinity in Wikipedia","PROCESSOR AFFINITY","Processor Affinity","Processor Affinity - Wikipedia","Processor Affinity - Wikipedia, The Free Encyclopedia","Processor affinity","Processor affinity - Wikipedia :: The free encyclopedia","Processor affinity - Wikipedia, the free encyclopedia","Processor affinity Wikipedia the free encyclopedia","Processor affinity on wikipedia.org","Processor affinity – Wikipedia, the free encyclopedia","Processor affinity; it is used under the","Prozessoraffinität","Satz der Affinität","Unit1/ Frame 4/ Multi Processing and Multi tasking","Wiki Wisdom: Affinity:","Wikipedia about processor affinity.","Wikipedia article CPU affinity","Wikipedia article Koligacja procesorów","Wikipedia article Processor affinity","Wikipedia article about Processor affinity","Wikipedia article on CPU affinity","Wikipedia article on Processor affinity","Wikipedia entry for Processor affinity","affinità di processore","affinité de processeurs","afinity","assigning a process to a CPU","core affinity","cpu affinity","en.wikipedia.org/wiki/Processor_affinity","establecer la afinidad","http://en.wikipedia....cessor_affinity","http://en.wikipedia.org/wiki/CPU_affinity","http://en.wikipedia.org/wiki/Processor affinity","http://en.wikipedia.org/wiki/Processor_a...","http://en.wikipedia.org/wiki/Processor_affini...","http://en.wikipedia.org/wiki/Processor_affinity","http://en.wikipedia.org/wiki/Processor_affinity)","http://pl.wikipedia.org/wiki/Koligacja_procesor%C3%B3w","impostare l'affinità","indstille affinitet","ja:プロセッサ親和性","koligacjï¿½","koligację","nastavení afinity","processor affinities","processor affinity","processor affinitásnak","processor and memory affinity","set processor affinity, in task manager.","set the affinity","the processor affinity","thread affinity","thread processor affinity","wikipedia - Processor affinity","wikipedia processor affinity","zestaw powinowactwa","набор сродство","プロセッサ親和性 - Wikipedia","处理器亲和度","親和性を設定"],"name":"Processor affinity","categories":["Processor scheduling algorithms"],"tag_line":"Processor affinity, or CPU pinning enables the binding and unbinding of a process or a thread to a central processing unit (CPU) or a range of CPUs, so that the process or thread will execute only on the designated CPU or CPUs rather than any CPU."}}
,{"_index":"throwtable","_type":"algorithm","_id":"finger-search-tree","_score":0,"_source":{"description":"In computer science, finger search trees are a type of binary search tree that keeps pointers to interior nodes, called fingers. The fingers speed up searches, insertions, and deletions for elements close to the fingers, giving amortized O(log n) lookups, and amortized O(1) insertions and deletions. It should not be confused with a finger tree nor a splay tree, although both can be used to implement finger search trees.\nGuibas et al. introduced ﬁnger search trees, by building upon B-trees. The original version supports ﬁnger searches in O(log d) time, where d is the number of elements between the ﬁnger and the search target. Updates take O(1) time, when only O(1) moveable ﬁngers are maintained. Moving a ﬁnger p positions requires O(log p) time. Huddleston and Mehlhorn refined this idea as level-linked B-trees.\nTsakalidis proposed a version based on AVL trees that facilitates searching from the ends of the tree; it can be used to implement a data structure with multiple fingers by using multiple of such trees.\nTo perform a finger search on a binary tree, the ideal way is to start from the finger, and search upwards to the root, until we reach the turning node or the least common ancestor of x and y, and then go downwards to find the element we're looking for. Determining if a node is the ancestor of another is non-trivial.\n\nTreaps, a randomized tree structure proposed by Seidel and Aragon, has the property that the expected path length of two elements of distance d is O(log d). For finger searching, they proposed adding pointers to determine the least common ancestor(LCA) quickly, or in every node maintain the minimum and maximum values of its subtree.\nA book chapter has been written that covers finger search trees in depth. In which, Brodal suggested an algorithm to perform finger search on treaps in O(log d) time, without needing any extra bookkeeping information; this algorithm accomplishes this by concurrently searching downward from the last candidate LCA.","alt_names":[],"name":"Finger search tree","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Pages using citations with accessdate and no URL","Search algorithms","Trees (data structures)"],"tag_line":"In computer science, finger search trees are a type of binary search tree that keeps pointers to interior nodes, called fingers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"gang-scheduling","_score":0,"_source":{"description":"In computer science, gang scheduling is a scheduling algorithm for parallel systems that schedules related threads or processes to run simultaneously on different processors. Usually these will be threads all belonging to the same process, but they may also be from different processes, for example when the processes have a producer-consumer relationship, or when they all come from the same MPI program.\nGang scheduling is used so that if two or more threads or processes communicate with each other, they will all be ready to communicate at the same time. If they were not gang-scheduled, then one could wait to send or receive a message to another while it is sleeping, and vice versa. When processors are over-subscribed and gang scheduling is not used within a group of processes or threads which communicate with each other, it can lead to situations where each communication event suffers the overhead of a context switch.\nTechnically, gang scheduling is based on a data structure called the Ousterhout matrix. In this matrix each row represents a time slice, and each column a processor. The threads or processes of each job are packed into a single row of the matrix. During execution, coordinated context switching is performed across all nodes to switch from the processes in one row to those in the next row.\nGang scheduling is stricter than coscheduling. It requires all threads of the same process to run concurrently, while coscheduling allows for fragments, which are sets of threads that do not run concurrently with the rest of the gang.\nGang scheduling was implemented and used in production mode on several parallel machines, most notably the Connection Machine CM-5.","alt_names":["...more on Wikipedia about Gang scheduling","Gang Schedule","Gang scheduling","Gang scheduling - Wikipedia, the free encyclopedia","Wikipedia (Gang scheduling)","Wikipedia article ''Gang scheduling''","Wikipedia article Gang scheduling","Wikipedia article on Gang scheduling","Wikipedia entry for Gang scheduling","en.wikipedia.org/wiki/Gang_scheduling","en:Gang scheduling","gang scheduler","gang scheduling","http://en.wikipedia.org/wiki/Gang_schedu","http://en.wikipedia.org/wiki/Gang_scheduling","yago-res:Gang scheduling"],"name":"Gang scheduling","categories":["All stub articles","Computer science stubs","Processor scheduling algorithms"],"tag_line":"In computer science, gang scheduling is a scheduling algorithm for parallel systems that schedules related threads or processes to run simultaneously on different processors."}}
,{"_index":"throwtable","_type":"algorithm","_id":"linear-hashing","_score":0,"_source":{"description":"Linear hashing is a dynamic hash table algorithm invented by Witold Litwin (1980), and later popularized by Paul Larson. Linear hashing allows for the expansion of the hash table one slot at a time. The frequent single slot expansion can very effectively control the length of the collision chain. The cost of hash table expansion is spread out across each hash table insertion operation, as opposed to being incurred all at once. Linear hashing is therefore well suited for interactive applications.","alt_names":["...more on Wikipedia about Linear hash","Adoption in language systems","Algorithm Details","Hash Linear Quadro,","Hash Linear bàn,","Hashing lineal","Lineaire Hashing","Linear Hash","Linear Hash Tabel,","Linear Hash Table","Linear Hash-Tabelle,","Linear Hashing","Linear hash","Linear hash - Wikipedia","Linear hash - Wikipedia, the free encyclopedia","Linear hash on Wikipedia","Linear hash table","Linear hashing","Linear hashing - Wikipedia, the free encyclopedia","Linear hashing Wikipedia the free encyclopedia","Linear hashing Wikipedia, the free ...","Linear_hashing","Wikipedia (Linear hash)","Wikipedia article Linear hash","Wikipedia article Linear hashing","Wikipedia article on Linear hash","Wikipedia article on Linear hashing","Wikipedia entry for Linear hashing","en.wikipedia.org/Linear_hash","en.wikipedia.org/wiki/Linear_hashing","http://en.wikipedia.org/wiki/Linear_hash","http://en.wikipedia.org/wiki/Linear_hashing","http://en.wikipedia.org/wiki/Linear_hash…","lineair Hash Table","linear hash","linear hash table","linear hash tables","linear hashing","linear hashing.","linear_hashing","lineare Hash Table,","liner hashing refer Wikipedia","lineær Hash tabel","tabla hash lineal,","table de hachage linéaire,","yago-res:Linear hashing","линейного хеширования","линейных хэш-таблицу,","เส้น ตาราง แฮ ช","リニアハッシュテーブル","線性哈希表","线性哈希表","线性散列","선형 해시 테이블,"],"name":"Linear hashing","categories":["Hashing","Search algorithms"],"tag_line":"Linear hashing is a dynamic hash table algorithm invented by Witold Litwin (1980), and later popularized by Paul Larson."}}
,{"_index":"throwtable","_type":"algorithm","_id":"mamf","_score":0,"_source":{"description":"MaMF, or Mammalian Motif Finder, is an algorithm for identifying motifs to which transcription factors bind.\nThe algorithm takes as input a set of promoter sequences, and a motif width(w), and as output, produces a ranked list of 30 predicted motifs(each motif is defined by a set of N sequences, where N is a parameter).\nThe algorithm firstly indexes each sub-sequence of length n, where n is a parameter around 4-6 base pairs, in each promoter, so they can be looked up efficiently. This index is then used to build a list of all pairs of sequences of length w, such that each sequence shares an n-mer, and each sequence forms an ungapped alignment with a substring of length w from the string of length 2w around the match, with a score exceeding a cut-off.\nThe pairs of sequences are then scored. The scoring function favours pairs which are very similar, but disfavours sequences which are very common in the target genome. The 1000 highest scoring pairs are kept, and the others are discarded. Each of these 1000 'seed' motifs are then used to search iteratively search for further sequences of length which maximise the score(a greedy algorithm), until N sequences for that motif are reached.\nVery similar motifs are discarded, and the 30 highest scoring motifs are returned as output.","alt_names":["Ma Mf","MaMF","MaMF - Wikipedia, the free encyclopedia","Wikipedia article MaMF","Wikipedia article on MaMF","Wikipedia entry for MaMF","http://en.wikipedia.org/wiki/MaMF","yago-res:MaMF"],"name":"MaMF","categories":["All orphaned articles","Bioinformatics","Orphaned articles from October 2008","Search algorithms"],"tag_line":"MaMF, or Mammalian Motif Finder, is an algorithm for identifying motifs to which transcription factors bind."}}
,{"_index":"throwtable","_type":"algorithm","_id":"any-angle-path-planning","_score":0,"_source":{"description":"Any-angle path planning algorithms search for paths on a cell decomposition of a continuous configuration space (such as a two-dimensional terrain).\n\n","alt_names":["Any Angle Path Planning","Any-angle path planning","Any-angle path planning - Wikipedia :: The free encyclopedia","Any-angle path planning - Wikipedia, the free encyclopedia","Any-angle path planning Wikipedia the free encyclopedia","Any-angle_path_planning","Field D*","How to apply for Any angle path planning","Wikipedia article Any-angle path planning","Wikipedia entry for Any-angle path planning","http://en.wikipedia.org/wiki/Any-angle_path_planning","n12:Any-angle_path_planning","yago-res:Any-angle path planning"],"name":"Any-angle path planning","categories":["Artificial intelligence","Robot navigation","Search algorithms"],"tag_line":"Any-angle path planning algorithms search for paths on a cell decomposition of a continuous configuration space (such as a two-dimensional terrain).\n\n"}}
,{"_index":"throwtable","_type":"algorithm","_id":"sss*","_score":0,"_source":{"description":"SSS* is a search algorithm, introduced by George Stockman in 1979, that conducts a state space search traversing a game tree in a best-first fashion similar to that of the A* search algorithm.\nSSS* is based on the notion of solution trees. Informally, a solution tree can be formed from any arbitrary game tree by pruning the number of branches at each MAX node to one. Such a tree represents a complete strategy for MAX, since it specifies exactly one MAX action for every possible sequence of moves might be made by the opponent. Given a game tree, SSS* searches through the space of partial solution trees, gradually analyzing larger and larger subtrees, eventually producing a single solution tree with the same root and Minimax value as the original game tree. SSS* never examines a node that alpha-beta pruning would prune, and may prune some branches that alpha-beta would not. Stockman speculated that SSS* may therefore be a better general algorithm than alpha-beta. However, Igor Roizen and Judea Pearl have shown that the savings in the number of positions that SSS* evaluates relative to alpha/beta is limited and generally not enough to compensate for the increase in other resources (e.g., the storing and sorting of a list of nodes made necessary by the best-first nature of the algorithm). However, Aske Plaat, Jonathan Schaeffer, Wim Pijls and Arie de Bruin have shown that a sequence of null-window alpha-beta calls is equivalent to SSS* (i.e., it expands the same nodes in the same order) when alpha-beta is used with a transposition table, as is the case in all game-playing programs for chess, checkers, etc. Now the storing and sorting of the OPEN list were no longer necessary. This allowed the implementation of (an algorithm equivalent to) SSS* in tournament quality game-playing programs. Experiments showed that it did indeed perform better than Alpha-Beta in practice, but that it did not beat NegaScout.\nThe reformulation of a best-first algorithm as a sequence of depth-first calls prompted the formulation of a class of null-window alpha-beta algorithms, of which MTD-f is the best known example.\n^ Roizen, Igor; Judea Pearl (March 1983). \"A minimax algorithm better than alpha-beta?: Yes and No\". Artificial Intelligence 21 (1-2): 199–220. doi:10.1016/s0004-3702(83)80010-1. \n^ Plaat, Aske; Jonathan Schaeffer; Wim Pijls; Arie de Bruin (November 1996). \"Best-first Fixed-depth Minimax Algorithms\". Artificial Intelligence 87 (1-2): 255–293. doi:10.1016/0004-3702(95)00126-3.","alt_names":["Algoritmo SSS","Algoritmo SSS - Wikipedia, la enciclopedia libre","SSS Star","SSS*","SSS* - Wikipedia, The Free Encyclopedia","SSS* - Wikipedia, the free encyclopedia","SSS* - Wikipedia, the free encyclopedia - Wikipedia","SSS* |","Wikipedia article SSS*","Wikipedia article about SSS*","Wikipedia article on SSS*","Wikipedia entry for SSS*","artículo de Wikipedia Algoritmo SSS","en.wikipedia.org/wiki/SSS*","es:Algoritmo SSS","http://en.wikipedia.org/wiki/SSS%2A","http://en.wikipedia.org/wiki/SSS*","http://es.wikipedia.org/wiki/Algoritmo_SSS","http://pl.wikipedia.org/wiki/SSS%2A","http://pl.wikipedia.org/wiki/SSS*","pl:SSS*","sss the free encyclopedia","sss* wikipedia the free encyclopedia","yago-res:SSS*","∙ SSS* - Wikipedia, the fre..."],"name":"SSS*","categories":["All articles needing additional references","Articles needing additional references from February 2010","Search algorithms"],"tag_line":"SSS* is a search algorithm, introduced by George Stockman in 1979, that conducts a state space search traversing a game tree in a best-first fashion similar to that of the A* search algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bootstrapping-populations","_score":0,"_source":{"description":"Starting with a sample  observed from a random variable X having a given distribution law with a set of non fixed parameters which we denote with a vector , a parametric inference problem consists of computing suitable values – call them estimates – of these parameters precisely on the basis of the sample. An estimate is suitable if replacing it with the unknown parameter does not cause major damage in next computations. In Algorithmic inference, suitability of an estimate reads in terms of compatibility with the observed sample.\nIn this framework, resampling methods are aimed at generating a set of candidate values to replace the unknown parameters that we read as compatible replicas of them. They represent a population of specifications of a random vector   compatible with an observed sample, where the compatibility of its values has the properties of a probability distribution. By plugging parameters into the expression of the questioned distribution law, we bootstrap entire populations of random variables compatible with the observed sample.\nThe rationale of the algorithms computing the replicas, which we denote population bootstrap procedures, is to identify a set of statistics  exhibiting specific properties, denoting a well behavior, w.r.t. the unknown parameters. The statistics are expressed as functions of the observed values , by definition. The  may be expressed as a function of the unknown parameters and a random seed specification  through the sampling mechanism , in turn. Then, by plugging the second expression in the former, we obtain  expressions as functions of seeds and parameters – the master equations – that we invert to find values of the latter as a function of: i) the statistics, whose values in turn are fixed at the observed ones; and ii) the seeds, which are random according to their own distribution. Hence from a set of seed samples we obtain a set of parameter replicas.\n^ By default, capital letters (such as U, X) will denote random variables and small letters (u, x) their corresponding realizations.","alt_names":["Bootstrapping populations","Bootstrapping populations - Wikipedia, the free encyclopedia","Unicdf.png","What is algorithm of Bootstrapping populations","What is method of Bootstrapping populations?","Wikipedia article Bootstrapping populations","Wikipedia entry for Bootstrapping populations","http://en.wikipedia.org/wiki/Bootstrapping_populations","population bootstrap","θ &breve; j , i"],"name":"Bootstrapping populations","categories":["Algorithmic inference","All Wikipedia articles needing context","All articles needing cleanup","All pages needing cleanup","Articles needing cleanup from January 2009","Cleanup tagged articles without a reason field from January 2009","Computational statistics","Resampling (statistics)","Wikipedia articles needing context from October 2009","Wikipedia introduction cleanup from October 2009","Wikipedia pages needing cleanup from January 2009"],"tag_line":"Starting with a sample  observed from a random variable X having a given distribution law with a set of non fixed parameters which we denote with a vector , a parametric inference problem consists of computing suitable values – call them estimates – of these parameters precisely on the basis of the sample."}}
,{"_index":"throwtable","_type":"algorithm","_id":"xtr","_score":0,"_source":{"description":"In cryptography, XTR is an algorithm for public-key encryption. XTR stands for ‘ECSTR’, which is an abbreviation for Efficient and Compact Subgroup Trace Representation. It is a method to represent elements of a subgroup of a multiplicative group of a finite field. To do so, it uses the trace over  to represent elements of a subgroup of .\nFrom a security point of view, XTR relies on the difficulty of solving Discrete Logarithm related problems in the full multiplicative group of a finite field. Unlike many cryptographic protocols that are based on the generator of the full multiplicative group of a finite field, XTR uses the generator  of a relatively small subgroup of some prime order  of a subgroup of . With the right choice of , computing Discrete Logarithms in the group, generated by , is, in general, as hard as it is in  and thus cryptographic applications of XTR use  arithmetics while achieving full  security leading to substantial savings both in communication and computational overhead without compromising security. Some other advantages of XTR are its fast key generation, small key sizes and speed.","alt_names":["- XTR :","Keuze van p en q","Wikipedia article XTR","Wikipedia article on XTR","Wikipedia entry for XTR","XTR","XTR - Wikipedia, the free encyclopedia","XTR - Wikipedia, the free encyclopedia - Wikipedia","XTR - Wikipedia, the free encyclopedia In cryptography, XTR","XTR stands for ECSTR', which is an abbreviation","XTR; it is used under the","Xtr","http://en.Liarpedia.org/wiki/Law Enforcement In","http://en.wikipedia.org/wiki/XTR","yago-res:XTR","“XTR - Wikipedia, the free encyclopedia”, en.wikipedia.org"],"name":"XTR","categories":["Asymmetric-key algorithms","Finite fields"],"tag_line":"In cryptography, XTR is an algorithm for public-key encryption."}}
,{"_index":"throwtable","_type":"algorithm","_id":"quantum-algorithm-for-linear-systems-of-equations","_score":0,"_source":{"description":"The quantum algorithm for linear systems of equations, designed by Aram Harrow, Avinatan Hassidim, and Seth Lloyd, is a quantum algorithm for solving linear systems formulated in 2009. The algorithm estimates the result of a scalar measurement on the solution vector to a given linear system of equations.\nThe algorithm is one of the main fundamental algorithms expected to provide an exponential speedup over their classical counterparts, along with Shor's factoring algorithm, Grover's search algorithm and quantum simulation. Provided the linear system is a sparse and has a low condition number , and that the user is interested in the result of a scalar measurement on the solution vector, instead of the values of the solution vector itself, then the algorithm has a runtime of , where  is the number of variables in the linear system.. This offers an exponential speedup over the fastest classical algorithm, which runs in  (or  for positive semidefinite matrices).\nAn implementation of the quantum algorithm for linear systems of equations was first demonstrated in 2013 by Cai et al., Barz et al.and Pan et al. in parallel. The demonstrations consisted of simple linear equations on specially designed quantum devices. \nDue to the prevalence of linear systems in virtually all areas of science and engineering, the quantum algorithm for linear systems of equations has the potential for widespread applicability.","alt_names":[],"name":"Quantum algorithm for linear systems of equations","categories":["Articles containing proofs","Integer factorization algorithms","Quantum algorithms","Quantum information science"],"tag_line":"The quantum algorithm for linear systems of equations, designed by Aram Harrow, Avinatan Hassidim, and Seth Lloyd, is a quantum algorithm for solving linear systems formulated in 2009."}}
,{"_index":"throwtable","_type":"algorithm","_id":"reeds–sloane-algorithm","_score":0,"_source":{"description":"The Reeds–Sloane algorithm, named after J. A. Reeds and N. J. A. Sloane, is an extension of the Berlekamp–Massey algorithm, an algorithm for finding the shortest linear feedback shift register (LFSR) for a given output sequence, for use on sequences that take their values from the integers mod n.","alt_names":[],"name":"Reeds–Sloane algorithm","categories":["All stub articles","Cryptanalytic algorithms","Cryptography stubs"],"tag_line":"The Reeds–Sloane algorithm, named after J."}}
,{"_index":"throwtable","_type":"algorithm","_id":"adaboost","_score":0,"_source":{"description":"AdaBoost, short for \"Adaptive Boosting\", is a machine learning meta-algorithm formulated by Yoav Freund and Robert Schapire who won the Gödel Prize in 2003 for their work. It can be used in conjunction with many other types of learning algorithms to improve their performance. The output of the other learning algorithms ('weak learners') is combined into a weighted sum that represents the final output of the boosted classifier. AdaBoost is adaptive in the sense that subsequent weak learners are tweaked in favor of those instances misclassified by previous classifiers. AdaBoost is sensitive to noisy data and outliers. In some problems, however, it can be less susceptible to the overfitting problem than other learning algorithms. The individual learners can be weak, but as long as the performance of each one is slightly better than random guessing (e.g., their error rate is smaller than 0.5 for binary classification), the final model can be proven to converge to a strong learner\nWhile every learning algorithm will tend to suit some problem types better than others, and will typically have many different parameters and configurations to be adjusted before achieving optimal performance on a dataset, AdaBoost (with decision trees as the weak learners) is often referred to as the best out-of-the-box classifier. When used with decision tree learning, information gathered at each stage of the AdaBoost algorithm about the relative 'hardness' of each training sample is fed into the tree growing algorithm such that later trees tend to focus on harder-to-classify examples.\n\n","alt_names":["Boosting algorithms","adaboost","AdaBoost",", http://en.wikipedia.org/wiki/Adaboost","- AdaBoost :","- Adaboost :","-> Read more about AdaBoost","...more on Wikipedia about AdaBoost","1 The algorithm for the binary classification task","2 Statistical Understanding of Boosting","Ada Boost","Ada Boost learning method","AdaBOOST","AdaBoost - Wikip?dia","AdaBoost - Wikipdia","AdaBoost - Wikipedia","AdaBoost - Wikipedia, the fr...","AdaBoost - Wikipedia, the free encyclopedia","AdaBoost - Wikipedia, the free encyclopediaAdaBoost, short for","AdaBoost - Wikipedia, the free enc…","AdaBoost - Wikipédia","AdaBoost - Wik…","AdaBoost Algorithmus","AdaBoost Wikipedia The Free Encyclopedia","AdaBoost Wikipedia the free encyclopedia","AdaBoost algorithm","AdaBoost algoritme","AdaBoost algoritmen","AdaBoost background","AdaBoost on Wikipedia","AdaBoost on wiki ..","AdaBoost |","AdaBoost алгоритм","AdaBoost – Wikipedia","AdaBoost — Википедия","AdaBoost, short for Adaptive Boosting, is a machine","AdaBoost.MH","AdaBoostを","AdaBoost的","AdaBoost算法","Adaboost","Adaboost; it is used under the","Adaboost的","Adaptive Boosting","Boosting.","Nicely written up on wikipedia","Statistical Understanding of Boosting","The AdaBoost algorithm","The algorithm for the binary classification task","Wikipedia AdaBoost","Wikipedia AdaBoost entry","Wikipedia article AdaBoost","Wikipedia article Adaboost","Wikipedia article on AdaBoost","Wikipedia article on Adaboost","Wikipedia entry for AdaBoost","Wikipedia on AdaBoost","Wikipedia sur AdaBoost","[12] AdaBoost","[AdaBoost]","adaptive boosting","article AdaBoost","boosted decision trees","en.wikipedia.org/AdaBoost","en.wikipedia.org/wiki/AdaBoost","en.wikipedia.org/wiki/AdaBoost (","fr:AdaBoost","http://en.wikipedia.org/wiki/AdaBoos","http://en.wikipedia.org/wiki/AdaBoost","http://en.wikipedia.org/wiki/AdaBoost.","http://en.wikipedia.org/wiki/Adaboost","http://fr.wikipedia.org/wiki/AdaBoost","http://ja.wikipedia.org/wiki/AdaBoost","http://pl.wikipedia.org/wiki/AdaBoost","http://pt.wikipedia.org/wiki/AdaBoost","http://ru.wikipedia.org/wiki/AdaBoost","ja:AdaBoost","mo AdaBOOST","particular loss function","pl:AdaBoost","pt:AdaBoost","ru:AdaBoost","tp://en.wikipedia.org/wiki/AdaBoost,","yago-res:AdaBoost","Википедии статью AdaBoost","“AdaBoost - Wikipedia, the free encyclopedia”, en.wikipedia.org","識別器","識別器のアルゴリズムを"],"name":"AdaBoost","categories":["Classification algorithms","Ensemble learning"],"tag_line":"AdaBoost, short for \"Adaptive Boosting\", is a machine learning meta-algorithm formulated by Yoav Freund and Robert Schapire who won the Gödel Prize in 2003 for their work."}}
,{"_index":"throwtable","_type":"algorithm","_id":"apriori-algorithm","_score":0,"_source":{"description":"Apriori is an algorithm for frequent item set mining and association rule learning over transactional databases. It proceeds by identifying the frequent individual items in the database and extending them to larger and larger item sets as long as those item sets appear sufficiently often in the database. The frequent item sets determined by Apriori can be used to determine association rules which highlight general trends in the database: this has applications in domains such as market basket analysis.","alt_names":["Apriori algorithm","Apriori-Algorithmus","- Apriori algorithm :","-> Leggi tutto l'articolo su 'Algoritmo apriori'","-> Read more about Apriori algorithm","2.1 Apriori Pseudocode","4 Programing code","A &rightarrow; B &rightarrow; C","A priori algorithm","A'priory","A-priori algoritme","A-priori algoritme - Wikipedia","Algoritmo apriori","Algoritmo apriori - Wikipedia","Algoritmo apriori - Wikipedia, la enciclopedia libre","Apriori Algorithm","Apriori Association Rule Miner Algorithm","Apriori Data Mining algorithm","Apriori algorithm - Wikipedia","Apriori algorithm - Wikipedia :: The free encyclopedia","Apriori algorithm - Wikipedia, the free encyclopedia","Apriori algorithm Wikipedia the free encyclopedia","Apriori algorithm by Wikipedia","Apriori algorithm – Wikipedia, the free encyclopedia","Apriori algorithm →","Apriori algoritme","Apriori algoritmus","Apriori algoritmus Wikipedia","Apriori в Wikipedia","Apriori एल्गोरिथ्म","Apriori-Algorithmus ? Wikipedia","Apriori-Algorithmus Wikipedia","Apriori-Algorithmus – Wikipedia","Apriori-algoritme","Apriori-based","Apriori_algorithm","Aprioriアルゴリズム","Apriori算法","Apriory algorithm","Programing code","Read More algoritmo apriori wikipedia","Read More algoritmo apriori wikipedia la enciclopedia libre","What is Apriori algorithm's example","What is Apriori algorithm's example?","Wikipedia article A priori algorithm","Wikipedia article Apriori algorithm","Wikipedia entry for Apriori algorithm","Wikipedia l'articolo Algoritmo apriori","Wikipedia link to the apriori algorithm","Wikipedia-Artikel Apriori-Algorithmus","Wikipedia-Seite zu 'Apriori-Algorithmus'","Wikipedia: Apriori-Algorithmus","Wikipedia:Algoritmo_apriori","Wikipedia:Apriori_algorithm","a priori algorithm","a-priori algoritme","algoritmo Apriori","algoritmo a priori","algoritmu Apriori","algorytm Apriori","algorytmu Apriori","apriori algorithm","apriori algorithm - Wikipedia, the free encyclopedia","apriori algorithm wikipedia the free encyclopedia","apriori algoritme","apriori-Algorithmus","artículo de Wikipedia Algoritmo apriori","confuso lemma della wiki inglese","de.wikipedia.org/wiki/Apriori-Algorithmus","de:Apriori-Algorithmus","einem Bereich des Datamining. Er dient der Auffindung","en.wikipedia.org/...Apriori_algorithm","en.wikipedia.org/wiki/Aprio...","en.wikipedia.org/wiki/Apriori_algorithm","es:Algoritmo apriori","fr:Algorithme APriori","http://de.wikipedia.org/wiki/Apriori-Alg","http://de.wikipedia.org/wiki/Apriori-Algorithmus","http://en.Liarpedia.org/wiki/Apriori_algorithm","http://en.wikipedia.org/wiki/A_priori_algorithm","http://en.wikipedia.org/wiki/Apriori_alg","http://en.wikipedia.org/wiki/Apriori_algorith","http://en.wikipedia.org/wiki/Apriori_algorith...","http://en.wikipedia.org/wiki/Apriori_algorithm","http://en.wikipedia.org/wiki/Apriori_algorithm#Apriori_Pseudocode","http://en.wikipedia.org/wiki/Apriori_algorithm#Apriori_Pseudocode and","http://en.wikipedia.org/wiki/Apriori_alg…","http://es.wikipedia.org/wiki/Algoritmo_apriori","http://fr.wikipedia.org/wiki/Algorithme_APriori","http://it.wikipedia.org/wiki/Algori","http://it.wikipedia.org/wiki/Algoritmo_apriori","http://nl.wikipedia.org/wiki/A-priori_algoritme","http://ru.wikipedia.org/wiki/Apriori","it:Algoritmo apriori","l'algorithme À Priori","nl:A-priori algoritme","ru:Apriori","ru:Алгоритм Apriori","~ Apriori algorithm","Алгоритм Apriori","Википедии статью Apriori","алгоритм Apriori","алгоритм Априори","алгоритма Apriori","априорная алгоритма","アプリオリアルゴリズム","的Apriori算法"],"name":"Apriori algorithm","categories":["Articles with example pseudocode","Data mining algorithms"],"tag_line":"Apriori is an algorithm for frequent item set mining and association rule learning over transactional databases."}}
,{"_index":"throwtable","_type":"algorithm","_id":"generalization-error","_score":0,"_source":{"description":"The generalization error of a machine learning model is a function that measures how well a learning machine generalizes to unseen data. It is measured as the distance between the error on the training set and the test set and is averaged over the entire set of possible training data that can be generated after each iteration of the learning process. It has this name because this function indicates the capacity of a machine that learns with the specified algorithm to infer a rule (or generalize) that is used by the teacher machine to generate data based only on a few examples.\nThe theoretical model assumes a probability distribution of the examples, and a function giving the exact target. The model can also include noise in the example (in the input and/or target output). The generalization error is usually defined as the expected value of the square of the difference between the learned function and the exact target (mean-square error). In practical cases, the distribution and target are unknown; statistical estimates are used.\nThe performance of a machine learning algorithm is measured by plots of the generalization error values through the learning process and are called learning curve.\nThe generalization error of a perceptron is the probability of the student perceptron to classify an example differently from the teacher and is given by the overlap of the student and teacher synaptic vectors and is a function of their scalar product.","alt_names":["- Generalization error :","...more on Wikipedia about Generalization error","Generalization Error","Generalization error","Generalization error - Wikipedia, the free encyclopedia","Generalization error by Wikipedia","Generalization error on wikipedia.org","Generalization_error","Wikipedia article Generalization error","Wikipedia article about Generalization error","Wikipedia entry for Generalization error","Wikipedia:Generalization_error","erro de generalização","generalization error","http://en.wikipedia.org/wiki/Generaliza","http://en.wikipedia.org/wiki/Generalizat","http://en.wikipedia.org/wiki/Generalization_error"],"name":"Generalization error","categories":["All stub articles","Classification algorithms","Robotics stubs"],"tag_line":"The generalization error of a machine learning model is a function that measures how well a learning machine generalizes to unseen data."}}
,{"_index":"throwtable","_type":"algorithm","_id":"teiresias-algorithm","_score":0,"_source":{"description":"The Teiresias algorithm is a combinatorial algorithm for the discovery of rigid patterns (motifs) in biological sequences. It is named after the Greek prophet Teiresias and was created in 1997 by Isidore Rigoutsos and Aris Floratos.\nThe problem of finding sequence similarities in the primary structure of related proteins or genes is one of the problems arising in the analysis of biological sequences. It can be shown that pattern discovery in its general form is NP-hard. The Teiresias algorithm, is based on the observation that if a pattern spans many positions and appears exactly k times in the input then all fragments (sub patterns) of the pattern have to appear at least k times in the input. The algorithm is able to produce all patterns that have a user-defined number of copies in the given input, and manages to be very efficient by avoiding the enumeration of the entire space. Finally, the algorithm reports motifs that are maximal in both length and composition.\nA new implementation of the Teiresias algorithm was recently made available by the Computational Medicine Center at Thomas Jefferson University . Teiresias is also accessible through an interactive web-based user interface by the same center. See external links for both.\n^ Rigoutsos, I, Floratos, A (1998) Combinatorial pattern discovery in biological sequences: The TEIRESIAS algorithm. Bioinformatics 14: 55-67\n^ Maier, D., \"The Complexity of Some Problems on Subsequences and Supersequences\", Journal of the ACM, 322-336, 1978","alt_names":[],"name":"Teiresias algorithm","categories":["Data mining algorithms","Official website not in Wikidata","Pattern matching"],"tag_line":"The Teiresias algorithm is a combinatorial algorithm for the discovery of rigid patterns (motifs) in biological sequences."}}
,{"_index":"throwtable","_type":"algorithm","_id":"k-medians-clustering","_score":0,"_source":{"description":"In statistics and data mining, k-medians clustering is a cluster analysis algorithm. It is a variation of k-means clustering where instead of calculating the mean for each cluster to determine its centroid, one instead calculates the median. This has the effect of minimizing error over all clusters with respect to the 1-norm distance metric, as opposed to the square of the 2-norm distance metric (which k-means does.)\nThis relates directly to the k-median problem which is the problem of finding k centers such that the clusters formed by them are the most compact. Formally, given a set of data points x, the k centers ci are to be chosen so as to minimize the sum of the distances from each x to the nearest ci.\nThe criterion function formulated in this way is sometimes a better criterion than that used in the k-means clustering algorithm, in which the sum of the squared distances is used. The sum of distances is widely used in applications such as facility location.\nThe proposed algorithm uses Lloyd-style iteration which alternates between an expectation (E) and maximization (M) step, making this an Expectation–maximization algorithm. In the E step, all objects are assigned to their nearest median. In the M step, the medians are recomputed by using the median in each single dimension.","alt_names":[],"name":"K-medians clustering","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Data clustering algorithms","Operations research","Statistical algorithms","Statistics stubs"],"tag_line":"In statistics and data mining, k-medians clustering is a cluster analysis algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"coboosting","_score":0,"_source":{"description":"CoBoost is a semi-supervised training algorithm proposed by Collins and Singer in 1999. The original application for the algorithm was the task of Named Entity Classification using very weak learners. It can be used for performing semi-supervised learning in cases in which there exist redundancy in features.\nIt may be seen as a combination of co-training and boosting. Each example is available in two views (subsections of the feature set), and boosting is applied iteratively in alternation with each view using predicted labels produced in the alternate view on the previous iteration. CoBoosting is not a valid boosting algorithm in the PAC learning sense.\n\n","alt_names":["- CoBoosting :","CoBoosting","CoBoosting - Wikipedia, the free encyclopedia","CoBoosting; it is used under the","Wikipedia article CoBoosting","Wikipedia article on CoBoosting","Wikipedia entry for CoBoosting","en.wikipedia.org/wiki/CoBoosting","http://en.wikipedia.org/wiki/CoBoosting","yago-res:CoBoosting"],"name":"CoBoosting","categories":["Classification algorithms"],"tag_line":"CoBoost is a semi-supervised training algorithm proposed by Collins and Singer in 1999."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cure-data-clustering-algorithm","_score":0,"_source":{"description":"CURE (Clustering Using REpresentatives) is an efficient data clustering algorithm for large databases that is more robust to outliers and identifies clusters having non-spherical shapes and size variances.","alt_names":[],"name":"CURE data clustering algorithm","categories":["All articles with unsourced statements","Articles with unsourced statements from May 2015","Data clustering algorithms"],"tag_line":"CURE (Clustering Using REpresentatives) is an efficient data clustering algorithm for large databases that is more robust to outliers and identifies clusters having non-spherical shapes and size variances."}}
,{"_index":"throwtable","_type":"algorithm","_id":"support-vector-machine","_score":0,"_source":{"description":"In machine learning, support vector machines (SVMs, also support vector networks) are supervised learning models with associated learning algorithms that analyze data and recognize patterns, used for classification and regression analysis. Given a set of training examples, each marked for belonging to one of two categories, an SVM training algorithm builds a model that assigns new examples into one category or the other, making it a non-probabilistic binary linear classifier. An SVM model is a representation of the examples as points in space, mapped so that the examples of the separate categories are divided by a clear gap that is as wide as possible. New examples are then mapped into that same space and predicted to belong to a category based on which side of the gap they fall on.\nIn addition to performing linear classification, SVMs can efficiently perform a non-linear classification using what is called the kernel trick, implicitly mapping their inputs into high-dimensional feature spaces.\nWhen data is not labeled, a supervised learning is not possible, and an unsupervised learning is required, that would find natural clustering of the data to groups, and map new data to these formed groups. The clustering algorithm which provides an improvement to the support vector machines is called support vector clustering (SVC) and is highly used in industrial applications either when data is not labeled or when only some data is labeled as a preprocessing for a classification pass; the clustering method was published.","alt_names":["http://en.wikipedia.org/wiki/Support_","svm","9 Implementation","SVM","Support Vector Machines","(SVM)","(http://en.wikipedia.org/wiki/Support_vector_machine)","- Support Vector Machine :","- Support vector machine :","-> Leggi tutto l'articolo su 'Macchine a vettori","-> Read the article about 'Support vector machine'","...Wikipedia Machine à vecteurs de support","...Wikipedia Stödvektormaskin","...mehr auf Wikipedia über Support-Vector-Maschine","...more on Wikipedia about Support vector machine",".wikipedia.org/wiki/Support_vector_machine.","1 Linear classification","1.2 Formalization","1.2 Motivation","1.3 Formalization","1.3 Further theory","1.4 Primal Form","1.5 Dual Form","12.2 Software","12.3 Interactive SVM applications","2 Non-linear classification","2 Soft margin","2.1 Primal form","2.2 Dual form","2.3 Biased and unbiased hyperplanes","2.4 Transductive support vector machines","220px-Kernel_Machine.png","220px-Svm_separating_ ...","3 Non-linear classification","3 Primal Form","3 Soft margin","4 Dual Form","4 Extensions to the linear SVM","4 Regression","4.1 Soft margin","4.2 Nonlinear classification","4.3 Parameter selection","5 Soft margin","6 Multiclass SVM","6 Non-linear classification","7 Regression","7 Structured SVM","8 Interactive SVM applications","8 Regression","8.3 Interactive SVM applications","<http://en.wikipedia.org/wiki/Support_vector_machine>","Dual Form of SVMs","Euskarri bektoredun makina","Extensions to the linear SVM","Figure: http://en.wikipedia.org/wiki/Support_vector_machine","Hỗ trợ Vector Machines","LIBSVM wikipedia","Le SVM (Support Vector Machine)","Learn about Support vector machine>>>","Linear SVM","Linear support vector machines (SVM)","Link to Support vector machine – Wikipedia, the free","M?quinas de vectores de soporte - Wikipedia, la","Macchine a vettori d","Macchine a vettori di supporto","Macchine a vettori di supporto - Wikipedia","Machine ? vecteurs de support - Wikip?dia","Machine vecteurs de support - Wikipdia","Machine à vecteurs de suppo...","Machine à vecteurs de support","Machine à vecteurs de support - Wikipédia","Machines à vecteurs de support","Maszyna wektor?w no?nych ? Wikipedia, wolna encyklopedia","Maszyna wektorów nosnych – Wikipedia, wolna encyklopedia","Maszyna wektorów nośnych – Wikipedia, wolna encyklopedia","Metoda podpornih vektorjev -...","Multi-class Kernel Support Vector Machines","Multiclass SVM","Mustererkennungsverfahren heraus. Als Durchbrüche wurden die Nutzbarmachung von","Máquinas de Soporte Vectorial","Máquinas de Vectores Soporte","Máquinas de Vectores de Soporte","Máquinas de soporte vectorial","Máquinas de vectores de soporte","Máquinas de vectores de soporte - Wikipedia, la enciclopedia","Noe lengre wikipedia-side om Support Vector Machine","Nonlinear classification","SVM (SVMc)","SVM (Support Vector Machine)","SVM (Support Vector Machines)","SVM (Support vector machines)","SVM (サポートベクターマシン)","SVM (서포트 벡터 머신)","SVM : Support Vector Machine","SVM WIKI","SVM article in Wikipedia","SVM classifier","SVM en wikipedia","SVM in wiki","SVM metodoak","SVM o Support Vector Machine che per comodità","SVM on wiki","SVM wikipedia","SVM's","SVM(サポートベクタマシン)","SVM(サポートベクターマシン)","SVM,","SVM-RFE","SVM-Wiki","SVM-based","SVM.","SVM1","SVMs","SVMs for Non-linear Classification","SVMs.","SVMを","SVMを用いた","SVM（Support Vector Machines)","Soft Margin","Soft margin","Stödvektormaskin","Suporta classificació multiclasse","Suppor Vector Machine","Suppor Vector Machine wiki","Support Vector Classification","Support Vector Machine","Support Vector Machine (SVM)","Support Vector Machine (SVM).","Support Vector Machine (SVN)","Support Vector Machine (Wikipedia)","Support Vector Machine - Wikipedia","Support Vector Machine ? Wikipedia","Support Vector Machine at Wikipedia","Support Vector Machine from Wiki","Support Vector Machine in Wikipedia","Support Vector Machine learning tool","Support Vector Machine maddesi","Support Vector Machine – Wikipedia","Support Vector Machine(SVM)","Support Vector Machine: SVM","Support Vector Machine; it is used under the","Support Vector Machines (SVM)","Support Vector Machines (SVMc)","Support Vector Machines (SVMs)","Support Vector Machines (Wikipedia)","Support Vector Machines (or SVM)","Support Vector Machines a","Support Vector Machines with multiple Kernels","Support Vector Machines(SVM)","Support Vector Machines,","Support Vector Machines.","Support Vector Machineを","Support Vector Marchines","Support Vector Maschine – Wikipedia","Support Vector Models","Support Vector Regression","Support Vektor Maschinen","Support vector classifier","Support vector machine","Support vector machine - Biased and unbiased hyperplanes","Support vector machine - Wikipedia","Support vector machine - Wikipedia :: The free encyclopedia","Support vector machine - Wikipedia, the free","Support vector machine - Wikipedia, the free ...","Support vector machine - Wikipedia, the free encyclopedia","Support vector machine - Wikipedia, the free encyclopedia ...","Support vector machine - Wikipedia, the free encyclopedia A","Support vector machine - Wikipedia, the free ency…","Support vector machine - Wikipedia,...","Support vector machine - Wikipedia…","Support vector machine Wikipedia the free","Support vector machine Wikipedia the free encyclopedia","Support vector machine Wikipedia the free encyclopedia - result","Support vector machine by Wikipedia","Support vector machine →","Support vector machine.","Support vector machines","Support vector machines (SVMs)","Support vector machines (SVMs) are a set of","Support vector machines - Wikipedie","Support vector machines on wikipedia.","Support vector machines.","Support vector regression","Support-Vector-Machine","Support-Vector-Machine (Wiki)","Support-Vector-Machines","Support-Vector-Maschine","Support-Vector-Maschinen","Support-Vektor-Maschine","Support_Vector_Machine","Support_Vector_Machines","Support_vector_machine","Support_vector_machines","Supporto Vector Machine","The Wikipedia On Support Vector Machine","The original SVM algorithm was invented by Vladimir","Théorie PAC de Valiant","Tukivektorikone","Tukivektorikone (support vector machine)","Tukivektorikone (support vector machine); SVM","Vector Support Machine","View Support vector machine on Wikipedia","W:Support vector machine","What are issues of Support vector machines?","What is Support vector machine's implementation","Wiki Eintrag zu SVM","Wikieintrag zu SVM","Wikipedia (Support vector machine)","Wikipedia - Support Vector maching (SVM)","Wikipedia - Support Vector maching (SVM).","Wikipedia Máquinas de soporte vectorial","Wikipedia SVM","Wikipedia SVM entry","Wikipedia article Support Vector Machine","Wikipedia article Support Vector Machines","Wikipedia article Support vector machine","Wikipedia article Support vector machines","Wikipedia article about SVM","Wikipedia article on Máquinas de vectores de soporte","Wikipedia article on Support Vector Machine","Wikipedia article on Support Vector Machines","Wikipedia article on Support vector machine","Wikipedia article on Support vector machines","Wikipedia artikel om SVM","Wikipedia artikel over SVM","Wikipedia entry about SVM","Wikipedia entry for Support vector machine","Wikipedia link to the support vector machine algorithm","Wikipedia on Support Vector Machines","Wikipedia sur Séparateurs à Vaste Marge","Wikipedia-Artikel Support Vector Machine","Wikipedia-Artikel Support-Vector-Maschine","Wikipedia-Artikel Support-Vektor-Maschine","Wikipedia-Artikel über SVM","Wikipedia-Seite zu 'Support Vector Machine'","Wikipedia-Seite zu 'Support-Vector-Maschine'","Wikipedia.jp:サポートベクターマシン","Wikipedia: Support Vector Machine","Wikipedia:Support vector machine","Wikipedia:Support_vector_machine","Wikipediaで「サポートベクトルマシン」を調べる","Wikipedii - Support Vector maching (SVM)","Wikipedii o SVM","[39] Support Vector Machines","articolo di Wikipedia su SVM","artículo de Wikipedia Maquinas de vectores de soporte","artículo de Wikipedia Máquinas de soporte vectorial","artículo de Wikipedia Máquinas de vectores de soporte","brilliant maths)","che cazzo è sta robaaa XD XD","color=#0066ccsupport vector machine'","complicated field. The three main techniques—","cs:Support vector machines","các phương pháp sử dụng vectơ hỗ trợ","de.wikipedia.org/...Support_Vector_Machine","de.wikipedia.org/wiki/Support_Vector_Machine","de:Support Vector Machine","en.wikipedia.org/...Support_vector_machine","en.wikipedia.org/...Support_vector_machines","en.wikipedia.org/wiki/Support_vector_...","en.wikipedia.org/wiki/Support_vector_mac...","en.wikipedia.org/wiki/Support_vector_machine","en.wikipedia.org/wiki/Support_vector_machines","en:Support vector machine","en:Support vector machines","es:Máquinas de vectores de soporte","eu:Euskarri bektoredun makina","f support vector machines","fa:ماشین بردار پشتیبانی","fi:Tukivektorikone","fr.wikipedia.org/wiki/Machine_à_vecteurs_de_support","fr:Machine à vecteurs de support","fr:Machine_à_vecteurs_de_support","given as examples here (at end of section","he:מכונת וקטורים תומכים","http://bit.ly/9hhLxk","http://cs.wikipedia.org/wiki/Support_vector_machines","http://de.wikipedia.org/wiki/S...or_Machine","http://de.wikipedia.org/wiki/Support-Vector-Maschine","http://de.wikipedia.org/wiki/Support-Vektor-Maschine","http://de.wikipedia.org/wiki/Support_Vec","http://de.wikipedia.org/wiki/Support_Vector_Machine","http://de.wikipedia.org/wiki/Support_Vector_Machine]support","http://en.wikipedia.org/wiki/Support vector machine","http://en.wikipedia.org/wiki/Support_Vector_","http://en.wikipedia.org/wiki/Support_Vector_Machine","http://en.wikipedia.org/wiki/Support_Vector_Machines","http://en.wikipedia.org/wiki/Support_ve ... malization","http://en.wikipedia.org/wiki/Support_vec","http://en.wikipedia.org/wiki/Support_vector","http://en.wikipedia.org/wiki/Support_vector_","http://en.wikipedia.org/wiki/Support_vector_m...","http://en.wikipedia.org/wiki/Support_vector_machi","http://en.wikipedia.org/wiki/Support_vector_machin","http://en.wikipedia.org/wiki/Support_vector_machine","http://en.wikipedia.org/wiki/Support_vector_machine#External_links","http://en.wikipedia.org/wiki/Support_vector_machine#Motivation","http://en.wikipedia.org/wiki/Support_vector_machine#Multiclass_SVM","http://en.wikipedia.org/wiki/Support_vector_machine#Non-linear_classification","http://en.wikipedia.org/wiki/Support_vector_machine#Soft_margin","http://en.wikipedia.org/wiki/Support_vector_machine#Software","http://en.wikipedia.org/wiki/Support_vector_machine.","http://en.wikipedia.org/wiki/Support_vector_machine?utm_source=twitterfeed&utm_medium","http://en.wikipedia.org/wiki/Support_vector_machines","http://en.wikipedia.org/wiki/Support_vect…","http://en.wikipedia.org/wiki/Support_vec…","http://en.wikipedia.org/wiki/Suppor…or_machine","http://es.wikipedia.org/wiki/M%C3%A1quinas_de_soporte_vectorial","http://es.wikipedia.org/wiki/M%C3%A1quinas_de_vectores_de_soporte","http://es.wikipedia.org/wiki/Máquinas_de_vectores_de_soporte","http://eu.wikipedia.org/wiki/Euskarri_bektoredun_makina","http://fa.wikipedia.org/wiki/ماشین_بردار_پشتیبانی","http://fi.wikipedia.org/wiki/Tukivektorikone","http://fr.wikipedia.org/wiki/Machine...urs_de_support","http://fr.wikipedia.org/wiki/Machine_%C3%A0_vecteurs_de_support","http://fr.wikipedia.org/wiki/Machine_à_vecteurs_de_support","http://it.wikipedia.org/wiki/Macchine_a ... i_supporto","http://pl.wikipedia.org/wiki/Maszyna...w_no%C5","http://pl.wikipedia.org/wiki/Maszyna_wektor%C3%B3w_no","http://ru.wikipedia.org/wiki/SVM","http://ru.wikipedia.org/wiki/SVM#.D0...B0","http://ru.wikipedia.org/wiki/Support_vector_machine","http://ru.wikipedia.org/wiki/Метод_опорных_векторов","http://sl.wikipedia.org/wiki/Metoda_podpornih_vektorjev","http://zh.wikipedia.org/zh/支持向量机","il supporto ai vettori macchina","introduction to SVMs","it:Macchine a vettori di supporto","ja:サポートベクターマシン","kernel methods and support vector machines","kernel-funktiolla","ko:서포트 벡터 머신","l'article de Wikipédia Support vector machine","la máquina de vectores soporte","las SVM","linear support vector machines","macchine a vettori di supporto","machines à support vectoriel","machines à vecteur de support","machines à vecteurs de support","many approaches have been suggested to perform multi","maszyn wektorowych wsparcie","maszyny wektorów wspierających","max-margin classifiers","máquina de vectores de soporte","máquinas de vectores de soporte","máquinas de vectores soporte","máquinas de vectores soporte (SVMC)","on support vector machines here.","pl:Maszyna wektorów nośnych","podporu vektorové stroje","potporni vektorski stroj","pySVM","rs.”http://en.wikipedia.org/","ru:Метод опорных векторов","ru:Метод_опорных_векторов","scale support vector machines","sl:Metoda podpornih vektorjev","stödvektormaskin","support vector classification","support vector classification (SVM)","support vector machine","support vector machine (SVM)","support vector machine (SVM) (SVM)","support vector machine implementation","support vector machine models","support vector machine wikipedia the free encyclopedia","support vector machine'","support vector machines","support vector machines (SVM)","support vector machines (SVMc)","support vector machines classifiers","support vector mechine, SVM","support vector regression (SVR)","support-vector machine","support-vector machines","support-vector-machines (SVMs)","sv:Stödvektormaskin","szupport vektor gép","séparateurs à vaste marge","thumbnail:サポートベクターマシン - Wikipedia","transductive SVM","trop petit","ttp://en.wikipedia.org/wiki/Support_vector_machine","ttpXGGenFwikipedi—ForgGwikiGƒupport•ve™tor•m—™hine","upport Vector Machines,","upport vector machine","vector machine supervised learning algorithm","vektor stroje podpora (SVMc)","vi:Support Vector Machines","w:Support vector machine","wikipedia article about SVM","wspierające maszyny wektorowe","zh:支持向量机","~ Support Vector Machine","Článek o SVM na Wikipedii","článku Wikipedie o SVM","Википедии статью SVM","Википедии статью Support vector machine","Википедии статью Метод опорных векторов","Машины опорных векторов","Метод Опорных Векторов","Метод опорных векторов","Метод опорных векторов — Википедия","Методу опорных векторов","Опорных векторов","Опору — векторам","СВМ,","СВМ.","англ. SVM (там же на русском)","машины опорных векторов","метод опорных векторов","метод опорных векторов.","метод опорных веторов","метода SVM","метода опорных векторов","опорных векторов","опорных векторов (ЮВГК)","опорных векторов машины","поддерживать машину вектора","про алгоритм","статье Википедии о SVM","מכונת וקטורים תומכים","מכונת וקטורים תומכים – ויקיפדיה","ماشین بردار پشتیبانی","ماشین بردار پشتیبانی - ویکیپدیا","समर्थन सदिश (SVMc) मशीनों","समर्थन सदिश) मशीन (SVMc","「サポートベクターマシン」をWikipediaで調べる","「サポートベクターマシン」をWikiで調べる","「サポートベクトルマシン」をWikipediaで調べる","のSVMの記事はウィキペディア","のサポートベクトルマシン","は、Support Vector 。","ウィキペディアの記事 サポートベクターマシン","サポートベクターマシン","サポートベクターマシン - Wikipedia","サポートベクターマシン ? Wikipedia","サポートベクターマシン [Wikipedia]","サポートベクターマシン – Wikipedia","サポートベクターマシン(SVM)","サポートベクターマシン（SVMc）","サポートベクターマシーン(Support Vector Machine, SVM)","サポートベクターマ�‚·ン - Wikipedia","サポートベクトルマシン","サポートベクトルマシン（Wikipedia）","分类- 概括的任务被知道适用于新数据的结构。例如，一个电子邮件节目可能试图分类同样合法的一个电子邮件或垃圾。普通算法包括决定树学习，最近的邻居，天真的贝叶斯的分类，","支持向量机","支持向量机- 维基百科，自由的百科全书","支持向量机的相关介绍Support vector machine - Wikipedia, the free encyclopedia","支持向量机（SVMc）","支持向量机（SVM）","支持向量機","支援向量機","的支持向量机","的支持向量機","維基百科的文章“ 支持向量机”","벡터 머신 지원","서포트 벡터 머신","위키 피 디아 문서 서포트 벡터 머신","ｻﾎﾟｰﾄﾍﾞｸﾀｰﾏｼﾝ","ｻﾎﾟｰﾄﾍﾞｸﾀｰﾏｼﾝ - Wikipedia","ｻﾎﾟｰﾄﾍﾞｸﾀｰﾏｼﾝ-wikipedia","𝐱 i"],"name":"Support vector machine","categories":["All articles with unsourced statements","Articles with unsourced statements from February 2015","Articles with unsourced statements from June 2013","Classification algorithms","Statistical classification","Support vector machines","Wikipedia articles with GND identifiers"],"tag_line":"In machine learning, support vector machines (SVMs, also support vector networks) are supervised learning models with associated learning algorithms that analyze data and recognize patterns, used for classification and regression analysis."}}
,{"_index":"throwtable","_type":"algorithm","_id":"perceptron","_score":0,"_source":{"description":"In machine learning, the perceptron is an algorithm for supervised learning of binary classifiers: functions that can decide whether an input (represented by a vector of numbers) belongs to one class or another. It is a type of linear classifier, i.e. a classification algorithm that makes its predictions based on a linear predictor function combining a set of weights with the feature vector. The algorithm allows for online learning, in that it processes elements in the training set one at a time.\nThe perceptron algorithm dates back to the late 1950s; its first implementation, in custom hardware, was one of the first artificial neural networks to be produced.","alt_names":["感知","percettroni","perceptrones","perceptrón","パーセプトロン","Perzeptronen","Perceptron","perceptron","'s의","- Linear perceptron :","- Perceptron :","- Perceptrons :","-> Read the article about 'Perceptron'","...Wikipedia Perceptron","...mehr auf Wikipedia über Perzeptron","...more on Wikipedia about Perceptron","Aprendizagem por redes neuronais (perceptron)","Besuche die Homepage von Netsurai!","D m = &lbrace; ( x 1 , y 1 ) , &ctdot","Dies führte zu einem Stillstand in der Forschung","Es besteht in der Grundversion einfaches Perzeptron aus","Feedforward Neural Network (Perceptron)","Gerade darin besteht die gewünschte Klassifizierungsfähigkeit des Perzeptrons","Linear perceptron","Mehrlagiges Perceptronen","Mehrlagiges Perzeptron (de.wikipedia.org)","Multiclass perceptron","Multilayer Perzeptron","Perceptr?n - Wikipedia, la enciclopedia libre","Perceptrn - Wikipedia, la enciclopedia libre","Perceptrn la enciclopedia libre","Perceptron (Wikipedia)","Perceptron (wikipedia)","Perceptron - Wikip?dia","Perceptron - Wikipdia","Perceptron - Wikipedia","Perceptron - Wikipedia, the free ...","Perceptron - Wikipedia, the free encyclopedia","Perceptron - Wikipedia, the free encyclopedianotesm05d04","Perceptron - Wikipédia","Perceptron - Βικιπαίδεια","Perceptron ? Wikipedia, wolna encyklopedia","Perceptron Algorithm","Perceptron Learning (PL)","Perceptron Logic","Perceptron Wikipedia","Perceptron Wikipedia the free encyclopedia","Perceptron by Wikipedia","Perceptron entry in Wikipedia","Perceptron from Wikipedia","Perceptron is","Perceptron learning algorithm","Perceptron on wikipedia.org","Perceptron |","Perceptron – Wikipedia, wolna encyklopedia","Perceptron →","Perceptron-Konvergenz-Theorem","Perceptron.","Perceptron/","Perceptron; it is used under the","Perceptrons; it is used under the","Perceptron을","Perceptró","Perceptró - Viquipèdia","Perceptrón","Perceptrón - Wikipedia, la enciclopedia libre","Percettrone","Percettrone - Wikipedia","Perzeptron","Perzeptron - Wikipedia","Perzeptron ? Wikipedia","Perzeptron Wikipedia","Perzeptron – Wikipedia","Perzeptrons","Rosenblatt Perceptron","Search info on Perceptrons at Wikipedia","Sind die Gewichtungen einmal gelernt, so ist ein","Source Wikipedia.org Arcticle - Perceptron","Structured perceptron","The Perceptron","They're pretty simple.","Threshold Logical Unit","Unter diesem Begriff werden heute verschiedene Kombinationen des","What is the history of Threshold neuron?","What variants of Threshold neuron are there?","Wikipedia (Perceptron)","Wikipedia - Perceptron","Wikipedia / perceptron","Wikipedia : Perceptron","Wikipedia Article: Perceptron","Wikipedia Perceptron entry","Wikipedia article ''Perceptron''","Wikipedia article Perceptron","Wikipedia article Perceptrons","Wikipedia article about Perceptron","Wikipedia article about Perceptrons","Wikipedia article on Perceptron","Wikipedia article on Perceptrons","Wikipedia article on Perceptrón","Wikipedia article Перцептрон","Wikipedia article פרספטרון","Wikipedia article เพอร์เซปตรอน","Wikipedia artikel Perceptron","Wikipedia entry for Perceptron","Wikipedia page on Perceptron","Wikipedia-Artikel Perceptron","Wikipedia-Artikel Perceptron-Konvergenz-Theorem","Wikipedia-Artikel Perzeptron","Wikipedia-Seite zu 'Perceptron'","Wikipedia-Seite zu 'Perzeptron'","Wikipedia.jp:パーセプトロン","Wikipedia: Perceptron","Wikipedia: perceptron","Wikipedia:Perceptron","Wikipediaで「パーセプトロン」を調べる","ako funguje perceptron, krok po kroku","ar:بيرسيبترون","article Perceptron","artículo de Wikipedia Perceptrón","begrepen","ca:Perceptró","cs:Perceptron","de:Perzeptron","el:Perceptron","en.wikipedia.org/Perceptron","en.wikipedia.org/wiki/Perceptron","en:Perceptron","erceptrón","es:Perceptrón","fa:پرسپترون","feed-forward perceptron","fr:Perceptron","he:פרספטרון","http://ca.wikipedia.org/wiki/Perceptr%C3%B3","http://cs.wikipedia.org/wiki/Perceptron","http://de.wikipedia.org/wiki/Pe rceptron","http://de.wikipedia.org/wiki/Perceptron","http://de.wikipedia.org/wiki/Perceptron-Konvergenz-Theorem","http://de.wikipedia.org/wiki/Perzeptron","http://de.wikipedia.org/wiki/Perzeptron ... -Lernregel","http://de.wikipedia.org/wiki/Perzeptron#...iges_Perzeptron","http://de.wikipedia.org/wiki/Perzeptron#Mehrlagiges_Perzeptron","http://de.wikipedia.org/wiki/Perzeptron#Perzeptron-Lernregel","http://el.wikipedia.org/wiki/Perceptron","http://en.wikipedia....wiki/Perceptron","http://en.wikipedia.org/wiki/Perceptron","http://en.wikipedia.org/wiki/Perceptron#History","http://en.wikipedia.org/wiki/Perceptron#Learning_algorithm","http://en.wikipedia.org/wiki/Perceptron.","http://en.wikipedia.org/wiki/Perceptrons","http://es.wikipedia.org/wiki/Perceptr%C3%B3n","http://fr.wikipedia.org/wiki/Perceptron","http://it.wikipedia.org/wiki/Percettrone","http://j.mp/m6xIGL","http://ja.wikipedia.org/wiki/パーセプトロン","http://nl.wikipedia.org/wiki/Perceptron","http://pl.wikipedia.org/wiki/Perceptron","http://pt.wikipedia.org/wiki/Perceptron","http://ru.wikipedia....�цептрон","http://ru.wikipedia.org/wiki/Персептрон","http://ru.wikipedia.org/wiki/Перцептрон","http://zh.wikipedia.org/wiki/感知器","it:Percettrone","ja:パーセプトロン","kernel-based perceptron classifier","ko:퍼셉트론","l'article de Wikipédia Perceptron","learning algorithm of Perceptron","linear perceptron","multiple layered perception","n perceptron","nl:Perceptron","perceptro","perceptron algorithm","perceptron function","perceptron learning algorithm","perceptron networks","perceptron neural networks","perceptron-like","perceptronilor","perceptronová","perceptronu","perceptronului","perceptrón simple","percettrone","pl.wikipedia.org/wiki/Perceptron","pl:Perceptron","pt:Perceptron","ru:Перцептрон","simple integrating machines","sk:Perceptrón","sl:Perceptron","stran Wikipedie za 'Perceptron'","sv:Perceptron","th:เพอร์เซปตรอน","the Perceptron Learning Algorithm","the Wikipedia article on perceptrons","the perceptron","the perceptron)","the perceptron.","threshold neuron","threshold neurons","uk:Перцептрон","w:uk:Перцептрон","w:Перцептрон","w:Перцептрон#Задача XOR","w:перцептроном","wiki-パーセプトロン","xor в перцептроне","zh:感知器","«перцептроника»","Википедии статью Перцептрон","Парсептроны","Персептрон Розенблатта","Персептроны","Перцептро́н, или персептрон — математическая и компьютерная модель восприятия","Перцептрон","Перцептрон Розенблатта","Перцептрон в викепедии","Перцептрон — Википедия","видах перцептрона","ерцептроны.","не считается при подсчёте слоёв","неточности и заблуждения","неточності і помилки","нижче.","однослойный персептрон Розенблатта","персептрон","персептрона","персептронами","перцептрон","перцептрон Розенблатта","перцептрона","перцептрона Розенблатта","перцептроном","перцептроны","статьи перцептрон","статью в вики про перцептрон","ויקיפדיה - 'פרספטרון'","פרספטרון","פרספטרון – ויקיפדיה","البيرسبترون","بالبيرسيبترون","پرسپترون","پرسپترون - ویکیپدیا","เพอร์เซปตรอน","เพอร์เซปตรอน - วิกิพีเดีย","“Perceptron”","「パーセプトロン」をWikipediaで調べる","ウィキペディア:パーセプトロン","パーセプトロン (Wikipedia)","パーセプトロン - Wikipedia","パーセプトロン - Wikipedia »","パーセプトロン -wikipedia","感知器","維基百科的文章“ 感知器”","维基百科的文章“ 感知器”","위키 피 디아 문서 퍼셉트론","퍼셉트론","ﾊﾟｰｾﾌﾟﾄﾛﾝ-wikipedia"],"name":"Perceptron","categories":["All accuracy disputes","Articles with disputed statements from August 2015","Articles with disputed statements from June 2014","Articles with example Python code","Artificial neural networks","Classification algorithms"],"tag_line":"In machine learning, the perceptron is an algorithm for supervised learning of binary classifiers: functions that can decide whether an input (represented by a vector of numbers) belongs to one class or another."}}
,{"_index":"throwtable","_type":"algorithm","_id":"syntactic-pattern-recognition","_score":0,"_source":{"description":"Syntactic pattern recognition or structural pattern recognition is a form of pattern recognition, in which each object can be represented by a variable-cardinality set of symbolic, nominal features. This allows for representing pattern structures, taking into account more complex interrelationships between attributes than is possible in the case of flat, numerical feature vectors of fixed dimensionality, that are used in statistical classification.\nSyntactic pattern recognition can be used instead of statistical pattern recognition if there is clear structure in the patterns. One way to present such structure is by means of a strings of symbols from a formal language. In this case the differences in the structures of the classes are encoded as different grammars.\nAn example of this would be diagnosis of the heart with ECG measurements. ECG waveforms can be approximated with diagonal and vertical line segments. If normal and unhealthy waveforms can be described as formal grammars, measured ECG signal can be classified as healthy or unhealthy by first describing it in term of the basic line segments and then trying to parse the descriptions according to the grammars. Another example is tessellation of tiling patterns.\nA second way to represent relations are graphs, where nodes are connected if corresponding subpatterns are related. An item can be labeled as belonging to a class if its graph representation is isomorphic with prototype graphs of the class.\nTypically, patterns are constructed from simpler sub patterns in a hierarchical fashion. This helps in dividing the recognition task into easier subtask of first identifying sub patterns and only then the actual patterns.\nStructural methods provide descriptions of items, which may be useful in their own right. For example, syntactic pattern recognition can be used to find out what objects are present in an image. Furthermore, structural methods are strong in finding a correspondence mapping between two images of an object. Under natural conditions, corresponding features will be in different positions and/or may be occluded in the two images, due to camera-attitude and perspective, as in face recognition. A graph-matching algorithm will yield the optimal correspondence.","alt_names":["- Syntactic pattern recognition :","Structural pattern recognition","Syntactic Pattern Recognition","Syntactic pattern recognition","Syntactic pattern recognition - Wikipedia, the free encyclopedia","Syntactic pattern recognition - Wikipedia, the free encyclopedia ...","Syntactic pattern recognition Wikipedia the free encyclopedia","Syntactic_pattern_recognition","Wikipedia article Syntactic pattern recognition","Wikipedia article on Syntactic pattern recognition","Wikipedia entry for Syntactic pattern recognition","en.wikipedia.org/...Syntactic_pattern_recognition","en.wikipedia.org/wiki/Syntactic_pattern_recognition","http://en.wikipedia.org/wiki/Syntactic_pattern_recognition","syntactic pattern recognition","yago-res:Syntactic pattern recognition"],"name":"Syntactic pattern recognition","categories":["Classification algorithms"],"tag_line":"Syntactic pattern recognition or structural pattern recognition is a form of pattern recognition, in which each object can be represented by a variable-cardinality set of symbolic, nominal features."}}
,{"_index":"throwtable","_type":"algorithm","_id":"random-subspace-method","_score":0,"_source":{"description":"Random subspace method  (or attribute bagging) is an ensemble classifier that consists of several classifiers each operating in a subspace of the original feature space, and outputs the class based on the outputs of these individual classifiers. Random subspace method has been used for decision trees (random decision forests), linear classifiers, support vector machines, nearest neighbours and other types of classifiers. This method is also applicable to one-class classifiers.\nThe algorithm is an attractive choice for classification problems where the number of features is much larger than the number of training objects, such as fMRI data or gene expression data.\nIn machine learning and statistics, feature selection, also known as variable selection, attribute selection or variable subset selection, is the process of selecting a subset of relevant features (variables, predictors) for use in model construction. Feature selection techniques are used for three reasons:\nsimplification of models to make them easier to interpret by researchers/users,[1] shorter training times, enhanced generalization by reducing overfitting[2](formally, reduction of variance[1]) The central premise when using a feature selection technique is that the data contains many features that are either redundant or irrelevant, and can thus be removed without incurring much loss of information.[2] Redundant or irrelevant features are two distinct notions, since one relevant feature may be redundant in the presence of another relevant feature with which it is strongly correlated.[3]","alt_names":["- Random subspace method :","Random Subspace Method","Random subspace method","Random subspace method - Wikipedia :: The free encyclopedia","Random subspace method - Wikipedia, the free encyclopedia","Random subspace method by Wikipedia","Wikipedia article Random subspace method","Wikipedia article about random subspace method","http://en.wikipedia.org/wiki/Random_subspace_method","random subspace method"],"name":"Random subspace method","categories":["CS1 errors: chapter ignored","Classification algorithms","Ensemble learning","Pages containing cite templates with deprecated parameters","Pages with citations having bare URLs","Pages with citations lacking titles"],"tag_line":"Random subspace method  (or attribute bagging) is an ensemble classifier that consists of several classifiers each operating in a subspace of the original feature space, and outputs the class based on the outputs of these individual classifiers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"multi-label-classification","_score":0,"_source":{"description":"In machine learning, multi-label classification and the strongly related problem of multi-output classification are variants of the classification problem where multiple target labels must be assigned to each instance. Multi-label classification should not be confused with multiclass classification, which is the problem of categorizing instances into one of more than two classes. Formally, multi-label learning can be phrased as the problem of finding a model that maps inputs x to binary vectors y, rather than scalar outputs as in the ordinary classification problem.\nThere are two main methods for tackling the multi-label classification problem: problem transformation methods and algorithm adaptation methods. Problem transformation methods transform the multi-label problem into a set of binary classification problems, which can then be handled using single-class classifiers. Algorithm adaptation methods adapt the algorithms to directly perform multi-label classification. In other words, rather than trying to convert the problem to a simpler problem, they try to address the problem in its full form.","alt_names":["- Multiclass labeling :","Multi label classification","Multi-class categorization","Multi-class classification","Multi-label classification","Multiclass Classification","Multiclass classification","Multiclass classification - Wikipedia, the free encyclopedia","Multiclass classification by Wikipedia","Multiclass labeling","Multiclass problem","Multiclass_classification","Wikipedia article Multi-label classification","Wikipedia entry for Multi-label classification","Wikipedia entry for Multiclass classification","Y &subseteq; L","http://en.wikipedia.org/wiki/Multi-label","http://en.wikipedia.org/wiki/Multi-label_classification","http://en.wikipedia.org/wiki/Multi-label_…","http://en.wikipedia.org/wiki/Multiclass_classification","http://en.wikipedia.org/wiki/Multiclass_classification.","http://en.wikipedia.org/wiki/Multiclass_problem","multi-class classification","multi-label","multi-label classification","multiclass classification","multiclass labeling","multiclass problem"],"name":"Multi-label classification","categories":["Classification algorithms"],"tag_line":"In machine learning, multi-label classification and the strongly related problem of multi-output classification are variants of the classification problem where multiple target labels must be assigned to each instance."}}
,{"_index":"throwtable","_type":"algorithm","_id":"winnow-(algorithm)","_score":0,"_source":{"description":"The winnow algorithm is a technique from machine learning for learning a linear classifier from labeled examples. It is very similar to the perceptron algorithm. However, the perceptron algorithm uses an additive weight-update scheme, while Winnow uses a multiplicative scheme that allows it to perform much better when many dimensions are irrelevant (hence its name). It is a simple algorithm that scales well to high-dimensional data. During training, Winnow is shown a sequence of positive and negative examples. From these it learns a decision hyperplane that can then be used to label novel examples as positive or negative. The algorithm can also be used in the online learning setting, where the learning and the classification phase are not clearly separated.","alt_names":["- Winnow (algorithm) :","Aventar","Wikipedia article Winnow (algorithm)","Wikipedia article Winnow_(algorithm)","Winnow (algorithm)","Winnow (algorithm) - Wikipedia, the free encyclopedia","Winnow algorithm","Winnow by Wikipedia","Winnow_(algorithm)","http://en.wikipedia.org/wiki/Winnow (algorithm)","http://en.wikipedia.org/wiki/Winnow_(algorithm)","oddělit zrno od plev","the winnow algorithm","winnow algorithm","winnowing algorithm","फटकना","ウィンナウ","温瑙","运筹"],"name":"Winnow (algorithm)","categories":["Classification algorithms"],"tag_line":"The winnow algorithm is a technique from machine learning for learning a linear classifier from labeled examples."}}
,{"_index":"throwtable","_type":"algorithm","_id":"margin-classifier","_score":0,"_source":{"description":"In machine learning, a margin classifier is a classifier which is able to give an associated distance from the decision boundary for each example. For instance, if a linear classifier (e.g. perceptron or linear discriminant analysis) is used, the distance (typically euclidean distance, though others may be used) of an example from the separating hyperplane is the margin of that example.\nThe notion of margin is important in several machine learning classification algorithms, as it can be used to bound the generalization error of the classifier. These bounds are frequently shown using the VC dimension. Of particular prominence is the generalization error bound on boosting algorithms and support vector machines.","alt_names":["- Margin classifier :","Boosting Definition of Margin","Examples of Margin-Based Algorithms","Generalization Error Bounds","Margin Classifier","Margin classifier","Margin classifier - Wikipedia, the free encyclopedia","Margin classifier by Wikipedia","Margin classifier; it is used under the","Support Vector Machine Definition of Margin","Wikipedia (Margin classifier)","Wikipedia article Margin classifier","Wikipedia article on Margin classifier","http://en.wikipedia.org/wiki/Margin_classifier","margin classifier","margin classifiers","max margin","rgin classifier."],"name":"Margin classifier","categories":["Classification algorithms","Statistical classification"],"tag_line":"In machine learning, a margin classifier is a classifier which is able to give an associated distance from the decision boundary for each example."}}
,{"_index":"throwtable","_type":"algorithm","_id":"information-fuzzy-networks","_score":0,"_source":{"description":"Info Fuzzy Networks(IFN) is a greedy machine learning algorithm for supervised learning. The data structure produced by the learning algorithm is also called Info Fuzzy Network. IFN construction is quite similar to decision trees' construction. However, IFN constructs a directed graph and not a tree. IFN also uses the conditional mutual information metric in order to choose features during the construction stage while decision trees usually use other metrics like entropy or gini.\n\n","alt_names":["Information Fuzzy Networks","Information Fuzzy Networks - Wikipedia, the free encyclopedia","Information Fuzzy Networks by Wikipedia","Information fuzzy networks","Wikipedia entry for Information Fuzzy Networks","http://en.wikipedia.org/wiki/Information_Fuzzy_Networks","yago-res:Information Fuzzy Networks"],"name":"Information Fuzzy Networks","categories":["All articles with topics of unclear notability","All orphaned articles","Articles with topics of unclear notability from May 2010","Classification algorithms","Orphaned articles from May 2010"],"tag_line":"Info Fuzzy Networks(IFN) is a greedy machine learning algorithm for supervised learning."}}
,{"_index":"throwtable","_type":"algorithm","_id":"evolved-antenna","_score":0,"_source":{"description":"In radio communications, an evolved antenna is an antenna designed fully or substantially by an automatic computer design program that uses an evolutionary algorithm that mimics Darwinian evolution. This sophisticated procedure has been used in recent years to design a few antennas for mission-critical applications involving stringent, conflicting, or unusual design requirements, such as unusual radiation patterns, for which none of the many existing antenna types are adequate.\nThe computer program starts with simple antenna shapes, then adds or modifies elements in a semirandom manner to create a number of new candidate antenna shapes. These are then evaluated to determine how well they fulfill the design requirements, and a numerical score is computed for each. Then, in a step similar to natural selection, a portion of the candidate antennas with the worst scores are discarded, leaving a small population of the highest-scoring designs. Using these antennas, the computer repeats the procedure, generating a population of even higher-scoring designs. After a number of iterations, the population of antennas is evaluated and the highest-scoring design is chosen. The resulting antenna often outperforms the best manual designs, because it has a complicated asymmetric shape that could not have been found with traditional manual design methods.\nThe first evolved antenna designs appeared in the mid-1990s from the work of Michielssen, Altshuler, Linden, Haupt, and Rahmat-Samii. Most practitioners use the genetic algorithm technique or some variant thereof to evolve antenna designs.\nAn example of an evolved antenna is an X-band antenna evolved for a 2006 NASA mission called Space Technology 5 (ST5). The mission consists of three satellites that will take measurements in Earth's magnetosphere. Each satellite has two communication antennas to talk to ground stations. The antenna has an unusual structure and was evolved to meet a challenging set of mission requirements, notably the combination of wide beamwidth for a circularly polarized wave and wide impedance bandwidth. For comparison, a traditional approach to meet the mission requirements might involve a helical antenna design, or specifically, a quadrifilar helix. The ST5 mission successfully launched on March 22, 2006, and so this evolved antenna represents the world's first artificially-evolved object to fly in space.","alt_names":["...more on Wikipedia about Evolved antenna","Evolved antenna","Evolved antenna - Wikipedia :: The free encyclopedia","Evolved antenna - Wikipedia, the free encyclopedia","Evolved antenna from Wikipedia","I can always Evolve one","Wikipedia article Evolved antenna","Wikipedia entry for Evolved antenna","antennas/ae","en.wikipedia.org/wiki/Evolved_antenna","evolved antenna","evolved antennas","http://en.wikipedia.org/wiki/Evolved_ant","http://en.wikipedia.org/wiki/Evolved_antenna","simulated usefully","using evolution to design an antenna","yago-res:Evolved antenna","“evolved antenna”"],"name":"Evolved antenna","categories":["Evolutionary algorithms","Radio frequency antenna types"],"tag_line":"In radio communications, an evolved antenna is an antenna designed fully or substantially by an automatic computer design program that uses an evolutionary algorithm that mimics Darwinian evolution."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cma-es","_score":0,"_source":{"description":"CMA-ES stands for Covariance Matrix Adaptation Evolution Strategy. Evolution strategies (ES) are stochastic, derivative-free methods for numerical optimization of non-linear or non-convex continuous optimization problems. They belong to the class of evolutionary algorithms and evolutionary computation. An evolutionary algorithm is broadly based on the principle of biological evolution, namely the repeated interplay of variation (via recombination and mutation) and selection: in each generation (iteration) new individuals (candidate solutions, denoted as ) are generated by variation, usually in a stochastic way, of the current parental individuals. Then, some individuals are selected to become the parents in the next generation based on their fitness or objective function value . Like this, over the generation sequence, individuals with better and better -values are generated.\nIn an evolution strategy, new candidate solutions are sampled according to a multivariate normal distribution in the . Recombination amounts to selecting a new mean value for the distribution. Mutation amounts to adding a random vector, a perturbation with zero mean. Pairwise dependencies between the variables in the distribution are represented by a covariance matrix. The covariance matrix adaptation (CMA) is a method to update the covariance matrix of this distribution. This is particularly useful, if the function  is ill-conditioned.\nAdaptation of the covariance matrix amounts to learning a second order model of the underlying objective function similar to the approximation of the inverse Hessian matrix in the Quasi-Newton method in classical optimization. In contrast to most classical methods, fewer assumptions on the nature of the underlying objective function are made. Only the ranking between candidate solutions is exploited for learning the sample distribution and neither derivatives nor even the function values themselves are required by the method.","alt_names":["CMA-ES","- CMA-ES :","400px-Concept_of_directional_ ...","A longer introduction on Wikipedia","CMA ES","CMA ES Wikipedia the free encyclopedia","CMA ES Wikipedia the free encyclopedia - result","CMA-ES - Wikipedia :: The free encyclopedia","CMA-ES - Wikipedia, the free encyclopedia","CMA-ES Related Content:","CMA-ES at wikipedia","CMA-ES from Wikipedia","CMA-ES on wikipedia.org","CMA-ES |","CMA-ES – Wikipedia","CMA-ES)","CMAES","Cma Es","Covariance Matrix Adaptation Evolution Strategy","Covariance Matrix Adaptation Evolution Strategy algorithm","Covariance Matrix Adaptation Evolution Strategy.","Covariance matrix adaptation","Covariance matrix adaptation evolution strategy (CMA-ES)","Example code in ...","Learn about CMA-ES>>>","What principles are CMA-ES based on","Wikipedia article CMA-ES","Wikipedia article about CMA-ES","Wikipedia entry for CMA-ES","Wikipedia-Artikel CMA-ES","covariance matrix adaptation evolution strategy","de.wikipedia.org/wiki/CMA-ES","en.wikipedia.org/wiki/CMA-ES","en:CMA-ES","http://de.wikipedia.org/wiki/CMA-ES","http://en.wikipedia.org/wiki/CMA-ES","http://en.wikipedia.org/wiki/Covariance_Matrix_Adaptation_Evolution_Strategy","wikipedia entry on CMAES","yago-res:CMA-ES"],"name":"CMA-ES","categories":["Evolutionary algorithms","Optimization algorithms and methods","Stochastic optimization"],"tag_line":"CMA-ES stands for Covariance Matrix Adaptation Evolution Strategy."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rader's-fft-algorithm","_score":0,"_source":{"description":"Rader's algorithm (1968) is a fast Fourier transform (FFT) algorithm that computes the discrete Fourier transform (DFT) of prime sizes by re-expressing the DFT as a cyclic convolution (the other algorithm for FFTs of prime sizes, Bluestein's algorithm, also works by rewriting the DFT as a convolution).\nSince Rader's algorithm only depends upon the periodicity of the DFT kernel, it is directly applicable to any other transform (of prime order) with a similar property, such as a number-theoretic transform or the discrete Hartley transform.\nThe algorithm can be modified to gain a factor of two savings for the case of DFTs of real data, using a slightly modified re-indexing/permutation to obtain two half-size cyclic convolutions of real data (Chu & Burrus, 1982); an alternative adaptation for DFTs of real data, using the discrete Hartley transform, was described by Johnson & Frigo (2007).\nWinograd extended Rader's algorithm to include prime-power DFT sizes  (Winograd 1976; Winograd 1978), and today Rader's algorithm is sometimes described as a special case of Winograd's FFT algorithm, also called the multiplicative Fourier transform algorithm (Tolimieri et al., 1997), which applies to an even larger class of sizes. However, for composite sizes such as prime powers, the Cooley–Tukey FFT algorithm is much simpler and more practical to implement, so Rader's algorithm is typically only used for large-prime base cases of Cooley–Tukey's recursive decomposition of the DFT (Frigo and Johnson, 2005).","alt_names":["Rader's FFT algorithm","Rader's","- Rader's FFT algorithm :","...more on Wikipedia about Rader's FFT algorithm","Learn about Rader's FFT algorithm>>>","Rader%27s_FFT_algorithm","Rader's FFT","Rader's FFT Algorithm","Rader's FFT algorithm - Wikipedia :: The free encyclopedia","Rader's FFT algorithm - Wikipedia, the ...","Rader's FFT algorithm - Wikipedia, the free encyclopedia","Rader's algorithm","Rader's algorithm,","Raderのアルゴリズム","Source Wikipedia.org Arcticle - Rader's FFT algorithm","What is algorithm of Rader FFT algorithm","What is algorithm of Rader's FFT algorithm?","Wikipedia article Rader's FFT algorithm","ader's","en.wikipedia.org/wiki/Rader's_FFT_algorithm","http://en.wikipedia.org/wiki/Rader%27s_FFT_algorithm","http://en.wikipedia.org/wiki/Rader's_FFT","http://en.wikipedia.org/wiki/Rader's_FFT_algorithm","rader's fft algorithm"],"name":"Rader's FFT algorithm","categories":["FFT algorithms"],"tag_line":"Rader's algorithm (1968) is a fast Fourier transform (FFT) algorithm that computes the discrete Fourier transform (DFT) of prime sizes by re-expressing the DFT as a cyclic convolution (the other algorithm for FFTs of prime sizes, Bluestein's algorithm, also works by rewriting the DFT as a convolution)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"darwintunes","_score":0,"_source":{"description":"DarwinTunes is a research project into the use of natural selection to create music led by Bob MacCallum and Armand Leroi, scientists at Imperial College London. The project asks volunteers on the Internet to listen to automatically generated sound loops and rate them based on aesthetic preference. After the volunteers rate the loops on a five-point scale, software permits the highest rated loops to 'reproduce sexually' and populate the next generation of musical loops.\nIn a paper published in the Proceedings of the National Academies of Science, the DarwinTunes developers describe how their first experimental population derived from two randomly generated founding loops, allowed 100 generations of loops to evolve without any selection pressure before asking members of the public to rate the loops. The paper found that for the first 500 to 600 generations, aesthetic quality of the loops dramatically improved before reaching a stable equilibrium. They tested this using ratings by listeners and also by using sampling techniques used by music information retrieval technology—namely the Chordino and Rhythm Patterns algorithms, which measure the presence of chords used in Western music and the presence of rhythm respectively.\n\n","alt_names":[],"name":"DarwinTunes","categories":["All stub articles","Artificial life models","Computer music software","Evolutionary algorithms","Music software stubs","Music theory stubs"],"tag_line":"DarwinTunes is a research project into the use of natural selection to create music led by Bob MacCallum and Armand Leroi, scientists at Imperial College London."}}
,{"_index":"throwtable","_type":"algorithm","_id":"biogeography-based-optimization","_score":0,"_source":{"description":"Biogeography-based optimization (BBO) is an evolutionary algorithm (EA) that optimizes a function by stochastically and iteratively improving candidate solutions with regard to a given measure of quality, or fitness function. BBO belongs to the class of metaheuristics since it includes many variations, and since it does not make any assumptions about the problem and can therefore be applied to a wide class of problems.\nBBO is typically used to optimize multidimensional real-valued functions, but it does not use the gradient of the function, which means that it does not require the function to be differentiable as required by classic optimization methods such as gradient descent and quasi-newton methods. BBO can therefore be used on discontinuous functions.\nBBO optimizes a problem by maintaining a population of candidate solutions, and creating new candidate solutions by combining existing ones according to a simple formula. In this way the objective function is treated as a black box that merely provides a measure of quality given a candidate solution, and the function's gradient is not needed.\nLike many EAs, BBO was motivated by a natural process; in particular, BBO was motivated by biogeography, which is the study of the distribution of biological species through time and space. BBO was originally introduced by Dan Simon in 2008.\n^ \n^","alt_names":[],"name":"Biogeography-based optimization","categories":["Evolutionary algorithms","Stochastic optimization"],"tag_line":"Biogeography-based optimization (BBO) is an evolutionary algorithm (EA) that optimizes a function by stochastically and iteratively improving candidate solutions with regard to a given measure of quality, or fitness function."}}
,{"_index":"throwtable","_type":"algorithm","_id":"constructive-cooperative-coevolution","_score":0,"_source":{"description":"The constructive cooperative coevolutionary algorithm (also called C3) is an global optimisation algorithm in artificial intelligence based on the multi-start architecture of the greedy randomized adaptive search procedure (GRASP). It incorporates the existing cooperative coevolutionary algorithm (CC). The considered problem is decomposed into subproblems. These subproblems are optimised separately while exchanging information in order to solve the complete problem. An optimisation algorithm, usually but not necessarily an evolutionary algorithm, is embedded in C3 for optimising those subproblems. The nature of the embedded optimisation algorithm determines whether C3's behaviour is deterministic or stochastic.\nThe C3 optimisation algorithm was originally designed for simulation-based optimisation but it can be used for global optimisation problems in general. Its strength over other optimisation algorithms, specifically cooperative coevolution, is that it is better able to handle non-separable optimisation problems.","alt_names":[],"name":"Constructive cooperative coevolution","categories":["Evolutionary algorithms","Evolutionary computation","Mathematical optimization","Optimization algorithms and methods"],"tag_line":"The constructive cooperative coevolutionary algorithm (also called C3) is an global optimisation algorithm in artificial intelligence based on the multi-start architecture of the greedy randomized adaptive search procedure (GRASP)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"artificial-bee-colony-algorithm","_score":0,"_source":{"description":"In computer science and operations research, the artificial bee colony algorithm (ABC) is an optimization algorithm based on the intelligent foraging behaviour of honey bee swarm, proposed by Karaboga in 2005.\n\n","alt_names":[],"name":"Artificial bee colony algorithm","categories":["All articles needing expert attention","Articles needing expert attention","Articles needing expert attention with no reason or talk parameter","Articles needing unspecified expert attention","Bees","Collective intelligence","Evolutionary algorithms","Optimization algorithms and methods"],"tag_line":"In computer science and operations research, the artificial bee colony algorithm (ABC) is an optimization algorithm based on the intelligent foraging behaviour of honey bee swarm, proposed by Karaboga in 2005.\n\n"}}
,{"_index":"throwtable","_type":"algorithm","_id":"cyclotomic-fast-fourier-transform","_score":0,"_source":{"description":"The cyclotomic fast Fourier transform is a type of fast Fourier transform algorithm over finite fields. This algorithm first decomposes a DFT into several circular convolutions, and then derives the DFT results from the circular convolution results. When applied to a DFT over , this algorithm has a very low multiplicative complexity. In practice, since there usually exist efficient algorithms for circular convolutions with specific lengths, this algorithm is very efficient.","alt_names":[],"name":"Cyclotomic fast Fourier transform","categories":["Discrete transforms","FFT algorithms"],"tag_line":"The cyclotomic fast Fourier transform is a type of fast Fourier transform algorithm over finite fields."}}
,{"_index":"throwtable","_type":"algorithm","_id":"particle-swarm-optimization","_score":0,"_source":{"description":"In computer science, particle swarm optimization (PSO) is a computational method that optimizes a problem by iteratively trying to improve a candidate solution with regard to a given measure of quality. PSO optimizes a problem by having a population of candidate solutions, here dubbed particles, and moving these particles around in the search-space according to simple mathematical formulae over the particle's position and velocity. Each particle's movement is influenced by its local best known position but, is also guided toward the best known positions in the search-space, which are updated as better positions are found by other particles. This is expected to move the swarm toward the best solutions.\nPSO is originally attributed to Kennedy, Eberhart and Shi and was first intended for simulating social behaviour, as a stylized representation of the movement of organisms in a bird flock or fish school. The algorithm was simplified and it was observed to be performing optimization. The book by Kennedy and Eberhart describes many philosophical aspects of PSO and swarm intelligence. An extensive survey of PSO applications is made by Poli.\nPSO is a metaheuristic as it makes few or no assumptions about the problem being optimized and can search very large spaces of candidate solutions. However, metaheuristics such as PSO do not guarantee an optimal solution is ever found. More specifically, PSO does not use the gradient of the problem being optimized, which means PSO does not require that the optimization problem be differentiable as is required by classic optimization methods such as gradient descent and quasi-newton methods. PSO can therefore also be used on optimization problems that are partially irregular, noisy, change over time, etc.\n\n","alt_names":["particle swarm optimization","- Particle swarm :","- Particle swarm optimization :","...Wikipedia Optimisation par essaims particulaires","...more on Wikipedia about Particle swarm optimization","2 A basic, canonical PSO algorithm","2.1 Pseudo code","3 Variations and practicalities","A basic canonical PSO algorithm","Definition Particle ... /span>","Definition Particle Swarm Optimisation","Enjambre de Partículas","Essaims particulaires","More specifically, PSO does not use the gradient","OEP (fr)","Opportunities for improvement: 1","Optimalizace hejnem částic","Optimalizace hejnem částic - Wikipedie","Optimisation par essaims de particules","Optimisation par essaims particulaires","Optimisation par essaims particulaires - Wikip?dia","Optimisation par essaims particulaires - Wikipédia","Optimización o Inteligencia por Enjambres de Partículas","Optimização por enxame de partículas","Otimização por enxame de partículas","PSO (Particle Swarm Optimi","PSO (Particle Swarm Optimisation)","PSO (Particle Swarm Optimization)","PSO (en)","PSO Algorithm","PSO wikipedia article","PSO?","Partical Swarm","Partical Swarm Optimization (PSO)","Particle Swarm","Particle Swarm Intelligence - Wikipedia","Particle Swarm Optimisation","Particle Swarm Optimization","Particle Swarm Optimization (PSO)","Particle Swarm Optimization(PSO)","Particle Swarm Optimization?","Particle Swarm Optimizer","Particle Swarm Optmization","Particle Sworm optimization","Particle swarm","Particle swarm optimisation","Particle swarm optimisation; it is used under the","Particle swarm optimizati","Particle swarm optimization","Particle swarm optimization (PSO)","Particle swarm optimization - Wikipedia, the free ...","Particle swarm optimization - Wikipedia, the free en...","Particle swarm optimization - Wikipedia, the free encyclo...","Particle swarm optimization - Wikipedia, the free encyclopedia","Particle swarm optimization - Wikipedia, the free encyclopedia ...","Particle swarm optimization ...","Particle swarm optimization Wikipedia the free encyclopedia","Particle swarm optimization Wikipedia the free encyclopedia - result","Particle swarm optimization →","Particle swarm optimization; it is used under the","Particle swarm optimizers","Particle-Swarm Optimisation","Particle_swarm_optimization","Read More particle swarm optimization wikipedia the free","Schwarm -> Particle Swarm Optimization","Stoluri de particule","Swarm Optimization","Swarm optimization","Tối ưu bầy đàn - Wikipedia tiếng Việt","Tối ưu bầy đàn – Wikipedia tiếng Việt","Tối ưu bẩy đàn","Variations and practicalities","View Particle swarm optimization on Wikipedia","WIKIPEDIA for PSO","What is the overview of Particle Swarm Optimization","Wikipedia article Optimização por enxame de partículas","Wikipedia article Particle swarm","Wikipedia article Particle swarm optimisation","Wikipedia article Particle swarm optimization","Wikipedia article on Particle Swarm Optimization","Wikipedia article on Particle swarm optimisation","Wikipedia article Метод роя частиц","Wikipedia entry for Particle swarm optimization","Wikipedia: Particle swarm optimization","Wikipediaで「粒子群最適化」を調べる","Wkipedia 粒子群最適化","cs:Optimalizace hejnem částic","en.wikipedia.org/...Particle_swarm_optimization","en.wikipedia.org/wiki/Particle_swarm_...","en.wikipedia.org/wiki/Particle_swarm_optimisa...","evolutionaeres","f particle swarm optimization","fa:روش بهینهسازی ازدحام ذرات","fr:Optimisation par essaims particulaires","http://cs.wikipedia.org/wiki/Optimalizace_hejnem_%C4%8D","http://en.wikipedia....rm_optimization","http://en.wikipedia.org/wiki/Parti [...] timization","http://en.wikipedia.org/wiki/Particl...m_optimization","http://en.wikipedia.org/wiki/Particle_Swarm_Optimization","http://en.wikipedia.org/wiki/Particle_s ... timization","http://en.wikipedia.org/wiki/Particle_sw","http://en.wikipedia.org/wiki/Particle_swarm","http://en.wikipedia.org/wiki/Particle_swarm_optimi zation","http://en.wikipedia.org/wiki/Particle_swarm_optimization","http://en.wikipedia.org/wiki/Particle_sw…","http://fr.wikipedia.org/wiki/Optimisation_par_essaims_partic...","http://fr.wikipedia.org/wiki/Optimisation_par_essaims_particulaires","http://j.mp/eMhdvt","it:Particle Swarm Optimization","it:Particle swarm optimization","j = 1 , ... , m","ja:粒子群最適化","logic of a swarm","optimisation par essaims particulaires","partical swarm optimization","particle swarm","particle swarm optimisation","particle swarm optimization (PSO)","particle swarm optimization (tối ưu bầy đàn)","particle swarm optimization algorithm","particle swarm optimization wikipedia the encyclopedia","particle swarms","particle-swarm optimisation","particle-swarm optimization","particle-swarm optimizer","particle-swarm-optimisation","partikelsvärmoptimering","pt:Enxame de partículas","pt:Optimização por enxame de partículas","ru:Метод роя частиц","részecske raj optimalizáció","search for consensus","source: http://en.wikipedia.org/wiki/Particle_Swarm_Optimization","uk:Метод рою часток","vi:Tối ưu bầy đàn","wikipedia entry on PSO","zh:粒子群优化","Метод роя частиц","роевой оптимизации","روش بهینهسازی ازدحام ذرات","روش بهینهسازی ازدحام ذرات - ویکی ...","روش بهینهسازی ازدحام ذرات - ویکیپدیا","झुंड","“Particle swarm optimization - Wikipedia, the free encyclopedia”, en","微粒群算法","粒子群优化","粒子群优化算法","粒子群優化- Wikipedia","粒子群優化- 維基百科，自由的百科全書","粒子群最適化","粒子群最適化 - Wikipedia","粒子群最適化-wikipedia","粒子群算法","𝐫 1 , 𝐫 2"],"name":"Particle swarm optimization","categories":["Evolutionary algorithms","Optimization algorithms and methods","Pages using citations with format and no URL"],"tag_line":"In computer science, particle swarm optimization (PSO) is a computational method that optimizes a problem by iteratively trying to improve a candidate solution with regard to a given measure of quality."}}
,{"_index":"throwtable","_type":"algorithm","_id":"gaussian-adaptation","_score":0,"_source":{"description":"Gaussian adaptation (GA) (also referred to as normal or natural adaptation and sometimes abbreviated as NA) is an evolutionary algorithm designed for the maximization of manufacturing yield due to statistical deviation of component values of signal processing systems. In short, GA is a stochastic adaptive process where a number of samples of an n-dimensional vector x[xT = (x1, x2, ..., xn)] are taken from a multivariate Gaussian distribution, N(m, M), having mean m and moment matrix M. The samples are tested for fail or pass. The first- and second-order moments of the Gaussian restricted to the pass samples are m* and M*.\nThe outcome of x as a pass sample is determined by a function s(x), 0 < s(x) < q ≤ 1, such that s(x) is the probability that x will be selected as a pass sample. The average probability of finding pass samples (yield) is\n\nThen the theorem of GA states:\n\nFor any s(x) and for any value of P < q, there always exist a Gaussian p. d. f. that is adapted for maximum dispersion. The necessary conditions for a local optimum are m = m* and M proportional to M*. The dual problem is also solved: P is maximized while keeping the dispersion constant (Kjellström, 1991).\n\nProofs of the theorem may be found in the papers by Kjellström, 1970, and Kjellström & Taxén, 1981.\nSince dispersion is defined as the exponential of entropy/disorder/average information it immediately follows that the theorem is valid also for those concepts. Altogether, this means that Gaussian adaptation may carry out a simultaneous maximisation of yield and average information (without any need for the yield or the average information to be defined as criterion functions).\nThe theorem is valid for all regions of acceptability and all Gaussian distributions. It may be used by cyclic repetition of random variation and selection (like the natural evolution). In every cycle a sufficiently large number of Gaussian distributed points are sampled and tested for membership in the region of acceptability. The centre of gravity of the Gaussian, m, is then moved to the centre of gravity of the approved (selected) points, m*. Thus, the process converges to a state of equilibrium fulfilling the theorem. A solution is always approximate because the centre of gravity is always determined for a limited number of points.\nIt was used for the first time in 1969 as a pure optimization algorithm making the regions of acceptability smaller and smaller (in analogy to simulated annealing, Kirkpatrick 1983). Since 1970 it has been used for both ordinary optimization and yield maximization.","alt_names":["Computer simulation of Gaussian adaptation","Gaussian Adaptation","Gaussian adapation","Gaussian adaptation","Gaussian adaptation - Wikipedia :: The free encyclopedia","Gaussian adaptation - Wikipedia, the free encyclopedia","Gaussian adaptation Wikipedia the free encyclopedia","Gaussian adaptation Wikipedia the free encyclopedia - result","Gaussian adaptation and free will","Gaussian adaptation,","Hamilton, 1963","How to climb a mountain","Natural evolution and Gaussian adaptation","P ( m ) = ∫ s ( x ) N ( m - x ) d","The evolution in the brain","Theorem of Gaussian adaptation","Wikipedia (Gaussian adaptation)","Wikipedia article Gaussian adaptation","Wikipedia article Gaussian_adaptation","Wikipedia entry for Gaussian adaptation","din wikisida","effektivitetsteorem","en:Gaussian adaptation","entirety of society","gaussian adaptation","gaussisk adaption","http://en.wikipedia.org/wiki/Gaussian_ad","http://en.wikipedia.org/wiki/Gaussian_adapation","http://en.wikipedia.org/wiki/Gaussian_adapation#References","http://en.wikipedia.org/wiki/Gaussian_adapation#The_evolution_in_the_brain","http://en.wikipedia.org/wiki/Gaussian_adapation#the-evolution","http://en.wikipedia.org/wiki/Gaussian_adaptation","http://en.wikipedia.org/wiki/Gaussian_adaptation#References","http://en.wikipedia.org/wiki/Gaussian_adaptation#references","referenserna","se referenslista","teoremen för centrering av normalfördelningar"],"name":"Gaussian adaptation","categories":["All articles lacking reliable references","All articles needing additional references","All articles needing expert attention","Articles lacking reliable references from July 2008","Articles needing additional references from July 2008","Articles needing expert attention from January 2015","Articles needing expert attention with no reason or talk parameter","Creationism","Creativity","Evolutionary algorithms","Free will","Mathematics articles needing expert attention","Wikipedia articles with possible conflicts of interest from March 2009"],"tag_line":"Gaussian adaptation (GA) (also referred to as normal or natural adaptation and sometimes abbreviated as NA) is an evolutionary algorithm designed for the maximization of manufacturing yield due to statistical deviation of component values of signal processing systems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"shoelace-formula","_score":0,"_source":{"description":"The shoelace formula or shoelace algorithm (also known as Gauss's area formula and the surveyor's formula) is a mathematical algorithm to determine the area of a simple polygon whose vertices are described by ordered pairs in the plane. The user cross-multiplies corresponding coordinates to find the area encompassing the polygon, and subtracts it from the surrounding polygon to find the area of the polygon within. It is called the shoelace formula because of the constant cross-multiplying for the coordinates making up the polygon, like tying shoelaces. It is also sometimes called the shoelace method. It has applications in surveying and forestry, among other areas.\nThe formula was described by Meister (1724-1788) in 1769 and by Gauss in 1795. It can be verified by dividing the polygon into triangles, but it can also be seen as a special case of Green's theorem.\nThe area formula is derived by taking each edge AB, and calculating the (signed) area of triangle ABO with a vertex at the origin O, by taking the cross-product (which gives the area of a parallelogram) and dividing by 2. As one wraps around the polygon, these triangles with positive and negative area will overlap, and the areas between the origin and the polygon will be cancelled out and sum to 0, while only the area inside the reference triangle remains. This is why the formula is called the Surveyor's Formula, since the \"surveyor\" is at the origin; if going counterclockwise, positive area is added when going from left to right and negative area is added when going from right to left, from the perspective of the origin.\nThe area formula is valid for any non-self-intersecting (simple) polygon, which can be convex or concave.\n^ Bart Braden (1986). \"The Surveyor’s Area Formula\" (PDF). The College Mathematics Journal 17 (4): 326–337. doi:10.2307/2686282. \n^ a b Dahlke, Karl. \"Shoelace Formula\". Retrieved 9 June 2008. \n^ Hans Pretzsch, Forest Dynamics, Growth and Yield: From Measurement to Model, Springer, 2009, ISBN 3-540-88306-1, p. 232.\n^ Meister, A. L. F. (1769), \"Generalia de genesi figurarum planarum et inde pendentibus earum affectionibus\", Nov. Com. Gött. (in Latin) 1: 144 .","alt_names":["Gauss' area formula","544513d76a101a9a64f28a8b58ed ...","Polygon_area_formula.jpg http://en.wikipedia.org/wiki/Shoelace_formula","Read More shoelace formula wikipedia the free encyclopedia","Recall: Shoelace Formula","Shoelace Method","Shoelace algorithm","Shoelace formula","Shoelace formula - Wikipedia, the free encyclopedia","Shoelace formula Wikipedia the free encyclopedia","Shoelace formula; it is used under the","Shoelace_formula","What are some examples of Shoelace formula","Wikipedia article Gauss' area formula","Wikipedia article Shoelace algorithm","Wikipedia article Shoelace formula","Wikipedia article on Gauss' area formula","Wikipedia entry for Shoelace formula","area of the polygon","http://en.wikipedia.org/wiki/Gauss%27_area_formula","http://en.wikipedia.org/wiki/Shoelace_formula","http://en.wikipedia.org/wiki/Shoelace_fo…","shoelace formula","𝐀 = 1 / 2 | x 1 y 2 + x"],"name":"Shoelace formula","categories":["CS1 Latin-language sources (la)","Geometric algorithms","Surveying"],"tag_line":"The shoelace formula or shoelace algorithm (also known as Gauss's area formula and the surveyor's formula) is a mathematical algorithm to determine the area of a simple polygon whose vertices are described by ordered pairs in the plane."}}
,{"_index":"throwtable","_type":"algorithm","_id":"diamond-square-algorithm","_score":0,"_source":{"description":"The diamond-square algorithm is a method for generating heightmaps for computer graphics. It is a slightly better algorithm than the three-dimensional implementation of the midpoint displacement algorithm which produces two-dimensional landscapes. It is also known as the random midpoint displacement fractal, the cloud fractal or the plasma fractal, because of the plasma effect produced when applied.\nThe idea was first introduced by Fournier, Fussell and Carpenter at SIGGRAPH 1982. It was later analyzed by Gavin S. P. Miller in SIGGRAPH 1986 who described it as flawed because the algorithm produces noticeable vertical and horizontal \"creases\" due to the most significant perturbation taking place in a rectangular grid.\nThe algorithm starts with a 2D grid then randomly generates terrain height from four seed values arranged in a grid of points so that the entire plane is covered in squares.\n\n","alt_names":["-Square Diamond algoritmo","0 2 4 8","Algorithme Diamant-Carré","Algorithme Diamant-Carré - Wikipédia","Diamant-Carré","Diamond Square","Diamond Square Algorithm","Diamond square algorithm","Diamond-Square","Diamond-Square Algorithm","Diamond-Square algorithm","Diamond-Square-Algorithmus","Diamond-Squares Algorithm","Diamond-pladsen algoritme","Diamond-square","Diamond-square algorithm","Diamond-square algorithm - Wikipedia :: The free encyclopedia","Diamond-square algorithm - Wikipedia, the free encyclopedia","Diamond-square algorithm - Wikipedia, the free encyclopedia ...","Diamond-square algorithm – Wikipedia, the free encyclopedia","Diamond-square algorithm.","Diamond-square algorithm; it is used under the","Diamond-square_algorithm","Diamond/Square","Learn about Diamond-square algorithm>>>","Midpoint Displacement Algorithm","Midpoint displacement algorithm","Plasma fractal","Rauschfunktion","What are applications of Diamond-square algorithm","Wikipedia article Diamond-square algorithm","Wikipedia article Midpoint displacement algorithm","Wikipedia article about Diamond-square algorithm","Wikipedia article about MDA","Wikipedia entry for Diamond-square algorithm","Wikipedia sur Algorithme Diamant-Carré","Wolkenfraktal","[Random Midpoint Displacement Method] Fournier,A., Fussel,D","ar:خوارزمية مربع الماس","diamant-náměstí algoritmus","diamant-čtverec","diamod-square algorithm","diamond square","diamond square algorithm","diamond squares","diamond-square","diamond-square algorithm","diamond-square algorithm here","dynamic terrain generation","en.wikipedia.org/wiki/Diamond-square_algorithm","fr:Algorithme Diamant-Carré","http://en.wikipedia....quare_algorithm","http://en.wikipedia.org/wiki/Diamond-squ","http://en.wikipedia.org/wiki/Diamond-square_algorithm","http://en.wikipedia.org/wiki/Midpoint_d ... _algorithm","http://en.wikipedia.org/wiki/Midpoint_displacement_algorithm","http://fr.wikipedia.org/wiki/Algorithme_Diamant-Carr%C3","mid-point displacement algorithm","midpoint displacement algorithm","midpoint displacement fractal","midpoint-displacement algorithm","random midpoint displacement","random midpoint displacement algorithm","the Diamond-Square Algorithm","خوارزمية مربع الماس","हूँ हीरे स्क्वायर","钻石广场算法"],"name":"Diamond-square algorithm","categories":["Computer graphics algorithms","Fractals","Pages using citations with accessdate and no URL","Procedural generation"],"tag_line":"The diamond-square algorithm is a method for generating heightmaps for computer graphics."}}
,{"_index":"throwtable","_type":"algorithm","_id":"marching-squares","_score":0,"_source":{"description":"Marching squares is a computer graphics algorithm that generates contours for a two-dimensional scalar field (rectangular array of individual numerical values). A similar method can be used to contour 2D triangle meshes.\nThe contours can be of two kinds:\nIsolines - lines following a single data level, or isovalue.\nIsobands - filled areas between isolines.\nTypical applications include the Contour lines on topographic maps or the generation of isobars for weather maps.\nMarching squares takes a similar approach to the 3D marching cubes algorithm:\nProcess each cell in the grid independently.\nCalculate a cell index using comparisons of the contour level(s) with the data values at the cell corners.\nUse a pre-built lookup table, keyed on the cell index, to describe the output geometry for the cell.\nApply linear interpolation along the boundaries of the cell to calculate the exact contour position.","alt_names":["...Wikipedia Marching squares","How it works for Marching squares","Marching Squares","Marching Squares - Wikipedia","Marching Squares Algorithm","Marching Squares on Wikipedia","Marching Squares – Wikipedia","Marching Squares/Cubes","Marching squares","Marching squares - Wikipedia, the free encyclopedia","Marching squares - Wikipédia","Marching_squares","Marschieren Quadrate","Plätze marschieren","Wikipedia article Marching squares","Wikipedia entry for Marching squares","Wikipedia（英語）リンク","diễu hành quảng trường","en marche carrés","en.wikipedia.org/wiki/Marching_squares","en:Marching_squares","http://de.wikipedia.org/wiki/Marching_Squares","http://en.wikipedia....arching_squares","http://en.wikipedia.org/wiki/Marching_sq","http://en.wikipedia.org/wiki/Marching_squares","http://en.wikipedia.org/wiki/Marching_squares.","http://ru.wikipedia.org/wiki/Marching_squares","hình vuông diễu hành","idzie placów","kotak berbaris","l'article de Wikipédia Marching Squares","l'article de Wikipédia Marching squares","marcha cuadrados","marchar cuadrados","marchar quadrados","marcheren pleinen","marcherende firkanter","marching piazze","marching squares","marching squares algorithm","marching-squares","marcia piazze","marschieren Plätzen","veranschaulichte Version des Marching-Squares-Algorithmus in der","yago-res:Marching squares","идут квадраты","походной квадратов","походных квадратов","مربعات سيارة","สี่เหลี่ยม marching","เดินขบวนสี่เหลี่ยม","を行進。","游行方阵","行進乗","行進二乗","遊行方陣","사각형을 행진","행진 사각형"],"name":"Marching squares","categories":["Computer graphics algorithms"],"tag_line":"Marching squares is a computer graphics algorithm that generates contours for a two-dimensional scalar field (rectangular array of individual numerical values)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"geometric-design","_score":0,"_source":{"description":"Geometric design (GD), also known as geometric modelling, is a branch of computational geometry. It deals with the construction and representation of free-form curves, surfaces, or volumes. Core problems are curve and surface modelling and representation. GD studies especially the construction and manipulation of curves and surfaces given by a set of points using polynomial, rational, piecewise polynomial, or piecewise rational methods. The most important instruments here are parametric curves and parametric surfaces, such as Bézier curves, spline curves and surfaces. An important non-parametric approach is the level set method.\nApplication areas include shipbuilding, aircraft, and automotive industries, as well as architectural design. The modern ubiquity and power of computers means that even perfume bottles and shampoo dispensers are designed using techniques unheard of by shipbuilders of 1960s.\nGeometric models can be built for objects of any dimension in any geometric space. Both 2D and 3D geometric models are extensively used in computer graphics. 2D models are important in computer typography and technical drawing. 3D models are central to computer-aided design and manufacturing, and many applied technical fields such as geology and medical image processing.\nGeometric models are usually distinguished from procedural and object-oriented models, which define the shape implicitly by an algorithm. They are also contrasted with digital images and volumetric models; and with implicit mathematical models such as the zero set of an arbitrary polynomial. However, the distinction is often blurred: for instance, geometric shapes can be represented by objects; a digital image can be interpreted as a collection of colored squares; and geometric shapes such as circles are defined by implicit mathematical equations. Also, the modeling of fractal objects often requires a combination of geometric and procedural techniques.\nGeometric problems originating in architecture can lead to interesting research and results in geometry processing, computer-aided geometric design, and discrete differential geometry.","alt_names":["- Geometric design :","Geometric Design","Geometric Design - Wikipedia, The Free Encyclopedia","Geometric design - Wikipedia, the free encyclopedia","Geometric_design","Wikipedia article Geometric design","Wikipedia article on Geometric design","Wikipedia entry for Geometric design","geometric design","http://en.wikipedia.org/wiki/Geometric_design","yago-res:Geometric design"],"name":"Geometric design","categories":["Computational science","Computer-aided design","Geometric algorithms"],"tag_line":"Geometric design (GD), also known as geometric modelling, is a branch of computational geometry."}}
,{"_index":"throwtable","_type":"algorithm","_id":"symmetrization-methods","_score":0,"_source":{"description":"In mathematics the symmetrization methods are algorithms of transforming a set  to a ball  with equal volume  and centered at the origin. B is called the symmetrized version of A, usually denoted . These algorithms show up in solving the classical isoperimetric inequality problem, which asks: Given all two-dimensional shapes of a given area, which of them has the minimal perimeter (for details see Isoperimetric inequality). The conjectured answer was the disk and Steiner in 1838 showed this to be true using the Steiner symmetrization method (described below). From this many other isoperimetric problems sprung and other symmetrization algorithms. For example, Rayleigh's conjecture is that the first eigenvalue of the Dirichlet problem is minimized for the ball (see Rayleigh–Faber–Krahn inequality for details). Another problem is that the Newtonian capacity of a set A is minimized by  and this was proved by Polya and G. Szego (1951) using circular symmetrization (described below).","alt_names":[],"name":"Symmetrization methods","categories":["Geometric algorithms","Geometric inequalities"],"tag_line":"In mathematics the symmetrization methods are algorithms of transforming a set  to a ball  with equal volume  and centered at the origin."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cone-algorithm","_score":0,"_source":{"description":"In computational geometry, the cone algorithm is an algorithm for identifying the particles that are near the surface of an object composed of discrete particles. Its applications include computational surface science and computational nano science. The cone algorithm was first described in a publication about nanogold in 2005.\nThe cone algorithm works well with clusters in condensed phases, including solid and liquid phases. It can handle the situations when one configuration includes multiple clusters or when holes exist inside clusters. It can also be applied to a cluster iteratively to identify multiple sub-surface layers.","alt_names":["Cone algorithm","Cone algorithm - Wikipedia, the free encyclopedia","The cone algorithm -- wikipedia","Wikipedia article about Cone algorithm","Wikipedia entry for Cone algorithm","http://en.wikipedia.org/wiki/Cone_algorithm"],"name":"Cone algorithm","categories":["Geometric algorithms","Molecular modelling software"],"tag_line":"In computational geometry, the cone algorithm is an algorithm for identifying the particles that are near the surface of an object composed of discrete particles."}}
,{"_index":"throwtable","_type":"algorithm","_id":"melomics","_score":0,"_source":{"description":"Melomics (derived from \"genomics of melodies\") is a computational system for the automatic composition of music (with no human intervention), based on bioinspired algorithms.","alt_names":[],"name":"Melomics","categories":["Biotechnology","Evolutionary algorithms","Music technology","Spanish Supercomputing Network"],"tag_line":"Melomics (derived from \"genomics of melodies\") is a computational system for the automatic composition of music (with no human intervention), based on bioinspired algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"newell's-algorithm","_score":0,"_source":{"description":"Newell's Algorithm is a 3D computer graphics procedure for elimination of polygon cycles in the depth sorting required in hidden surface removal. It was proposed in 1972 by brothers Martin Newell and Dick Newell, and Tom Sancha, while all three were working at CADCentre.\nIn the depth sorting phase of hidden surface removal, if two polygons have no overlapping extents or extreme minimum and maximum values in the x, y, and z directions, then they can be easily sorted. If two polygons, Q and P, do have overlapping extents in the Z direction, then it is possible that cutting is necessary.\n\nIn that case Newell's algorithm tests the following:\nTest for Z overlap; implied in the selection of the face Q from the sort list\nThe extreme coordinate values in X of the two faces do not overlap (minimax test in X)\nThe extreme coordinate values in Y of the two faces do not overlap (minimax test in Y)\nAll vertices of P lie deeper than the plane of Q\nAll vertices of Q lie closer to the viewpoint than the plane of P\nThe rasterisation of P and Q do not overlap\nNote that the tests are given in order of increasing computational difficulty.\nNote also that the polygons must be planar.\nIf the tests are all false, then the polygons must be split. Splitting is accomplished by selecting one polygon and cutting it along the line of intersection with the other polygon. The above tests are again performed, and the algorithm continues until all polygons pass the above tests.","alt_names":["Newell's algorithm","(External) http://en.wikipedia.org/wiki/Newell%27s_algorithm","- Newell's algorithm :","...Wikipedia Algoritmo de Newell","...mehr auf Wikipedia über Newells Algorithmus","Algoritmo de Newell","Depth-Sort-Algorithmus","Depth-Sort-Algorithmus - Wikipedia","Depth-Sort-Algorithmus â€“ Wikipedia","Depth-Sort-Algorithmus – Wikipedia","Newell%27s_algorithm","Newell&#39;s algorithm - Wikipedia, the free encyclopedia","Newell's Algorithm","Newell's algorithm - Wikipedia, the free encyclopedia","Newell's algorithm from Wikipedia","Wikipedia article Newell algorithm","Wikipedia article Newell's algorithm","Wikipedia-Artikel Depth-Sort-Algorithmus","Wikipedia-Artikel Newells Algorithmus","artículo de Wikipedia Algoritmo de Newell","http://de.wikipedia.org/wiki/Depth-Sort-","http://de.wikipedia.org/wiki/Depth-Sort-Algorithmus","http://en.wikipedia.org/wiki/Newell%27s_algorithm","http://en.wikipedia.org/wiki/Newell's_algorithm","http://es.wikipedia.org/wiki/Algoritmo_de_Newell","ich hatte echt schon mehr Spaß","mehr zu Depth-Sort-Algorithmus","that's a concept as old as CG itself"],"name":"Newell's algorithm","categories":["3D computer graphics","All stub articles","Computer graphics algorithms","Computer graphics stubs"],"tag_line":"Newell's Algorithm is a 3D computer graphics procedure for elimination of polygon cycles in the depth sorting required in hidden surface removal."}}
,{"_index":"throwtable","_type":"algorithm","_id":"mclone","_score":0,"_source":{"description":"MClone, or Clonal Mosaic, is a pattern formation algorithm proposed in 1998 used specially for simulating the visible patches of color in the fur of giraffes and members of the Felidae family of the mammalians. It was primarily proposed as a 2D model and lately was extended to 3D. An important feature of the algorithm is that it is biologically plausible.\nSince the algorithm was created in order to address some of the problems with texture mapping, its main goal is to produce, with the same set of parameters, a variable number of color patterns for a 2D or 3D object model. This way, for a relatively big amount of different entities represented by the same model, instead of using the same texture (and, doing so, each object would be equal to the others), one could use the different color patterns created by the MClone algorithm. Another useful feature of MClone is that it can be used to create patterns along with growing data of the object model.\n^ Walter, M. (December 1998). Integration of Complex Shapes and Natural Patterns (Ph.D. thesis). University of British Columbia. CiteSeerX: 10.1.1.89.5497. \n^ Walter, M.; Fournier, A.; Reimers, M. (June 1998). \"Clonal mosaic model for the synthesis of mammalian coat patterns\". Proceedings of Graphics Interface 1998. pp. 82–91. CiteSeerX: 10.1.1.6.1013. \n^ M.Walter, A.Fournier, and D.Menevaux. 2001. Integrating shape and pattern in mammalian models. Proceedings of SIGGRAPH 2001 (August), 317-326.","alt_names":["MClone","MClone - Wikipedia, the free encyclopedia","MClone; it is used under the","Wikipedia article MClone","http://en.wikipedia.org/wiki/MClone"],"name":"MClone","categories":["All articles needing additional references","Articles needing additional references from June 2011","Computer graphics algorithms"],"tag_line":"MClone, or Clonal Mosaic, is a pattern formation algorithm proposed in 1998 used specially for simulating the visible patches of color in the fur of giraffes and members of the Felidae family of the mammalians."}}
,{"_index":"throwtable","_type":"algorithm","_id":"marching-tetrahedra","_score":0,"_source":{"description":"Marching tetrahedra is an algorithm in the field of computer graphics to render implicit surfaces. It clarifies a minor ambiguity problem of the marching cubes algorithm with some cube configurations.\nSince more than 20 years have passed from the patent filing date of the marching cubes (June 5, 1985), the original algorithm can be used freely again, adding only the minor modification to circumvent the aforementioned ambiguity in some configurations.\nIn marching tetrahedra, each cube is split into six irregular tetrahedra by cutting the cube in half three times, cutting diagonally through each of the three pairs of opposing faces. In this way, the tetrahedra all share one of the main diagonals of the cube. Instead of the twelve edges of the cube, we now have nineteen edges: the original twelve, six face diagonals, and the main diagonal. Just like in marching cubes, the intersections of these edges with the isosurface are approximated by linearly interpolating the values at the grid points.\nAdjacent cubes share all edges in the connecting face, including the same diagonal. This is an important property to prevent cracks in the rendered surface, because interpolation of the two distinct diagonals of a face usually gives slightly different intersection points. An added benefit is that up to five computed intersection points can be reused when handling the neighbor cube. This includes the computed surface normals and other graphics attributes at the intersection points.\nEach tetrahedron has sixteen possible configurations, falling into three classes: no intersection, intersection in one triangle and intersection in two (adjacent) triangles. It is straightforward to enumerate all sixteen configurations and map them to vertex index lists defining the appropriate triangle strips.","alt_names":[],"name":"Marching tetrahedra","categories":["All articles needing additional references","Articles needing additional references from September 2012","Computer graphics algorithms"],"tag_line":"Marching tetrahedra is an algorithm in the field of computer graphics to render implicit surfaces."}}
,{"_index":"throwtable","_type":"algorithm","_id":"david-avis","_score":0,"_source":{"description":"David Michael Avis (born March 20, 1951) is a Canadian and British computer scientist known for his contributions to geometric computations. Avis is a professor in computational geometry and applied mathematics in the School of Computer Science, McGill University, in Montreal. Since 2010, he belongs to Department of Communications and Computer Engineering, School of Informatics, Kyoto University.\nAvis received his Ph.D. in 1977 from Stanford University. He has published more than 70 journal papers and articles. Writing with Komei Fukuda, Avis proposed a reverse-search algorithm for the vertex enumeration problem; their algorithm generates all of the vertices of a convex polytope.\nHe has a collaboration article with Paul Erdős. Therefore, his Erdős number is 1.\n^ David Avis at the Mathematics Genealogy Project\n^ Avis & Fukuda (1992)\n^ Avis & Fukuda (1996)\n^ David Avis, Paul Erdös and János Pach: \"Repeated distances in space\"(1988)","alt_names":["- David Avis :","Avis, D.","Avis, David","David Avis","David Avis - Wikipedia, la enciclopedia libre","David Avis - Wikipedia, the free encyclopedia","David Avis - Wikipedya","David Avis from Wikipedia","David Avis – Wikipedia, the free encyclopedia","Wikipedia article David Avis","Wikipedia article about David Avis","Wikipedia article on David Avis","david avis wikipedia the free encyclopedia","ht:David Avis","http://en.wikipedia.org/wiki/David Avis","http://en.wikipedia.org/wiki/David_Avis","http://es.wikipedia.org/wiki/David_Avis","yago-res:David Avis"],"name":"David Avis","categories":["1951 births","20th-century British mathematicians","21st-century British mathematicians","All stub articles","Anglophone Quebec people","British mathematician stubs","Living people","McGill University faculty","Researchers in geometric algorithms","Stanford University alumni","Wikipedia articles with ISNI identifiers","Wikipedia articles with VIAF identifiers"],"tag_line":"David Michael Avis (born March 20, 1951) is a Canadian and British computer scientist known for his contributions to geometric computations."}}
,{"_index":"throwtable","_type":"algorithm","_id":"timothy-m.-chan","_score":0,"_source":{"description":"Timothy Moon-Yew Chan is Professor and University Research Chair in the David R. Cheriton School of Computer Science, University of Waterloo, Canada.\nHe graduated with BA (summa cum laude) from Rice University in 1992, and completed his Ph.D. in Computer Science at UBC in 1995 at the age of 19.\nHe was awarded the Governor General's Gold Medal (as Head of Graduating Class in the Faculty of Graduate Studies at the University of British Columbia during convocation), the NSERC doctoral prize, and the Premier's Research Excellence Award (PREA) of Ontario, Canada.\nHe is currently an associate editor for the ACM Transactions on Algorithms (TALG), and the International Journal of Computational Geometry and Applications. He is also a member of the editorial board of Algorithmica, Discrete and Computational Geometry, as well as Computational Geometry: Theory and Applications.\nChan has published extensively. His research covers Data Structures, Algorithms and Computational geometry.\n\n","alt_names":["- Timothy M. Chan :","...more on Wikipedia about Timothy M. Chan","Chan, T.","Chan, T. M.","Chan, Timothy M.","Tim Chan","Timothy M Chan","Timothy M. Chan","Timothy M. Chan - Wikipedia, the free encyclopedia","Timothy M. Chan - Wikipedia, the free encyclopedia wikipedia","Who is Timothy M. Chan","Wikipedia article Timothy M. Chan","Wikipedia article on Timothy M. Chan","Wikipedia entry for Timothy M. Chan","en.wikipedia.org/wiki/Timothy_M._Chan","http://en.wikipedia.org/wiki/Timothy M. Chan","http://en.wikipedia.org/wiki/Timothy_M._Chan","wikipedia:en:Timothy M. Chan","yago-res:Timothy M. Chan"],"name":"Timothy M. Chan","categories":["1976 births","Living people","Researchers in geometric algorithms","Rice University alumni","University of British Columbia alumni","University of Waterloo faculty"],"tag_line":"Timothy Moon-Yew Chan is Professor and University Research Chair in the David R. Cheriton School of Computer Science, University of Waterloo, Canada."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lars-arge","_score":0,"_source":{"description":"Lars Allan Arge is a Danish computer scientist, the head of the Center for Massive Data Algorithmics (MADALGO) at Aarhus University, where he is also a professor of computer science. His research involves the study of algorithms and data structures for handling massive data, especially in graph algorithms and computational geometry.\nArge earned his Ph.D. in 1996 from Aarhus University, under the supervision of Erik Meineche Schmidt. He was a professor at Duke University before returning to Aarhus as a professor in 2004, and he continues to hold an adjunct professorship at Duke.\nArge is a member of the Royal Danish Academy of Sciences and Letters, and was elected to the presidium of the academy in 2015. In 2012, he was elected as a Fellow of the Association for Computing Machinery \"for contributions to massive data algorithmics\", becoming only the second ACM Fellow in Denmark. He also belongs to the Danish Academy of Technical Sciences.","alt_names":["Lars Arge"],"name":"Lars Arge","categories":["Aarhus University alumni","Aarhus University faculty","Danish computer scientists","Duke University faculty","Fellows of the Association for Computing Machinery","Living people","Researchers in geometric algorithms","Year of birth missing (living people)"],"tag_line":"Lars Allan Arge is a Danish computer scientist, the head of the Center for Massive Data Algorithmics (MADALGO) at Aarhus University, where he is also a professor of computer science."}}
,{"_index":"throwtable","_type":"algorithm","_id":"progressive-refinement","_score":0,"_source":{"description":"Progressive refinement is a ray tracing algorithm that quickly reveals coarse structure of an image, and gradually reveals additional detail over time.\nThe first pixel is rendered as a single rectangle occupying the entire work area. The second through fourth each occupy a quarter of the work area. Sufficient progression will refine the image until the rendered rectangles correspond to a target resolution (for example, a screen resolution).\nRectangles are laid out with an overlap pattern so as to avoid unnecessary rendering.","alt_names":["Progressive Refinement","Progressive refinement","Progressive refinement - Wikipedia, the free encyclopedia","Wikipedia article Progressive refinement","Wikipedia entry for Progressive refinement","http://en.wikipedia.org/wiki/Progressive_refinement","progressive refinement"],"name":"Progressive refinement","categories":["All articles lacking sources","All stub articles","Articles lacking sources from December 2009","Computer graphics algorithms","Computer graphics stubs"],"tag_line":"Progressive refinement is a ray tracing algorithm that quickly reveals coarse structure of an image, and gradually reveals additional detail over time."}}
,{"_index":"throwtable","_type":"algorithm","_id":"jiří-matoušek-(mathematician)","_score":0,"_source":{"description":"Jiří (Jirka) Matoušek (10 March 1963 – 9 March 2015) was a Czech mathematician working in computational geometry and algebraic topology. He was a professor at Charles University in Prague and the author of several textbooks and research monographs.\nMatoušek was born in Prague. In 1986, he received his Master's degree at Charles University under Miroslav Katětov. From 1986 until his death he was employed at the Department of Applied Mathematics of Charles University in Prague, holding a professor position since 2000. He was also a visiting and later full professor at ETH Zurich.\nIn 1996, he won the European Mathematical Society prize and in 2000 he won the Scientist award of the Learned Society of the Czech Republic. He became a fellow of the Learned Society of the Czech Republic in 2005.\nMatoušek's paper on computational aspects of algebraic topology won the Best Paper award at the 2012 ACM Symposium on Discrete Algorithms.\nAside from his own academic writing, he has translated the popularization book Mathematics: A Very Short Introduction by Timothy Gowers into Czech.\nHe was a supporter and signatory of the Cost of Knowledge protest. He died in 2015, aged 51.\n^ Matoušek, Jiří (1986). Vlastnosti R-stromů (M.Sc. thesis) (in Czech). Charles University in Prague. \n^ a b Jan Kratochvíl, Martin Loebl, Jarik Nešetřil, Pavel Valtr. \"Prof. Jiří Matoušek\". Retrieved 2015-03-18. In the name of Jiří Matoušek's colleagues and friends from Charles University , obituary\n^ EMS Prize Winners.\n^ 2000 Awards, Learned Society of the Czech Republic.\n^ Member profile, Learned Society of the Czech Republic, retrieved 2015-03-10.\n^ \"SIAM: Best Paper Awards\". Retrieved 18 March 2015. \n^ Gowers, Timothy (2006). Mathematics: A Very Short Introduction [Matematika: Průvodce pro každého] (in Czech). Translated by Jiří Matoušek. Dokořán. ISBN 80-7363-083-4. \n^ \"The Cost Of Knowledge\". Retrieved 18 March 2015. I've been practicing this for many years, with some exceptions (journals with few good alternatives, requests for reports from people I didn't want to disappoint). I hope this initiative will not die out. \n^ \"Obituary of Jiří Matoušek\". Faculty of Mathematics and Physics, Charles University. 12 March 2015. Retrieved 18 March 2015.","alt_names":[],"name":"Jiří Matoušek (mathematician)","categories":["1963 births","2015 deaths","All stub articles","CS1 Czech-language sources (cs)","CS1 errors: invisible characters","Charles University in Prague faculty","Czech mathematicians","European mathematician stubs","People from Prague","Researchers in geometric algorithms","Wikipedia articles with BNF identifiers","Wikipedia articles with GND identifiers","Wikipedia articles with ISNI identifiers","Wikipedia articles with LCCN identifiers","Wikipedia articles with VIAF identifiers"],"tag_line":"Jiří (Jirka) Matoušek (10 March 1963 – 9 March 2015) was a Czech mathematician working in computational geometry and algebraic topology."}}
,{"_index":"throwtable","_type":"algorithm","_id":"frances-yao","_score":0,"_source":{"description":"Frances Foong Chu Yao (儲楓) is a Chinese-born American mathematician and computer scientist. She was Chair Professor and Head of the Department of computer science at the City University of Hong Kong, where she is now an honorary professor.\nAfter receiving a B.S. in mathematics from National Taiwan University in 1969, Yao did her Ph.D. studies under the supervision of Michael J. Fischer at the Massachusetts Institute of Technology, receiving her Ph.D. in 1973. She then held positions at the University of Illinois at Urbana-Champaign, Brown University, and Stanford University, before joining the staff at the Xerox Palo Alto Research Center in 1979 where she stayed until her retirement in 1999.\nIn 2003, she came out of retirement to become the Head and a Chair Professor of the Department of Computer Science at City University, which she held until June 2011. She is a Fellow of the American Association for the Advancement of Science; in 1991, she and Ronald Graham won the Lester R. Ford Award of the Mathematical Association of America for their expository article, A Whirlwind Tour of Computational Geometry.\nYao's husband, Andrew Yao, is also a well-known theoretical computer scientist and Turing Award winner.\nMuch of Yao's research has been in the subject of computational geometry and combinatorial algorithms; she is known for her work with Mike Paterson on binary space partitioning, her work with Dan Greene on finite-resolution computational geometry, and her work with Alan Demers and Scott Shenker on scheduling algorithms for energy-efficient power management.\nMore recently she has been working in cryptography. Along with her husband Andrew Yao and Wang Xiaoyun, they found new attacks on the SHA-1 cryptographic hash function.\n\n","alt_names":["- Frances Yao :","F. Yao","Foong Frances Yao","Frances Foong Yao","Frances Yao","Frances Yao - Wikipedia :: The free encyclopedia","Frances Yao - Wikipedia, the free encyclopedia","Frances Yao on wikipedia.org","Frances_Yao","Who is Frances Yao","Wikipedia article Frances Foong Yao","Wikipedia article Frances Yao","Wikipedia article on Frances Yao","Wikipedia entry for Frances Yao","Yao, F. F.","Yao, Frances","en.wikipedia.org/wiki/Frances_Yao","en:Frances Yao","http://en.wikipedia.org/wiki/Frances Yao","http://en.wikipedia.org/wiki/Frances_Yao","yago-res:Frances Yao"],"name":"Frances Yao","categories":["American computer scientists","Brown University faculty","Chinese emigrants to the United States","Faculty of the City University of Hong Kong","Fellows of the American Association for the Advancement of Science","Living people","Massachusetts Institute of Technology alumni","National Taiwan University alumni","Researchers in geometric algorithms","Stanford University Department of Computer Science faculty","University of Illinois at Urbana–Champaign faculty","Women computer scientists"],"tag_line":"Frances Foong Chu Yao (儲楓) is a Chinese-born American mathematician and computer scientist."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bernard-chazelle","_score":0,"_source":{"description":"Bernard Chazelle (born November 5, 1955) is the Eugene Higgins Professor of Computer Science at Princeton University. Much of his work is in computational geometry, where he has found many of the best-known algorithms, such as linear-time triangulation of a simple polygon, as well as major complexity results, such as lower bound techniques based on discrepancy theory. He is also known for his invention of the soft heap data structure and the most asymptotically efficient known algorithm for finding minimum spanning trees.\n^ http://www.cs.princeton.edu/~chazelle/\n^ Chazelle, Bernard (1991), \"Triangulating a Simple Polygon in Linear Time\", Discrete & Computational Geometry 6: 485–524, doi:10.1007/BF02574703, ISSN 0179-5376 \n^ Chazelle, Bernard (2000), The Discrepancy Method: Randomness and Complexity, Cambridge University Press, ISBN 978-0-521-00357-5 \n^ Chazelle, Bernard (2000), \"A minimum spanning tree algorithm with inverse-Ackermann type complexity\", Journal of the Association for Computing Machinery 47 (6): 1028–1047, doi:10.1145/355541.355562, MR 1866456 .","alt_names":["Chazelle","- Bernard Chazelle :","-> Read more about Bernard Chazelle","-> Read the article about 'Bernard Chazelle'","...Wikipedia Bernard Chazelle","...more on Wikipedia about Bernard Chazelle","1955 - Bernard Chazelle, French computer scientist (best known","B. Chazelle","Bernad Chazelle","Bernard Chazelle","Bernard Chazelle - Wikipedia, the free encyclopedia","Bernard Chazelle at Wikipedia - http://en.wikipedia.org","Bernard Chazelle from Wikipedia","Bernard Chazelle; it is used under the","Bernard_Chazelle","Chazelle, B.","Chazelle, Bernard","Wikipedia - Bernard_Chazelle","Wikipedia article ''Bernard Chazelle''","Wikipedia article Bernard Chazelle","Wikipedia article on Bernard Chazelle","Wikipedia entry for Bernard Chazelle","artículo de Wikipedia Bernard Chazelle","bernard chazelle wikipedia the free encyclopedia","en.wikipedia.org/wiki/Bernard_Chazelle","es:Bernard Chazelle","http://en.wikipedia.org/wiki/Bernard_Chazelle","http://es.wikipedia.org/wiki/Bernard_Chazelle","yago-res:Bernard Chazelle"],"name":"Bernard Chazelle","categories":["1955 births","American computer scientists","Articles with hCards","BLP articles lacking sources from October 2012","Fellows of the Association for Computing Machinery","French computer scientists","Guggenheim Fellows","Infobox person using numbered parameter","Living people","People from Paris","Princeton University faculty","Researchers in geometric algorithms","Wikipedia articles with BNF identifiers","Wikipedia articles with ISNI identifiers","Wikipedia articles with VIAF identifiers","Yale University alumni"],"tag_line":"Bernard Chazelle (born November 5, 1955) is the Eugene Higgins Professor of Computer Science at Princeton University."}}
,{"_index":"throwtable","_type":"algorithm","_id":"shang-hua-teng","_score":0,"_source":{"description":"Shang-Hua Teng (Chinese: 滕尚华; pinyin: Téng Shàng-huá, born 1964) is a Chinese-American computer scientist. He is the Seeley G. Mudd Professor of Computer Science and Mathematics at the University of Southern California. Previously, he was the chairman of the Computer Science Department at the Viterbi School of Engineering of the University of Southern California. In 2008 he was awarded the Gödel Prize for his joint work on smoothed analysis of algorithms with Daniel Spielman. They went to win the prize again in 2015 for their contribution on \"nearly-linear-time Laplacian solvers\". In 2009, he received the Fulkerson Prize given by the American Mathematical Society and the Mathematical Programming Society.\n^ Parberry, Ian (1999-05-10). \"2008 Gödel Prize\". ACM SIGACT. Retrieved 2007-02-12. \n^ \"Diana Williams, Shanghua Teng\". The New York Times. July 27, 2003. Retrieved November 7, 2011. \n^ Calverley, Bob (July 15, 2009). \"Computer Scientist Teng to Join USC\". USC News. .\n^ \"ACM SIGACT: Prizes: Gödel\" (PDF). ACM SIGACT. Retrieved 2015-05-29. \n^ https://www.eatcs.org/index.php/component/content/article/1-news/2117-goedel-prize-2015","alt_names":[],"name":"Shang-Hua Teng","categories":["1964 births","All articles with dead external links","All stub articles","American computer scientists","Articles containing Chinese-language text","Articles with dead external links from October 2010","Boston University faculty","Carnegie Mellon University alumni","Chinese computer scientists","Chinese emigrants to the United States","Computer specialist stubs","Educators from Beijing","Fellows of the Association for Computing Machinery","Gödel Prize laureates","IBM employees","Intel people","Living people","Massachusetts Institute of Technology faculty","Microsoft people","Researchers in geometric algorithms","Shanghai Jiao Tong University alumni","Sloan Fellows","USC Viterbi School of Engineering alumni","University of Illinois at Urbana–Champaign faculty","University of Minnesota faculty","University of Southern California faculty","Wikipedia articles with GND identifiers","Wikipedia articles with LCCN identifiers","Wikipedia articles with VIAF identifiers","Xerox people"],"tag_line":"Shang-Hua Teng (Chinese: 滕尚华; pinyin: Téng Shàng-huá, born 1964) is a Chinese-American computer scientist."}}
,{"_index":"throwtable","_type":"algorithm","_id":"michael-segal","_score":0,"_source":{"description":"Michael Segal (Hebrew: מיכאל סגל; Russian: Михаил Сегал, born 1972 in Kishinev, USSR) is a Professor of Communication Systems Engineering at Ben-Gurion University of the Negev, known for his work in ad-hoc and sensor networks.\nAfter completing his undergraduate studies at Ben-Gurion University in 1994, Segal received a Ph.D. in Mathematics and Computer Science from Ben-Gurion University in 2000 under the supervision of Klara Kedem. The topic of his PhD Dissertation was: Covering point sets and accompanying problems.\nAfter continuing his studies with David G. Kirkpatrick at University of British Columbia, and Pacific Istitute for the Mathematical Studies  he joined the faculty at Ben-Gurion University in 2000, where he also served as the head of the Communication Systems Engineering department between 2005-2010. He is known (equally with his coauthors) for being first to analyze the analytical performance of the well-known Least Cluster Change (LCC) algorithm that is widely used in ad hoc networks for re-clustering in order to reduce the number of modifications. He also was one of the first to introduce and analyze the construction of multi-criteria spanners for ad hoc networks.\nSegal has published over 140 scientific papers and was a recipient of the Toronto Prize for Research in 2010. He is serving as the Editor-in-Chief for the Journal of Computer and System Sciences. Along with his Ben-Gurion University professorship, he also is visiting professor at Cambridge University.","alt_names":[],"name":"Michael Segal","categories":["1972 births","CS1 errors: external links","Israeli computer scientists","Israeli mathematicians","Living people","Pages using infoboxes with thumbnail images","Pages using web citations with no URL","Pages with citations lacking titles","Researchers in geometric algorithms"],"tag_line":"Michael Segal (Hebrew: מיכאל סגל; Russian: Михаил Сегал, born 1972 in Kishinev, USSR) is a Professor of Communication Systems Engineering at Ben-Gurion University of the Negev, known for his work in ad-hoc and sensor networks."}}
,{"_index":"throwtable","_type":"algorithm","_id":"david-eppstein","_score":0,"_source":{"description":"David Arthur Eppstein (born 1963) is an American computer scientist and mathematician. He is a Chancellor's Professor of computer science at University of California, Irvine. He is known for his work in computational geometry, graph algorithms, and recreational mathematics.Especially,he improved algorithm for NP-hardness like traveling salesman problem.","alt_names":["- David Eppstein :","D. Eppstein","David Eppstein","David Eppstein - Wikipedia, the free encyclopedia","David Eppstein Wikipedia the free encyclopedia","David Eppstein Wikipedia the free encyclopedia - result","David Eppstein from Wikipedia","David Eppstein – Wikipédia, a enciclopédia livre","David_Eppstein","Eppstein D","Eppstein, D.","Eppstein, David","Read More david eppstein wikipedia the free encyclopedia","Wikipedia article David Eppstein","Wikipedia article on David Eppstein","Wikipedia entry for David Eppstein","continue reading http://en.wikipedia.org/wiki/David_Eppstein","david eppstein wikipedia the free encyclopedia","http://en.wikipedia.org/wiki/David_Eppst","http://en.wikipedia.org/wiki/David_Eppstein","the WP entry about me","w:David Eppstein","Дэвида Эпштайна"],"name":"David Eppstein","categories":["1963 births","American computer scientists","British emigrants to the United States","Cellular automatists","Columbia School of Engineering and Applied Science alumni","Fellows of the Association for Computing Machinery","Graph drawing people","Graph theorists","Living people","Palo Alto High School alumni","People from Irvine, California","Recreational mathematicians","Researchers in geometric algorithms","Stanford University alumni","University of California, Irvine faculty","Wikipedia articles with BNF identifiers","Wikipedia articles with GND identifiers","Wikipedia articles with ISNI identifiers","Wikipedia articles with LCCN identifiers","Wikipedia articles with VIAF identifiers","Wikipedia indefinitely semi-protected biographies of living people"],"tag_line":"David Arthur Eppstein (born 1963) is an American computer scientist and mathematician."}}
,{"_index":"throwtable","_type":"algorithm","_id":"györgy-elekes","_score":0,"_source":{"description":"György Elekes (19 May 1949 – 29 September 2008) was a Hungarian mathematician and computer scientist who specialized in Combinatorial geometry and Combinatorial set theory. He may be best known for his work in the field that would eventually be called Additive Combinatorics. Particularly notable was his \"ingenious\" application of the Szemerédi–Trotter theorem to improve the best known lower bound for the sum-product problem. He also proved that any polynomial-time algorithm approximating the volume of convex bodies must have a multiplicative error, and the error grows exponentially on the dimension. With Micha Sharir he set up a framework which eventually led Guth and Katz to the solution of the Erdős distinct distances problem. (See below.)","alt_names":[],"name":"György Elekes","categories":["1949 births","2008 deaths","Combinatorialists","Hungarian computer scientists","Hungarian mathematicians","Number theorists","Researchers in geometric algorithms"],"tag_line":"György Elekes (19 May 1949 – 29 September 2008) was a Hungarian mathematician and computer scientist who specialized in Combinatorial geometry and Combinatorial set theory."}}
,{"_index":"throwtable","_type":"algorithm","_id":"out-of-kilter-algorithm","_score":0,"_source":{"description":"The out-of-kilter algorithm is an algorithm that computes the solution to the minimum-cost flow problem in a flow network. It was published in 1961 by D. R. Fulkerson.","alt_names":[],"name":"Out-of-kilter algorithm","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Network flow"],"tag_line":"The out-of-kilter algorithm is an algorithm that computes the solution to the minimum-cost flow problem in a flow network."}}
,{"_index":"throwtable","_type":"algorithm","_id":"leabra","_score":0,"_source":{"description":"Leabra stands for \"Local, Error-driven and Associative, Biologically Realistic Algorithm\". It is a model of learning which is a balance between Hebbian and error-driven learning with other network-derived characteristics. This model is used to mathematically predict outcomes based on inputs and previous learning influences. This model is heavily influenced by and contributes to neural network designs and models. This algorithm is the default algorithm in Emergent (successor of PDP++) when making a new project, and is extensively used in various simulations.\nHebbian learning is performed using conditional principal components analysis (CPCA) algorithm with correction factor for sparse expected activity levels.\nError-driven learning is performed using GeneRec, which is a generalization of the Recirculation algorithm, and approximates Almeida-Pineda recurrent backpropagation. The symmetric, midpoint version of GeneRec is used, which is equivalent to the contrastive Hebbian learning algorithm (CHL). See O'Reilly (1996; Neural Computation) for more details.\nThe activation function is a point-neuron approximation with both discrete spiking and continuous rate-code output.\nLayer or unit-group level inhibition can be computed directly using a k-winners-take-all (KWTA) function, producing sparse distributed representations.\nThe net input is computed as an average, not a sum, over connections, based on normalized, sigmoidally transformed weight values, which are subject to scaling on a connection-group level to alter relative contributions. Automatic scaling is performed to compensate for differences in expected activity level in the different projections.\nDocumentation about this algorithm can be found in the book \"Computational Explorations in Cognitive Neuroscience: Understanding the Mind by Simulating the Brain\" published by MIT press. and in the Emergent Documentation\n^ O'Reilly, R. C., Munakata, Y. (2000). Computational explorations in cognitive neuroscience. Cambridge: MIT Press. ISBN 0-19-510491-9.","alt_names":["- Leabra :","LEABRA","Leabra","Leabra - Wikipedia, the free encyclopedia","Leabra by Wikipedia","Leabra |","Source Wikipedia.org Arcticle - Leabra","Wikipedia article Leabra","Wikipedia article about Leabra","Wikipedia entry for Leabra","http://en.Liarpedia.org/wiki/Frank Mannion","http://en.wikipedia.org/wiki/Leabra","leabra wikipedia the encyclopedia"],"name":"Leabra","categories":["Artificial neural networks","Machine learning algorithms"],"tag_line":"Leabra stands for \"Local, Error-driven and Associative, Biologically Realistic Algorithm\"."}}
,{"_index":"throwtable","_type":"algorithm","_id":"minimum-redundancy-feature-selection","_score":0,"_source":{"description":"Minimum redundancy feature selection is an algorithm frequently used in a method to accurately identify characteristics of genes and phenotypes and narrow down their relevance and is usually described in its pairing with relevant feature selection as Minimum Redundancy Maximum Relevance (mRMR).\nFeature selection, one of the basic problems in pattern recognition and machine learning, identifies subsets of data that are relevant to the parameters used and is normally called Maximum Relevance. These subsets often contain material which is relevant but redundant and mRMR attempts to address this problem by removing those redundant subsets. mRMR has a variety of applications in many areas such as cancer diagnosis and speech recognition.\nFeatures can be selected in many different ways. One scheme is to select features that correlate strongest to the classification variable. This has been called maximum-relevance selection. Many heuristic algorithms can be used, such as the sequential forward, backward, or floating selections.\nOn the other hand features can be selected to be mutually far away from each other while still having \"high\" correlation to the classification variable. This scheme, termed as Minimum Redundancy Maximum Relevance (mRMR) selection has been found to be more powerful than the maximum relevance selection.\nAs a special case, the \"correlation\" can be replaced by the statistical dependency between variables. Mutual information can be used to quantify the dependency. In this case, it is shown that mRMR is an approximation to maximizing the dependency between the joint distribution of the selected features and the classification variable.\nStudies have tried different measures for redundancy and relevance measures. A recent study compared several measures within the context of biomedical images.\n\n","alt_names":["Minimum redundancy feature selection","Minimum redundancy feature selection - Wikipedia, the free ...","Minimum redundancy feature selection - Wikipedia, the free ... ...","Minimum redundancy feature selection Wikipedia the free","Minimum redundancy feature selection by Wikipedia","Wikipedia article Minimum redundancy feature selection","http://en.wikipedia.org/wiki/Minimum_red","http://en.wikipedia.org/wiki/Minimum_redundancy_feature_selection","minimum redundancy feature selection"],"name":"Minimum redundancy feature selection","categories":["All stub articles","Artificial intelligence stubs","Machine learning algorithms","Robotics stubs"],"tag_line":"Minimum redundancy feature selection is an algorithm frequently used in a method to accurately identify characteristics of genes and phenotypes and narrow down their relevance and is usually described in its pairing with relevant feature selection as Minimum Redundancy Maximum Relevance (mRMR)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"genetic-algorithm-for-rule-set-production","_score":0,"_source":{"description":"Genetic Algorithm for Rule Set Production (GARP) is a computer program based on genetic algorithm that creates ecological niche models for species. The generated models describe environmental conditions (precipitation, temperatures, elevation, etc.) under which the species should be able to maintain populations. As input, local observations of species and related environmental parameters are used which describe potential limits of the species' capabilities to survive. Such environmental parameters are commonly stored in geographical information systems. A GARP model is a random set of mathematical rules which can be read as limiting environmental conditions. Each rule is considered as a gene; the set of genes is combined in random ways to further generate many possible models describing the potential of the species to occur.","alt_names":["Algoritmi genetici per la produzione Regola","Genetic Algorithm for Rule Set Production","Genetic Algorithm for Rule Set Production - Wikipedia :: The","Genetic Algorithm for Rule Set Production - Wikipedia, the","Genetic Algorithm for Rule Set Production by Wikipedia","Genetic Algorithm for Rule Set Production; it is","Genetic Algorithm for Rule-set Prediction","Genetic Algorithm for Rule-set Production","What software does Genetic Algorithm for Rule Set","Wikipedia article Genetic Algorithm for Rule Set Production","Wikipedia article Genetic Algorithm for Rule-set Prediction","Wikipedia entry for Genetic Algorithm for Rule Set","http://en.wikipedia.org/wiki/Genetic_Alg","http://en.wikipedia.org/wiki/Genetic_Algorithm_for_Rule_Set_Production"],"name":"Genetic Algorithm for Rule Set Production","categories":["All stub articles","Ecology stubs","Machine learning algorithms"],"tag_line":"Genetic Algorithm for Rule Set Production (GARP) is a computer program based on genetic algorithm that creates ecological niche models for species."}}
,{"_index":"throwtable","_type":"algorithm","_id":"luus–jaakola","_score":0,"_source":{"description":"In computational engineering, Luus–Jaakola (LJ) denotes a heuristic for global optimization of a real-valued function. In engineering use, LJ is not an algorithm that terminates with an optimal solution; nor is it an iterative method that generates a sequence of points that converges to an optimal solution (when one exists). However, when applied to a twice continuously differentiable function, the LJ heuristic is a proper iterative method, that generates a sequence that has a convergent subsequence; for this class of problems, Newton's method is recommended and enjoys a quadratic rate of convergence, while no convergence rate analysis has been given for the LJ heuristic. In practice, the LJ heuristic has been recommended for functions that need be neither convex nor differentiable nor locally Lipschitz: The LJ heuristic does not use a gradient or subgradient when one be available, which allows its application to non-differentiable and non-convex problems.\nProposed by Luus and Jaakola, LJ generates a sequence of iterates. The next iterate is selected from a sample from a neighborhood of the current position using a uniform distribution. With each iteration, the neighborhood decreases, which forces a subsequence of iterates to converge to a cluster point.\nLuus has applied LJ in optimal control, transformer design, metallurgical processes, and chemical engineering.","alt_names":[],"name":"Luus–Jaakola","categories":["Heuristic algorithms","Optimization algorithms and methods"],"tag_line":"In computational engineering, Luus–Jaakola (LJ) denotes a heuristic for global optimization of a real-valued function."}}
,{"_index":"throwtable","_type":"algorithm","_id":"local-outlier-factor","_score":0,"_source":{"description":"In anomaly detection, the local outlier factor (LOF) is an algorithm proposed by Markus M. Breunig, Hans-Peter Kriegel, Raymond T. Ng and Jörg Sander in 2000 for finding anomalous data points by measuring the local deviation of a given data point with respect to its neighbours.\nLOF shares some concepts with DBSCAN and OPTICS such as the concepts of \"core distance\" and \"reachability distance\", which are used for local density estimation.","alt_names":["LOF hat viele Konzepte gemeinsam mit den Clusteranalyse","Local Outlier Factor","Local Outlier Factor (LOF)","Local Outlier Factor - Wikipedia","Local Outlier Factor - Wikipedia, the free encyclopedia","Local Outlier Factor by Wikipedia","Local Outlier Factor – Wikipedia","Local outlier factor","Local outlier factor - Wikipedia, the free encyclopedia","The key idea of LOF is comparing the","Wikipedia article Local Outlier Factor","Wikipedia-Seite zu 'Local Outlier Factor'","http://en.wikipedia.org/wiki/Local_Outlier_Factor","http://en.wikipedia.org/wiki/Local_outlier_factor"],"name":"Local outlier factor","categories":["Data mining","Machine learning algorithms","Statistical outliers"],"tag_line":"In anomaly detection, the local outlier factor (LOF) is an algorithm proposed by Markus M. Breunig, Hans-Peter Kriegel, Raymond T. Ng and Jörg Sander in 2000 for finding anomalous data points by measuring the local deviation of a given data point with respect to its neighbours."}}
,{"_index":"throwtable","_type":"algorithm","_id":"multiple-kernel-learning","_score":0,"_source":{"description":"Multiple kernel learning refers to a set of machine learning methods that use a predefined set of kernels and learn an optimal linear or non-linear combination of kernels as part of the algorithm. Reasons to use multiple kernel learning include a) the ability to select for an optimal kernel and parameters from a larger set of kernels, reducing bias due to kernel selection while allowing for more automated machine learning methods, and b) combining data from different sources (e.g. sound and images from a video) that have different notions of similarity and thus require different kernels. Instead of creating a new kernel, multiple kernel algorithms can be used to combine kernels already established for each individual data source.\nMultiple kernel learning approaches have been used in many applications, such as event recognition in video.., object recognition in images, and biomedical data fusion.","alt_names":[],"name":"Multiple kernel learning","categories":["All orphaned articles","Data mining","Machine learning algorithms","Orphaned articles from January 2015"],"tag_line":"Multiple kernel learning refers to a set of machine learning methods that use a predefined set of kernels and learn an optimal linear or non-linear combination of kernels as part of the algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"quadratic-unconstrained-binary-optimization","_score":0,"_source":{"description":"Quadratic unconstrained binary optimization (QUBO) is a pattern matching technique, common in machine learning applications. QUBO is an NP hard problem.\nQUBO problems may sometimes be well-suited to algorithms aided by quantum annealing.\nQUBO is given by the formula:","alt_names":["E ( X 1 , X 2 , . . . , X N ) = ∑ i","Quadratic unconstrained binary optimization","Quadratic unconstrained binary optimization - Wikipedia, the ...","Quadratic unconstrained binary optimization - Wikipedia, the free ...","Quadratic unconstrained binary optimization - Wikipedia, the free ... ...","Quadratic unconstrained binary optimization Wikipedia the free","Quadratic unconstrained binary optimization Wikipedia the free - result","Quadratic unconstrained binary optimization by Wikipedia","Wikipedia article Quadratic unconstrained binary optimization","Wikipedia entry for Quadratic unconstrained binary optimization","http://en.wikipedia.org/wiki/Quadratic_unconstrain...","http://en.wikipedia.org/wiki/Quadratic_unconstrained_binary_optimization"],"name":"Quadratic unconstrained binary optimization","categories":["All articles needing additional references","All stub articles","Articles needing additional references from September 2014","Artificial intelligence stubs","Machine learning algorithms"],"tag_line":"Quadratic unconstrained binary optimization (QUBO) is a pattern matching technique, common in machine learning applications."}}
,{"_index":"throwtable","_type":"algorithm","_id":"monte-carlo-tree-search","_score":0,"_source":{"description":"In computer science, Monte Carlo tree search (MCTS) is a heuristic search algorithm of making decisions in some decision processes, most notably employed in game playing. The leading example of its use is in contemporary computer Go programs, but it is also used in other board games, as well as real-time video games and non-deterministic games such as poker (see history section).","alt_names":[],"name":"Monte Carlo tree search","categories":["CS1 errors: invisible characters","Combinatorial game theory","Heuristic algorithms","Monte Carlo methods","Wikipedia articles needing clarification from November 2015"],"tag_line":"In computer science, Monte Carlo tree search (MCTS) is a heuristic search algorithm of making decisions in some decision processes, most notably employed in game playing."}}
,{"_index":"throwtable","_type":"algorithm","_id":"social-cognitive-optimization","_score":0,"_source":{"description":"Social cognitive optimization (SCO) is a population-based metaheuristic optimization algorithm which was developed in 2002. This algorithm is based on the social cognitive theory, and the key point of the ergodicity is the process of individual learning of a set of agents with their own memory and their social learning with the knowledge points in the social sharing library. It has been used for solving continuous optimization, integer programming, and combinatorial optimization problems. It has been incorporated into the NLPSolver extension of Calc in Apache OpenOffice.","alt_names":[],"name":"Social cognitive optimization","categories":["Collective intelligence","Heuristic algorithms","Metaheuristics","Optimization algorithms and methods"],"tag_line":"Social cognitive optimization (SCO) is a population-based metaheuristic optimization algorithm which was developed in 2002."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rprop","_score":0,"_source":{"description":"Rprop, short for resilient backpropagation, is a learning heuristic for supervised learning in feedforward artificial neural networks. This is a first-order optimization algorithm. This algorithm was created by Martin Riedmiller and Heinrich Braun in 1992.\nSimilarly to the Manhattan update rule, Rprop takes into account only the sign of the partial derivative over all patterns (not the magnitude), and acts independently on each \"weight\". For each weight, if there was a sign change of the partial derivative of the total error function compared to the last iteration, the update value for that weight is multiplied by a factor η−, where η− < 1. If the last iteration produced the same sign, the update value is multiplied by a factor of η+, where η+ > 1. The update values are calculated for each weight in the above manner, and finally each weight is changed by its own update value, in the opposite direction of that weight's partial derivative, so as to minimise the total error function. η+ is empirically set to 1.2 and η− to 0.5.\nNext to the cascade correlation algorithm and the Levenberg–Marquardt algorithm, Rprop is one of the fastest weight update mechanisms.\nRPROP is a batch update algorithm.","alt_names":["...mehr auf Wikipedia über Resilient Propagation","RPROP","RProp","Resilient Backpropagation","Resilient Propagation","Resilient Propagation (RProp)","Resilient Propagation - Wikipedia","Resilient Propagation Wikipedia","Resilient Propagation – Wikipedia","Resilient_Propagation","Rprop","Rprop - Wikipedia","Rprop - Wikipedia, the free encyclopedia","Rprop - Wikipedia, the free encyclopedia - Wikipedia","Rprop Related Content:","Rprop bei der wikipedia","Rprop by Wikipedia","Rprop |","Rprop – Wikipedia, the free encyclopedia","What are variations of Rprop","Wikipedia article Rprop","Wikipedia entry for Rprop","Wikipedia-Artikel Resilient Propagation","Wikipedia-Artikel Rprop","de:Resilient Propagation","en.wikipedia.org/wiki/Rprop","http://de.wikipedia.org/wiki/Resilient_Propagation","http://en.wikipedia.org/wiki/Rprop","yago-res:Rprop"],"name":"Rprop","categories":["Artificial neural networks","Machine learning algorithms"],"tag_line":"Rprop, short for resilient backpropagation, is a learning heuristic for supervised learning in feedforward artificial neural networks."}}
,{"_index":"throwtable","_type":"algorithm","_id":"mark-compact-algorithm","_score":0,"_source":{"description":"In computer science, a mark-compact algorithm is a type of garbage collection algorithm used to reclaim unreachable memory. Mark-compact algorithms can be regarded as a combination of the mark-sweep algorithm and Cheney's copying algorithm. First, reachable objects are marked, then a compacting step relocates the reachable (marked) objects towards the beginning of the heap area. Compacting garbage collection is used by Microsoft's Common Language Runtime and by the Glasgow Haskell Compiler.","alt_names":["Mark compact algorithm","Mark-compact algorithm","Mark-compact algorithm - Wikipedia :: The free encyclopedia","Mark-compact algorithm - Wikipedia, the free encyclopedia","Mark-compact algorithm - Wikipedia, the free encyclopedia ...","Mark-compact algorithm from Wikipedia","Speicher verschoben in","Wikipedia article Mark-compact algorithm","flyttet rundt i hukommelsen","http://en.Liarpedia.org/wiki/Mark-compact_algorithm","http://en.wikipedia.org/wiki/Mark-compac","http://en.wikipedia.org/wiki/Mark-compact_algorithm","mark - compactの","mark-compact","mark-compact GC","mark-compacte","mark-compatta","moved around in memory","mærke kompakt","označit kompaktní","pohybovat v paměti","przemieszczać się w pamięci","spostato in memoria","verplaatst in het geheugen","znaku kompaktowy","Марк-компактно","перемещены в памяти","निशान कॉम्पैक्ट","メモリ内で移動","在内存中移动"],"name":"Mark-compact algorithm","categories":["Automatic memory management","Memory management algorithms","Use dmy dates from August 2012"],"tag_line":"In computer science, a mark-compact algorithm is a type of garbage collection algorithm used to reclaim unreachable memory."}}
,{"_index":"throwtable","_type":"algorithm","_id":"edge-disjoint-shortest-pair-algorithm","_score":0,"_source":{"description":"Edge disjoint shortest pair algorithm is an algorithm in computer network routing. The algorithm is used for generating the shortest pair of edge disjoint paths between a given pair of vertices as follows:\nRun the shortest path algorithm for the given pair of vertices\nReplace each edge of the shortest path (equivalent to two oppositely directed arcs) by a single arc directed towards the source vertex\nMake the length of each of the above arcs negative\nRun the shortest path algorithm (Note: the algorithm should accept negative costs)\nErase the overlapping edges of the two paths found, and reverse the direction of the remaining arcs on the first shortest path such that each arc on it is directed towards the sink vertex now. The desired pair of paths results.\nSuurballe's algorithm solves the same problem more quickly by reweighting the edges of the graph to avoid negative costs, allowing Dijkstra's algorithm to be used for both shortest path steps.","alt_names":["Edge Disjoint Shortest Pair Algorithm","Edge disjoint shortest pair algorithm","Edge disjoint shortest pair algorithm - Wikipedia, the free","Edge_Disjoint_Shortest_Pair_Algorithm","Wikipedia article ''Edge Disjoint Shortest Pair Algorithm''","Wikipedia article Edge Disjoint Shortest Pair Algorithm","Wikipedia article Edge disjoint shortest pair algorithm","Wikipedia article on Edge Disjoint Shortest Pair Algorithm","Wikipedia article on Edge disjoint shortest pair algorithm","Wikipedia entry for Edge disjoint shortest pair algorithm","edge and node-diverse or disjoint routing","en:Edge Disjoint Shortest Pair Algorithm","http://en.wikipedia.org/wiki/Edge_disjo ... _algorithm","http://en.wikipedia.org/wiki/Edge_disjoi","http://en.wikipedia.org/wiki/Edge_disjoint_shortest_pair_algorithm","yago-res:Edge disjoint shortest pair algorithm"],"name":"Edge disjoint shortest pair algorithm","categories":["All articles needing additional references","All stub articles","Articles needing additional references from January 2010","Computer network stubs","Routing algorithms"],"tag_line":"Edge disjoint shortest pair algorithm is an algorithm in computer network routing."}}
,{"_index":"throwtable","_type":"algorithm","_id":"active-queue-management","_score":0,"_source":{"description":"In Internet routers, active queue management (AQM) is the intelligent drop of network packets inside a buffer associated with a network interface controller (NIC), when that buffer becomes full or gets close to becoming full, often with the larger goal of reducing network congestion. This task is performed by the network scheduler, which for this purpose uses various algorithms such as random early detection (RED), Explicit Congestion Notification (ECN), or controlled delay (CoDel). RFC 7567 recommends active queue management as a best practice.","alt_names":[],"name":"Active queue management","categories":["All articles needing additional references","Articles needing additional references from December 2009","Network performance","Network scheduling algorithms","Packets (information technology)"],"tag_line":"In Internet routers, active queue management (AQM) is the intelligent drop of network packets inside a buffer associated with a network interface controller (NIC), when that buffer becomes full or gets close to becoming full, often with the larger goal of reducing network congestion."}}
,{"_index":"throwtable","_type":"algorithm","_id":"state-action-reward-state-action","_score":0,"_source":{"description":"State-Action-Reward-State-Action (SARSA) is an algorithm for learning a Markov decision process policy, used in the reinforcement learning area of machine learning. It was introduced in a technical note  where the alternative name SARSA was only mentioned as a footnote.\nThis name simply reflects the fact that the main function for updating the Q-value depends on the current state of the agent \"S1\", the action the agent chooses \"A1\", the reward \"R\" the agent gets for choosing this action, the state \"S2\" that the agent will now be in after taking that action, and finally the next action \"A2\" the agent will choose in its new state. Taking every letter in the quintuple (st, at, rt, st+1, at+1) yields the word SARSA.","alt_names":[],"name":"State-Action-Reward-State-Action","categories":["Machine learning algorithms"],"tag_line":"State-Action-Reward-State-Action (SARSA) is an algorithm for learning a Markov decision process policy, used in the reinforcement learning area of machine learning."}}
,{"_index":"throwtable","_type":"algorithm","_id":"temporally-ordered-routing-algorithm","_score":0,"_source":{"description":"The Temporally Ordered Routing Algorithm (TORA) is an algorithm for routing data across Wireless Mesh Networks or Mobile ad hoc networks.\nIt was developed by Vincent Park and Scott Corson at the University of Maryland and the Naval Research Laboratory. Park has patented his work, and it was licensed by Nova Engineering, who are marketing a wireless router product based on Park's algorithm.","alt_names":[],"name":"Temporally ordered routing algorithm","categories":["Ad hoc routing protocols","All articles lacking sources","Articles lacking sources from July 2013","Routing algorithms","Wireless networking"],"tag_line":"The Temporally Ordered Routing Algorithm (TORA) is an algorithm for routing data across Wireless Mesh Networks or Mobile ad hoc networks."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pseudo-lru","_score":0,"_source":{"description":"Pseudo-LRU is a cache algorithm created to improve the Least Recently Used (LRU) algorithm.\nPLRU usually refers to two cache replacement algorithms: tree-PLRU and bit-PLRU.","alt_names":["...more on Wikipedia about Pseudo-LRU","Learn about Pseudo-LRU>>>","Pseudo LRU","Pseudo-LRU","Pseudo-LRU - Wikipedia, the free encyclopedia","Pseudo-LRU; it is used under the","PseudoLRU","Wikipedia article ''Pseudo-LRU''","Wikipedia article PLRU","Wikipedia article Pseudo-LRU","Wikipedia article about Pseudo-LRU","Wikipedia article on Pseudo-LRU","Wikipedia entry for Pseudo-LRU","Wikipedia: Pseudo-LRU","http://en.wikipedia.org/wiki/Pseudo-LRU","pseudo-LRU"],"name":"Pseudo-LRU","categories":["All stub articles","Computer science stubs","Memory management algorithms","Use dmy dates from August 2012"],"tag_line":"Pseudo-LRU is a cache algorithm created to improve the Least Recently Used (LRU) algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lirs-caching-algorithm","_score":0,"_source":{"description":"LIRS (Low Inter-reference Recency Set) is a page replacement algorithm with an improved performance over LRU (Least Recently Used) and many other newer replacement algorithms. This is achieved by using reuse distance as a metric for dynamically ranking accessed pages to make a replacement decision. The algorithm was developed by Song Jiang and Xiaodong Zhang.","alt_names":[],"name":"LIRS caching algorithm","categories":["Memory management algorithms","Online algorithms","Virtual memory"],"tag_line":"LIRS (Low Inter-reference Recency Set) is a page replacement algorithm with an improved performance over LRU (Least Recently Used) and many other newer replacement algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"query-level-feature","_score":0,"_source":{"description":"A query level feature or QLF is a ranking feature utilized in a machine-learned ranking algorithm.\nExample QLFs:\nHow many times has this query been run in the last month?\nHow many words are in the query?\nWhat is the sum/average/min/max/median of the BM25F values for the query?","alt_names":[],"name":"Query level feature","categories":["All stub articles","Artificial intelligence stubs","Machine learning","Machine learning algorithms"],"tag_line":"A query level feature or QLF is a ranking feature utilized in a machine-learned ranking algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"special-ordered-set","_score":0,"_source":{"description":"In discrete optimization, a special ordered set (SOS) is an ordered set of variables, used as an additional way to specify integrality conditions in an optimization model. Special order sets are basically a device or tool used in branch and bound methods for branching on sets of variables, rather than individual variables, as in ordinary mixed integer programming. Knowing that a variable is part of a set and that it is ordered gives the branch and bound algorithm a more intelligent way to face the optimization problem, helping to speed up the search procedure. The members of a special ordered set individually may be continuous or discrete variables in any combination. However, even when all the members are themselves continuous, a model containing one or more special ordered sets becomes a discrete optimization problem requiring a mixed integer optimizer for its solution.\nThe ‘only’ beneﬁt of using Special Ordered Sets compared with using only constraints, is that the search procedure will generally be noticeably faster.\nAs per J.A. Tomlin, Special Order Sets provide a powerful means of modeling nonconvex functions and discrete requirements, though there has been a tendency to think of them only in terms of multiple-choice zero-one programming.","alt_names":["Special Ordered Sets","Special ordered set","Special ordered set - Wikipedia, the free encyclopedia","Wikipedia article Special Ordered Sets","Wikipedia article Special ordered set","Wikipedia entry for Special ordered set","http://en.wikipedia.org/wiki/Special_ord","http://en.wikipedia.org/wiki/Special_ordered_set","special order sets of type 2","special ordered set of type 2","special ordered sets"],"name":"Special ordered set","categories":["Mathematical optimization","Optimization algorithms and methods"],"tag_line":"In discrete optimization, a special ordered set (SOS) is an ordered set of variables, used as an additional way to specify integrality conditions in an optimization model."}}
,{"_index":"throwtable","_type":"algorithm","_id":"odlyzko–schönhage-algorithm","_score":0,"_source":{"description":"In mathematics, the Odlyzko–Schönhage algorithm is a fast algorithm for evaluating the Riemann zeta function at many points, introduced by (Odlyzko & Schönhage 1988). The main point is the use of the fast Fourier transform to speed up the evaluation of a finite Dirichlet series of length N at O(N) equally spaced values from O(N2) to O(N1+ε) steps (at the cost of storing O(N1+ε) intermediate values). The Riemann–Siegel formula used for calculating the Riemann zeta function with imaginary part T uses a finite Dirichlet series with about N = T1/2 terms, so when finding about N values of the Riemann zeta function it is sped up by a factor of about T1/2. This reduces the time to find the zeros of the zeta function with imaginary part at most T from about T3/2+ε steps to about T1+ε steps.\nThe algorithm can be used not just for the Riemann zeta function, but also for many other functions given by Dirichlet series.\nThe algorithm was used by Gourdon (2004) to verify the Riemann hypothesis for the first 1013 zeros of the zeta function.","alt_names":[],"name":"Odlyzko–Schönhage algorithm","categories":["Algorithms and data structures stubs","All stub articles","Analytic number theory","Computational number theory","Computer science stubs","Zeta and L-functions"],"tag_line":"In mathematics, the Odlyzko–Schönhage algorithm is a fast algorithm for evaluating the Riemann zeta function at many points, introduced by (Odlyzko & Schönhage 1988)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"integer-relation-algorithm","_score":0,"_source":{"description":"An integer relation between a set of real numbers x1, x2, ..., xn is a set of integers a1, a2, ..., an, not all 0, such that\n\nAn integer relation algorithm is an algorithm for finding integer relations. Specifically, given a set of real numbers known to a given precision, an integer relation algorithm will either find an integer relation between them, or will determine that no integer relation exists with coefficients whose magnitudes are less than a certain upper bound.","alt_names":["Ferguson-Forcade algorithm","Ferguson–Forcade algorithm","How to apply for Integer relation algorithm","Integer Relation Algorithm","Integer Relation Algorithm.","Integer relation algorithm","Integer relation algorithm - Wikipedia :: The free encyclopedia","Integer relation algorithm - Wikipedia, the free encyclopedia","Integer relation algorithms","Integer_relation_algorithm","PSLQ","PSLQ algorithm","PSLQ algorithm; it is used under the","What is the history of Integer relation algorithm","What is the history of PSLQ algorithm?","Wikipedia article Integer relation algorithm","Wikipedia article PSLQ algorithm","Wikipedia article on PSLQ algorithm","Wikipedia entry for Integer relation algorithm","e Ferguson?Forcade algorith","en.wikipedia.org/wiki/Integer_relation_algorithm","en.wikipedia.org/wiki/PSLQ_algorithm","en:Integer relation algorithm","en:integer relation algorithm","http://en.wikipedia.org/wiki/Integer_rel","http://en.wikipedia.org/wiki/Integer_relation_algorithm","http://en.wikipedia.org/wiki/PSLQ_algorithm","integer relation","integer relation algorithm","integer relation algorithms","integer relation finding","integer relation finding algorithm","nteger relation algorithm,","∙ Integer relation algorith..."],"name":"Integer relation algorithm","categories":["Number theoretic algorithms"],"tag_line":"An integer relation between a set of real numbers x1, x2, ..., xn is a set of integers a1, a2, ..., an, not all 0, such that\n\nAn integer relation algorithm is an algorithm for finding integer relations."}}
,{"_index":"throwtable","_type":"algorithm","_id":"polylogarithmic-function","_score":0,"_source":{"description":"A polylogarithmic function in n is a polynomial in the logarithm of n,\n\nIn computer science, polylogarithmic functions occur as the order of memory used by some algorithms (e.g., \"it has polylogarithmic order\").\nAll polylogarithmic functions are\n\nfor every exponent ε > 0 (for the meaning of this symbol, see small o notation), that is, a polylogarithmic function grows more slowly than any positive exponent. This observation is the basis for the soft O notation Õ(n).","alt_names":[],"name":"Polylogarithmic function","categories":["All stub articles","Analysis of algorithms","Computer science stubs","Mathematical analysis","Mathematical analysis stubs","Polynomials"],"tag_line":"A polylogarithmic function in n is a polynomial in the logarithm of n,\n\nIn computer science, polylogarithmic functions occur as the order of memory used by some algorithms (e.g., \"it has polylogarithmic order\")."}}
,{"_index":"throwtable","_type":"algorithm","_id":"frank–wolfe-algorithm","_score":0,"_source":{"description":"The Frank–Wolfe algorithm is an iterative first-order optimization algorithm for constrained convex optimization. Also known as the conditional gradient method, reduced gradient algorithm and the convex combination algorithm, the method was originally proposed by Marguerite Frank and Philip Wolfe in 1956. In each iteration, the Frank–Wolfe algorithm considers a linear approximation of the objective function, and moves slightly towards a minimizer of this linear function (taken over the same domain).\n\n","alt_names":[],"name":"Frank–Wolfe algorithm","categories":["First order methods","Gradient methods","Iterative methods","Optimization algorithms and methods"],"tag_line":"The Frank–Wolfe algorithm is an iterative first-order optimization algorithm for constrained convex optimization."}}
,{"_index":"throwtable","_type":"algorithm","_id":"shuffled-frog-leaping-algorithm","_score":0,"_source":{"description":"The shuffled frog leaping algorithm (SFLA) is an optimization algorithm used in artificial intelligence (AI). It is like a genetic algorithm.\n\n^ Muzaffar Eusuff , Kevin Lansey & Fayzul Pasha (2006) Shuffled frog-leaping algorithm: a memetic meta-heuristic for discrete optimization, Engineering Optimization, 38:2, 129–154, DOI: 10.1080/03052150500384759","alt_names":[],"name":"Shuffled frog leaping algorithm","categories":["All stub articles","Artificial intelligence stubs","Mathematical optimization","Optimization algorithms and methods","Search algorithms"],"tag_line":"The shuffled frog leaping algorithm (SFLA) is an optimization algorithm used in artificial intelligence (AI)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"competitive-analysis-(online-algorithm)","_score":0,"_source":{"description":"Competitive analysis is a method invented for analyzing online algorithms, in which the performance of an online algorithm (which must satisfy an unpredictable sequence of requests, completing each request without being able to see the future) is compared to the performance of an optimal offline algorithm that can view the sequence of requests in advance. An algorithm is competitive if its competitive ratio—the ratio between its performance and the offline algorithm's performance—is bounded. Unlike traditional worst-case analysis, where the performance of an algorithm is measured only for \"hard\" inputs, competitive analysis requires that an algorithm perform well both on hard and easy inputs, where \"hard\" and \"easy\" are defined by the performance of the optimal offline algorithm.\nFor many algorithms, performance is dependent not only on the size of the inputs, but also on their values. One such example is the quicksort algorithm, which sorts an array of elements. Such data-dependent algorithms are analysed for average-case and worst-case data. Competitive analysis is a way of doing worst case analysis for on-line and randomized algorithms, which are typically data dependent.\nIn competitive analysis, one imagines an \"adversary\" that deliberately chooses difficult data, to maximize the ratio of the cost of the algorithm being studied and some optimal algorithm. Adversaries range in power from the oblivious adversary, which has no knowledge of the random choices made by the algorithm pitted against it, to the adaptive adversary that has full knowledge of how an algorithm works and its internal state at any point during its execution. Note that this distinction is only meaningful for randomized algorithms. For a deterministic algorithm, either adversary can simply compute what state that algorithm must have at any time in the future, and choose difficult data accordingly.\nFor example, the quicksort algorithm chooses one element, called the \"pivot\", that is, on average, not too far from the center value of the data being sorted. Quicksort then separates the data into two piles, one of which contains all elements with value less than the value of the pivot, and the other containing the rest of the elements. If quicksort chooses the pivot in some deterministic fashion (for instance, always choosing the first element in the list), then it is easy for an adversary to arrange the data beforehand so that quicksort will perform in worst-case time. If, however, quicksort chooses some random element to be the pivot, then an adversary without knowledge of what random numbers are coming up cannot arrange the data to guarantee worst-case execution time for quicksort.\nThe classic on-line problem first analysed with competitive analysis (Sleator & Tarjan 1985) is the list update problem: Given a list of items and a sequence of requests for the various items, minimize the cost of accessing the list where the elements closer to the front of the list cost less to access. (Typically, the cost of accessing an item is equal to its position in the list.) After an access, the list may be rearranged. Most rearrangements have a cost. The Move-To-Front algorithm simply moves the requested item to the front after the access, at no cost. The Transpose algorithm swaps the accessed item with the item immediately before it, also at no cost. Classical methods of analysis showed that Transpose is optimal in certain contexts. In practice, Move-To-Front performed much better. Competitive analysis was used to show that an adversary can make Transpose perform arbitrarily badly compared to an optimal algorithm, whereas Move-To-Front can never be made to incur more than twice the cost of an optimal algorithm.\nIn the case of online requests from a server, competitive algorithms are used to overcome uncertainties about the future. That is, the algorithm does not \"know\" the future, while the imaginary adversary (the \"competitor\") \"knows\". Similarly, competitive algorithms were developed for distributed systems, where the algorithm has to react to a request arriving at one location, without \"knowing\" what has just happened in a remote location. This setting was presented in (Awerbuch, Kutten & Peleg 1992).","alt_names":["- Competitive analysis (online algorithm) :","- Competitive ratio :","Competitive Analysis (Online Algorithm)","Competitive analysis (online algorithm)","Competitive analysis (online algorithm) - Wikipedia, the free","Competitive analysis (online algorithm) - Wikipedia, the free ...","Competitive analysis (online algorithm) - Wikipedia, the free encyclopedia","Competitive analysis (online algorithm); it is used under","Competitive analysis online algorithm","Competitive analysis online algorithm Wikipedia the free","Competitive ratio","Competitive_analysis_%28online_algorithm%29","Competitive_analysis_(online_algorithm)","Wikipedia article Competitive analysis (online algorithm)","Wikipedia article Competitive ratio","Wikipedia entry for Competitive analysis (online algorithm)","competitive analysis (online algorithm)","competitive ratio","http://en.wikipedia.org/wiki/Competitive_analysis_ (online_algorithm)","http://en.wikipedia.org/wiki/Competitive_analysis_%28online_algorithm%29","http://en.wikipedia.org/wiki/Competitive_analysis_(online_algorithm)","http://en.wikipedia.org/wiki/Competitive_analysis_（online_algorithm）","kompetitive Analyse"],"name":"Competitive analysis (online algorithm)","categories":["Analysis of algorithms","Online algorithms"],"tag_line":"Competitive analysis is a method invented for analyzing online algorithms, in which the performance of an online algorithm (which must satisfy an unpredictable sequence of requests, completing each request without being able to see the future) is compared to the performance of an optimal offline algorithm that can view the sequence of requests in advance."}}
,{"_index":"throwtable","_type":"algorithm","_id":"augmented-lagrangian-method","_score":0,"_source":{"description":"Augmented Lagrangian methods are a certain class of algorithms for solving constrained optimization problems. They have similarities to penalty methods in that they replace a constrained optimization problem by a series of unconstrained problems and add a penalty term to the objective; the difference is that the augmented Lagrangian method adds yet another term, designed to mimic a Lagrange multiplier. The augmented Lagrangian is not the same as the method of Lagrange multipliers.\nViewed differently, the unconstrained objective is the Lagrangian of the constrained problem, with an additional penalty term (the augmentation).\nThe method was originally known as the method of multipliers, and was studied much in the 1970 and 1980s as a good alternative to penalty methods. It was first discussed by Magnus Hestenes in 1969 and by Powell in 1969. The method was studied by R. Tyrrell Rockafellar in relation to Fenchel duality, particularly in relation to proximal-point methods, Moreau–Yosida regularization, and maximal monotone operators: These methods were used in structural optimization. The method was also studied by Dimitri Bertsekas, notably in his 1982 book, together with extensions involving nonquadratic regularization functions, such as entropic regularization, which gives rise to the \"exponential method of multipliers,\" a method that handles inequality constraints with a twice differentiable augmented Lagrangian function.\nSince the 1970s, sequential quadratic programming (SQP) and interior point methods (IPM) have had increasing attention, in part because they more easily use sparse matrix subroutines from numerical software libraries, and in part because IPMs have proven complexity results via the theory of self-concordant functions. The augmented Lagrangian method was rejuvenated by the optimization systems LANCELOT and AMPL, which allowed sparse matrix techniques to be used on seemingly dense but \"partially separable\" problems. The method is still useful for some problems. Around 2007, there was a resurgence of augmented Lagrangian methods in fields such as total-variation denoising and compressed sensing. In particular, a variant of the standard augmented Lagrangian method that uses partial updates (similar to the Gauss-Seidel method for solving linear equations) known as the alternating direction method of multipliers or ADMM gained some attention.","alt_names":["augmented Lagrangian","- Augmented Lagrangian method :","Augmented Lagrangian Method","Augmented Lagrangian method","Augmented Lagrangian method - Wikipedia, the free encyclopedia","Augmented Lagrangian methods","Wikipedia article on Augmented Lagrangian method","alternating direction method of multipliers","http://en.wikipedia.org/wiki/Augmented_ … ian_method","http://en.wikipedia.org/wiki/Augmented_Lagrangian_method"],"name":"Augmented Lagrangian method","categories":["Optimization algorithms and methods"],"tag_line":"Augmented Lagrangian methods are a certain class of algorithms for solving constrained optimization problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"golden-section-search","_score":0,"_source":{"description":"The golden section search is a technique for finding the extremum (minimum or maximum) of a strictly unimodal function by successively narrowing the range of values inside which the extremum is known to exist. The technique derives its name from the fact that the algorithm maintains the function values for triples of points whose distances form a golden ratio. The algorithm is the limit of Fibonacci search (also described below) for a large number of function evaluations. Fibonacci search and Golden section search were discovered by Kiefer (1953). (see also Avriel and Wilde (1966)).","alt_names":["хорошо написано","Метод золотого сечения","Golden section search","- Golden section search :","-> Read the article about 'Golden section search'","...more on Wikipedia about Golden section search","Búsqueda de la Sección Áurea","Golden Section Search","Golden Section Search: 1 dimensional optimization","Golden section search - Wikipedia :: The free encyclopedia","Golden section search - Wikipedia, the free encyclopedia","Golden section search - Wikipedia, the free encyclopedia ...","Golden section search Wikipedia the free encyclopedia","Golden section search Wikipedia, the ...","Golden section search from Wikipedia","Golden_ratio_search","Golden_section_search","Metoda zlotego podzialu – Wikipedia, wolna encyklopedia","Metoda złotego podziału","Metoda złotego podziału – Wikipedia, wolna encyklopedia","The article you linked","Wikipedia - Golden section search","Wikipedia article Golden ratio search","Wikipedia article Golden section search","Wikipedia article Метод золотого сечения","Wikipedia entry for Golden section search","Zbieżność metody","c a = a b .","en.wikipedia.org/wiki/Golden_section_...","en.wikipedia.org/wiki/Golden_section_search","golden section 1 dimensional optimizer","golden section search","golden section search [","golden section search algorithm","golden section search wikipedia the free encyclopedia","golden-section method","http://en.wikipedia.org/wiki/Golden_sect","http://en.wikipedia.org/wiki/Golden_section_s...","http://en.wikipedia.org/wiki/Golden_section_search","http://en.wikipedia.org/wiki/Golden_section_search#Fibonacci_search","http://pl.wikipedia.org/wiki/Metoda_z%C5%8","http://pl.wikipedia.org/wiki/Metoda_z%C5%82otego_podzia","http://ru.wikipedia.org/wiki/Метод_золотого_сечения","http://ru.wikipedia.org/wiki/Метод_чисел_Фибоначчи","methode van de gulden snede","pl:Metoda złotego podziału","pl:Metoda_złotego_podziału","ru:Метод золотого сечения","the original is here","Википедия - Метод золотого сечения","Метод Фибоначи","Метод Фибоначчи","РњРµС‚РѕРґ Р·РѕР»РѕС‚РѕРіРѕ СЃРµС‡РµРЅРёСЏ","а вот и метод с фибоначи","метод золотого сечения"],"name":"Golden section search","categories":["Articles with example Java code","Fibonacci numbers","Golden ratio","Optimization algorithms and methods"],"tag_line":"The golden section search is a technique for finding the extremum (minimum or maximum) of a strictly unimodal function by successively narrowing the range of values inside which the extremum is known to exist."}}
,{"_index":"throwtable","_type":"algorithm","_id":"solving-quadratic-equations-with-continued-fractions","_score":0,"_source":{"description":"In mathematics, a quadratic equation is a polynomial equation of the second degree. The general form is\n\nwhere a ≠ 0.\nThe quadratic equation can be solved using the well-known quadratic formula, which can be derived by completing the square. That formula always gives the roots of the quadratic equation, but the solutions are expressed in a form that often involves a quadratic irrational number, which is an algebraic fraction that can be evaluated as a decimal fraction only by applying an additional root extraction algorithm.\nIf the roots are real, there is an alternative technique that obtains a rational approximation to one of the roots by manipulating the equation directly. The method works in many cases, and long ago it stimulated further development of the analytical theory of continued fractions.","alt_names":["0750c68d90d9fd7e171a58cdd9a ...","9aba3b29e7385c69320547132b368a ...","A general theorem","An algebraic explanation","Complex coefficients","Learn about Solving quadratic equations with continued fractions","M?sodfok? egyenletek megold?sa l?nct?rtekkel","Másodfokú egyenletek megoldása lánctörtekkel","Másodfokú egyenletek megoldása lánctörtekkel - Wikipédia","Solving quadratic equations with continued fractions","Solving quadratic equations with continued fractions - Wikipedia ...","Solving quadratic equations with continued fractions - Wikipedia, the","Solving quadratic equations with continued fractions - Wikipedia,...","Solving quadratic equations with continued fractions ...","Solving quadratic equations with continued fractions: A general","Solving quadratic equations with continued fractions: A simple","Solving quadratic equations with continued fractions: An algebraic","Solving quadratic equations with continued fractions: Complex coefficients","Solving quadratic equations with continued fractions: The general","Solving quadratic equations with continued fractions; it is","Source Wikipedia.org Arcticle - Solving quadratic equations with","The general quadratic equation","Wikipedia article Solving quadratic equations with continued fractions","Wikipedia article about Solving quadratic equations with continued","Wikipedia entry for Solving quadratic equations with continued","a3eac5a0b17a06ad9ccc401714e35d ...","begin align x 2 p 2 amp c p","http://en.wikipedia.org/wiki/Solving_qua","http://en.wikipedia.org/wiki/Solving_quadratic_equations_with_continued_fractions","http://en.wikipedia.org/wiki/Solving_qua…","technique for approximating the roots of quadratic equations","x = - b - c - b - c - b - c - b","yago-res:Solving quadratic equations with continued fractions","与连分数有关的提取平方根的方法","與連分數有關的提取平方根的方法","連分數來逼近"],"name":"Solving quadratic equations with continued fractions","categories":["Continued fractions","Elementary algebra","Equations","Mathematical analysis","Root-finding algorithms"],"tag_line":"In mathematics, a quadratic equation is a polynomial equation of the second degree."}}
,{"_index":"throwtable","_type":"algorithm","_id":"halley's-method","_score":0,"_source":{"description":"In numerical analysis, Halley’s method is a root-finding algorithm used for functions of one real variable with a continuous second derivative, i.e., C2 functions. It is named after its inventor Edmond Halley.\nThe algorithm is second in the class of Householder's methods, right after Newton's method. Like the latter, it produces iteratively a sequence of approximations to the root; their rate of convergence to the root is cubic. Multidimensional versions of this method exist.\nHalley's method can be viewed as exactly finding the roots of a linear-over-linear Padé approximation to the function, in contrast to Newton's method/Secant method (approximates/interpolates the function linearly) or Cauchy's method/Muller's method (approximates/interpolates the function quadratically).\n\n","alt_names":["Halley's method","- Halley's method :","0 = f ( a ) = f ( x n ) + f ' ( x","723cf18d7b70b80b06a835f5a06c ...","879601211a390db5cd5d02bec2727f ...","Halley s method","Halley%27s_method","Halley's Method","Halley's method - Wikipedia, the free encyclopedia","Halley's_method","Halley-Verfahren","Halley-Verfahren bei der wikipedia","Halley-Verfahren – Wikipedia","Halleyeva metoda, MNM str 137.","Metoda Halleya","Mètode de Halley","Méthode de Halley","Méthode de Halley - Wikipédia","What is the derivation of Halley method","Wikipedia article Halley method","Wikipedia article Halley's method","Wikipedia article Metoda Halleya","Wikipedia sur Iteration de Halley","Wikipedia sur Itération de Halley","Wikipedia sur Méthode de Halley","Wikipedia-Artikel Halley-Verfahren","Wikipedia: Halley's method","ca:Mètode de Halley","de:Halley-Verfahren","en.wikipedia.org/wiki/Halley%27s_method","en.wikipedia.org…Halley%27s_method","en:Halley's method","er Halley's method","fr:Itération de Halley","http://de.wikipedia.org/wiki/Halley-Verf","http://de.wikipedia.org/wiki/Halley-Verfahren","http://en.wikipedia.org/wiki/Halley%27s_method","http://en.wikipedia.org/wiki/Halley's method","http://en.wikipedia.org/wiki/Halley's_method","http://fr.wikipedia.org/wiki/Itération_de_Halley","http://fr.wikipedia.org/wiki/M%C3%A9thode_de_Halley","http://pl.wikipedia.org/wiki/Metoda_Halleya","itération de Halley","pl:Metoda Halleya","r Halley's method","use Halley's method","wikipedia on Halley's Method"],"name":"Halley's method","categories":["Root-finding algorithms","Use dmy dates from July 2013"],"tag_line":"In numerical analysis, Halley’s method is a root-finding algorithm used for functions of one real variable with a continuous second derivative, i.e., C2 functions."}}
,{"_index":"throwtable","_type":"algorithm","_id":"maximum-subarray-problem","_score":0,"_source":{"description":"In computer science, the maximum subarray problem is the task of finding the contiguous subarray within a one-dimensional array of numbers (containing at least one positive number) which has the largest sum. For example, for the sequence of values −2, 1, −3, 4, −1, 2, 1, −5, 4; the contiguous subarray with the largest sum is 4, −1, 2, 1, with sum 6.\nThe problem was first posed by Ulf Grenander of Brown University in 1977, as a simplified model for maximum likelihood estimation of patterns in digitized images. A linear time algorithm was found soon afterwards by Jay Kadane of Carnegie-Mellon University (Bentley 1984).","alt_names":["Bentley 1984","Bài toán mảng con lớn nhất – Wikipedia tiếng","Kadane's Algorithm","Kadane's algorithm","Learn about Maximum subarray problem>>>","Maximum Continuous Subarray","Maximum Subarray Problem","Maximum subarray problem","Maximum subarray problem - Wikipedia, the free encyclopedia","Maximum_subarray_problem","What are generalizations of Maximum subarray problem","Wikipedia article Kadane's Algorithm","Wikipedia article Kadane's algorithm","Wikipedia entry for Maximum subarray problem","an O(N) solution","en.wikipedia.org/wiki/Kadane%27s_Algorithm","en.wikipedia.org/wiki/Maximum_subarray_problem","finds maximum sub-array of any size","first university assignment","http://en.wikipedia.org/wiki/Kadane%27s_Algorithm","http://en.wikipedia.org/wiki/Kadane%27s_algorithm","http://en.wikipedia.org/wiki/Maximum_subarray_problem","http://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane.27s_algorithm","http://en.wikipedia.org/wiki/Maximum_subarray_problem]","maximum subarray problem","maximum-weight subarray problem"],"name":"Maximum subarray problem","categories":["Articles with example Python code","Dynamic programming","Optimization algorithms and methods"],"tag_line":"In computer science, the maximum subarray problem is the task of finding the contiguous subarray within a one-dimensional array of numbers (containing at least one positive number) which has the largest sum."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bobyqa","_score":0,"_source":{"description":"BOBYQA (Bound Optimization BY Quadratic Approximation) is a numerical optimization algorithm by Michael J. D. Powell. It is also the name of Powell's Fortran 77 implementation of the algorithm.\nBOBYQA solves bound constrained optimization problems without using derivatives of the objective function, which makes it a derivative-free algorithm. The algorithm solves the problem using a trust region method that forms quadratic models by interpolation. One new point is computed on each iteration, usually by solving a trust region subproblem subject to the bound constraints, or alternatively, by choosing a point to replace an interpolation point so as to promote good linear independence in the interpolation conditions.\nThe same as NEWUOA, BOBYQA constructs the quadratic models by the least Frobenius norm updating  technique.\nBOBYQA software was released on January 5, 2009.\nIn the comment of the software's source code, it is said that the name BOBYQA denotes \"Bound Approximation BY Quadratic Approximation\", which seems to be a typo of \"Bound Optimization BY Quadratic Approximation\".\nThe BOBYQA software is distributed under The GNU Lesser General Public License (LGPL).","alt_names":[],"name":"BOBYQA","categories":["All articles with links needing disambiguation","Articles with links needing disambiguation from April 2014","CS1 errors: invisible characters","Optimization algorithms and methods"],"tag_line":"BOBYQA (Bound Optimization BY Quadratic Approximation) is a numerical optimization algorithm by Michael J. D. Powell."}}
,{"_index":"throwtable","_type":"algorithm","_id":"laguerre's-method","_score":0,"_source":{"description":"In numerical analysis, Laguerre's method is a root-finding algorithm tailored to polynomials. In other words, Laguerre's method can be used to numerically solve the equation\n\nfor a given polynomial p. One of the most useful properties of this method is that it is, from extensive empirical study, very close to being a \"sure-fire\" method, meaning that it is almost guaranteed to always converge to some root of the polynomial, no matter what initial guess is chosen. This method is named in honour of Edmond Laguerre, a French mathematician.","alt_names":["Laguerre's method","-> Read more about Laguerre's method","-> Read the article about 'Laguerre's method'","...more on Wikipedia about Laguerre's method","Laguerre method","Laguerre's Method","Laguerre's method - Wikipedia, the free encyclopedia","Laguerre's method.","Metodo di Laguerre","Méthode de Laguerre","Wikipedia (Laguerre's method)","Wikipedia article Laguerre method","Wikipedia article Laguerre's method","a = n G ( n - 1 ) ( n H - G","b47c3cf73633a2d7b5676ec0a387d ...","en.wikipedia.org/wiki/Laguerre%27s_method","fr:Méthode de Laguerre","http://en.wikipedia....erre%27s_method","http://en.wikipedia.org/wiki/Laguerre%27s_method","http://en.wikipedia.org/wiki/Laguerre%27…","http://en.wikipedia.org/wiki/Laguerre's_method","http://es.wikipedia.org/wiki/M%C3%A9todo_de_Laguerre","http://fr.wikipedia.org/wiki/M%C3%A9thode_de_Laguerre","http://it.wikipedia.org/wiki/Metodo_di_Laguerre","it:Metodo di Laguerre","metodo di Laguerre","méthode de Laguerre"],"name":"Laguerre's method","categories":["Root-finding algorithms"],"tag_line":"In numerical analysis, Laguerre's method is a root-finding algorithm tailored to polynomials."}}
,{"_index":"throwtable","_type":"algorithm","_id":"berndt–hall–hall–hausman-algorithm","_score":0,"_source":{"description":"The Berndt–Hall–Hall–Hausman (BHHH) algorithm is a numerical optimization algorithm similar to the Gauss–Newton algorithm. It is named after the four originators: Ernst R. Berndt, B. Hall, Robert Hall, and Jerry Hausman.\n\n","alt_names":[],"name":"Berndt–Hall–Hall–Hausman algorithm","categories":["All articles with unsourced statements","Articles with unsourced statements from March 2013","Econometrics","Optimization algorithms and methods"],"tag_line":"The Berndt–Hall–Hall–Hausman (BHHH) algorithm is a numerical optimization algorithm similar to the Gauss–Newton algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"swarm-intelligence","_score":0,"_source":{"description":"Swarm intelligence (SI) is the collective behavior of decentralized, self-organized systems, natural or artificial. The concept is employed in work on artificial intelligence. The expression was introduced by Gerardo Beni and Jing Wang in 1989, in the context of cellular robotic systems.\nSI systems consist typically of a population of simple agents or boids interacting locally with one another and with their environment. The inspiration often comes from nature, especially biological systems. The agents follow very simple rules, and although there is no centralized control structure dictating how individual agents should behave, local, and to a certain degree random, interactions between such agents lead to the emergence of \"intelligent\" global behavior, unknown to the individual agents. Examples in natural systems of SI include ant colonies, bird flocking, animal herding, bacterial growth, fish schooling and microbial intelligence.\nThe application of swarm principles to robots is called swarm robotics, while 'swarm intelligence' refers to the more general set of algorithms. 'Swarm prediction' has been used in the context of forecasting problems.","alt_names":["sometimes...","swarming technology","Swarm intelligence","swarm intelligence","'swarm' intelligence","'swarm' theory","(swarm intelligence)",") Vor emerge.","- Intelligent Water Drops :","- Swarm Intelligence :","- Swarm intelligence :","- Swarm theory :","...more on Wikipedia about Swarm intelligence","1 Example algorithms","1.1 Ant Colony Optimization","1.2 Particle Swarm Optimization","1.3 Stochastic Diffusion Search","1.4 Gravitational Search Algorithm","2.2 Ant-based routing","4 Notable researchers","<http://en.wikipedia.org/wiki/Swarm_intelligence>","Algoritmi zasnovani na inteligenciji roja","Cada organismo é um exemplo de uma multi","Collective and Swarm intelligence","Example algorithms","Examples of Swarm Intelligence in popular culture","Flock teorisinin","Ganāmpulka teorijas","Hacker News: Swarm intelligence","How to apply for Swarm intelligence?","How to apply for Swarm theory?","Inteligence hejna pedie","Inteligencia de Enjambres","Inteligencia de enjambre","Inteligencia de enjambre - Wikipedia, la enciclopedia libre","Inteligencia de enjambres","Inteligență „roi”","Intelligent Water Drops","Intelligent_Water_Drops","L'intelligence en essaim","La intel ligència de eixam","La inteligencia de enjambre","Learn about Swarm intelligence>>>","Locust Swarm - Swarm Intelligence","Método de Swarm Intelligence","Particle swarms","Parviäly","Parviälyä","Postar um comentário","Pulko teorija","Read More swarm intelligence wikipedia the free encyclopedia","SI means","SWARM INTELLIGENCE","SWARM intelligence","Saime teorija","Swam intelligence","Swarm Inteligence","Swarm Intelligence","Swarm Intelligence (which is a more general introduction","Swarm Intelligence (wikipedia)","Swarm Intelligence - Wikipedia","Swarm Intelligence : Wikipedia","Swarm Intelligence Resources","Swarm Intelligence Wikipedia","Swarm Intelligence and Foraging-based Optimization","Swarm Intelligence at Wikipedia","Swarm Intelligence(SI).","Swarm Intelligence(link)","Swarm Intelligence.","Swarm Theory","Swarm computing","Swarm faisnéise","Swarm intelligence (SI)","Swarm intelligence (SI) Swarm intelligence (SI) is artificial","Swarm intelligence - Simple ...","Swarm intelligence - Simple English Wikipedia, the free encyclopedia","Swarm intelligence - Wikipedia","Swarm intelligence - Wikipedia, the free encyclopedia","Swarm intelligence - Wikipedia, the free encyclopedia | Augmented Collective","Swarm intelligence - Wikipedia, the free encyclopediaSwarm intelligence","Swarm intelligence Wikipedia the free encyclopedia","Swarm intelligence Wikipedia the free encyclopedia - result","Swarm intelligence in animals and humans","Swarm intelligence – Wikipedia, the free encyclopedia","Swarm intelligence →","Swarm intelligence(the study of self-organizing processes","Swarm theory","Swarm-Wiki","Swarm-based optimization algorithms","Swarm-intelligence","Swarm-theory","Swarm_Intelligence","Swarm_intelligence","Swarming Intelligence","Sürü teori","Teooria kari","Teoria a efectivului de","Teoria e kopesë","Teoria parven","Teoria stada","Teorie hejna","Teorie stáda","Teorija jate","Teorija stada","Teória kŕdle","Teória stáda","The concept is employed in work on artificial","The wiki page isn't a bad start","Theorie der Herde","Theorie von der Herde","Tos kilmės teorija","Un área nueva de la inteligencia artificial","What is swarm intelligence?","Wiki - Swarm Intelligence","Wikipedia / Swarm_Intelligence","Wikipedia article Swarm intelligence","Wikipedia article Swarm theory","Wikipedia article on Swarm Intelligence","Wikipedia article on Swarm intelligence","Wikipedia article ذكاء الأسراب","Wikipedia article ความฉลาดแบบกลุ่ม","Wikipedia entry for Intelligent Water Drops","Wikipedia entry for Swarm intelligence","Wikipedia on Swarm Intelligence","Wikipedia zu 'Swarm Intelligence","Wikipedia: Swarm Intelligence","Wikipedia: swarm intelligence","Wikipedia:Swarm intelligence","Zwermintelligentie","Zwermintelligentie - Wikipedia","[COLOR=#0000ff]swarm intelligence[/COLOR]","[Particle Swarms]","[Wikipedia Swarm Intelligence]","[群知能","about swarm intelligence on wikipedia","ackumulerade kunskapen","als een collectief","ant-based routing","ar:ذكاء الأسراب","artifical intelligences","artículo de Wikipedia Inteligencia de enjambre","as swarm intelligence.","cs:Inteligence hejna","decentralized, self-organized systems","dell'intelligenza di sciame","edit] Ant colony optimization","eixam intel·ligent","elmélet a nyáj","emergent, swarming","en.wikipedia.org/...Swarm_intelligence","en.wikipedia.org/wiki/Swarm_intellige...","en.wikipedia.org/wiki/Swarm_intelligence","en.wikipedia.org/wiki/Swarm_intelligence#Ant-based_routing","en.wikipedia.org/wiki/Swarm_intelligence#Ant_Colony_Optim...","en: Intelligent Water Drops","en:Swarm Intelligence","enjambres de abejas","enlaces de la wikipedia","es:Inteligencia de enjambre","example algorithms","fa:هوش ازدحامی","faisnéis Swarm","fi:Parviäly","flock AI","flocking techniques","gli sciami","haid cudd-wybodaeth","http://en.wikipedia....rm_intelligence","http://en.wikipedia.org/wiki/Intelligent_Water_Drops","http://en.wikipedia.org/wiki/Swarm_Intel ligence","http://en.wikipedia.org/wiki/Swarm_Intelligence","http://en.wikipedia.org/wiki/Swarm_i...ple_algorithms","http://en.wikipedia.org/wiki/Swarm_intel","http://en.wikipedia.org/wiki/Swarm_intel...","http://en.wikipedia.org/wiki/Swarm_intelligen...","http://en.wikipedia.org/wiki/Swarm_intelligenc...","http://en.wikipedia.org/wiki/Swarm_intelligence","http://en.wikipedia.org/wiki/Swarm_intelligence#Ant_Colony_Optimization","http://en.wikipedia.org/wiki/Swarm_intelligence#References_in_popular_culture","http://en.wikipedia.org/wiki/Swarm_theory","http://en.wikipedia.org/wiki/S​warm_intelligence","http://en.wikipedia.org/wi​ki/Swarm_intelligence","http://en.wikipedia.org/wi​ki/Swarm_theory","http://es.wikipedia.org/wiki/Inteligencia_de_enjambre","http://fi.wikipedia.org/wiki/Parvi%C3%A4ly","http://it.wikipedia.org/wiki/Swarm_intel…","http://nl.wikipedia.org/wiki/Zwermintelligentie","http://ru.wikipedia.org/wiki/Роевой_интеллект","http://ru.wikipedia.org/wiki/Ройный_интеллект","http://simple.wikipedia.org/wiki/Swarm_intelligence","http://www.csc.liv.ac.uk/~mjw/Prof_Michael_Wooldridge_","inherent intelligence","inteligenci hejna","inteligencia de enjambre","inteligencia de partículas","inteligencia del enjambre","inteligencia del enjambre (swarm intelligence)","inteligencija roja","inteligjencës gëlon","inteligência de grupo","intelligence distributed among members","intelligenza di sciame","ja:群知能","kawanan intelijen","ko:다중 지성","kuolematon kuntaolento","kvik upplýsingaöflun","lý thuyết của đàn","lý thuyết về tổng đàn","lý thuyết về đàn chiên","mekanismin","mekanizëm","nature inspired ai","networking and logistics POV","nl.wikipedia.org/wiki/Zwermintelligentie","nl:Zwermintelligentie","nonlinear swarm algorithm","organised swarms","other computer simulated swarming","own personal swarm","parvi älykkyyttä","patterns of far greater complexity than we have","pūļa zināšanas","raj intelligencia","reactive agents swarm","ro:Inteligență „roi”","roj inteligenca","ru.wikipedia.org/...%D0%BB%D0%BB%D0","ru:Роевой интеллект","saggezza dello stormo","sciame intelligente","sciami d'api","simple:Swarm intelligence","simplicity that leads to the overwhelming complexity","sistemi sciame","sverm intelligens","svärmintelligens","svärmisk intelligens","sværm intelligens","swam intelligence","swarm AI","swarm algorithms","swarm computing","swarm effects","swarm intellegence","swarm intelligance","swarm intelligenc","swarm intelligence in our human and robot systems","swarm intelligence on Wikipedia","swarm intelligence wikipedia","swarm intelligence,","swarm intelligence.","swarm intelligence/hive mind","swarm intelligence]","swarm intellligence","swarm mentality","swarm network","swarm of interlinked nanotechnological units","swarm optimization","swarm out","swarm programming","swarm systems","swarm technologies","swarm theory","swarm thông minh","swarm – intelligence","swarm-intelligence","swarming behavior","swarmintelligence","swarms coming from complexity theory","swarn intelligence","sülem intelligentsus","sürüsü istihbarat","ta:மந்தை புத்தி","teori av flocken","teori kawanan","teori om den flok","teori om flocken","teori om flokken","teoria de les ovelles","teoria del ramat","teoria do rebanho","teorien om den flokken","teorien om flokken","teorija tal-qatgħa","teorya ng kawan","teoría de la manada","teoría de las ovejas","teoría do rabaño","th:ความฉลาดแบบกลุ่ม","the collective behaviour of decentralized, self-organized systems","the mechanisms behind this","theorie van de bevolking","theorie van de kudde","théorie du troupeau","to organize","uk:Ройовий інтелект","un cardumen","warm intelligence","wiki:SWARM_Intillegence","zwerm intelligentie","zwermintelligentie","θεωρία του σμήνους","Роевой интеллект","Ройовий інтелект","Скопление разведки","Теории стада","Теория стадо","Теория стаи","Теорија стада","Теорія зграї","Теорія стадо","Теорії стада","раіцца разведкі","роевого интеллекта","роевой","роевой интеллект","роевой оптимизацией","роевый интеллект","роиться разведки","рояк разузнаване","роїтися розвідки","рој интелигенције","теорията на стадото","התיאוריה של הצאן","נחיל מודיעין","נחילים","ازدحام اطلاعاتی","ذكاء الأسراب","سرب الاستخبارات","نظرية القطيع","هوش ازدحامي","هوش ازدحامی","هوش ازدحامی - ویکیپدیا","ویکیپدیا => الگوریتم مورچه ها - هوش ازدحامی","۱ روشهای هوش ازدحامی","۱.۱ الگوریتم مورچه ها","۱.۲ الگوریتم کوچ پرستوها","۲ جذابیت هوش ازدحامی در فناوری اطلاعات","۳ مراحل طراحی یک سامانه","۴ کاربردهای فعلی و آتی","झुंड के सिद्धांत","झुंड के सिद्धांत के","झुंड खुफिया","ความฉลาดแบบกลุ่ม","ความฉลาดแบบกลุ่ม - วิกิพีเดีย","ทฤษฎีของฝูง","ปัญญารุม","“Intelligenza di sciame”","„inteligencję roju","の理論のある自然","理论的羊群","羊群理论的","群れの理論","群れの理論は、","群体智能","群知能","群知能 - Wikipedia","群知能-wikipedia","群知能理論","群體智能","郡知能","공동 인텔리 전스","군집지성(Swarm Intelligence: SI)","다중 지성","다중 지성 - 위키백과, 우리 모두의 백과사전","다중지성","무리 이론","무리 이론의","무리 인텔리 전스","위키 피 디아 문서 다중 지성"],"name":"Swarm intelligence","categories":["All articles needing additional references","All articles with unsourced statements","Articles needing additional references from August 2013","Articles with unsourced statements from September 2015","Behavioral and social facets of systemic risk","Collective intelligence","Intelligence by type","Multi-agent systems","Optimization algorithms and methods"],"tag_line":"Swarm intelligence (SI) is the collective behavior of decentralized, self-organized systems, natural or artificial."}}
,{"_index":"throwtable","_type":"algorithm","_id":"metaphone","_score":0,"_source":{"description":"Lawrence Philips redirects here. For the football player, see Lawrence Phillips.\nMetaphone is a phonetic algorithm, published by Lawrence Philips in 1990, for indexing words by their English pronunciation. It fundamentally improves on the Soundex algorithm by using information about variations and inconsistencies in English spelling and pronunciation to produce a more accurate encoding, which does a better job of matching words and names which sound similar. As with Soundex, similar sounding words should share the same keys. Metaphone is available as a built-in operator in a number of systems.\nThe original author later produced a new version of the algorithm, which he named Double Metaphone. Contrary to the original algorithm whose application is limited to English only, this version takes into account spelling peculiarities of a number of other languages. In 2009 Lawrence Philips released a third version, called Metaphone 3, which achieves an accuracy of approximately 99% for English words, non-English words familiar to Americans, and first names and family names commonly found in the United States, having been developed according to modern engineering standards against a test harness of prepared correct encodings.","alt_names":["变音","- Metaphone :","-> Read the article about 'Metaphone'","3.1 Downloadable Implementations","Dobbelt-metaphone","Doble Metaphone","Dobre Metaphone","Doppel Metaphone","Doppel metaphone","Doppel-metaphone","Doppelklicken Metaphone","Doppelzimmer metaphone.","Doppia Metaphone","Double - Metaphone","Double Metaphone","Double Metaphone (DMetaPhone)","Double Metaphone - Wikipedia, the free encyclopedia","Double Metaphone - Wikipédia","Double Metaphone by Lawrence Philips","Double Metaphone,","Double Metaphone.","Double metaphone","Double Метафон","Double-Metaphone","Double-Metaphone-Algorithmus","Double-Metaphone”","Double-metaphone","DoubleMetaphone","DoubleMetaphone algorithm","Dubbel metaphone","Dubbelklik Metaphone","Dupla Metaphone","Dvivietis Metaphone","Dvojlôžková metaphone","Dvoulůžkový metaphone","Dwukrotnie Metaphone","English metaphone rules","Haga doble Metaphone","HÃ¤r finns mera information om metaphone","Här finns mera information om metaphone","Lawrence Philip","Learn about Metaphone>>>","MetaPhone","Metafone","Metaphe","Metaphone","Metaphone (Wikipedia)","Metaphone - Wikipedia, la enciclopedia libre","Metaphone - Wikipedia, the free encyclopedia","Metaphone - Wikipédia","Metaphone - Á'Â?∫Á?æÁß Ôº?Ë?™Á","Metaphone - ็'ๅ?บ็?พ็ง ๏ผ?่?ช็","Metaphone Camera","Metaphone Double","Metaphone Wikipedia the free encyclopedia","Metaphone [Wikipedia]","Metaphone algorithm","Metaphone alogirthm","Metaphone and Double Metaphone","Metaphone at Wikipedia","Metaphone casal","Metaphone doble","Metaphone na Wikipedia","Metaphone ouble","Metaphone – Wikipedia","Metaphone – Wikipedia, the free encyclopedia","Metaphone — Википедия","Metaphone-Algorithmus","Metaphone.","Metaphone3","Metaphoneの","Metaphoneのを","Metaphone的","Metaphone를","Metaphonkonzept","Methaphone","Métaphone","OPPIO Metaphone","OUBLE Metaphone","Of course, there's a Wikipedia link too","The Wikipedia article on Double Metaphone","What is alphabet of Metaphone","What is alphabet of Metaphone?","Wikipedia - Double Metaphone","Wikipedia article Lawrence Philips","Wikipedia article Metaphone","Wikipedia article on Lawrence Philips","Wikipedia article on Metaphone","Wikipedia article on Usuario:Shooke/Archivo/Julio 2009","Wikipedia entry for Double Metaphone","Wikipedia entry for Metaphone","Wikipedia-Artikel Metaphone","Wikipedia-Seite zu 'Metaphone'","Wikipedia:Metaphone","artículo de Wikipedia Metaphone","de.wikipedia.org/wiki/Metaphone","de:Metaphone","dobbelt metaphone","doble Metaphone","doble metaphone","doppelt metaphone","doppelten metaphone","doppia Metaphone","doppio Metaphone","doppio metaphone","double metaphone","double metaphone algorithm","double metaphone matching","double-metaphone","double-metaphone algorithm","dubbele Metaphone","dubbele metaphone","dvojité metaphone","dvojitý metaphone","en.wikipedia.org/...Double_Metaphone","en.wikipedia.org/wiki/Metaphone","es:Metaphone","http://de.wikipedia.org/wiki/Metaphone","http://en.wikipedia....ouble_Metaphone","http://en.wikipedia.org/wiki/Double-Metaphone","http://en.wikipedia.org/wiki/Double-Metaphone을","http://en.wikipedia.org/wiki/Double_...uble_Metaphone","http://en.wikipedia.org/wiki/Double_Meta","http://en.wikipedia.org/wiki/Double_Metaphone","http://en.wikipedia.org/wiki/Double_Metaphone#Double_Metaphone","http://en.wikipedia.org/wiki/Double_Metaphone#Double_Metaphone...","http://en.wikipedia.org/wiki/Double_Metaphone.","http://en.wikipedia.org/wiki/Metaphone","http://en.wikipedia.org/wiki/Metaphone#Double_Metaphone","http://es.wikipedia.org/wiki/Metaphone","http://fr.wikipedia.org/wiki/Double_Metaphone","http://fr.wikipedia.org/wiki/Metaphone","http://ru.wikipedia.org/wiki/Metaphone","http://zh.wikipedia.org/wiki/Metaphone","l'article de Wikipédia Metaphone","metaphone","metaphone OBLE","metaphone doble.","metaphone doppio","metaphone doppio.","metaphone double","metaphone double.","metaphone dupla","metaphone dupla.","metaphone ganda","metaphone ganda.","metaphone gấp đôi.","metaphone คู่.","metaphone-Algorithmus","metaphones","metaphoneの","metaphonize","métaphone","ouble Metaphone","ouble Metaphoneの","ouble metaphone","ouble Метафон","oubleのMetaphone","ouble元电话","ouble元電話","podwójne metaphone","podwójnego metaphone","the double metaphone","ttp://en.wikipedia.org/wiki/Double-Metaphone","uk:Метафон","zh:Metaphone","Đôi Metaphone","đôi Metaphone","đôi metaphone","Διπλό Metaphone","Википедии статью Metaphone","Дважды Metaphone","Двойна Metaphone","Двоструки Метапхоне","Метафон","Подвійний Metaphone","двойной Metaphone","двойной метафон","двойной метафон.","двойной метафонов","двойную метафон","двойных метафон","метафон","метафонов","دو Metaphone","نقرا Metaphone","डबल Metaphone","डी ouble","คู่ Metaphone","のMetaphone","ダブルMetaphoneの","ダブルmetaphoneが","ダブルmetaphoneの","ダブルのMetaphone","ダブルのmetaphone","二重のMetaphoneの","元电话","元電話","双Metaphone的","双元电话","双变音","双的metaphone，","双重的metaphone","双音位","維基百科的文章“ Metaphone ”","维基百科的文章“ Metaphone ”","重Metaphoneの","雙元電話","雙重的metaphone。","더블 Metaphone","더블 Metaphone가","더블 metaphone","두 번 metaphone","：ouble"],"name":"Metaphone","categories":["Phonetic algorithms"],"tag_line":"Lawrence Philips redirects here."}}
,{"_index":"throwtable","_type":"algorithm","_id":"earley-parser","_score":0,"_source":{"description":"In computer science, the Earley parser is an algorithm for parsing strings that belong to a given context-free language, though (depending on the variant) it may suffer problems with certain nullable grammars. The algorithm, named after its inventor, Jay Earley, is a chart parser that uses dynamic programming; it is mainly used for parsing in computational linguistics. It was first introduced in his dissertation in 1968 (and later appeared in abbreviated, more legible form in a journal).\nEarley parsers are appealing because they can parse all context-free languages, unlike LR parsers and LL parsers, which are more typically used in compilers but which can only handle restricted classes of languages. The Earley parser executes in cubic time in the general case , where n is the length of the parsed string, quadratic time for unambiguous grammars , and linear time for almost all LR(k) grammars. It performs particularly well when the rules are written left-recursively.\n\n","alt_names":["Earley's algorithm","- Earley algorithm :","- Earley parser :","- Early Parser :","-> Read the article about 'Earley parser'","...mehr auf Wikipedia über Earley-Algorithmus","...more on Wikipedia about Earley parser","5.1 Implementations","5.1.1 C","5.1.2 Java","5.1.3 Perl","5.1.4 Python","5.1.5 Common Lisp","Algorithme d'Earley","Algoritmo Earley ? Wikip?dia, a enciclop?dia livre","Algoritmo Earley – Wikipédia, a enciclopédia livre","Algoritmo de Earley","Algoritmo de Earley - Wikipedia, la enciclopedia libre","Algorytm Earleya","Algorytm Earleya ? Wikipedia, wolna encyklopedia","Algorytm Earleya â€“ Wikipedia, wolna encyklopedia","Algorytm Earleya – Wikipedia, wolna encyklopedia","Algorytm Earleya – Wikipedia...","Analyse Earley","Analyse Earley - Wikipédia","EARLEY","Earley Algorithm","Earley Parser","Earley algorithm","Earley chart parsing algorithm","Earley parser","Earley parser - Wikipedia, the free encyclopedia","Earley parser – Wikipedia, the free encyclopedia","Earley parser; it is used under the","Earley parsing algorithm","Earley stil kontekst gratis parser","Earley stylu kontekście swobodnego parser","Earley анализатор,","Earley 파서","Earley's Algorithm","Earley's chart-parsing algorithm","Earley-Algorithmus","Earley-Algorithmus - Wikipedia","Earley-Algorithmus bei der wikipedia","Earley-Algorithmus â€“ Wikipedia","Earley-Algorithmus – Wikipedia","Earley-Parser","Earley-Parser - Wikipedia","Earley-Parser-Generator,","Earley-stijl context vrij parser","Earley-styl bezkontextové parser","Earley-style context free parser","Earley_algorithm","Earley_parser","Earley算法","Early Parser","Early's Algorithm","Early's parsing algorithm","Early_Parser","Learn about Earley parser>>>","Parser Эрли","Skeletor says","What is Earley Parser's example","Wikipedia (Earley parser)","Wikipedia article Algoritmo Earley","Wikipedia article Algoritmo de Earley","Wikipedia article Earley algorithm","Wikipedia article Earley parser","Wikipedia article Earley's algorithm","Wikipedia article Early Parser","Wikipedia article on Algoritmo de Earley","Wikipedia article on Algorytm Earleya","Wikipedia article on Earley algorithm","Wikipedia article on Earley parser","Wikipedia article on Early Parser","Wikipedia entry for Earley parser","Wikipedia-Artikel Earley-Algorithmus","Wikipedia-Seite zu 'Earley-Algorithmus'","Wikipedia-Seite zu 'Earley-Parser'","Wikipediaで「アーリー法」を調べる","analisador Earley","analizador de Earley","analyse Earley","analyzátor Earley","artículo de Wikipedia Algoritmo de Earley","bg:Алгоритъм на Ерли","contesto in stile free-parser Earley","d'analyseur Earley","de Earley parser","der Earley-Parser","earley parser","earley-parser","early-algoritme","en.wikipedia.org/wiki/Earley_parser","en:Earley parser","es:Algoritmo de Earley","estilo de contexto libre analizador Earley","http://de.wikipedia.org/wiki/Earley-Algo","http://de.wikipedia.org/wiki/Earley-Algorithmus","http://en.wikipedia.org/wiki/Earley%5Falgorithm","http://en.wikipedia.org/wiki/Earley's_algorithm","http://en.wikipedia.org/wiki/Earley_algorithm","http://en.wikipedia.org/wiki/Earley_pars","http://en.wikipedia.org/wiki/Earley_parser","http://en.wikipedia.org/wiki/Early_Parser","http://es.wikipedia.org/wiki/Algoritmo_de_Earley","http://fr.wikipedia.org/wiki/Analyse_Earley","http://pl.wikipedia.org/wiki/Algorytm_Earleya","http://pt.wikipedia.org/wiki/Algoritmo_Earley","l'analyse Earley","parser Earley","phân tích cú pháp Earley","pl.wikipedia.org/wiki/Algorytm_Earleya","pl:Algorytm Earleya","pt:Algoritmo Earley","ru:Алгоритм Эрли","sr:Erlijev analizator","the Earley parser","the algorithm it implements","uk:Алгоритм Ерлі","Алгоритм Эрли","Алгоритъм на Ерли","Эрли стиле контексте бесплатно анализатор","алгоритм Earley","анализатором Эрли","गति की","アーリースタイルの文脈自由パーサー","アーリーパーサ","アーリーパーサの","アーリー法","アーリー法 - Wikipedia","ウィキペディアの記事 アーリー法","厄雷分析器","在欧莱分析器","阿利分析器","ｱｰﾘｰ法-wikipedia"],"name":"Earley parser","categories":["Dynamic programming","Parsing algorithms"],"tag_line":"In computer science, the Earley parser is an algorithm for parsing strings that belong to a given context-free language, though (depending on the variant) it may suffer problems with certain nullable grammars."}}
,{"_index":"throwtable","_type":"algorithm","_id":"newuoa","_score":0,"_source":{"description":"NEWUOA is a numerical optimization algorithm by Michael J. D. Powell. It is also the name of Powell's Fortran 77 implementation of the algorithm.\nNEWUOA solves unconstrained optimization problems without using derivatives, which makes it a derivative-free algorithm. The algorithm is iterative, and exploits trust region technique. On each iteration, the algorithm establishes a model function  by quadratic interpolation, and then minimizes  within a trust region.\nOne important feature of NEWUOA algorithm is the least Frobenius norm updating  technique. Suppose that the objective function  has  variables, and one wants to uniquely determine the quadratic model  by purely interpolating the function values of , then it is necessary to evaluate  at  points, as a quadratic polynomial of  variables has this amount of independent coefficients. But this is impractical when  is large, because the function values are supposed to be expensive in derivative-free optimization. In NEWUOA, the model  interpolates only  (an integer between  and , typically of order ) function values of , and the remaining degree of freedom is taken up by minimizing the Frobenius norm of . This technique mimics the least change secant updates  for Quasi-Newton methods, and can be considered as the derivative-free version of PSB update (Powell's Symmetric Broyden update).\nTo construct the models, NEWUOA maintains a set of interpolation points throughout the iterations. The update of this set is another feature of NEWUOA.\nNEWUOA algorithm was developed from UOBYQA (Unconstrained Optimization BY Quadratic Approximation). A major difference between them is that UOBYQA constructs quadratic models by interpolating the objective function at  points.\nNEWUOA software was released on December 16, 2004. It can solve unconstrained optimization problems of a few hundreds variables to high precision without using derivatives. In the software,  is set to  by default.\nOther derivative-free optimization algorithms by Powell include COBYLA, UOBYQA, BOBYQA, and LINCOA. BOBYQA and LINCOA are extensions of NEWUOA to bound constrained and linearly constrained optimization respectively.\nPowell did not explain how he coined the name \"NEWUOA\" either in the introducing report  or in the software, although COBYLA, UOBYQA, BOBYQA and LINCOA are all named by acronyms. Probably \"NEWUOA\" means \"NEW Unconstrained Optimization Algorithm\".\nThe NEWUOA software is distributed under The GNU Lesser General Public License (LGPL).","alt_names":[],"name":"NEWUOA","categories":["Optimization algorithms and methods"],"tag_line":"NEWUOA is a numerical optimization algorithm by Michael J. D. Powell."}}
,{"_index":"throwtable","_type":"algorithm","_id":"powell's-method","_score":0,"_source":{"description":"Powell's method, strictly Powell's conjugate direction method, is an algorithm proposed by Michael J. D. Powell for finding a local minimum of a function. The function need not be differentiable, and no derivatives are taken.\nThe function must be a real-valued function of a fixed number of real-valued inputs. The caller passes in the initial point. The caller also passes in a set of initial search vectors. Typically N search vectors are passed in which are simply the normals aligned to each axis.\nThe method minimises the function by a bi-directional search along each search vector, in turn. The new position can then be expressed as a linear combination of the search vectors. The new displacement vector becomes a new search vector, and is added to the end of the search vector list. Meanwhile, the search vector which contributed most to the new direction, i.e. the one which was most successful, is deleted from the search vector list. The algorithm iterates an arbitrary number of times until no significant improvement is made.\nThe method is useful for calculating the local minimum of a continuous but complex function, especially one without an underlying mathematical definition, because it is not necessary to take derivatives. The basic algorithm is simple; the complexity is in the linear searches along the search vectors, which can be achieved via Brent's method.","alt_names":["Powell's method","Interpolation methods","- Powell's method :","Powell s method Wikipedia the free encyclopedia","Powell's conjugate gradient descend method","Powell's method - Wikipedia, the free ...","http://en.wikipedia.org/wiki/Powell%27s_method"],"name":"Powell's method","categories":["All articles needing additional references","Articles needing additional references from August 2009","Optimization algorithms and methods"],"tag_line":"Powell's method, strictly Powell's conjugate direction method, is an algorithm proposed by Michael J. D. Powell for finding a local minimum of a function."}}
,{"_index":"throwtable","_type":"algorithm","_id":"apostolico–giancarlo-algorithm","_score":0,"_source":{"description":"In computer science, the Apostolico–Giancarlo algorithm is a variant of the Boyer–Moore string search algorithm, the basic application of which is searching for occurrences of a pattern  in a text . As with other comparison-based string searches, this is done by aligning  to a certain index of  and checking whether a match occurs at that index.  is then shifted relative to  according to the rules of the Boyer-Moore algorithm, and the process repeats until the end of  has been reached. Application of the Boyer-Moore shift rules often results in large chunks of the text being skipped entirely.\nWith regard to the shift operation, Apostolico-Giancarlo is exactly equivalent in functionality to Boyer-Moore. The utility of Apostolico-Giancarlo is to speed up the match-checking operation at any index. With Boyer-Moore, finding an occurrence of  in  requires that all  characters of  be explicitly matched. For certain patterns and texts, this is very inefficient - a simple example is when both pattern and text consist of the same repeated character, in which case Boyer-Moore runs in  where  is the length in characters of . Apostolico-Giancarlo speeds this up by recording the number of characters matched at the alignments of  in a table, which is combined with data gathered during the pre-processing of  to avoid redundant equality checking for sequences of characters that are known to match.","alt_names":[],"name":"Apostolico–Giancarlo algorithm","categories":["String matching algorithms"],"tag_line":"In computer science, the Apostolico–Giancarlo algorithm is a variant of the Boyer–Moore string search algorithm, the basic application of which is searching for occurrences of a pattern  in a text ."}}
,{"_index":"throwtable","_type":"algorithm","_id":"reactive-search-optimization","_score":0,"_source":{"description":"Reactive search optimization (RSO) defines local-search heuristics based on machine learning, a family of optimization algorithms based on the local search techniques. It refers to a class of heuristics that automatically adjust their working parameters during the optimization phase. RSO methods are at the basis of the Learning and Intelligent Optimization (LION) approach combining machine learning and optimization .","alt_names":["...more on Wikipedia about Reactive search","Reactive Search","Reactive Search Optimization","Reactive Search Optimization(RSO)","Reactive search","Reactive search optimization","Reactive search optimization - Wikipedia :: The free encyclopedia","Reactive search optimization - Wikipedia, the free encyclope...","Reactive search optimization - Wikipedia, the free encyclopedia","Reactive search optimization - Wikipedia, the free...","Reactive_search","Read More reactive search optimization wikipedia the free","Search Engine Optimization sem","What is the overview of Reactive search optimization","Wikipedia article Reactive Search Optimization","Wikipedia article Reactive search","Wikipedia article Reactive search optimization","Wikipedia entry for Reactive search optimization","eactive search optimization","en.wikipedia.org/...Reactive_search_optimization","http://en.wikipedia.org/wiki/Reactive_s ... timization","http://en.wikipedia.org/wiki/Reactive_se","http://en.wikipedia.org/wiki/Reactive_search_optimization","reactive search","reactive search optimization","reactive search optimization (RSO)"],"name":"Reactive search optimization","categories":["All articles with peacock terms","All articles with topics of unclear notability","All articles with unsourced statements","Articles with peacock terms from December 2014","Articles with topics of unclear notability from December 2014","Articles with unsourced statements from July 2013","Heuristics","Optimization algorithms and methods","Wikipedia articles with possible conflicts of interest from December 2014"],"tag_line":"Reactive search optimization (RSO) defines local-search heuristics based on machine learning, a family of optimization algorithms based on the local search techniques."}}
,{"_index":"throwtable","_type":"algorithm","_id":"mm-algorithm","_score":0,"_source":{"description":"The MM algorithm is an iterative optimization method which exploits the convexity of a function in order to find their maxima or minima. The MM stands for “Majorize-Minimization” or “Minorize-Maximization”, depending on whether the desired optimization is a maximization or a minimization. MM itself is not an algorithm, but a description of how to construct an optimization algorithm.\nThe EM algorithm can be treated as a special case of the MM algorithm. However, in the EM algorithm complex conditional expectation and extensive analytical skills are usually involved, while in the MM algorithm convexity and inequalities are our major focus, and it is relatively easier to understand and apply in most of the cases.","alt_names":[],"name":"MM algorithm","categories":["CS1 errors: invisible characters","Optimization algorithms and methods"],"tag_line":"The MM algorithm is an iterative optimization method which exploits the convexity of a function in order to find their maxima or minima."}}
,{"_index":"throwtable","_type":"algorithm","_id":"estimation-of-distribution-algorithm","_score":0,"_source":{"description":"Estimation of distribution algorithms (EDAs), sometimes called probabilistic model-building genetic algorithms (PMBGAs), are stochastic optimization methods that guide the search for the optimum by building and sampling explicit probabilistic models of promising candidate solutions. Optimization is viewed as a series of incremental updates of a probabilistic model, starting with the model encoding the uniform distribution over admissible solutions and ending with the model that generates only the global optima.\nEDAs belong to the class of evolutionary algorithms. The main difference between EDAs and most conventional evolutionary algorithms is that evolutionary algorithms generate new candidate solutions using an implicit distribution defined by one or more variation operators, whereas EDAs use an explicit probability distribution encoded by a Bayesian network, a multivariate normal distribution, or another model class. Similarly as other evolutionary algorithms, EDAs can be used to solve optimization problems defined over a number of representations from vectors to LISP style S expressions, and the quality of candidate solutions is often evaluated using one or more objective functions.\nThe general procedure of an EDA is outlined in the following:\nt = 0\ninitialize model M(0) to represent uniform distribution over admissible solutions\nwhile (termination criteria not met)\n\nP = generate N>0 candidate solutions by sampling M(t)\nF = evaluate all candidate solutions in P\nM(t+1) = adjust_model(P,F,M(t))\nt = t + 1\n\nUsing explicit probabilistic models in optimization allowed EDAs to feasibly solve optimization problems that were notoriously difficult for most conventional evolutionary algorithms and traditional optimization techniques, such as problems with high levels of epistasis. Nonetheless, the advantage of EDAs is also that these algorithms provide an optimization practitioner with a series of probabilistic models that reveal a lot of information about the problem being solved. This information can in turn be used to design problem-speciﬁc neighborhood operators for local search, to bias future runs of EDAs on a similar problem, or to create an efficient computational model of the problem.\nFor example, if the population is represented by bit strings of length 4, the EDA can represent the population of promising solution using a single vector of four probabilities (p1, p2, p3, p4) where each component of p defines the probability of that position being a 1. Using this probability vector it is possible to create an arbitrary number of candidate solutions.\nBetter-known EDAs include\nPopulation-based incremental learning (PBIL)\nHill Climbing with Learning (HCwL)\nCompact Genetic Algorithm (cGA)\nUnivariate Marginal Distribution Algorithm (UMDA)\nEstimation of Multivariate Normal Algorithm (EMNA)\nMutual Information Maximization for Input Clustering (MIMIC)\nBivariate Marginal Distribution Algorithm (BMDA)\nExtended Compact Genetic Algorithm (ECGA)\nBayesian Optimization Algorithm (BOA)\nEstimation of Bayesian Networks Algorithm (EBNA)\nStochastic hill climbing with learning by vectors of normal distributions (SHCLVND)\nReal-coded PBIL\nProbabilistic Incremental Program Evolution (PIPE)\nEstimation of Gaussian Networks Algorithm (EGNA)","alt_names":["- Estimation of distribution algorithm :","...Wikipedia Algorithme à estimation de distribution","Algorithme ? estimation de distribution - Wikip?dia","Algorithme à estimation de distribution","Algorithme à estimation de distribution - Wikipédia","Algoritmo de estimaci?n de distribuci?n - Wikipedia","Algoritmo de estimación de distribución","Algoritmo de estimación de distribución - Wikipedia, la ...","Algoritmos de estimação de distribuição","EDAs' context","Estimation of Distribution Algorithm","Estimation of Distribution Algorithms","Estimation of Distribution Algorithms or EDAs","Estimation of distribution algorithm","Estimation of distribution algorithm - Wikipedia, the free","Estimation of distribution algorithm - Wikipedia, the free ...","Estimation of distribution algorithm - Wikipedia, the free ... ...","Estimation of distribution algorithm - Wikipedia, the free encyclope","Estimation of distribution algorithm - Wikipedia, the free encyclopedia","Estimation of distribution algorithms","Estimation_of_distribution_algorithm","Learn about Estimation of distribution algorithm>>>","Wikipedia article Algorithme à estimation de distribution","Wikipedia article Estimation of Distribution Algorithm","Wikipedia article Estimation of Distribution Algorithms","Wikipedia article Estimation of distribution algorithm","Wikipedia article on Algoritmo de estimación de distribución","Wikipedia article on Estimation of distribution algorithm","Wikipedia entry for Estimation of distribution algorithm","Wikipedia sur Algorithme à estimation de distribution","Wikipedia sur Algorithmes à estimation de distribution","Wikipedia:Estimation_of_Distribution_Algorithms","algorithmes à estimation de distribution","artículo de Wikipedia Algoritmo de Estimacion de Distribucion","artículo de Wikipedia Algoritmo de Estimación de Distribución","artículo de Wikipedia Algoritmo de estimacion de distribucion","artículo de Wikipedia Algoritmo de estimación de distribución","en.wikipedia.org/wiki/Estimation_of_distribution_algorithm","es:Algoritmo de estimación de distribución","estimation of distribution algorithm","estimation of distribution algorithm - Wikipedia, the free ...","estimation of distribution algorithms","fr:Algorithme à estimation de distribution","http://en.wikipedia.org/wiki/Estimation_of_distribution_algorithm","http://es.wikipedia.org/wiki/Algoritmo_de_Estim...","http://es.wikipedia.org/wiki/Algoritmo_de_estimaci%C3%B3n_de_distribuci","http://fr.wikipedia.org/wiki/Algorithme_%C3%A0_estimation_de_distribution","kilr0y"],"name":"Estimation of distribution algorithm","categories":["All Wikipedia articles needing context","All articles covered by WikiProject Wikify","All articles needing additional references","All articles needing references cleanup","All pages needing cleanup","Articles covered by WikiProject Wikify from September 2009","Articles needing additional references from January 2008","Evolutionary computation","Stochastic algorithms","Wikipedia articles needing context from September 2009","Wikipedia introduction cleanup from September 2009","Wikipedia references cleanup from September 2009"],"tag_line":"Estimation of distribution algorithms (EDAs), sometimes called probabilistic model-building genetic algorithms (PMBGAs), are stochastic optimization methods that guide the search for the optimum by building and sampling explicit probabilistic models of promising candidate solutions."}}
,{"_index":"throwtable","_type":"algorithm","_id":"stochastic-diffusion-search","_score":0,"_source":{"description":"Stochastic diffusion search (SDS) was first described in 1989 as a population-based, pattern-matching algorithm [Bishop, 1989]. It belongs to a family of swarm intelligence and naturally inspired search and optimisation algorithms which includes ant colony optimization, particle swarm optimization and genetic algorithms. Unlike stigmergetic communication employed in ant colony optimization, which is based on modification of the physical properties of a simulated environment, SDS uses a form of direct (one-to-one) communication between the agents similar to the tandem calling mechanism employed by one species of ants, Leptothorax acervorum.\nIn SDS agents perform cheap, partial evaluations of a hypothesis (a candidate solution to the search problem). They then share information about hypotheses (diffusion of information) through direct one-to-one communication. As a result of the diffusion mechanism, high-quality solutions can be identified from clusters of agents with the same hypothesis. The operation of SDS is most easily understood by means of a simple analogy – The Restaurant Game.","alt_names":["Stochastic Diffusion Search","Stochastic Diffusion Search - Wikipedia, the free encyclopedia","Stochastic diffusion search","Stochastic diffusion search - Wikipedia, the free encyclopedia","Stochastic_diffusion_search","The Restaurant Game","What is analysis of Stochastic Diffusion Search?","Wikipedia article Stochastic diffusion search","Wikipedia article on Stochastic diffusion search","Wikipedia entry for Stochastic diffusion search","http://en.wikipedia.org/wiki/Stochastic_diffusion_search","stochastic diffusion search","stochastic diffusion search algorithms","yago-res:Stochastic diffusion search","隨機散播搜尋法"],"name":"Stochastic diffusion search","categories":["Artificial intelligence","Stochastic algorithms"],"tag_line":"Stochastic diffusion search (SDS) was first described in 1989 as a population-based, pattern-matching algorithm [Bishop, 1989]."}}
,{"_index":"throwtable","_type":"algorithm","_id":"monte-carlo-algorithm","_score":0,"_source":{"description":"In computing, a Monte Carlo algorithm is a randomized algorithm whose running time is deterministic, but whose output may be incorrect with a certain (typically small) probability.\nThe related class of Las Vegas algorithms are also randomized, but in a different way: they take an amount of time that varies randomly, but always produce the correct answer. A Monte Carlo algorithm can be converted into a Las Vegas algorithm whenever there exists a procedure to verify that the output produced by the algorithm is indeed correct. If so, then the resulting Las Vegas algorithm is merely to repeatedly run the Monte Carlo algorithm until one of the runs produces an output that can be verified to be correct.\nThe name refers to the grand casino in the Principality of Monaco at Monte Carlo, which is well-known around the world as an icon of gambling.\n\n","alt_names":[],"name":"Monte Carlo algorithm","categories":["All articles lacking in-text citations","Articles lacking in-text citations from August 2011","Randomized algorithms"],"tag_line":"In computing, a Monte Carlo algorithm is a randomized algorithm whose running time is deterministic, but whose output may be incorrect with a certain (typically small) probability."}}
,{"_index":"throwtable","_type":"algorithm","_id":"stochastic-computing","_score":0,"_source":{"description":"Stochastic computing is a collection of techniques that represent continuous values by streams of random bits. Complex computations can then be computed by simple bit-wise operations on the streams.\nDespite the similarity in their names, stochastic computing is distinct from the study of randomized algorithms.","alt_names":[],"name":"Stochastic computing","categories":["All articles with unsourced statements","Articles with unsourced statements from October 2014","History of computing hardware","Models of computation","Stochastic algorithms"],"tag_line":"Stochastic computing is a collection of techniques that represent continuous values by streams of random bits."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bht-algorithm","_score":0,"_source":{"description":"The BHT algorithm is a quantum algorithm that solves the collision problem. In this problem, one is given n and an r-to-1 function  and needs to find two inputs that f maps to the same output. The BHT algorithm only makes  queries to f, which matches the lower bound of  in the black box model.\nThe algorithm was discovered by Brassard, Hoyer, and Tapp in 1997. It uses Grover's algorithm, which was discovered in the previous year.","alt_names":[],"name":"BHT algorithm","categories":["Quantum algorithms"],"tag_line":"The BHT algorithm is a quantum algorithm that solves the collision problem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"zhu–takaoka-string-matching-algorithm","_score":0,"_source":{"description":"In computer science, the Zhu–Takaoka string matching algorithm is a variant of the Boyer–Moore string search algorithm. It uses two consecutive text characters to compute the bad character shift. It is faster when the alphabet or pattern is small, but the skip table grows quickly, slowing the pre-processing phase.","alt_names":[],"name":"Zhu–Takaoka string matching algorithm","categories":["String matching algorithms"],"tag_line":"In computer science, the Zhu–Takaoka string matching algorithm is a variant of the Boyer–Moore string search algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"brute-force-search","_score":0,"_source":{"description":"In computer science, brute-force search or exhaustive search, also known as generate and test, is a very general problem-solving technique that consists of systematically enumerating all possible candidates for the solution and checking whether each candidate satisfies the problem's statement.\nA brute-force algorithm to find the divisors of a natural number n would enumerate all integers from 1 to n, and check whether each of them divides n without remainder. A brute-force approach for the eight queens puzzle would examine all possible arrangements of 8 pieces on the 64-square chessboard, and, for each arrangement, check whether each (queen) piece can attack any other.\nWhile a brute-force search is simple to implement, and will always find a solution if it exists, its cost is proportional to the number of candidate solutions – which in many practical problems tends to grow very quickly as the size of the problem increases. Therefore, brute-force search is typically used when the problem size is limited, or when there are problem-specific heuristics that can be used to reduce the set of candidate solutions to a manageable size. The method is also used when the simplicity of implementation is more important than speed.\nThis is the case, for example, in critical applications where any errors in the algorithm would have very serious consequences; or when using a computer to prove a mathematical theorem. Brute-force search is also useful as a baseline method when benchmarking other algorithms or metaheuristics. Indeed, brute-force search can be viewed as the simplest metaheuristic. Brute force search should not be confused with backtracking, where large sets of solutions can be discarded without being explicitly enumerated (as in the textbook computer solution to the eight queens problem above). The brute-force method for finding an item in a table — namely, check all entries of the latter, sequentially — is called linear search.","alt_names":["подбора","brut force","brute force algorithm","brute-forced","Brute Force Method","recherche exhaustive","брута","“brute force”","Brute-Force-Methode","брутфорс","Brute-Force-Angriffe","brute force metode","Brute-Force","перебор","brute force search","&#8220;brute force&#8221;","&leftarrow;","'Brute-Force Search'","'Brute-force attack'","(брутфорсы)","- Brute force search :","- Brute-force :","- Brute-force search :","- Exhaustive search :","-> Read the article about 'Brute-force search'","... mehr zum Begriff 'Brute-Force-Angriff' bei Wikipedia","...Wikipedia Força bruta","...Wikipedia Metodo forza bruta","...mehr auf Wikipedia über Brute-Force-Methode","...more on Wikipedia about Brute-force search","1 Implementing the brute-force search","1.1 Basic algorithm","2 Combinatorial explosion","3 Speeding up brute-force searches","4 Reordering the search space","4Примечания","5 Alternatives to brute force search","6 In cryptography",">> Brute-Force","Attacco a forza bruta","Ausprobieren von derartig vielen Möglichkeiten","B?squeda de fuerza bruta - Wikipedia, la enciclopedia","BRUTE FORCE ATTACK","BRUTE-FORCE","BRUTE-FORCE METHOD","Brut-Force","Brut-Force-Attacken","Brut-Force-Methode","Brut-Forcing","Brutal Force","Brute Force - Wikipedia","Brute Force Algorithm","Brute Force Angriff","Brute Force Attacken","Brute Force Attaken","Brute Force Hacking","Brute Force Idee","Brute Force Methode","Brute Force Methode – Wikipedia","Brute Force Password-List","Brute Force Search","Brute Force bedeutet hier also simples Ausprobieren von","Brute Force search","Brute Force – Wikipedia","Brute Force-Algorithmus","Brute Force-Attacken","Brute Force-Methode","Brute Force/Exhaustion","Brute Forcen","Brute Forces","Brute Froce Wikipedia","Brute force - Wikipedia, den frie encykl...","Brute force search","Brute force search Wikipedia the free encyclopedia","Brute force search Wikipedia the free encyclopedia - result","Brute force search; it is used under the","Brute force searches","Brute force(força bruta)","Brute-Force - Wikipedia","Brute-Force Attacke","Brute-Force Attacken","Brute-Force Methode","Brute-Force Methoden","Brute-Force Search","Brute-Force Wikipedia","Brute-Force-Algorithmus","Brute-Force-Angriffen","Brute-Force-Attacke","Brute-Force-Attacke.","Brute-Force-Attacken","Brute-Force-Method","Brute-Force-Methode - Wikipedia","Brute-Force-Methode ? Wikipedia","Brute-Force-Methode @ Wikipedia","Brute-Force-Methode in","Brute-Force-Methode â€“ Wikipedia","Brute-Force-Methode – Wikipedia","Brute-Force-Methode)","Brute-Force-Methode-Info","Brute-Force-Methode:","Brute-Force-Methoden","Brute-Force-Prevention","Brute-Force-Suche","Brute-Force-Taktik","Brute-Force-Technik","Brute-Force-Versuche","Brute-Force-Versuchen","Brute-Force-related","Brute-Forcen","Brute-force Methode","Brute-force Search","Brute-force keyspace search","Brute-force metoda","Brute-force search","Brute-force search - Wikipedia :: The free encyclopedia","Brute-force search - Wikipedia, the free encyclopedia","Brute-force search - Wikipedia, the free encyclopedia ...","Brute-force search from Wikipedia","Brute-force searches","Brute-force-Attacke","Brute-force-Methode","Brute-force_search","BruteForce Attacke","BruteForce-Algorithmus","BruteForce-Angriffe","BruteForceAttacken","BruteForcing","Brute_force_search","Bruteforce-Attacke","Bruteforce-Attacken","Bruteforcen","Bruteforcer","Bruteforces","Brutforce","Búsqueda de fuerza bruta","Búsqueda de fuerza bruta - Wikipedia, la enciclopedia libre","Die Brute-Force-Methode (von engl. brute = animalisch","EKS (exhaustive key search)","Em ciência da computação, força bruta (ou busca","Erklärung zu Brut-Force","Exhaustive search","FORZA BRUTA","Force-Methode","Forza Bruta","Força bruta","Força bruta - Wikipédia, a enciclopédia livre","Força bruta – Wikipédia, a enciclopédia livre","Força-bruta","Fuerza bruto","Hier kriegst du Brute Force","Hrubou silou","Informationen zur Brute-Force-Methode","Informationen über Brute Force bei Wikipedia","Kryptologie","La Fuerza Bruta","Learn about Brute-force search>>>","METODO FORCE BRUTE","Metodo forza bruta","Metodo forza bruta - Wikipedia","Metodo forza bruta. Da Wikipedia, l'enciclopedia libera","PT-X","Pesquisa com Força Bruta na Wikipedia","Read More bruteforce search wikipedia the free encyclopedia","Recherche exhaustive","Recherche exhaustive - Wikipédia","Recherche exhaustive - Wikipédia http://fr.wikipedia.org/wiki","Ricerca esaustiva","Speeding up brute ...","Speeding up brute-force searches","Stichwort Bruteforce-Attacke","Thumbnail of screenshot of Brute-force search - Wikipedia","Vicky.","View Brute-force on Wikipedia","Was ist Brute-Force?","Wiki Brute Force","Wikiartikel)","Wikipedia (Força bruta)","Wikipedia Artikel zum Thema Brute-Force","Wikipedia article Brute force search","Wikipedia article Brute-Force-Methode","Wikipedia article Brute-force","Wikipedia article Brute-force search","Wikipedia article Exhaustive search","Wikipedia article Força bruta","Wikipedia article Metodo forza bruta","Wikipedia article on Búsqueda de fuerza bruta","Wikipedia article Полный перебор","Wikipedia article כוח גס","Wikipedia article بحث شامل","Wikipedia entry for Brute-force search","Wikipedia l'articolo Attacco a forza bruta","Wikipedia's page on Brute-force Search techniques","Wikipedia-Artikel Brute Force","Wikipedia-Artikel Brute force","Wikipedia-Artikel Brute-Force","Wikipedia-Artikel Brute-Force-Methode","Wikipedia-Seite zu 'Brute Force'","Wikipedia-Seite zu 'Brute-Force'","Wikipedia-Seite zu 'Brute-Force-Methode'","Wikipedia.de zum Thema Brutforce","Wikipedia: Brute-Force","Wikipedia: Brute-Force Search","Wikipedia: Brute-Force-Methode","Wikipedia: Brute-force Search","Wikipedia:Brute-force search","Wikipediaで「力まかせ探索」を調べる","Wikipédia artigo Força Bruta","Wikipédia artigo Força-bruta","Wörterbuch maschinell ausprobieren","Wörterbuch-Angriffe","algoritmo di brute force","algoritmo di forza bruta","ar:بحث شامل","article Brute-force","artigo da Wikipédia Força bruta","artículo de Wikipedia Busqueda de fuerza bruta","artículo de Wikipedia Búsqueda de fuerza bruta","astig-lakas ng paghahanap","ataque por força bruta","attacchi a forza bruta","attacchi brute-force","attacchi dizionario di forza bruta","attacco Brute Force","attacco a forza bruta","attacco brute force (forza bruta)","attacco brute-force","attachi a forza bruta","ausprobieren","brut-forçable","brutare","brute force approach","brute force computational techniques","brute force computing","brute force enumeration","brute force linear search","brute force searches","brute force searching","brute force string search","brute force útokom","brute force útokům","brute force атака","brute force-Attacke","brute forcella","brute forcen","brute force방식","brute-force","brute-force algorithms","brute-force approach","brute-force method","brute-force my way through the problem space","brute-force search","brute-force search strategies","brute-force searches","brute-force searching","brute-force voting","brute-force vyhledávání","brute-force-Ansatz","brute-force-Methodik","brute-force.","brute-forces","brute-forcing it","bruteforcer","busca de força bruta","búsqueda de fuerza bruta","búsqueda mediante fuerza bruta","cerca fer força bruta","cerca per força bruta","check all of them","color=#004b91Brute Force Search","cs:Brute force","cs:Řešení hrubou silou","da:Brute force","dann dieses","de.wikipedia.org/wiki/Brute-Force-Methode","de:Brute-Force-Methode","detailed writeup","durchprobiert","en.wikipedia.org/wiki/Brute-force_search","en:Brute-force search","en:brute-force","erca per força bruta","erraten","erschöpfende Suche","es:Búsqueda de fuerza bruta","esaustiva","esse método","exhaustive enumeration","exhaustive searches","forza bruta !","forza bruta di ricerca","força-bruta","for�a bruta","fr:Recherche exhaustive","he.wikipedia.org/wiki/כוח_גס","he:כוח גס","http://cs.wikipedia.org/wiki/Brute_force","http://de.wikiped...ce-Methode","http://de.wikipedia....e-Force-Methode","http://de.wikipedia....iki/Brute_Force","http://de.wikipedia....iki/Brute_force","http://de.wikipedia.org/---/Brute-Force-Methode","http://de.wikipedia.org/wiki/Br ute-Force","http://de.wikipedia.org/wiki/Br ute_force","http://de.wikipedia.org/wiki/Br...hode","http://de.wikipedia.org/wiki/Brute-Force","http://de.wikipedia.org/wiki/Brute-Force-Method","http://de.wikipedia.org/wiki/Brute-Force-Methode","http://de.wikipedia.org/wiki/Brute-Force…","http://de.wikipedia.org/wiki/Brute_Force","http://de.wikipedia.org/wiki/Brute_Force]BruteForce-Verfahren","http://de.wikipedia.org/wiki/Brute_force","http://de.wikipedia.org/wiki/Brute_force#Informatik","http://de.wikipedia.org/wiki/Brute_force#Kryptologie)","http://de.wikipedia.org/wiki/Brute_force~~V","http://en.wikipedia....te-force_search","http://en.wikipedia.org/wiki/Brute-","http://en.wikipedia.org/wiki/Brute-force","http://en.wikipedia.org/wiki/Brute-force_sear...","http://en.wikipedia.org/wiki/Brute-force_search","http://en.wikipedia.org/wiki/Brute-force_searchを","http://en.wikipedia.org/wiki/Brute-force_…","http://en.wikipedia.org/wiki/Brute-fuerzosearch","http://en.wikipedia.org/wiki/Brute_force_search","http://en.wikipedia.org/wiki/Exhaustive_search","http://es.wikipedia.org/wiki/B%C3%BAsqueda_de_fuerza_bruta","http://fr.wikipedia.org/wiki/Recherche_exhaustive","http://he.wikipedia.org/wiki/%D7%9B%...7_","http://he.wikipedia.org/wiki/כוח_גס","http://is.wikipedia.org/wiki/Jar%C3%B0","http://it.wikipedia.org/wiki/Attacco_a_forza_bruta","http://it.wikipedia.org/wiki/Brute_force","http://it.wikipedia.org/wiki/Metodo...zza_informatica","http://it.wikipedia.org/wiki/Metodo_forza_bruta","http://it.wikipedia.org/wiki/Metodo_forz…","http://it.wikipedia.org/wiki/Ricerca_esaustiva","http://pt.wikipedia.org/wiki/For%C3%A7a_bruta","http://pt.wikipedia.org/wiki/Força_bruta","http://ru.wikipedia....тод_грубой_силы","http://ru.wikipedia.org/wiki/Brute_force","http://ru.wikipedia.org/wiki/Brute_force...","http://ru.wikipedia.org/wiki/Метод_грубой_силы","http://ru.wikipedia.org/wiki/Полный_пере...","http://ru.wikipedia.org/wiki/Полный_перебор","is:Jarðýtuáras","it:Metodo forza bruta","ja:力まかせ探索","klick hier für mehr Info","l'article de Wikipédia Recherche exhaustive","la búsqueda de fuerza bruta","la force brute de recherche","la fuerza bruta de la búsqueda","linear (item-by-item) search","man wikipedia","mein freund Wiki","metodo Brute Force","metodo a forza bruta","metodo basato sulla forza bruta","metodo brute-force","metodo della forza bruta","metodo forza bruta","metodo “forza bruta”","métodos de força bruta","naive string search","naïve solution","pencarian brute force","per tentativi","pesquisa exaustiva","recherche par force brute","ricerca di forza bruta","ricerca in forza bruta","ru.wikipedia.org/wiki/Полный_перебор","ru:Полный перебор","rute force searches","siehe allwissende Müllhalde","tecniche brute-force","the brute force method.","ttp://de.wikipedia.org/wiki/Brute-Force-Methode","tìm kiếm brute force-và","und so wird es gemacht","vean esta página cucha de Wikipedia para más","w:Exhaustive search","w:כוח גס","was ist brute force überhaupt","wyszukiwania brute-force","xhaustive enumeration","xhaustive search i","«brute force» (força bruta)","«методе грубой силы»","Ð¿Ð¾Ð²Ð½Ð¸Ð¹ Ð¿ÐµÑ€ÐµÐ±Ñ–Ñ","ÐŸÐ¾Ð»Ð½Ñ‹Ð¹ Ð¿ÐµÑ€ÐµÐ±Ð¾Ñ€ â","Řešení hrubou silou","Řešení hrubou silou - Wikipedie","Атака грубой силой","Атака полного перебора","Брутфорс","Брутфорс (определение)","Брутфорс:","Википедии статью Brute force","Википедии статью Метод грубой силы","Википедии статью Полный перебор","Интересная статья - по перебору паролей","Клацкать тут","Мдааа....","Метод грубой силы","Метод грубой силы — Википедия","Методы оптимизации полного ...","Полный перебор","Полный перебор — Википедия","Полный_перебор","Пример продолжительности ...","Статья . Википедия.Метод полного перебора","атака грубой силой","атаке «грубой силы»","атаку грубой си-","брут","брут-форса","брутить","брутофорс","брутфорс-атакой","брутфорса","брутфорсер","брутфорсом","брут‑форса","грубого перебора","грубой силы поиска","грубіянскай сілы","лобовая атака","метод грубой силы","метод грубої сили","метода грубой силы","методе «грубой силы»","неинформативный поиск","олный перебор (или метод «грубой силы»)","перебором поиска","повним перебором","подбирают","полного перебора","полный перебор","полный перебор паролей","прямого перебора","силовой атаки","сколько времени","хттп://де.википедиа.орг/вики/Бруте_форце","ברוט פורס","התקפת כח גס","ויקיפדיה - 'כוח גס'","חיפוש גס","כוח גס","כוח גס (Brute Force). הוא חיפוש ממצה של","כוח גס (Bruteforce)","כוח גס – ויקיפדיה","כוח-גס","البحث الشامل","بحث شامل","بروتي فورچي","เดรัจฉาน ค้นหา แรง-และ","“brute force algorithm”","“brute force”-Attacke","“força bruta”","ウィキペディアの記事 力まかせ探索","力ずくの検索","力まかせ探索","力まかせ探索 - Wikipedia","力まかせ探索-wikipedia","力まかせ探索とは？ (Wikipediaへのリンク)","力まかせ探索とバックトラッキングの違い","力任せの方法","力任せ探索","強力搜索","强力搜索","짐승 - 강제로 검색과"],"name":"Brute-force search","categories":["All articles needing additional references","Articles needing additional references from February 2008","Search algorithms"],"tag_line":"In computer science, brute-force search or exhaustive search, also known as generate and test, is a very general problem-solving technique that consists of systematically enumerating all possible candidates for the solution and checking whether each candidate satisfies the problem's statement."}}
,{"_index":"throwtable","_type":"algorithm","_id":"beam-search","_score":0,"_source":{"description":"In computer science, beam search is a heuristic search algorithm that explores a graph by expanding the most promising node in a limited set. Beam search is an optimization of best-first search that reduces its memory requirements. Best-first search is a graph search which orders all partial solutions (states) according to some heuristic which attempts to predict how close a partial solution is to a complete solution (goal state). But in beam search, only a predetermined number of best partial solutions are kept as candidates.\nBeam search uses breadth-first search to build its search tree. At each level of the tree, it generates all successors of the states at the current level, sorting them in increasing order of heuristic cost. However, it only stores a predetermined number of best states at each level (called the beam width). Only those states are expanded next. The greater the beam width, the fewer states are pruned. With an infinite beam width, no states are pruned and beam search is identical to breadth-first search. The beam width bounds the memory required to perform the search. Since a goal state could potentially be pruned, beam search sacrifices completeness (the guarantee that an algorithm will terminate with a solution, if one exists). Beam search is not optimal (that is, there is no guarantee that it will find the best solution). It returns the first solution found.\nThe beam width can either be fixed or variable. One approach that uses a variable beam width starts with the width at a minimum. If no solution is found, the beam is widened and the procedure is repeated.","alt_names":["- Beam search :","-> Read more about Beam search","Beam Search","Beam Search Wiki","Beam search","Beam search - Wikipedia :: The free encyclopedia","Beam search - Wikipedia, the free encyclopedia","Beam search - Wikipedia, the free encyclopedia .","Beam search; it is used under the","Beam_search","Important Algorithms: Beam Search","Source Wikipedia.org Arcticle - Beam search","What is name of Beam search","Wikipedia (Beam search)","Wikipedia article ''Beam search''","Wikipedia article Beam search","Wikipedia article on Beam search","Wikipedia entry for Beam search","article Beam search","beam search","beam-search","en.wikipedia.org/Beam_search","en: Beam search","http://en.wikipedia.org/wiki/Beam_search","local beam search","p://en.wikipedia.org/wiki/Beam_search"],"name":"Beam search","categories":["Search algorithms"],"tag_line":"In computer science, beam search is a heuristic search algorithm that explores a graph by expanding the most promising node in a limited set."}}
,{"_index":"throwtable","_type":"algorithm","_id":"list-scheduling","_score":0,"_source":{"description":"The basic idea of list scheduling is to make an ordered list of processes by assigning them some priorities, and then repeatedly execute the following two steps until a valid schedule is obtained :\nSelect from the list, the process with the highest priority for scheduling.\nSelect a resource to accommodate this process.\nIf no resource can be found, we select the next process in the list.\nThe priorities are determined statically before scheduling process begins. The first step chooses the process with the highest priority, the second step selects the best possible resource. Some known list scheduling strategies are :\nHighest level first algorithm or HLF\nLongest path algorithm or LP\nLongest processing time\nCritical path method\nHeterogeneous Earliest Finish Time or HEFT. For the case heterogeneous workers.","alt_names":["...more on Wikipedia about List scheduling","List Scheduling","List scheduling","List scheduling - Wikipedia, the free encyclopedia","Wikipedia (List scheduling)","Wikipedia article ''List scheduling''","Wikipedia article List scheduling","Wikipedia article on List scheduling","en:List scheduling","http://en.wikipedia.org/wiki/List_schedu","http://en.wikipedia.org/wiki/List_scheduling","yago-res:List scheduling"],"name":"List scheduling","categories":["Pages using citations with accessdate and no URL","Scheduling algorithms"],"tag_line":"The basic idea of list scheduling is to make an ordered list of processes by assigning them some priorities, and then repeatedly execute the following two steps until a valid schedule is obtained :\nSelect from the list, the process with the highest priority for scheduling."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cdmf","_score":0,"_source":{"description":"In cryptography, CDMF (Commercial Data Masking Facility) is an algorithm developed at IBM in 1992 to reduce the security strength of the 56-bit DES cipher to that of 40-bit encryption, at the time a requirement of U.S. restrictions on export of cryptography. Rather than a separate cipher from DES, CDMF constitutes a key generation algorithm, called key shortening. It is one of the cryptographic algorithms supported by S-HTTP.","alt_names":["- CDMF :","CDMF","CDMF (en)","CDMF - Wikipedia, the free encyclopedia","CDMF Related Content:","CDMF; it is used under the","Cdmf","What is algorithm of Commercial Data Masking Facility","Wikipedia article CDMF","Wikipedia article on CDMF","Wikipedia entry for CDMF","http://en.wikipedia.org/wiki/CDMF","yago-res:CDMF"],"name":"CDMF","categories":["All stub articles","Block ciphers","Cryptographic algorithms","Cryptography stubs","Data Encryption Standard","Key management"],"tag_line":"In cryptography, CDMF (Commercial Data Masking Facility) is an algorithm developed at IBM in 1992 to reduce the security strength of the 56-bit DES cipher to that of 40-bit encryption, at the time a requirement of U.S. restrictions on export of cryptography."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bach's-algorithm","_score":0,"_source":{"description":"Bach's algorithm is a probabilistic polynomial time algorithm for generating random numbers along with their factorization, named after its discoverer, Eric Bach. It is of interest because no algorithm is known that efficiently factors numbers, so the straightforward method, namely generating a random number and then factoring it, is impractical.\nThe algorithm performs, in expectation, O(log n) primality tests.\nA simpler, but less efficient algorithm (performing, in expectation, O(log2 n) primality tests), is known and is due to Adam Kalai","alt_names":["Bach's algorithm","...more on Wikipedia about Bach's algorithm","Bach&#39;s algorithm - Wikipedia, the free encyclopedia","Bach's algorithm - Wikipedia :: The free encyclopedia","Bach's algorithm - Wikipedia, the free ...","Bach's algorithm - Wikipedia, the free encyclopedia","Bach's algorithm; it is used under the","N 2 < x ≤ N","Wikipedia article Bach algorithm","http://en.wikipedia.org/wiki/Bach%27s_algorithm","http://en.wikipedia.org/wiki/Bach_algorithm"],"name":"Bach's algorithm","categories":["Cryptographic algorithms"],"tag_line":"Bach's algorithm is a probabilistic polynomial time algorithm for generating random numbers along with their factorization, named after its discoverer, Eric Bach."}}
,{"_index":"throwtable","_type":"algorithm","_id":"szymański's-algorithm","_score":0,"_source":{"description":"Szymanski's Mutual Exclusion Algorithm is a mutual exclusion algorithm devised by computer scientist Dr. Boleslaw Szymanski, which has many favorable properties including linear wait, and which extension  solved the open problem posted by Leslie Lamport whether there is an algorithm with a constant number of communication bits per process that satisfies every reasonable fairness and failure-tolerance requirement that Lamport conceived of (Lamport's solution used n factorial communication variables vs. Szymanski's 5).","alt_names":[],"name":"Szymański's algorithm","categories":["All stub articles","Computer science stubs","Concurrency control algorithms"],"tag_line":"Szymanski's Mutual Exclusion Algorithm is a mutual exclusion algorithm devised by computer scientist Dr. Boleslaw Szymanski, which has many favorable properties including linear wait, and which extension  solved the open problem posted by Leslie Lamport whether there is an algorithm with a constant number of communication bits per process that satisfies every reasonable fairness and failure-tolerance requirement that Lamport conceived of (Lamport's solution used n factorial communication variables vs. Szymanski's 5)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rainbow-table","_score":0,"_source":{"description":"A rainbow table is a precomputed table for reversing cryptographic hash functions, usually for cracking password hashes. Tables are usually used in recovering a plaintext password up to a certain length consisting of a limited set of characters. It is a practical example of a space/time trade-off, using less computer processing time and more storage than a brute-force attack which calculates a hash on every attempt, but more processing time and less storage than a simple lookup table with one entry per hash. Use of a key derivation function that employs a salt makes this attack infeasible.\nRainbow tables are an application of an earlier, simpler algorithm by Martin Hellman.\n\n","alt_names":["first Google result","precomputation attacks","http://en.wikipedia.org/wiki/Rainbow_table","Rainbow-Tables","Rainbow Tables","% Http://en.wikipedia.org/wiki/Rainbow 5Ftable","'porodice duginih tabela'","'rainbow tables'","(rainbow википедия)","- Rainbow table :","- Rainbow tables :","-Tabelle vor den Angriffen des Regenbogens","...Wikipedia Philippe Oechslin","...Wikipedia Table arc-en-ciel","...mehr auf Wikipedia über Rainbow Table","...more on Wikipedia about Rainbow table","1 Precomputed hash chains","2 Rainbow tables","3 Defense against rainbow tables",": http://en.wikipedia.org/wiki/Rainbow_table",":http://en.wikipedia.org/wiki/Rainbow_table","Actually, you can reverse it, if you're","Albo...","As far as passwords go, this","Atak z użyciem tęczowych tablic - wikipedia","DO łamania WPA2","Defense against rainbow tables","Duga Tablica","Een rainbow table","Hash chains","Hier meer over Rainbow tables","Information about Rainbow Tables","Las tablas Arcoiris","MD5 hash with rainbow tables,","MD5 rainbow tables","Mesas de Arco iris","Mesas de Arco-íris","More on Rainbow Tables here","NEPOSOLJENI HEŠ","Opaco","Opis ogólny Rainbow Tables","Password Security: Rainbow Tables","Pearl\\'s Rainbow Key West","Philippe Oechslin","Philippe Oechslin auteur de RainbowCrack","Raibow Table","RainBowTabels...","RainboW Tables","Rainbow Angriffe","Rainbow Attack","Rainbow Cracking","Rainbow Cuadro","Rainbow Tabell","Rainbow Tabellen","Rainbow Table","Rainbow Table - Wikipedia, The Free Encyclopedia","Rainbow Table ? Wikipedia","Rainbow Table attack","Rainbow Table attacks","Rainbow Table ها","Rainbow Table – Wikipedia","Rainbow Table-Attacken","Rainbow Table-Attacken,","Rainbow Table-Attacken.","Rainbow Table; it is used under the","Rainbow Table?","Rainbow Tables (Wiki)","Rainbow Tables (Wikipedia)","Rainbow Tables (wikipedia en)","Rainbow Tables (“Tabelelor Curcubeu”)","Rainbow Tables - Cracking Passwords","Rainbow Tables - Wikipedia","Rainbow Tables Wikipedia Entry","Rainbow Tables method","Rainbow Tables,","Rainbow Tables.","Rainbow Tables?","Rainbow Tabulka","Rainbow aanslagen","Rainbow angreb","Rainbow attack","Rainbow attacks","Rainbow bảng,","Rainbow cracking","Rainbow tabelama","Rainbow tabele","Rainbow tabeli","Rainbow tabellen","Rainbow tabeller","Rainbow table","Rainbow table (tecnica di crypto analisi)","Rainbow table (time-efficient recovery of hashed passwords","Rainbow table - Wikipedia","Rainbow table - Wikipedia :: The free encyclopedia","Rainbow table - Wikipedia, the free encyclope...","Rainbow table - Wikipedia, the free encyclopedia","Rainbow table - Wikipedia, the free encyclopedia:","Rainbow table @ wiki (defense rész)","Rainbow table Wikipedia the free encyclopedia","Rainbow table in Wikipedia","Rainbow table method","Rainbow table was implied for testing 4gb usage","Rainbow table – Wikipedia, the free encyclopedia","Rainbow table.","Rainbow table: Common uses","Rainbow table: Defense against rainbow tables","Rainbow table: Example","Rainbow table; it is used under the","Rainbow tables","Rainbow tables @ Wikipedia","Rainbow tables for LM hashes","Rainbow tables in Wikipedia","Rainbow tables!","Rainbow tables.","Rainbow tabulky","Rainbow tafel","Rainbow taulukot","Rainbow атака","Rainbow таблиц,","Rainbow таблица","Rainbow таблицы","Rainbow таблицы,","Rainbow таблицы.","Rainbow ตาราง","Rainbow-Angriff","Rainbow-Tabelle","Rainbow-Tabelle Angriffe","Rainbow-Tabellen","Rainbow-Tabellen,","Rainbow-Table","Rainbow-Table-","Rainbow-Tales","Rainbow-tabellen","Rainbow-table","Rainbow-tables","Rainbow-таблицей","Rainbow-таблицы","RainbowTables","Rainbow_Table","Rainbow_Tables","Rainbow_table","Rainbowtabellen","Rainbowtable","Rainbowtables","Rainbow表","Rainboxtables","Rainboy table","RaindowTable","Randbow table","Read More About rainbow table - wikipedia the free","Read More rainbow table wikipedia the free encyclopedia","Regenbogen Tabelle","Regenbogen Tabelle Angriffe","Regenbogen Tabellen","Regenbogen-Tischen","Regenbogens Tabelle,","Regenbogentabelle","Regenbogentabellen","Szivárványtábla","TMTO ili rainbow tablice","Tabella arcobaleno","Tabella arcobaleno - Wikipedia","Tabelle vor den Angriffen des Regenbogens","Tablas Rainbow","Tablas Rainbow - Wikipedia, la enciclopedia libre","Table arc-en-ciel","Table arc-en-ciel - Wikipédia","Table en arc en ciel, rainbow table","Tables Arc-en-Ciel","Tables Arc-en-ciel","Tables arc-en-ciel sur Wikipedia","Taules Rainbow","Tęczowe tablice","Tęczowe tablice – Wikipedia, wolna encyklopedia","Tęczowe_tablice","Tęczowych tablic","WIKI pagina","WIKI レインボーテーブル","WP: Rainbow Table","Was sind Rainbow Tables?","Wiki - Rainbow Tables","Wiki Rainbows","Wiki about rainbow tables","Wiki on Rainbow Table","Wiki on Rainbow Tables","Wiki – Rainbow Tables","Wiki: RainbowTable","Wikimedia Error foundation ...","Wikipedia (Rainbow table)","Wikipedia - Rainbow Tables","Wikipedia - Rainbowtable","Wikipedia : レインボーテーブル","Wikipedia Artikel zu Rainbow Tables","Wikipedia article Rainbow Table","Wikipedia article Rainbow attack","Wikipedia article Rainbow table","Wikipedia article Rainbow tables","Wikipedia article Reduction function","Wikipedia article on Rainbow Table","Wikipedia article on Rainbow table","Wikipedia article on Rainbow tables","Wikipedia entry for Rainbow table","Wikipedia l'articolo Tabelle arcobaleno","Wikipedia page for rainbow tables","Wikipedia som skriver om Rainbowtabeller","Wikipedia's Rainbow table entry","Wikipedia's article on Rainbow tables","Wikipedia-Artikel Rainbow Table","Wikipedia-Artikel Rainbow Tables","Wikipedia-Artikel Rainbow-Table","Wikipedia-Artikel Rainbowtable","Wikipedia-Seite zu 'Rainbow Table'","Wikipedia/Rainbow_table#Defense_against_rainbow_tables","Wikipedia: Rainbow Table","Wikipedia: Rainbow Tables","Wikipedia: Rainbow table","Wikipedia:Tabella_arcobaleno","Wikipediaで「レインボーテーブル」を調べる","[6]rainbow tables","[7] http://en.wikipedia.org/wiki/Rainbow_table","[EN] Wikipedia — Rainbow table","[FR] Wikipédia — Table arc-en-ciel","_table","a 'rainbow key'","a very complete example","about rainbow tables","ainbow table","algoritmo di salting","arco iris de la tabla","arco iris mesa","as tabelas do arco-íris","atak tęczy","atakom Rainbow","atakom tabeli tęczy","ataque del arco iris","ataques de arco-íris tabela","ataques de mesa arco iris","attacco arcobaleno","attaques rainbow table","bahaghari mesa atake","bahaghari mesa,","bahaghari mesa.","bahaghari table","bahaghari talahanayan,","being “salted” with an additional random string","bảng cầu vồng","bảng cầu vồng,","bảng cầu vồng.","bảng rainbow","bảng ranbow","cryptographic rainbow table","cầu vồng tấn công bảng","da tavola rainbow.","dank Rainbow-Tables","das Prinzip von Rainbow Tables","de mesa arco iris","de mesa arco iris,","de mesa arco iris.","de table arc","de.wikipedia.org/...Rainbow_Table","de:Rainbow Table","defense against rainbow tables","des tables Rainbow,","des tables arc-en","des tables arc-en-","des tables ranbow","duha útok","easier than it should be","en.wikipedia.org/...Rainbow_table","en.wikipedia.org/wik...nbow_table","en.wikipedia.org/wiki/Rainbow_table","en.wikipedia.org/wiki/Rainbow_tables","en:Rainbow_table","erilaisilla","es:Tablas Rainbow","est intéressante","explain all this crazy incomprehensible jargon...","fr:Table arc-en-ciel","giant table of hash values for plaintext passwords","gigantische tafel van hash-waarden voor onversleutelde wachtwoorden","gli attacchi Arcobaleno","gli attacchi tavolo arcobaleno","go read wikipedia if you don't","gökkuşağı tablosu","here (rainbow tables)","hier nog meer","http://de.wikipedia.org/wiki/Ra inbow_Table","http://de.wikipedia.org/wiki/Rainbow-Table","http://de.wikipedia.org/wiki/Rainbow...ma.C3","http://de.wikipedia.org/wiki/Rainbow_Tab","http://de.wikipedia.org/wiki/Rainbow_Table","http://de.wikipedia.org/wiki/Rainbow_Tables","http://de.wikipedia.org/wiki/Rainbow_Tab…","http://de.wikipedia.org/wiki/Rainbowtable","http://en.wikip...i/Rainbow_table","http://en.wikipedia..../Rainbow_tables","http://en.wikipedia....i/Rainbow_table","http://en.wikipedia.org/wiki/Rainbo...","http://en.wikipedia.org/wiki/Rainbo..._rainbow_tables","http://en.wikipedia.org/wiki/Rainbow%5Ftable","http://en.wikipedia.org/wiki/Rainbow...rainbow_tables","http://en.wikipedia.org/wiki/Rainbow_Table","http://en.wikipedia.org/wiki/Rainbow_attack","http://en.wikipedia.org/wiki/Rainbow_attack.","http://en.wikipedia.org/wiki/Rainbow_ta ... bow_tables","http://en.wikipedia.org/wiki/Rainbow_tab","http://en.wikipedia.org/wiki/Rainbow_tab...","http://en.wikipedia.org/wiki/Rainbow_tabl","http://en.wikipedia.org/wiki/Rainbow_table#Defense_agai...","http://en.wikipedia.org/wiki/Rainbow_table#Defense_against_r...","http://en.wikipedia.org/wiki/Rainbow_table#Defense_against_rainbow_tables","http://en.wikipedia.org/wiki/Rainbow_table#Example","http://en.wikipedia.org/wiki/Rainbow_table.","http://en.wikipedia.org/wiki/Rainbow_table...","http://en.wikipedia.org/wiki/Rainbow_table..._rainbow_tables","http://en.wikipedia.org/wiki/Rainbow_tables","http://en.wikipedia.org/wiki/Rainbow_tables # Defense_against_rainbow_tables","http://en.wikipedia.org/wiki/Rainbow_tables#Defense_ag...","http://en.wikipedia.org/wiki/Rainbow_tables#Defense_against_rainbow_tables","http://en.wikipedia.org/wiki/Rainbow_tables＃Defense_against_rainbow_tables","http://en.wikipedia.org/wiki/Rainbow_tables＃のDefense_against_rainbow_tables","http://en.wikipedia.org/wiki/Rainbow_tableを","http://en.wikipedia.org/wiki/Rainbow_tabl…","http://en.wikipedia.org/wiki/Rainbow_tab​les","http://en.wikipedia.org/wiki/Rainbow_tab…","http://en.wikipedia.org/wiki/rainbow_tab...","http://en.wikipedia.org/wi​ki/Rainbow_table","http://es.wikipedia.org/wiki/Tablas_Rain...","http://es.wikipedia.org/wiki/Tablas_Rainbow","http://fr.wikipedia....ble_arc-en-ciel","http://fr.wikipedia.org/wiki/Philippe_Oechslin","http://fr.wikipedia.org/wiki/Rainbow_table","http://fr.wikipedia.org/wiki/Table_arc-en-ciel","http://htn.to/6s9E2Y","http://it.wikipedia.org/wiki/Rainbow_tables","http://it.wikipedia.org/wiki/Tabella_arcobaleno","http://it.wikipedia.org/wiki/Tabella_arc…","http://j.mp/cLTLYg","http://ja.wikipedia.org/wiki/レインボーテーブル","http://nl.wikipedia.org/wiki/Rainbow_table","http://pl.wikiped...we_tablice","http://pl.wikipedia....258;owe_tablice","http://pl.wikipedia....99czowe_tablice","http://pl.wikipedia.org/wiki/T%C4%99czowe_tablice","http://pl.wikipedia.org/wiki/Tęczowe_tablice","http://pt.wikipedia.org/wiki/Rainbow_table","http://ru.wikipedia....i/Rainbow_table","http://ru.wikipedia.org/wiki/Rainbow_table","http://ru.wikipedia.org/wiki/Радужная_та...","http://ru.wikipedia.org/wiki/Радужная_таблица","http://ru.wikipedia.org/wiki/Радужная_таблица#.D0.97","http://ru.wikipedia.org/wiki/Радужные_таблицы","it is also vulnerable to rainbow tables.","it:Rainbow tables","it:Tabella arcobaleno","ja:レインボーテーブル","kan terugleiden","kæmpe tabel over hash-værdier for alm passwords","l'article de Wikipédia Philippe Oechslin","las tablas de arco iris,","las tablas del arco iris","le rainbow tables","le tabelle arcobaleno","le tabelle rainbow","le tabelle ranbow","les Tables d'Arc-en-ciel","les tables arc en ciel","los ataques de arco iris de la tabla","los ataques del arco iris","mavričnih tabel","may not be enough","md5 rainbow table","meja pelangi","meja pelangi serangan","meja pelangi,","mesa arco iris","mesa arco iris.","mesa de arco iris","mesa de los ataques del arco iris","mesa gigante de los valores hash de contraseñas","mesas de arco iris","mesas-íris,","metodei pe care o folosesti la crackuit","mga talahanayan ng Rainbow,","nl:Rainbow table","obří tabulku hash hodnoty pro nešifrovaná hesla","olbrzymi tabeli wartości hash dla hasła w postaci","pelangi meja","pelangi meja,","pelangi tabel","pl.wikipedia.org/wiki/T%C4%99czowe_tablice","pl.wikipedia.org/wiki/Tęczowe_tablice","pl:Tęczowe tablice","precalculated tables","precomputed hash maps","preventing rainbow table attacks","pt:Rainbow table","quite more complex","rainbow attack","rainbow attacks","rainbow attrack","rainbow hack","rainbow lenteles","rainbow ones","rainbow tabel","rainbow tabele","rainbow tabelu","rainbow table","rainbow table aanvallen","rainbow table attack","rainbow table attacks","rainbow table efficiency can be nulled","rainbow table endpoints","rainbow table methods","rainbow table software","rainbow table wikipedia the free encyclopedia","rainbow table,","rainbow table.","rainbow tables","rainbow tables (F)","rainbow tables attack","rainbow tables attacks","rainbow tables but the Wikipedia","rainbow tables bzw. Regenbogentabellen","rainbow tables to crack passwords","rainbow tables!","rainbow tables'","rainbow tables,","rainbow tablice","rainbow tablo","rainbow tabulas","rainbow tabulky","rainbow trables","rainbow таблиц","rainbow таблици","rainbow таблицы","rainbow-Tabelle","rainbow-tabel","rainbow-table","rainbow-table attacks","rainbow-tables","rainbow-taulukoiden","rainbowtable","rainbowtables","raindow tables","ranbow Tabellen","ranbow tables","ranbow 테이블이","ranbowテーブル","read this article about Rainbow Tables","regenboog aanval","regnbue angreb","regnbue bord","regnbue bord angreb","regnbue borde","regnbue tabel","regnbue tabeller","regnbue tavler","regnbuen tabeller","regnbågstabeller","rel=nofollow>http://en.wikipedia.org/wiki/Rainbow_table","riesige Tabelle von Hash-Werten für Klartext-Passwörter","ru.wikipedia.org/wiki/Википедия:Как_делать_таблицы -","ru:Радужная таблица","s. http://en.wikipedia.org/wiki/Rainbow_","salt for added security","salt you use to prevent the use of","salting the passwords","sateenkaari taulukoihin","see rainbow tables","sog. “Rainbow Tables”","soleniu zahashowanych haseł i tęczowych tablicach","stół tęczy","stůl duhové","such tables","szivárványtáblás","szivárványtáblát","tabel Rainbow,","tabel pelangi","tabel ranbow","tabela a partir dos ataques do arco-íris","tabela com os ataques do arco-íris","tabela de arco-íris,","tabela do arco-íris","tabela do arco-íris,","tabela do arco-íris.","tabelas Rainbow","tabelas Rainbow,","tabelas de arco-íris","tabelas do arco-íris","tabelas ranbow","tabele curcubeu","tabele rainbow","tabeli Rainbow","tabella arcobaleno","tabella di Rainbow","tabella gigante di valori hash di password in","tabella rainbow.","tabelle arcobaleno","tabelle arcobaleno,","tabelle di Rainbow,","tabelle rainbow","tabla arcoiris","tabla de arco iris","tabla de arco iris,","tabla de los ataques del arco iris","tabla del arco iris","tabla rainbow","tablas Arco iris","tablas Rainbow","tablas Rainbow,","tablas arcoiris","tablas de arco iris","tablas de arco iris,","tablas del arco iris","tablas del arcoiris","tablas precalculadas","tablas rainbow","tablas ranbow","table arc en ciel","table arc-en-","table arc-en-ciel","table bahaghari","table d'attaques de l'arc-en-","table des attaques de l'arc en ciel","table rainbow,","tables Rainbow","tables arc-en-ciel","tables de hashs","tablic tęczowych","tablice tęczowe","tabulku Rainbow","tafel uit de aanvallen van de regenboog","tavola arcobaleno","tavolo arcobaleno","tavolo arcobaleno,","tavolo dagli attacchi dell'arcobaleno","teczowych tablic","tp://de.wikipedia.org/wiki/Rainbow_Table.","try to guess/crack your password","ttp://en.wikipedia.org/wiki/Rainbow_table","táboas rainbow","tęcza tabele","tęczowe tablice","tęczowej tablicy","tęczowych tablic","tęczowych tablicach","tęczowych tablicach (rainbow tables)","tęczowymi tablicami","tęczową tablicę","tęczy tabeli","une table arc-en-ciel","unique and long salt for each password","vereinfachte Rainbow Table mit","vorberechnete passwort-hash-kombinationen","wiki Rainbow Table c'est quoi ça ?","wikipedia:レインボーテーブル","worked over","| http://en.wikipedia.org/wiki/Rainbow_table","| rainbow table","«радужной» таблице","«радужные таблицы»,","«радужных» таблиц","útokům Duha","Википедии статью Rainbow table","Википедии статью Радужная таблица","Инфо на ВИКИ","Радужная таблица","Радужная таблица (англ. rainbow table) — специальный вариант таблиц","Радужная таблица — Википедия","Радужная_таблица","Радужные Таблицы","Радужные таблицы","Радужным таблицам","Спасибо.","Столами Радуги","атак радуги","гигантские таблицы хеш-значения для текста пароли","метод радужных таблиц","още материали","радуга таблиц","радуга таблице","радуга таблице атак","радуги таблице","радуги таблицы","радужная таблица","радужные таблицы","радужным таблицам","радужными таблицами","радужных таблиц","радужных таблицах","словарей md5","стола от атак радуги","таблиц Rainbow","таблиц Rainbow,","таблиц ranbow","таблиц радуги","таблице радуги","таблицы атак Rainbow","таблицы от нападений радуги","уГмуВдуГ│уГЬуГ╝уГЖуГ╝уГЦуГл","хмм…","хттп://ен.уикипедиа.орг/уики/Раинбоу_табле","גאונית בפשטותה","טבלאות קשת בענן","לבסיסי נתונים גדולים יותר","अक्षरांची जेव्हढी काँबीनेशन्स","इंद्रधनुष तालिका","इंद्रधनुष तालिकाओं","इंद्रधनुष हमले","पार्स इंद्रधनुष","होगी इंद्रधनुष","การ โจมตี ตาราง สายรุ้ง","ตาราง ranbow","ตาราง สายรุ้ง","ตาราง สายรุ้ง,","ตาราง สายรุ้ง.","ตารางรุ้ง","โต๊ะ สายรุ้ง","“Rainbow Table”","“rainbow table”","„Rainbow Tables“","、プレーンテキストのパスワードのハッシュ値の巨大なテーブルを","「salt」と呼ばれる手法を組み合わせる","ありがとうございます。","に高価なので、1","のテーブル。","レインボーテーブル","レインボーテーブル - Wikipedia","レインボーテーブル - Wikipedia http://ja.wikipedia.org/wiki/%E3","レインボーテーブルを","レインボーテーブル攻撃","レインボー表","レンボーテーブル","为明文密码的哈希值巨头表","什么是彩虹表？","什麽是彩虹表？","使用彩虹","像彩虹","彩虹攻击","彩虹表","彩虹表(英文)","彩虹表攻击","彩虹表攻击从","彩虹表攻擊","彩虹表的","来自彩虹表攻击","琐碎的","英語版 Wikipedia の Precomputed hash chains の章","虹のテーブル","虹のテーブルは","虹のテーブルを","虹の攻撃","虹の攻撃からテーブルを","虹の攻撃を","虹の表の","虹の表の攻撃","虹の表の攻撃を","虹攻撃のテーブルから","蚊怕水表","더 레인보우 테이블을","레인보우 테이블","무지개 테이블","무지개 테이블,을","무지개 테이블은","무지개 테이블을","무지개 테이블을 공격하는","무지개 테이블의","무지개를 테이블과","무지개를 테이블로","무지개를 테이블에","）ハッシュ検索","ﾚｲﾝﾎﾞｰﾃｰﾌﾞﾙ-wikipedia"],"name":"Rainbow table","categories":["All articles lacking in-text citations","All articles with unsourced statements","Articles lacking in-text citations from March 2009","Articles with DMOZ links","Articles with unsourced statements from January 2011","Articles with unsourced statements from January 2014","Articles with unsourced statements from July 2013","Cryptographic attacks","Cryptographic hash functions","Search algorithms"],"tag_line":"A rainbow table is a precomputed table for reversing cryptographic hash functions, usually for cracking password hashes."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rsa-numbers","_score":0,"_source":{"description":"In mathematics, the RSA numbers are a set of large semiprimes (numbers with exactly two prime factors) that are part of the RSA Factoring Challenge. The challenge was to find the prime factors but it was declared inactive in 2007. It was created by RSA Laboratories in March 1991 to encourage research into computational number theory and the practical difficulty of factoring large integers.\nRSA Laboratories published a number of semiprimes with 100 to 617 decimal digits. Cash prizes of varying size were offered for factorization of some of them. The smallest RSA number was factored in a few days. Most of the numbers have still not been factored and many of them are expected to remain unfactored for many years to come. As of September 2013, 18 of the 54 listed numbers have been factored: the 17 smallest from RSA-100 to RSA-704, plus RSA-768.\nThe RSA challenge officially ended in 2007 but people are still attempting to find the factorizations. According to RSA Laboratories, \"Now that the industry has a considerably more advanced understanding of the cryptanalytic strength of common symmetric-key and public-key algorithms, these challenges are no longer active.\" Some of the smaller prizes had been awarded at the time. The remaining prizes were retracted.\nThe first RSA numbers generated, from RSA-100 to RSA-500, were labeled according to their number of decimal digits. Later, beginning with RSA-576, binary digits are counted instead. An exception to this is RSA-617, which was created before the change in the numbering scheme. The numbers are listed in increasing order below.\n^ RSA Laboratories, The RSA Factoring Challenge. Retrieved on 2008-03-10.\n^ RSA Laboratories, The RSA Factoring Challenge FAQ. Retrieved on 2008-03-10.","alt_names":["RSA-576","RSA-2048","RSA-640","RSA-129","RSA numbers","- RSA numbers :","- RSA-129 :","- RSA-155 :","- RSA-200 :","- RSA-768 :","--> Линка <--","-> Leggi tutto l'articolo su 'Numeri RSA'","...Wikipedia Nombre RSA","...Wikipedia RSA-100","...Wikipedia RSA-1024","...Wikipedia RSA-110","...Wikipedia RSA-120","...Wikipedia RSA-129","...Wikipedia RSA-130","...Wikipedia RSA-140","...Wikipedia RSA-150","...Wikipedia RSA-1536","...Wikipedia RSA-155","...Wikipedia RSA-160","...Wikipedia RSA-170","...Wikipedia RSA-180","...Wikipedia RSA-190","...Wikipedia RSA-200","...Wikipedia RSA-2048","...Wikipedia RSA-210","...Wikipedia RSA-220","...Wikipedia RSA-230","...Wikipedia RSA-232","...Wikipedia RSA-240","...Wikipedia RSA-250","...Wikipedia RSA-260","...Wikipedia RSA-270","...Wikipedia RSA-280","...Wikipedia RSA-290","...Wikipedia RSA-300","...Wikipedia RSA-309","...Wikipedia RSA-310","...Wikipedia RSA-320","...Wikipedia RSA-330","...Wikipedia RSA-340","...Wikipedia RSA-350","...Wikipedia RSA-360","...Wikipedia RSA-370","...Wikipedia RSA-380","...Wikipedia RSA-390","...Wikipedia RSA-400","...Wikipedia RSA-410","...Wikipedia RSA-420","...Wikipedia RSA-430","...Wikipedia RSA-440","...Wikipedia RSA-450","...Wikipedia RSA-460","...Wikipedia RSA-470","...Wikipedia RSA-480","...Wikipedia RSA-490","...Wikipedia RSA-500","...Wikipedia RSA-617","...Wikipedia RSA-640","...Wikipedia RSA-704","...Wikipedia RSA-768","...Wikipedia RSA-896","...more on Wikipedia about RSA-129","...more on Wikipedia about RSA-155","...more on Wikipedia about RSA-200","...more on Wikipedia about RSA-330","...more on Wikipedia about RSA-768","1024 Bits","200 digit number","200-decimal digit RSA","663 Bits","768 bits","768-bit long key","<http://en.wikipedia.org/wiki/RSA_numbers#RSA−390","Factorization of RSA-129","James: RSA numbers - Wikipedia, the free encyclopedia","Kazumaro Aoki","Les nombres RSA sur Wikipédia","Look for Fr:RSA-100","Look for Fr:RSA-1536","Look for Fr:RSA-232","Look for Fr:RSA-250","Look for Fr:RSA-260","Look for Fr:RSA-309","Look for Fr:RSA-320","Look for Fr:RSA-370","Look for Fr:RSA-460","Look for Fr:RSA-490","Look for Fr:RSA-896","Nombre RSA - Wikipédia","Nombre_RSA","Numeri RSA","Numeri RSA - Wikipedia","RSA Number","RSA challenge numbers","RSA compettons","RSA number","RSA numbers - Wikipedia, the free encyclopedia","RSA numbers#RSA-200","RSA-100","RSA-1024 - Wikipédia","RSA-110","RSA-120","RSA-129 - Wikipédia","RSA-129 factoring challenge","RSA-129 – Wikipedia","RSA-130","RSA-140","RSA-150","RSA-1536","RSA-155","RSA-155 - Wikipédia","RSA-155 w","RSA-160","RSA-170","RSA-180","RSA-190","RSA-200","RSA-2048 - Wikipédia","RSA-210","RSA-220","RSA-230","RSA-232","RSA-240","RSA-250","RSA-260","RSA-270","RSA-280","RSA-290","RSA-300","RSA-309","RSA-310","RSA-320","RSA-330","RSA-340","RSA-350","RSA-360","RSA-370","RSA-380","RSA-390","RSA-400","RSA-410","RSA-420","RSA-430","RSA-440","RSA-450","RSA-460","RSA-470","RSA-480","RSA-490","RSA-500","RSA-617","RSA-704","RSA-768","RSA-768 - Wikipédia","RSA-896","RSA-896 - Wikipédia","RSA-Zahlen","RSA129","RSA200","RSA2048","RSA_numbers","Site web Wikipédia RSA-768","Tallet som ville gjort deg berømt om du","This number is named RSA-210 and has","Wikipedia article RSA numbers","Wikipedia article RSA-129","Wikipedia article RSA-155","Wikipedia article RSA-200","Wikipedia article RSA-330","Wikipedia article RSA-768","Wikipedia article about RSA-129","Wikipedia article on RSA numbers","Wikipedia article on RSA-129","Wikipedia article on RSA-200","Wikipedia entry for RSA numbers","Wikipedia-Artikel RSA-129","Wikipedia-Seite zu 'RSA-129'","Wikipedia:Numero_RSA","Wikipedia:RSA-1024","Wikipedia:RSA-129","Wikipedia:RSA-155","a 768-bit integer","alcuni semiprimi","article RSA-129","broken ten years ago","chiffrage en 2048 bits RSA","de:RSA-129","en.wikipedia.org/wiki/RSA_numbers","en.wikipedia.org/wiki/RSA_numbers#RSA-768","en:RSA numbers#RSA-100","en:RSA numbers#RSA-1024","en:RSA numbers#RSA-110","en:RSA numbers#RSA-120","en:RSA numbers#RSA-129","en:RSA numbers#RSA-130","en:RSA numbers#RSA-140","en:RSA numbers#RSA-150","en:RSA numbers#RSA-1536","en:RSA numbers#RSA-155","en:RSA numbers#RSA-160","en:RSA numbers#RSA-170","en:RSA numbers#RSA-180","en:RSA numbers#RSA-190","en:RSA numbers#RSA-200","en:RSA numbers#RSA-2048","en:RSA numbers#RSA-210","en:RSA numbers#RSA-220","en:RSA numbers#RSA-230","en:RSA numbers#RSA-232","en:RSA numbers#RSA-240","en:RSA numbers#RSA-250","en:RSA numbers#RSA-260","en:RSA numbers#RSA-270","en:RSA numbers#RSA-280","en:RSA numbers#RSA-290","en:RSA numbers#RSA-300","en:RSA numbers#RSA-309","en:RSA numbers#RSA-310","en:RSA numbers#RSA-320","en:RSA numbers#RSA-330","en:RSA numbers#RSA-340","en:RSA numbers#RSA-350","en:RSA numbers#RSA-360","en:RSA numbers#RSA-370","en:RSA numbers#RSA-380","en:RSA numbers#RSA-390","en:RSA numbers#RSA-400","en:RSA numbers#RSA-410","en:RSA numbers#RSA-420","en:RSA numbers#RSA-430","en:RSA numbers#RSA-440","en:RSA numbers#RSA-450","en:RSA numbers#RSA-460","en:RSA numbers#RSA-470","en:RSA numbers#RSA-480","en:RSA numbers#RSA-490","en:RSA numbers#RSA-500","en:RSA numbers#RSA-617","en:RSA numbers#RSA-640","en:RSA numbers#RSA-704","en:RSA numbers#RSA-768","en:RSA numbers#RSA-896","fr:RSA-1024","fr:RSA-370","http://de.wikipedia.org/wiki/RSA-129","http://en.wikipedia....SA-768#RSA-1024","http://en.wikipedia.org/wiki/RSA-129","http://en.wikipedia.org/wiki/RSA-129#RSA","http://en.wikipedia.org/wiki/RSA-155","http://en.wikipedia.org/wiki/RSA-200","http://en.wikipedia.org/wiki/RSA-200#RSA","http://en.wikipedia.org/wiki/RSA-330","http://en.wikipedia.org/wiki/RSA-768","http://en.wikipedia.org/wiki/RSA-768#RSA","http://en.wikipedia.org/wiki/RSA200","http://en.wikipedia.org/wiki/RSA_numbers","http://en.wikipedia.org/wiki/RSA_numbers#RSA-100","http://en.wikipedia.org/wiki/RSA_numbers#RSA-1024","http://en.wikipedia.org/wiki/RSA_numbers#RSA-129","http://en.wikipedia.org/wiki/RSA_numbers#RSA-140","http://en.wikipedia.org/wiki/RSA_numbers#RSA-155","http://en.wikipedia.org/wiki/RSA_numbers#RSA-160","http://en.wikipedia.org/wiki/RSA_numbers#RSA-170","http://en.wikipedia.org/wiki/RSA_numbers#RSA-190","http://en.wikipedia.org/wiki/RSA_numbers#RSA-200","http://en.wikipedia.org/wiki/RSA_numbers#RSA-2048","http://en.wikipedia.org/wiki/RSA_numbers#RSA-210","http://en.wikipedia.org/wiki/RSA_numbers#RSA-300","http://en.wikipedia.org/wiki/RSA_numbers#RSA-390","http://en.wikipedia.org/wiki/RSA_numbers#RSA-576","http://en.wikipedia.org/wiki/RSA_numbers#RSA-640","http://en.wikipedia.org/wiki/RSA_numbers#RSA-704","http://en.wikipedia.org/wiki/RSA_numbers#RSA-768","http://fr.wikipedia.org/wiki/Nombre_RSA","http://fr.wikipedia.org/wiki/RSA-1024","http://fr.wikipedia.org/wiki/RSA-110","http://fr.wikipedia.org/wiki/RSA-120","http://fr.wikipedia.org/wiki/RSA-129","http://fr.wikipedia.org/wiki/RSA-130","http://fr.wikipedia.org/wiki/RSA-140","http://fr.wikipedia.org/wiki/RSA-150","http://fr.wikipedia.org/wiki/RSA-1536","http://fr.wikipedia.org/wiki/RSA-155","http://fr.wikipedia.org/wiki/RSA-160","http://fr.wikipedia.org/wiki/RSA-190","http://fr.wikipedia.org/wiki/RSA-200","http://fr.wikipedia.org/wiki/RSA-2048","http://fr.wikipedia.org/wiki/RSA-220","http://fr.wikipedia.org/wiki/RSA-232","http://fr.wikipedia.org/wiki/RSA-250","http://fr.wikipedia.org/wiki/RSA-270","http://fr.wikipedia.org/wiki/RSA-320","http://fr.wikipedia.org/wiki/RSA-350","http://fr.wikipedia.org/wiki/RSA-420","http://fr.wikipedia.org/wiki/RSA-440","http://fr.wikipedia.org/wiki/RSA-460","http://fr.wikipedia.org/wiki/RSA-480","http://fr.wikipedia.org/wiki/RSA-500","http://fr.wikipedia.org/wiki/RSA-704","http://fr.wikipedia.org/wiki/RSA-768","http://fr.wikipedia.org/wiki/RSA-896","http://it.wikipedia.org/wiki/Numeri_RSA","http://it.wikipedia.org/wiki/Numeri_RSA#RSA-100","http://it.wikipedia.org/wiki/Numeri_RSA#RSA-129","http://it.wikipedia.org/wiki/RSA-1024","http://it.wikipedia.org/wiki/RSA-640","http://pl.wikipedia.org/wiki/Liczby_RSA","it:Numeri RSA#RSA-100","it:Numeri RSA#RSA-1024","it:Numeri RSA#RSA-110","it:Numeri RSA#RSA-120","it:Numeri RSA#RSA-129","it:Numeri RSA#RSA-130","it:Numeri RSA#RSA-140","it:Numeri RSA#RSA-150","it:Numeri RSA#RSA-1536","it:Numeri RSA#RSA-155","it:Numeri RSA#RSA-160","it:Numeri RSA#RSA-170","it:Numeri RSA#RSA-180","it:Numeri RSA#RSA-190","it:Numeri RSA#RSA-200","it:Numeri RSA#RSA-2048","it:Numeri RSA#RSA-210","it:Numeri RSA#RSA-220","it:Numeri RSA#RSA-230","it:Numeri RSA#RSA-232","it:Numeri RSA#RSA-240","it:Numeri RSA#RSA-250","it:Numeri RSA#RSA-260","it:Numeri RSA#RSA-270","it:Numeri RSA#RSA-280","it:Numeri RSA#RSA-290","it:Numeri RSA#RSA-300","it:Numeri RSA#RSA-309","it:Numeri RSA#RSA-310","it:Numeri RSA#RSA-320","it:Numeri RSA#RSA-330","it:Numeri RSA#RSA-340","it:Numeri RSA#RSA-350","it:Numeri RSA#RSA-360","it:Numeri RSA#RSA-370","it:Numeri RSA#RSA-380","it:Numeri RSA#RSA-390","it:Numeri RSA#RSA-400","it:Numeri RSA#RSA-410","it:Numeri RSA#RSA-420","it:Numeri RSA#RSA-430","it:Numeri RSA#RSA-440","it:Numeri RSA#RSA-450","it:Numeri RSA#RSA-460","it:Numeri RSA#RSA-470","it:Numeri RSA#RSA-480","it:Numeri RSA#RSA-490","it:Numeri RSA#RSA-500","it:Numeri RSA#RSA-617","it:Numeri RSA#RSA-704","it:Numeri RSA#RSA-896","it:RSA-1024","it:RSA-129","it:RSA-155","it:RSA-2048","l'article de Wikipédia Rsa-617","le:http://en.wikipedia.org/wiki/RSA_numbers","math problem.","nombre RSA-768","nombres RSA","numeri RSA","número de 200 dígitos","números do desafio RSA","números propuestos","pl:RSA-576","pl:RSA-640","romper claves","rsa768","see Wikipedia for cracked RSA's here","the list of RSA challenges","una voce unica","w:RSA numbers","wikipedia: RSA numbers","число RSA-100","“RSA numbers - Wikipedia, the free encyclopedia”, en.wikipedia"],"name":"RSA numbers","categories":["All articles containing potentially dated statements","Articles containing potentially dated statements from September 2013","Integer factorization algorithms","Large integers","RSA Factoring Challenge"],"tag_line":"In mathematics, the RSA numbers are a set of large semiprimes (numbers with exactly two prime factors) that are part of the RSA Factoring Challenge."}}
,{"_index":"throwtable","_type":"algorithm","_id":"s-box","_score":0,"_source":{"description":"In cryptography, an S-box (substitution-box) is a basic component of symmetric key algorithms which performs substitution. In block ciphers, they are typically used to obscure the relationship between the key and the ciphertext — Shannon's property of confusion.\nIn general, an S-box takes some number of input bits, m, and transforms them into some number of output bits, n, where n is not necessarily equal to m. An m×n S-box can be implemented as a lookup table with 2m words of n bits each. Fixed tables are normally used, as in the Data Encryption Standard (DES), but in some ciphers the tables are generated dynamically from the key (e.g. the Blowfish and the Twofish encryption algorithms).\nOne good example of a fixed table is the S-box from DES (S5), mapping 6-bit input into a 4-bit output:\nGiven a 6-bit input, the 4-bit output is found by selecting the row using the outer two bits (the first and last bits), and the column using the inner four bits. For example, an input \"011011\" has outer bits \"01\" and inner bits \"1101\"; the corresponding output would be \"1001\".\nThe 8 S-boxes of DES were the subject of intense study for many years out of a concern that a backdoor — a vulnerability known only to its designers — might have been planted in the cipher. The S-box design criteria were eventually published (in Coppersmith 1994) after the public rediscovery of differential cryptanalysis, showing that they had been carefully tuned to increase resistance against this specific attack. Biham and Shamir found that even small modifications to an S-box could significantly weaken DES.\nThere has been a great deal of research into the design of good S-boxes, and much more is understood about their use in block ciphers than when DES was released.\nAny S-box where each output bit is produced by a bent function of the input bits, and where any linear combination of the output bits is also a bent function of the input bits, is a perfect S-box.","alt_names":["S-box","s-box","Sbox","S-Box","...Wikipedia Boîte-S","...Wikipedia S-BOX","...Wikipedia S-box","...Wikipedia S-caja","...mehr auf Wikipedia über S-Box","...more on Wikipedia about Substitution box","Caixes-S","Learn about S-box>>>","S Box","S-BOX","S-BOXów","S-Box - Wikipedia","S-Box - Wikipedia, la enciclopedia libre","S-Box ? Wikipedia","S-Box ? Wikipedia, wolna encyklopedia","S-Box – Wikipedia","S-Box – Wikipedia, wolna encyklopedia","S-Boxen","S-Boxes","S-Cajas","S-bloków","S-box - Wikipedia, the free encyclopedia","S-box Related Content:","S-box on wikipedia.org","S-box; it is used under the","S-boxes","S-boxes so that, when presented with a","S-boxes themselves","S-boxů","S-boîtes","S-cajas","S-table","Search info on S-Box at Wikipedia","Substitution box","Substitution box - Simple English Wikipedia, the free ...","Substitution box - Simple English Wikipedia, the free encycl","Substitution box - Simple English Wikipedia, the free encyclopedia","Substitution box @ Wikipedia","Substitution boxes","Substitution-boxes","Substitutionsboxen","Substitutionstabelle (S-Box)","Sボックス","Sボックス - Wikipedia","Sボックスとは？ (Wikipediaへのリンク)","Sﾎﾞｯｸｽ-wikipedia","WP: S-Box","Wikipedia : Sボックス","Wikipedia Caja de sustitución","Wikipedia article S-Box","Wikipedia article S-box","Wikipedia article S-boxes","Wikipedia article Substitution box","Wikipedia article on S-Box","Wikipedia article on S-box","Wikipedia article on S-caja","Wikipedia entry for S-box","Wikipedia l'articolo S-box","Wikipedia sur Boîte-S","Wikipedia-Artikel S-Box","Wikipedia-Seite zu 'S-Box'","Wikipedia: S-Box","Wikipedia:S-box","Wikipedia:Substitution box","Wikipediaで「Sボックス」を調べる","an article of Wikipedia","artículo de Wikipedia Caja de sustitución","artículo de Wikipedia S-Box","ca:Caixes-S","caixes de Substitució","caja-S","cajas s-box","cajas-S","de:S-Box","en.wikipedia.org/wiki/S-box","en.wikipedia.org/wiki/Substitution_box","en:S-box","es:Caja de sustitución","es:S-Box","fr:S-Box","http://de.wikipedia.org/wiki/S-Box","http://de.wikipedia.org/wiki/S-Box#Beispiel","http://en.wikipedia.org/wiki/S-Box","http://en.wikipedia.org/wiki/S-box","http://en.wikipedia.org/wiki/S-boxes","http://en.wikipedia.org/wiki/Substitution_box","http://es.wikipedia.org/wiki/S-Box","http://es.wikipedia.org/wiki/S-caja","http://fr.wikipedia.org/wiki/S-Box","http://it.wikipedia.org/wiki/S-Box","http://it.wikipedia.org/wiki/S-box","http://pl.wikipedia.org/wiki/S-BOX","http://pl.wikipedia.org/wiki/S-Box","it:S-Box","ja:Sボックス","misztikum","monimutkaisten taulukoiden","of S-boxe","pl:S-Box","s-boxes","simple.wikipedia.org/wiki/Substitution_box","simple:Substitution box","substitution box","substitution boxes (S-boxes)","tables de substitution","utbytestabeller (S-box)","блок подстановки","ウィキペディアの記事 Sボックス"],"name":"S-box","categories":["All articles needing additional references","All articles with unsourced statements","Articles needing additional references from March 2009","Articles with unsourced statements from April 2012","CS1 errors: external links","CS1 maint: Explicit use of et al.","Cryptographic algorithms","S-box"],"tag_line":"In cryptography, an S-box (substitution-box) is a basic component of symmetric key algorithms which performs substitution."}}
,{"_index":"throwtable","_type":"algorithm","_id":"information-theoretic-security","_score":0,"_source":{"description":"A cryptosystem is information-theoretically secure if its security derives purely from information theory. That is, it cannot be broken even when the adversary has unlimited computing power. The adversary simply does not have enough information to break the encryption, so these cryptosystems are considered cryptanalytically unbreakable.\nAn encryption protocol that has information-theoretic security does not depend for its effectiveness on unproven assumptions about computational hardness, and such an algorithm is not vulnerable to future developments in computer power such as quantum computing. An example of an information-theoretically secure cryptosystem is the one-time pad. The concept of information-theoretically secure communication was introduced in 1949 by American mathematician Claude Shannon, the inventor of information theory, who used it to prove that the one-time pad system was secure. Information-theoretically secure cryptosystems have been used for the most sensitive governmental communications, such as diplomatic cables and high-level military communications, because of the great efforts enemy governments expend toward breaking them.\nAn interesting special case is perfect security: an encryption algorithm is perfectly secure if a ciphertext produced using it provides no information about the plaintext without knowledge of the key. If E is a perfectly secure encryption function, for any fixed message m there must exist for each ciphertext c at least one key k such that . It has been proved that any cipher with the perfect secrecy property must use keys with effectively the same requirements as one-time pad keys.\nIt is common for a cryptosystem to leak some information but nevertheless maintain its security properties even against an adversary that has unlimited computational resources. Such a cryptosystem would have information theoretic but not perfect security. The exact definition of security would depend on the cryptosystem in question.\nThere are a variety of cryptographic tasks for which information-theoretic security is a meaningful and useful requirement. A few of these are:\nSecret sharing schemes such as Shamir's are information-theoretically secure (and also perfectly secure) in that less than the requisite number of shares of the secret provide no information about the secret.\nMore generally, secure multiparty computation protocols often, but not always, have information-theoretic security.\nPrivate information retrieval with multiple databases can be achieved with information-theoretic privacy for the user's query.\nReductions between cryptographic primitives or tasks can often be achieved information-theoretically. Such reductions are important from a theoretical perspective, because they establish that primitive  can be realized if primitive  can be realized.\nSymmetric encryption can be constructed under an information-theoretic notion of security called entropic security, which assumes that the adversary knows almost nothing about the message being sent. The goal here is to hide all functions of the plaintext rather than all information about it.\nQuantum cryptography is largely part of information-theoretic cryptography.\nConventional secrecy entails encrypting messages. Beyond this, some scenarios require covert communication, a stronger type of secrecy which also hides the fact that communication is happening at all. \n^ a b Shannon, Claude E. (October 1949). \"Communication Theory of Secrecy Systems\" (PDF). Bell System Technical Journal (USA: AT&T Corporation) 28 (4): 656–715. doi:10.1002/j.1538-7305.1949.tb00928.x. Retrieved 2011-12-21. \n^ Soltani, R.; Bash, B.; Goeckel, D.; Guha, S.; Towsley, D. (Sep 2014). \"Covert single-hop communication in a wireless network with distributed artificial noise generation\". Communication, Control, and Computing (Allerton), 2014 52nd Annual Allerton Conference on: 1078–1085.","alt_names":[],"name":"Information-theoretic security","categories":["Information-theoretically secure algorithms","Theory of cryptography"],"tag_line":"A cryptosystem is information-theoretically secure if its security derives purely from information theory."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pollard's-rho-algorithm","_score":0,"_source":{"description":"Pollard's rho algorithm is a special-purpose integer factorization algorithm. It was invented by John Pollard in 1975. It is particularly effective for a composite number having a small prime factor.\n\n","alt_names":["Pollard's Rho","Pollard rho method","élitisme","Pollard's rho algorithm","Pollard's rho","- Pollard rho :","...Wikipedia Algorithme rho de Pollard","...Wikipedia Rho Pollarda","...mehr auf Wikipedia über Pollard-Rho-Methode","...more on Wikipedia about Pollard's rho algorithm","1 . 177 p","1d2d33aa3a05b3b63fd3859b8ab738 ...","8c99c5756e52e6de1bafe10621c234 ...","???????? rho ?? ????? – ????????","Algorithme rho de Pollard","Algorithme rho de Pollard - Wikipédia","Algoritmo rho de Pollard","Algoritmo rho de Pollard - Wikipedia, la enciclopedia libre","Algoritmo rho di Pollard","Algoritmo rho di Pollard - Wikipedia","Algorytm faktoryzacji rho Pollarda","Algorytm rho Pollarda","Brent's loop-finding algorithm","Learn about Pollard's rho algorithm>>>","P-алгоритм Полларда","Pollard Rho Algorithmus","Pollard rho algorithm","Pollard rho integer factorization","Pollard s rho algorithm Wikipedia the free encyclopedia","Pollard ρ-Algorithmus","Pollard के रो एल्गोरिथ्म","Pollard&#39;s rho algorithm - Wikipedia, the free","Pollard's","Pollard's Rho Algorithm","Pollard's Rho Algorithm - Wikipedia, The Free Encyclopedia","Pollard's Rho Method","Pollard's Rho algorithm","Pollard's Rho method","Pollard's Rho-algoritme","Pollard's rho algorithm (wikipedia)","Pollard's rho algorithm - Wikipedia :: The free encyclopedia","Pollard's rho algorithm - Wikipedia, the ...","Pollard's rho algorithm - Wikipedia, the free encyclopedia","Pollard's rho algoritme","Pollard's rho heuristic","Pollard-Rho Methode","Pollard-Rho algorithm.","Pollard-Rho-Algorithmus","Pollard-Rho-Methode","Pollard-Rho-Methode (Wiki)","Pollard-Rho-Methode – Wikipedia","Pollard-rho","Pollard_Rho分解因子算法","Pollard_rho","Pollards rho-algoritme","Pollards rho-algoritme - Wikipedia","Pollardův/Brentův algoritmus","Pollardのrhoアルゴリズムを","Pollard的卢算法","Rho de Pollard","Rho алгоритм Полларда","Rho-Methode von Pollard","Rho-algoritme van Pollard","WikiPedia.ja:ポラード・ロー素因数分解法","Wikipedia (Pollard's rho algorithm)","Wikipedia article ''Pollard's rho algorithm''","Wikipedia article Pollard rho","Wikipedia article Pollard's Rho Algorithm","Wikipedia article Pollard's rho algorithm","Wikipedia article on Algoritmo rho de Pollard","Wikipedia article on Pollard rho","Wikipedia artikel Pollard's rho algoritme","Wikipedia-Artikel Pollard-Rho-Methode","Wikipedia-Seite zu 'Pollard-Rho-Methode'","a 1977 algorithm","a at http://en.wikipedia.","algorithme Rho de Pollard","algoritmo Pollard rho","algorytm rho Pollarda","artículo de Wikipedia Algoritmo rho de Pollard","artículo de Wikipedia Método rho de Pollard","c) Pollard's rho factorizing method","ca:Algorisme rho de Pollard","de.wikipedia.org/wiki/Pollard-Rho-Methode","del algoritmo rho de Pollard","en.wikipedia.org/wiki/Pollard's_rho_algorithm","en:Pollard's rho algorithm","es:Algoritmo rho de Pollard","f4f71686d288ded564d75ad86003e ...","fr.wikipedia.org/wiki/Algorithme_rho_de_Pollard","g) Pollard´s factorization","he:אלגוריתם rho של פולרד","http://de.wikipedia.org/wiki/Pollard-Rho","http://de.wikipedia.org/wiki/Pollard-Rho-Methode","http://en.wikipedia....ent.27s_variant","http://en.wikipedia.org/wiki/Pollard %27s_rho_algorithm","http://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm","http://en.wikipedia.org/wiki/Pollard's_rho_algorithm","http://en.wikipedia.org/wiki/Pollard's_r…","http://en.wikipedia.org/wiki/Pollard...rithm#Variants","http://en.wikipedia.org/wiki/Pollard_rho","http://en.wikipedia.org/wiki/Pollard_rho#Richard_Brent.27s_variant","http://es.wikipedia.org/wiki/Algoritmo_rho_de_Pollard","http://fr.wikipedia.org/wiki/Algorithme_rho_de_Pollard","http://it.wikipedia.org/wiki/Algoritmo_rho_di_Pollard","http://nl.wikipedia.org/wiki/Pollards_rho-algoritm","http://nl.wikipedia.org/wiki/Pollards_rho-algoritme","http://pl.wikipedia.org/wiki/Algorytm_faktoryzacji_rho_Pollarda","http://pl.wikipedia.org/wiki/Rho_Pollarda","http://ru.wikipedia.org/wiki/?-алгоритм_Полларда","http://ru.wikipedia.org/wiki/Ρ-алгоритм_Полларда","it:Algoritmo rho di Pollard","ja:ポラード・ロー素因数分解法","l'algorithme rho de Pollard","l'algoritmo rho di Pollard","my favorite factorization algorithm","método rho de Pollard","nl:Pollard's rho algoritme","nl:Pollards rho-algoritme","pl:Algorytm faktoryzacji rho Pollarda","pollard rho prime factorisation","pollard's-rho","pollard-ρ","rho algorithme Pollard","rho de Pollard","vi:Thuật toán RHO","wikipedia:ポラード・ロー素因数分解法","Ρ-алгоритм Полларда","Ρ-алгоритм Полларда — Википедия","Википедии статью Ρ-алгоритм Полларда","Ро-метод Полларда","ро алгоритм Полларда","ро-метода","אלגוריתם rho של פולרד","אלגוריתם rho של פולרד – ויקיפדיה","ויקיפדיה - 'אלגוריתם Rho של פולרד'","“Pollard's rho algorithm - Wikipedia, the free encyclopedia”, en","ウィキペディアの記事 ポラード・ロー素因数分解法","ポラード Rho アルゴリズム","ポラードのRhoのアルゴリズム","ポラードのローのアルゴリズムを","ポラード・ローアルゴリズム","ポラード・ロー素因数分解法","ポラード・ロー素因数分解法 - Wikipedia","一般に素因数分解は、対象の数 n について、その平方根以下の全ての素数について n を割ってみる","波拉德的RHO算法","波拉德的卢算法"],"name":"Pollard's rho algorithm","categories":["Integer factorization algorithms"],"tag_line":"Pollard's rho algorithm is a special-purpose integer factorization algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"crypt-(c)","_score":0,"_source":{"description":"crypt is the library function which is used to compute a password hash that can be used to store user account passwords while keeping them relatively secure (a passwd file). The output of the function is not simply the hash— it is a text string which also encodes the salt (usually the first two characters are the salt itself and the rest is the hashed result), and identifies the hash algorithm used (defaulting to the \"traditional\" one explained below). This output string is what is meant for putting in a password record which may be stored in a plain text file.\nMore formally, crypt provides cryptographic key derivation functions for password validation and storage on Unix systems.\n\n","alt_names":[],"name":"Crypt (C)","categories":["All articles with unsourced statements","Articles with unsourced statements from April 2010","Articles with unsourced statements from July 2011","Broken cryptography algorithms","Computer access control protocols","Cryptographic hash functions","Key derivation functions","Password authentication"],"tag_line":"crypt is the library function which is used to compute a password hash that can be used to store user account passwords while keeping them relatively secure (a passwd file)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"berlekamp–massey-algorithm","_score":0,"_source":{"description":"The Berlekamp–Massey algorithm is an algorithm that will find the shortest linear feedback shift register (LFSR) for a given binary output sequence. The algorithm will also find the minimal polynomial of a linearly recurrent sequence in an arbitrary field. The field requirement means that the Berlekamp–Massey algorithm requires all non-zero elements to have a multiplicative inverse. Reeds and Sloane offer an extension to handle a ring.\nElwyn Berlekamp invented an algorithm for decoding Bose–Chaudhuri–Hocquenghem (BCH) codes. James Massey recognized its application to linear feedback shift registers and simplified the algorithm. Massey termed the algorithm the LFSR Synthesis Algorithm (Berlekamp Iterative Algorithm), but it is now known as the Berlekamp–Massey algorithm.","alt_names":[],"name":"Berlekamp–Massey algorithm","categories":["All articles with dead external links","Articles with German-language external links","Articles with dead external links from June 2015","Cryptanalytic algorithms","Error detection and correction"],"tag_line":"The Berlekamp–Massey algorithm is an algorithm that will find the shortest linear feedback shift register (LFSR) for a given binary output sequence."}}
,{"_index":"throwtable","_type":"algorithm","_id":"factor-base","_score":0,"_source":{"description":"In computational number theory, a factor base is a small set of prime numbers commonly used as a mathematical tool in algorithms involving extensive sieving for potential factors of a given integer.","alt_names":["Factor Base","Factor base","Factor base - Wikipedia, the free encyclopedia","Factor_base","Source Wikipedia.org Arcticle - Factor base","Wikipedia article Factor Base","Wikipedia article Factor base","Wikipedia article on Factor base","Wikipedia entry for Factor base","factor base","factor bases","http://en.wikipedia.org/wiki/Factor base","http://en.wikipedia.org/wiki/Factor_base","x ≠ y","yago-res:Factor base"],"name":"Factor base","categories":["All stub articles","Integer factorization algorithms","Number theory stubs"],"tag_line":"In computational number theory, a factor base is a small set of prime numbers commonly used as a mathematical tool in algorithms involving extensive sieving for potential factors of a given integer."}}
,{"_index":"throwtable","_type":"algorithm","_id":"constrained-clustering","_score":0,"_source":{"description":"In computer science, constrained clustering is a class of semi-supervised learning algorithms. Typically, constrained clustering incorporates either a set of must-link constraints, cannot-link constraints, or both, with a Data clustering algorithm. Both a must-link and a cannot-link constraint define a relationship between two data instances. A must-link constraint is used to specify that the two instances in the must-link relation should be associated with the same cluster. A cannot-link constraint is used to specify that the two instances in the cannot-link relation should not be associated with the same cluster. These sets of constraints acts as a guide for which a constrained clustering algorithm will attempt to find clusters in a data set which satisfy the specified must-link and cannot-link constraints. Some constrained clustering algorithms will abort if no such clustering exists which satisfies the specified constraints. Others will try to minimize the amount of constraint violation should it be impossible to find a clustering which satisfies the constraints. Constraints could also be used to guide the selection of a clustering model among several possible solutions. \nExamples of constrained clustering algorithms include:\nCOP K-means \nPCKmeans\nCMWK-Means \n^ Pourrajabi, M.; Moulavi, D.; Campello, R. J. G. B.; Zimek, A.; Sander, J.; Goebel, R. (2014). \"Model Selection for Semi-Supervised Clustering\". Proceedings of the 17th International Conference on Extending Database Technology (EDBT),. pp. 331–342. doi:10.5441/002/edbt.2014.31. \n^ Wagstaff, K.; Cardie, C.; Rogers, S.; Schrödl, S. (2001). \"Constrained K-means Clustering with Background Knowledge\". Proceedings of the Eighteenth International Conference on Machine Learning. pp. 577–584. \n^ de Amorim, R. C. (2012). \"Constrained Clustering with Minkowski Weighted K-Means\". Proceedings of the 13th IEEE International Symposium on Computational Intelligence and Informatics. pp. 13–17. doi:10.1109/CINTI.2012.6496753.","alt_names":["- Constrained clustering :","Constrained clustering","Constrained clustering - Wikipedia, the free encyclopedia","Constrained clustering by Wikipedia","Learn about Constrained clustering>>>","Wikipedia (Constrained clustering)","Wikipedia article Constrained clustering","clustering with constraints","en:Constrained clustering","http://en.wikipedia.org/wiki/Constrained_clustering"],"name":"Constrained clustering","categories":["All stub articles","Cluster analysis","Computer science stubs","Data clustering algorithms"],"tag_line":"In computer science, constrained clustering is a class of semi-supervised learning algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"k-nearest-neighbors-algorithm","_score":0,"_source":{"description":"In pattern recognition, the k-Nearest Neighbors algorithm (or k-NN for short) is a non-parametric method used for classification and regression. In both cases, the input consists of the k closest training examples in the feature space. The output depends on whether k-NN is used for classification or regression:\n\nIn k-NN classification, the output is a class membership. An object is classified by a majority vote of its neighbors, with the object being assigned to the class most common among its k nearest neighbors (k is a positive integer, typically small). If k = 1, then the object is simply assigned to the class of that single nearest neighbor.\n\nIn k-NN regression, the output is the property value for the object. This value is the average of the values of its k nearest neighbors.\n\nk-NN is a type of instance-based learning, or lazy learning, where the function is only approximated locally and all computation is deferred until classification. The k-NN algorithm is among the simplest of all machine learning algorithms.\nBoth for classification and regression, it can be useful to assign weight to the contributions of the neighbors, so that the nearer neighbors contribute more to the average than the more distant ones. For example, a common weighting scheme consists in giving each neighbor a weight of 1/d, where d is the distance to the neighbor.\nThe neighbors are taken from a set of objects for which the class (for k-NN classification) or the object property value (for k-NN regression) is known. This can be thought of as the training set for the algorithm, though no explicit training step is required.\nA shortcoming of the k-NN algorithm is that it is sensitive to the local structure of the data. The algorithm has nothing to do with and is not to be confused with k-means, another popular machine learning technique.","alt_names":[],"name":"K-nearest neighbors algorithm","categories":["All articles with unsourced statements","Articles with unsourced statements from December 2008","Articles with unsourced statements from March 2013","CS1 errors: external links","Classification algorithms","Machine learning algorithms","Search algorithms"],"tag_line":"In pattern recognition, the k-Nearest Neighbors algorithm (or k-NN for short) is a non-parametric method used for classification and regression."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cobweb-(clustering)","_score":0,"_source":{"description":"COBWEB is an incremental system for hierarchical conceptual clustering. COBWEB was invented by Professor Douglas H. Fisher, currently at Vanderbilt University.\nCOBWEB incrementally organizes observations into a classification tree. Each node in a classification tree represents a class (concept) and is labeled by a probabilistic concept that summarizes the attribute-value distributions of objects classified under the node. This classification tree can be used to predict missing attributes or the class of a new object.\nThere are four basic operations COBWEB employs in building the classification tree. Which operation is selected depends on the category utility of the classification achieved by applying it. The operations are:\nMerging Two Nodes\nMerging two nodes means replacing them by a node whose children is the union of the original nodes' sets of children and which summarizes the attribute-value distributions of all objects classified under them.\nSplitting a node\nA node is split by replacing it with its children.\nInserting a new node\nA node is created corresponding to the object being inserted into the tree.\nPassing an object down the hierarchy\nEffectively calling the COBWEB algorithm on the object and the subtree rooted in the node.","alt_names":["COBWEB","Cobweb (Clustering)","Cobweb (clustering)","Cobweb (clustering) - Wikipedia, the free encyclopedia","Cobweb (clustering) - Wikipedia, the free encyclopedia ...","Cobweb clustering","Read More cobweb clustering wikipedia the free encyclopedia","Wikipedia article Cobweb (clustering)","Wikipedia entry for Cobweb (clustering)","Wikipedia:COBWEB","http://en.wikipedia.org/wiki/Cobweb (clustering)","http://en.wikipedia.org/wiki/Cobweb_%28clustering%29","http://en.wikipedia.org/wiki/Cobweb_(clustering)"],"name":"Cobweb (clustering)","categories":["Artificial intelligence","Data clustering algorithms"],"tag_line":"COBWEB is an incremental system for hierarchical conceptual clustering."}}
,{"_index":"throwtable","_type":"algorithm","_id":"decision-boundary","_score":0,"_source":{"description":"In a statistical-classification problem with two classes, a decision boundary or decision surface is a hypersurface that partitions the underlying vector space into two sets, one for each class. The classifier will classify all the points on one side of the decision boundary as belonging to one class and all those on the other side as belonging to the other class.\nA decision boundary is the region of a problem space in which the output label of a classifier is ambiguous.\nIf the decision surface is a hyperplane, then the classification problem is linear, and the classes are linearly separable.\nDecision boundaries are not always clear cut. That is, the transition from one class in the feature space to another is not discontinuous, but gradual. This effect is common in fuzzy logic based classification algorithms, where membership in one class or another is ambiguous.","alt_names":["- Decision boundary :","...more on Wikipedia about Decision boundary","Decision Boundary","Decision boundary","Decision boundary - Wikipedia, the free encyclopedia","Decision boundary Wikipedia the free encyclopedia","Wikipedia article Decision boundary","Wikipedia article Decision surfaces","Wikipedia entry for Decision boundary","decision boundaries","decision boundary","http://en.wikipedia.org/wiki/Decision_bo","http://en.wikipedia.org/wiki/Decision_boundary","límite de la decisión","yago-res:Decision boundary"],"name":"Decision boundary","categories":["All articles needing additional references","All stub articles","Articles needing additional references from September 2014","Artificial intelligence stubs","Classification algorithms","Pattern recognition","Statistical classification"],"tag_line":"In a statistical-classification problem with two classes, a decision boundary or decision surface is a hypersurface that partitions the underlying vector space into two sets, one for each class."}}
,{"_index":"throwtable","_type":"algorithm","_id":"nearest-neighbor-chain-algorithm","_score":0,"_source":{"description":"In the theory of cluster analysis, the nearest-neighbor chain algorithm is a method that can be used to perform several types of agglomerative hierarchical clustering, using an amount of memory that is linear in the number of points to be clustered and an amount of time linear in the number of distinct distances between pairs of points. The main idea of the algorithm is to find pairs of clusters to merge by following paths in the nearest neighbor graph of the clusters until the paths terminate in pairs of mutual nearest neighbors. The algorithm was developed and implemented in 1982 by J. P. Benzécri and J. Juan, based on earlier methods that constructed hierarchical clusterings using mutual nearest neighbor pairs without taking advantage of nearest neighbor chains.","alt_names":[],"name":"Nearest-neighbor chain algorithm","categories":["Data clustering algorithms"],"tag_line":"In the theory of cluster analysis, the nearest-neighbor chain algorithm is a method that can be used to perform several types of agglomerative hierarchical clustering, using an amount of memory that is linear in the number of points to be clustered and an amount of time linear in the number of distinct distances between pairs of points."}}
,{"_index":"throwtable","_type":"algorithm","_id":"k-q-flats","_score":0,"_source":{"description":"In data mining and machine learning,  -flats algorithm   is an iterative method which aims to partition  observations into  clusters where each cluster is close to a -flat, where  is a given integer.\nIt is a generalization of the -means algorithm. In -means algorithm, clusters are formed in the way that each cluster is close to one point, which is a -flat.  -flats algorithm gives better clustering result than -means algorithm for some data set.\n\n","alt_names":[],"name":"K q-flats","categories":["All articles needing expert attention","All articles that are too technical","Articles needing expert attention from December 2011","Data clustering algorithms","Wikipedia articles that are too technical from December 2011"],"tag_line":"In data mining and machine learning,  -flats algorithm   is an iterative method which aims to partition  observations into  clusters where each cluster is close to a -flat, where  is a given integer."}}
,{"_index":"throwtable","_type":"algorithm","_id":"linde–buzo–gray-algorithm","_score":0,"_source":{"description":"The Linde–Buzo–Gray algorithm (introduced by Yoseph Linde, Andrés Buzo and Robert M. Gray in 1980) is a vector quantization algorithm to derive a good codebook.\nIt is similar to the k-means method in data clustering.","alt_names":[],"name":"Linde–Buzo–Gray algorithm","categories":["Algorithms and data structures stubs","All articles lacking reliable references","All stub articles","Articles lacking reliable references from June 2012","Artificial neural networks","Computer science stubs","Data clustering algorithms","Machine learning algorithms"],"tag_line":"The Linde–Buzo–Gray algorithm (introduced by Yoseph Linde, Andrés Buzo and Robert M. Gray in 1980) is a vector quantization algorithm to derive a good codebook."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sukhotin's-algorithm","_score":0,"_source":{"description":"Sukhotin's algorithm (introduced by Boris V. Sukhotin) is a statistical classification algorithm for classifying characters in a text as vowels or consonants. It may also be of use in some of substitution ciphers and has been considered in deciphering the Voynich manuscript, though one problem is to agree on the set of symbols the manuscript is written in.","alt_names":[],"name":"Sukhotin's algorithm","categories":["Classification algorithms","Natural language processing"],"tag_line":"Sukhotin's algorithm (introduced by Boris V. Sukhotin) is a statistical classification algorithm for classifying characters in a text as vowels or consonants."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fftw","_score":0,"_source":{"description":"The Fastest Fourier Transform in the West (FFTW) is a software library for computing discrete Fourier transforms (DFTs) developed by Matteo Frigo and Steven G. Johnson at the Massachusetts Institute of Technology.\nFFTW is known as the fastest free software implementation of the Fast Fourier transform (FFT) algorithm (upheld by regular benchmarks). It can compute transforms of real and complex-valued arrays of arbitrary size and dimension in O(n log n) time.\nIt does this by supporting a variety of algorithms and choosing the one (a particular decomposition of the transform into smaller transforms) it estimates or measures to be preferable in the particular circumstances. It works best on arrays of sizes with small prime factors, with powers of two being optimal and large primes being worst case (but still O(n log n)). To decompose transforms of composite sizes into smaller transforms, it chooses among several variants of the Cooley–Tukey FFT algorithm (corresponding to different factorizations and/or different memory-access patterns), while for prime sizes it uses either Rader's or Bluestein's FFT algorithm. Once the transform has been broken up into subtransforms of sufficiently small sizes, FFTW uses hard-coded unrolled FFTs for these small sizes that were produced (at compile time, not at run time) by code generation; these routines use a variety of algorithms including Cooley–Tukey variants, Rader's algorithm, and prime-factor FFT algorithms.\nFor a sufficiently large number of repeated transforms it is advantageous to measure the performance of some or all of the supported algorithms on the given array size and platform. These measurements, which the authors refer to as \"wisdom\", can be stored in a file or string for later use.\nFFTW has a \"guru interface\" that intends \"to expose as much as possible of the flexibility in the underlying FFTW architecture\". This allows, among other things, multi-dimensional transforms and multiple transforms in a single call (e.g., where the data is interleaved in memory).\nFFTW has limited support for out-of-order transforms (using the MPI version). The data reordering incurs an overhead, which for in-place transforms of arbitrary size and dimension is non-trivial to avoid. It is undocumented for which transforms this overhead is significant.\nFFTW is licensed under the GNU General Public License. It is also licensed commercially by MIT and is used in the commercial MATLAB matrix package for calculating FFTs. FFTW is written in the C language, but Fortran and Ada interfaces exist, as well as interfaces for a few other languages. The Julia base library includes an interface to FFTW by default.  While the library itself is C, the code is actually generated from a program called 'genfft', which is written in OCaml.\nIn 1999, FFTW won the J. H. Wilkinson Prize for Numerical Software.\n^ a b c Frigo M, Johnson SG (February 2005). \"The design and implementation of FFTW3\" (PDF). Proceedings of the IEEE 93 (2): 216–231. doi:10.1109/JPROC.2004.840301. \n^ Frigo M, Johnson SG (1998). \"FFTW: an adaptive software architecture for the FFT\". Proceedings of the 1998 IEEE International Conference on Acoustics, Speech and Signal Processing 3: 1381–1384. doi:10.1109/ICASSP.1998.681704. \n^ Johnson SG and Frigo M (September 2008). \"ch.11: Implementing FFTs in practice\". In C. S. Burrus. Fast Fourier Transforms. Houston TX: Connexions: Rice University. \n^ Homepage, second paragraph [1], and benchmarks page [2]\n^ [3]\n^ Faster Finite Fourier Transforms: MATLAB 6 incorporates FFTW\n^ \"Julia stdlib documentation\"\n^ \"FFTW FAQ\"","alt_names":["- FFTW :","...Wikipedia FFTW","FFTW","FFTW - Wikipedia","FFTW - Wikipedia, the free encyclopedia","FFTW - Wikipedia：日本語解説","FFTW - Wikipédia","FFTW FTW","FFTW Wikipedia the free encyclopedia","FFTW at wikipedia","FFTW from Wikipedia","FFTW has limited support for out-of-order","FFTW in Wikipedia","FFTW is known as the fastest free software","FFTW – Wikipedia, wolna encyklopedia","FFTW-wikipedia","FFTW; it is used under the","FFTWは","FFTWを","FFTw","Fastest Fourier Transform in the West","Fftw","Look for Pl:FFTW","Source Wikipedia.org Arcticle - FFTW","Wikipedia article FFTW","Wikipedia article on FFTW","Wikipedia entry for FFTW","Wikipedia l'articolo FFTw","Wikipedia:FFTw","Wikipediaで「FFTW」を調べる","en.wikipedia.org/wiki/FFTW","fftw - Wikipedia, the free encyclopedia","http://en.wikipedia.org/wiki/FFTW","http://fr.wikipedia.org/wiki/FFTW","http://it.wikipedia.org/wiki/FFTW","http://it.wikipedia.org/wiki/FFTw","http://ja.wikipedia.org/wiki/FFTW","http://pl.wikipedia.org/wiki/FFTW","ja:FFTW","pl:FFTW","the west is the best","very bright people","yago-res:FFTW","“Fastest Fourier Transform in the West”","的FFTW"],"name":"FFTW","categories":["FFT algorithms","Free mathematics software","Numerical libraries","OCaml software"],"tag_line":"The Fastest Fourier Transform in the West (FFTW) is a software library for computing discrete Fourier transforms (DFTs) developed by Matteo Frigo and Steven G. Johnson at the Massachusetts Institute of Technology."}}
,{"_index":"throwtable","_type":"algorithm","_id":"algorithms-for-recovery-and-isolation-exploiting-semantics","_score":0,"_source":{"description":"In computer science, Algorithms for Recovery and Isolation Exploiting Semantics, or ARIES is a recovery algorithm designed to work with a no-force, steal database approach; it is used by IBM DB2, Microsoft SQL Server and many other database systems.\nThree main principles lie behind ARIES\nWrite ahead logging: Any change to an object is first recorded in the log, and the log must be written to stable storage before changes to the object are written to disk.\nRepeating history during Redo: On restart after a crash, ARIES retraces the actions of a database before the crash and brings the system back to the exact state that it was in before the crash. Then it undoes the transactions still active at crash time.\nLogging changes during Undo: Changes made to the database while undoing transactions are logged to ensure such an action isn't repeated in the event of repeated restarts.","alt_names":["...more on Wikipedia about Algorithms for Recovery and","ARIES (Informatik)","ARIES (Informatik) ? Wikipedia","ARIES (Informatik) – Wikipedia","ARIES Algorithms for Recovery and Isolation Exploiting Semantics","ARIES-style","ARIES_(Informatik)","Algorithms for Recovery and Isolati Exploiting Semantics ...","Algorithms for Recovery and Isolation Exploiting Semantics","Algorithms for Recovery and Isolation Exploiting Semantics - Wikipedia","Algorithms for Recovery and Isolation Exploiting Semantics -...","Algorithms for Recovery and Isolation Exploiting Semantics ...","Algorithms for Recovery and Isolation Exploiting Semantics ...Repeating","Algorithms for Recovery and Isolation Exploiting Semantics; it","Learn about Algorithms for Recovery and Isolation Exploiting","WAL compliant","What did Algorithms for recovery and isolation exploiting","Wikipedia - ARIES","Wikipedia article ''Algorithms for Recovery and Isolation Exploiting","Wikipedia article Algorithms for Recovery and Isolation Exploiting","Wikipedia article on Algorithms for Recovery and Isolation","Wikipedia auf ARIES","Wikipedia di Aries","Wikipedia en ARIES","Wikipedia entry for Algorithms for Recovery and Isolation","Wikipedia on ARIES","Wikipedia su ARIES","Wikipedia trên Aries","Wikipedia-Artikel ARIES (Informatik)","Wikipedia-Seite zu 'ARIES (Informatik)'","Wikipédia ARIES","Wikipédia em ARIES","de:ARIES (Informatik)","http://de.wikipedia.org/wiki/ARIES_(Informatik)","http://en.wikipedia.org/wiki/Algorithms … _Semantics","http://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semant","http://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics","Википедия ОВЕН","วิกิพีเดียในราศีเมษ","出典：牡羊に","維基百科對白羊座","维基百科对白羊座","위키백과 양자리에"],"name":"Algorithms for Recovery and Isolation Exploiting Semantics","categories":["All articles lacking in-text citations","Articles lacking in-text citations from March 2013","Database algorithms"],"tag_line":"In computer science, Algorithms for Recovery and Isolation Exploiting Semantics, or ARIES is a recovery algorithm designed to work with a no-force, steal database approach; it is used by IBM DB2, Microsoft SQL Server and many other database systems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"multifactor-dimensionality-reduction","_score":0,"_source":{"description":"Multifactor dimensionality reduction (MDR) is a data mining approach for detecting and characterizing combinations of attributes or independent variables that interact to influence a dependent or class variable. MDR was designed specifically to identify interactions among discrete variables that influence a binary outcome and is considered a nonparametric alternative to traditional statistical methods such as logistic regression.\nThe basis of the MDR method is a constructive induction algorithm that converts two or more variables or attributes to a single attribute. This process of constructing a new attribute changes the representation space of the data. The end goal is to create or discover a representation that facilitates the detection of nonlinear or nonadditive interactions among the attributes such that prediction of the class variable is improved over that of the original representation of the data.","alt_names":["Data mining with MDR","Multifactor Dimensionality Reduction","Multifactor Dimensionality Reduction - Wikipedia, The Free ...","Multifactor dimensiality reducti the free ...","Multifactor dimensionality reduction","Multifactor dimensionality reduction - Wikipedia, the free ...","Multifactor dimensionality reduction - Wikipedia, the free encyclopedia","Multifactor dimensionality reduction Wikipedia the free","Multifactor dimensionality reduction – Wikipedia, the free encyclopedia","Multifactor_dimensionality_reduction","What is software of Multifactor dimensionality reduction","Wikipedia article Multifactor dimensionality reduction","Wikipedia article explaining the concept of MDR","Wikipedia article on Multifactor dimensionality reduction","Wikipedia entry for Multifactor dimensionality reduction","en.wikipedia.org/wiki/Multifactor_dimensionality_reduction","http://en.wikipedia.org/wiki/Multifactor_dimensionality_reduction","ltifactor","multifactor dimensionality reductio","multifactor dimensionality reduction","reducción de dimensionalidad multifactorial","redução de *dimensionalidad *multifactorial","réduction de dimensionalidad multifactorial"],"name":"Multifactor dimensionality reduction","categories":["All articles lacking in-text citations","All articles with unsourced statements","Articles lacking in-text citations from November 2010","Articles with unsourced statements from December 2010","Classification algorithms","Data mining","Dimension reduction","Use dmy dates from December 2010"],"tag_line":"Multifactor dimensionality reduction (MDR) is a data mining approach for detecting and characterizing combinations of attributes or independent variables that interact to influence a dependent or class variable."}}
,{"_index":"throwtable","_type":"algorithm","_id":"logitboost","_score":0,"_source":{"description":"In machine learning and computational learning theory, LogitBoost is a boosting algorithm formulated by Jerome Friedman, Trevor Hastie, and Robert Tibshirani. The original paper casts the AdaBoost algorithm into a statistical framework. Specifically, if one considers AdaBoost as a generalized additive model and then applies the cost functional of logistic regression, one can derive the LogitBoost algorithm.","alt_names":["- LogitBoost :","LogLossBoost (LogitBoost)","LogitBoost","LogitBoost - Wikipedia, the free encyclopedia","LogitBoost by Wikipedia","Wikipedia article LogitBoost","Wikipedia article on LogitBoost","Wikipedia entry for LogitBoost","en.wikipedia.org/wiki/LogitBoost","http://en.wikipedia.org/wiki/LogitBoost","yago-res:LogitBoost","∑ i log 1 + e - y i f ( x"],"name":"LogitBoost","categories":["All stub articles","Artificial intelligence stubs","Classification algorithms","Ensemble learning","Machine learning algorithms"],"tag_line":"In machine learning and computational learning theory, LogitBoost is a boosting algorithm formulated by Jerome Friedman, Trevor Hastie, and Robert Tibshirani."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rules-extraction-system-family","_score":0,"_source":{"description":"Rules Extraction System (RULES) is one family of inductive learning that include several covering algorithms. This family is used to build a predictive model based on given observation. It works based on the concept of separate-and-conquer to directly induce rules from a given training set and build its knowledge repository.\nAlgorithms under RULES family are usually available in data mining tools, such as KEEL and WEKA, known for knowledge extraction and decision making.","alt_names":[],"name":"Rules Extraction System Family","categories":["All orphaned articles","Classification algorithms","Knowledge engineering","Orphaned articles from February 2015"],"tag_line":"Rules Extraction System (RULES) is one family of inductive learning that include several covering algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"shepp–logan-phantom","_score":0,"_source":{"description":"The Shepp–Logan phantom is a standard test image created by Larry Shepp and Benjamin F. Logan for their 1974 paper The Fourier Reconstruction of a Head Section. It serves as the model of a human head in the development and testing of image reconstruction algorithms.","alt_names":[],"name":"Shepp–Logan phantom","categories":["1974 works","Algorithms and data structures stubs","All stub articles","Computer science stubs","Image processing","Test items"],"tag_line":"The Shepp–Logan phantom is a standard test image created by Larry Shepp and Benjamin F. Logan for their 1974 paper The Fourier Reconstruction of a Head Section."}}
,{"_index":"throwtable","_type":"algorithm","_id":"learning-vector-quantization","_score":0,"_source":{"description":"In computer science, learning vector quantization (LVQ), is a prototype-based supervised classification algorithm. LVQ is the supervised counterpart of vector quantization systems.\n\n","alt_names":[],"name":"Learning vector quantization","categories":["Artificial neural networks","Classification algorithms"],"tag_line":"In computer science, learning vector quantization (LVQ), is a prototype-based supervised classification algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cuckoo-search","_score":0,"_source":{"description":"Cuckoo search (CS) is an optimization algorithm developed by Xin-she Yang and Suash Deb in 2009. It was inspired by the obligate brood parasitism of some cuckoo species by laying their eggs in the nests of other host birds (of other species). Some host birds can engage direct conflict with the intruding cuckoos. For example, if a host bird discovers the eggs are not their own, it will either throw these alien eggs away or simply abandon its nest and build a new nest elsewhere. Some cuckoo species such as the New World brood-parasitic Tapera have evolved in such a way that female parasitic cuckoos are often very specialized in the mimicry in colors and pattern of the eggs of a few chosen host species \nCuckoo search idealized such breeding behavior, and thus can be applied for various optimization problems. It seems that it can outperform other metaheuristic algorithms in applications.\nCuckoo search (CS) uses the following representations:\nEach egg in a nest represents a solution, and a cuckoo egg represents a new solution. The aim is to use the new and potentially better solutions (cuckoos) to replace a not-so-good solution in the nests. In the simplest form, each nest has one egg. The algorithm can be extended to more complicated cases in which each nest has multiple eggs representing a set of solutions.\nCS is based on three idealized rules:\nEach cuckoo lays one egg at a time, and dumps its egg in a randomly chosen nest;\nThe best nests with high quality of eggs will carry over to the next generation;\nThe number of available hosts nests is fixed, and the egg laid by a cuckoo is discovered by the host bird with a probability . Discovering operate on some set of worst nests, and discovered solutions dumped from farther calculations.\nIn addition, Yang and Deb discovered that the random-walk style search is better performed by Lévy flights rather than simple random walk.\nThe pseudo-code can be summarized as:\n\nObjective function: \nGenerate an initial population of  host nests; \nWhile (t<MaxGeneration) or (stop criterion)\n   Get a cuckoo randomly (say, i) and replace its solution by performing Lévy flights;\n   Evaluate its quality/fitness \n         [For maximization,  ];\n   Choose a nest among n (say, j) randomly;\n   if (),\n          Replace j by the new solution;\n   end if\n   A fraction () of the worse nests are abandoned and new ones are built;\n   Keep the best solutions/nests;\n   Rank the solutions/nests and find the current best;\n   Pass the current best solutions to the next generation;\nend while\n\nAn important advantage of this algorithm is its simplicity. In fact, comparing with other population- or agent-based metaheuristic algorithms such as particle swarm optimization and harmony search, there is essentially only a single parameter  in CS (apart from the population size ). Therefore, it is very easy to implement.","alt_names":["- Cuckoo search :","Cuckoo search","Cuckoo search - Wikipedia :: The free encyclopedia","Cuckoo search - Wikipedia, the free encyclopedia","What is a Cuckoo search","Wikipedia article Cuckoo search","Wikipedia article on Cuckoo search","Wikipedia entry for Cuckoo search","cuckoo search","http://en.wikipedia.org/wiki/Cuckoo_search","yago-res:Cuckoo search"],"name":"Cuckoo search","categories":["All articles needing additional references","Articles needing additional references from June 2015","Evolutionary algorithms","Optimization algorithms and methods","Pages using citations with accessdate and no URL"],"tag_line":"Cuckoo search (CS) is an optimization algorithm developed by Xin-she Yang and Suash Deb in 2009."}}
,{"_index":"throwtable","_type":"algorithm","_id":"evolutionary-programming","_score":0,"_source":{"description":"Evolutionary programming is one of the four major evolutionary algorithm paradigms. It is similar to genetic programming, but the structure of the program to be optimized is fixed, while its numerical parameters are allowed to evolve.\nIt was first used by Lawrence J. Fogel in the US in 1960 in order to use simulated evolution as a learning process aiming to generate artificial intelligence. Fogel used finite state machines as predictors and evolved them. Currently evolutionary programming is a wide evolutionary computing dialect with no fixed structure or (representation), in contrast with some of the other dialects. It is becoming harder to distinguish from evolutionary strategies.\nIts main variation operator is mutation; members of the population are viewed as part of a specific species rather than members of the same species therefore each parent generates an offspring, using a (μ + μ) survivor selection.","alt_names":["Evolutionary Programming","evolutionary programming","-> Read more about Evolutionary programming","...Wikipedia Programación evolutiva","...Wikipedia Programowanie ewolucyjne","...mehr auf Wikipedia über Evolutionäre Programmierung","Evolucijsko programiranje","Evolution%C3%A4re_Programmierung bei der wikipedia","Evolutionary programming","Evolutionary programming - Wikipedia, the free encyclopedia","Evolutionary programming; it is used under the","Evolutionäre Programmierung","Evolutionäre Programmierung – Wikipedia","Evolutionäre Programmierung — Wikipedia","Genetic Programming or Evolutionary Programming","Programación Evolutiva","Programación evolutiva","Programowanie ewolucyjne","Source Wikipedia.org Arcticle - Evolutionary programming","The First Evolutionary Programming Implementation","What is a Evolutionary programming","Wikipedia Programación evolutiva","Wikipedia article Evolutionary programming","Wikipedia article Programación evolutiva","Wikipedia article about Evolutionary programming","Wikipedia article on Evolutionary programming","Wikipedia entry for Evolutionary programming","Wikipedia-Artikel Evolutionäre Programmierung","Wikipedia-Seite zu 'Evolutionäre Programmierung'","Wikipediaで「進化プログラミング」を調べる","artículo de Wikipedia Programacion evolutiva","artículo de Wikipedia Programación evolutiva","de:Evolutionäre Programmierung","en.wikipedia.org/wiki/Evolutionary_programming","es:Programación evolutiva","evolutionary programing","evolutionary(演化) programming","http://de.wikipedia.org/wiki/Evolution%C3%A4re_Programmierung","http://de.wikipedia.org/wiki/Evolutionäre_Programmierung","http://en.wikipedia.org/wiki/Evolutionary_programming","http://es.wikipedia.org/wiki/Programaci%C3%B3n_evolutiva","http://pl.wikipedia.org/wiki/Programowanie_ewolucyjne","ja:進化的プログラミング","pl:Programowanie ewolucyjne","programación evolutiva","programowanie ewolucyjne","tune the child GA's parameters","yago-res:Evolutionary programming","you apply evolution to something like computer programming","Эволюционное программирование","эволюционное программирование","эволюционную программу","ウィキペディアの記事 進化的プログラミング","進化プログラミング - Wikipedia","進化的プログラミング","進化的プログラミング - Wikipedia","進化的ﾌﾟﾛｸﾞﾗﾐﾝｸﾞ-wikipedia"],"name":"Evolutionary programming","categories":["All stub articles","Computer science stubs","Evolutionary algorithms","Optimization algorithms and methods"],"tag_line":"Evolutionary programming is one of the four major evolutionary algorithm paradigms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"eagle-strategy","_score":0,"_source":{"description":"Eagle strategy is a search strategy for solving nonlinear optimization problems, and this strategy was developed by Xin-she Yang and Suash Deb, based on the foraging behaviour of eagle species such as golden eagles.\nIn optimization, a common strategy is to search for the optimal solution starting from a set of initial guess solutions (either random and educated guess). In the case when the cost functions are multimodal with multiple local best solutions, the final solutions may heavily depend on the initial starting solutions. In order to minimize such dependence on initial random solutions, most modern algorithms, especially metaheuristic algorithms, are able to escape local optima by using some sophisticated random techniques. However, most of these algorithms are one-stage type; that is, once initialization is done, the search process continues until an algorithm stops. Running an algorithm many times from different initial solutions may occasionally improve the overall performance on average.\nEagle strategy improves this by using an iterative, interacting two-stage strategy to enhance the search efficiency by escaping the local optima and use initial solutions in different regions. It uses a slow search stage and a fast stage to simulate an eagle searching for prey tends to search on a large area and then quickly switches to a rapid chasing phase once a prey is in sight. In optimization, it uses a coarse search stage on a larger area in a search space in combination with an intensive faster search algorithm in the neighbourhood of promising solutions. Two stages interchanges and proceed iteratively.\nAs there are two stages in the strategy, each stage can employ different algorithms. For example, differential evolution can be used within eagle strategy. Studies show that such a combination is better than any of its components.\nIn the simplest case, when the first stage does not use any algorithm (just initialization), it essentially degenerates into a hill-climbing with random restart. However, this strategy could be potentially much more powerful if a good combination of different algorithms is used.","alt_names":[],"name":"Eagle strategy","categories":["Artificial intelligence","Evolutionary algorithms","Optimization algorithms and methods"],"tag_line":"Eagle strategy is a search strategy for solving nonlinear optimization problems, and this strategy was developed by Xin-she Yang and Suash Deb, based on the foraging behaviour of eagle species such as golden eagles."}}
,{"_index":"throwtable","_type":"algorithm","_id":"evolutionary-algorithm-for-landmark-detection","_score":0,"_source":{"description":"there are several algorithms for locating landmarks in images such as satellite maps, medical images etc.\nnowadays evolutionary algorithms such as particle swarm optimization are so useful to perform this task. evolutionary algorithms generally have two phase, training and test.\nin the training phase, we try to learn the algorithm to locate landmark correctly. this phase performs in some iterations and finally in the last iteration we hope to obtain a system that can locate the landmark, correctly. in the particle swarm optimization there are some particles that search for the landmark. each particle uses a specific formula in each iteration to optimizes the landmark detecting.\nThe fundamental particle swarm optimization algorithm used in training phase generally as follows:\nRandomly initialise 100 individuals in the search space in the range [-1,1]\nLOOP UNTIL 100 iterations performed OR detection error of gbest is 0%\nFOR each particle p\nDetection errors at x = 0\nFOR each image i in training set\nFOR each pixel coordinate c in i\nEvaluate x of p on visual features at c\nIF evaluation is highest so far for i THEN\nDetected position in i = c\nIF distance between detected position and marked-up position > 2mm THEN\nDetection errors at x = Detection errors at x + 1\nFitness of p at x = 1- ( Detection errors at x /Total no. of images in training set)\nIF new _tness of p at x > previous _tness of p at pbest THEN\npbest _tness of p = new _tness of p at x\npbest position of p = x of p\nIF new _tness of p at x > previous gbest _tness THEN\ngbest _tness = new _tness of p at x\ngbest position of p = x of p\nFOR each particle p\nCalculate v of p\nIF magnitude of v > v max THEN\nMagnitude of v = v max\nMove x of p to next position using v\nIF x of p outside [-1,1] range THEN\nx of p = -1 or 1 as appropriate\nREPEAT\nOutput gbest of last iteration as trained detector d","alt_names":["Evolutionary Algorithm for Landmark Detection","Evolutionary algorithm for landmark detection","Learn about Evolutionary Algorithm for Landmark Detection>>>","http://en.wikipedia.org/wiki/Evolutionary_Algorithm_for_Landmark_Detection"],"name":"Evolutionary Algorithm for Landmark Detection","categories":["All articles needing cleanup","All articles needing expert attention","All orphaned articles","Articles needing cleanup from December 2010","Articles needing expert attention from December 2010","Articles needing expert attention with no reason or talk parameter","Articles needing unspecified expert attention","Cleanup tagged articles without a reason field from December 2010","Evolutionary algorithms","Orphaned articles from November 2010","Wikipedia pages needing cleanup from December 2010"],"tag_line":"there are several algorithms for locating landmarks in images such as satellite maps, medical images etc."}}
,{"_index":"throwtable","_type":"algorithm","_id":"neuroevolution","_score":0,"_source":{"description":"Neuroevolution, or neuro-evolution, is a form of machine learning that uses evolutionary algorithms to train artificial neural networks. It is most commonly applied in artificial life, computer games, and evolutionary robotics. A main benefit is that neuroevolution can be applied more widely than supervised learning algorithms, which require a syllabus of correct input-output pairs. In contrast, neuroevolution requires only a measure of a network's performance at a task. For example, the outcome of a game (i.e. whether one player won or lost) can be easily measured without providing labeled examples of desired strategies.","alt_names":["- Neuroevolution :","-> Read more about Neuroevolution","...more on Wikipedia about Neuroevolution","Direct and Indirect Encoding of Networks","NeuroEvolution","Neuroevolution","Neuroevolution (NE)","Neuroevolution - Wikipedia","Neuroevolution - Wikipedia, ...","Neuroevolution - Wikipedia, the free ...","Neuroevolution - Wikipedia, the free encyclopedia","Neuroevolution - Wikipedia, the free encyclopedia wikipedia.org Neuroevolution","Neuroevolution Wikipedia the free encyclopedia","Neuroevolution →","Neuroevolution; it is used under the","Source Wikipedia.org Arcticle - Neuroevolution","What are the features of Neuroevolution","Wikipedia (Neuroevolution)","Wikipedia article ''Neuroevolution''","Wikipedia article Neuroevolution","Wikipedia article about Neuroevolution","Wikipedia article on Neuroevolution","Wikipedia entry for Neuroevolution","Wikipediaで「Neuroevolution」を調べる","edit] Taxonomy of Embryogenic Systems for Indirect Encoding","en.wikipedia.org/wiki/Neuroevolution","existing work","http://en.wikipedia.org/wiki/Neuroevolut","http://en.wikipedia.org/wiki/Neuroevolution","http://ja.wikipedia.org/wiki/Neuroevolution","neiroevolūcijas","neuro-evolutie","neuroevolution","neuroevolution algorithm","the branch of science that evolves neural networks","yago-res:Neuroevolution","Нейроэволюция"],"name":"Neuroevolution","categories":["Evolutionary algorithms"],"tag_line":"Neuroevolution, or neuro-evolution, is a form of machine learning that uses evolutionary algorithms to train artificial neural networks."}}
,{"_index":"throwtable","_type":"algorithm","_id":"natural-evolution-strategy","_score":0,"_source":{"description":"Natural evolution strategies (NES) are a family of numerical optimization algorithms for black-box problems. Similar in spirit to evolution strategies, they iteratively update the (continuous) parameters of a search distribution by following the natural gradient towards higher expected fitness.\n\n","alt_names":["Natural Evolution Strategies","Natural evolution strategies","Natural evolution strategy","http://en.wikipedia.org/wiki/Natural_evolution_strategy","natural evolution strategies"],"name":"Natural evolution strategy","categories":["All articles lacking in-text citations","Articles lacking in-text citations from March 2015","Articles with example pseudocode","Evolutionary algorithms","Optimization algorithms and methods","Stochastic optimization"],"tag_line":"Natural evolution strategies (NES) are a family of numerical optimization algorithms for black-box problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cache-oblivious-matrix-multiplication","_score":0,"_source":{"description":"Rectangular matrices can be multiplied when the size of the cache and cache line is not known to the algorithm, or cache-obliviously. Cache-oblivious matrix multiplication was first formalized by Harald Prokop.","alt_names":[],"name":"Cache-oblivious matrix multiplication","categories":["Analysis of algorithms","Cache (computing)","External memory algorithms","Matrix multiplication algorithms","Models of computation"],"tag_line":"Rectangular matrices can be multiplied when the size of the cache and cache line is not known to the algorithm, or cache-obliviously."}}
,{"_index":"throwtable","_type":"algorithm","_id":"closest-pair-of-points-problem","_score":0,"_source":{"description":"The closest pair of points problem or closest pair problem is a problem of computational geometry: given n points in metric space, find a pair of points with the smallest distance between them. The closest pair problem for points in the Euclidean plane was among the first geometric problems which were treated at the origins of the systematic study of the computational complexity of geometric algorithms.\nA naive algorithm of finding distances between all pairs of points and selecting the minimum requires O(dn2) time. It turns out that the problem may be solved in O(n log n) time in a Euclidean space or Lp space of fixed dimension d. In the algebraic decision tree model of computation, the O(n log n) algorithm is optimal. The optimality follows from the observation that the element uniqueness problem (with the lower bound of Ω(n log n) for time complexity) is reducible to the closest pair problem: checking whether the minimal distance is 0 after the solving of the closest pair problem answers the question whether there are two coinciding points.\nIn the computational model which assumes that the floor function is computable in constant time the problem can be solved in O(n log log n) time. If we allow randomization to be used together with the floor function, the problem can be solved in O(n) time.\n^ M. I. Shamos and D. Hoey. \"Closest-point problems.\" In Proc. 16th Annual IEEE Symposium on Foundations of Computer Science (FOCS), pp. 151—162, 1975 (DOI 10.1109/SFCS.1975.8)\n^ S. Fortune and J.E. Hopcroft. \"A note on Rabin's nearest-neighbor algorithm.\" Information Processing Letters, 8(1), pp. 20—23, 1979\n^ S. Khuller and Y. Matias. A simple randomized sieve algorithm for the closest-pair problem. Inf. Comput., 118(1):34—37,1995\n^ Richard Lipton (24 September 2011). \"Rabin Flips a Coin\".","alt_names":["Brute-force algorithm","Closest Pair Of Points Problem","Closest Pair of Points Problem","Closest Pair of Points Problem - Wikipedia","Closest Pair problem","Closest pair of points","Closest pair of points problem","Closest pair of points problem - Wikipedia, the free","Closest pair of points problem ...","Closest pair of points problem Wikipedia the free","Closest pair of points problem on wiki","Closest pair of points problem – Wikipedia, the free","Closest pair problem","Dichtestes Punktpaar","Dichtestes Punktpaar Wikipedia","Dichtestes Punktpaar – Wikipedia","Dichtestes Punktpaar-Problem","Dynamic closest-pair problem","Engstes Punktpaar - Wikipedia","Learn about Closest pair of points problem>>>","Problem najbližjega para točk","Problema do par de pontos mais próximo","Screenshot http://de.wikipedia.org/wiki/Dichtestes_Punktpaar","Suggested: closest pair of points problem","The Closest Pair Problem","Wikipedia article Closest pair of points problem","Wikipedia article Closest pair problem","Wikipedia article Dichtestes Punktpaar","Wikipedia article Problema do par de pontos mais","Wikipedia entry for Closest pair of points problem","Wikipedia-Artikel Dichtestes Punktpaar","Wikipedia-Artikel Engstes Punktpaar","Wikipedia-Seite zu 'Dichtestes Punktpaar'","Wikipédia artigo Par de pontos mais próximo","artigo da Wikipédia Par de pontos mais próximo","bichromatic closest pair problem","closest pair of points","closest pair of points problem","closest pair problem","closest pairs","closest-pair-of-points problem","coppia problema più vicina","de:Dichtestes Punktpaar","dichtstbijzijnde pair probleem","dichtstbijzijnde twee punten","en yakın iki nokta","en.wikipedia.org/...Closest_pair_of_points","en.wikipedia.org/wiki/Closest_pair_problem","en:Closest pair of points","http://de.wikipedia.org/wiki/Dichtestes_","http://de.wikipedia.org/wiki/Dichtestes_Punktpaar","http://en.wikipedia...._points_problem","http://en.wikipedia.org...t_pair_of_points_problem","http://en.wikipedia.org/wiki/Closest% 5Fpair% 5Fof","http://en.wikipedia.org/wiki/Closest% 5Fpair%% 5Fof","http://en.wikipedia.org/wiki/Closest%5Fpair%5Fof","http://en.wikipedia.org/wiki/Closest...points_problem","http://en.wikipedia.org/wiki/Closest_pai","http://en.wikipedia.org/wiki/Closest_pair_...lem#Planar_cas","http://en.wikipedia.org/wiki/Closest_pair_of_points","http://en.wikipedia.org/wiki/Closest_pair_of_points#Planar_case","http://en.wikipedia.org/wiki/Closest_pair_of_points.","http://en.wikipedia.org/wiki/Closest_pair_of_points_problem","http://en.wikipedia.org/wiki/Closest_pair_of_points_problem#Planar_case","http://en.wikipedia.org/wiki/Closest_pair_of_points_problem#Planar_case.","http://en.wikipedia.org/wiki/Closest_pair_problem","http://en.wikipedia.org/wiki/Closest_pair_problem~~V","http://en.wikipedia.org/wiki/Closest％5Fpair％の","http://sl.wikipedia.org/wiki/Problem_najbli%C5%BEjega_para_to","nächste Paar Problem","nächsten zwei Punkte","nærmeste par problemet","old homework assignment","problem najbliższe parę","problema de par más cercano","pt:Problema do par de pontos mais próximo","sl:problem najbližjega para točk","taking O(n log n) time","the closest pair of points problem","w:Closest pair of points problem","članak na engleskom","ближайшей пары точек","ближайших пары проблемы","задачи нахождения ближайшей пары точек","чланак на енглеском","点最接近的一对","问题最接近的一对"],"name":"Closest pair of points problem","categories":["All articles with unsourced statements","Articles with example pseudocode","Articles with unsourced statements from October 2015","Geometric algorithms"],"tag_line":"The closest pair of points problem or closest pair problem is a problem of computational geometry: given n points in metric space, find a pair of points with the smallest distance between them."}}
,{"_index":"throwtable","_type":"algorithm","_id":"jts-topology-suite","_score":0,"_source":{"description":"The Java Topology Suite (JTS) is an open source Java software library that provides an object model for Euclidean planar linear geometry together with a set of fundamental geometric functions. JTS is primarily intended to be used as a core component of vector-based geomatics software such as geographical information systems. It can also be used as a general-purpose library providing algorithms in computational geometry.\nJTS implements the geometry model and API defined in the OpenGIS Consortium Simple Features Specification for SQL.\nJTS defines a standards-compliant geometry system for building spatial applications; examples include viewers, spatial query processors, and tools for performing data validation, cleaning and integration. In addition to the Java library, the foundations of JTS and selected functions are maintained in a C++ port, for use in C-style linking on all major operating systems, in the form of the GEOS software library.\nJTS, and the GEOS port, are published under the GNU Lesser General Public License (LGPL).\n^ \"The 2012 Free and Open Source GIS Software Map – A Guide to facilitate Research, Development and Adoption\", S. Steiniger and A.J.S. Hunter\n^ \"Secrets of the JTS Topology Suite - M. Davis\" (PDF). Retrieved 2013-05-27.","alt_names":["JTS Topology Suite","JTS Topology Suite - Wikipedia, the free encyclopedia","JTS Topology Suite - Wikipedia, the free encyclopedia ...","JTS Topology Suite ? Wikipedia","JTS Topology Suite Wikipedia","JTS Topology Suite Wikipedia the free encyclopedia","JTS Topology Suite at Wikipedia","JTS Topology Suite – Wikipedia","JTS_Topology_Suite","Java Topology Suite","Java Topology Suite (JTS)","Java Topology Suite - Wikipedia, la enciclopedia libre","Java Topology Suite -Wikipedia, la enciclopedia libre","Jts Topology Suite","Projects using JTS","What is the history of JTS Topology Suite","Wikipedia - JTS Topology Suite","Wikipedia article JTS Topology Suite","Wikipedia entry for JTS Topology Suite","Wikipedia on JTS","Wikipedia-Artikel JTS Topology Suite","Wikipedia-Seite zu 'JTS Topology Suite'","artículo de Wikipedia Java Topology Suite","de:JTS Topology Suite","en.wikipedia.org/wiki/JTS_Topology_Suite","es:Java Topology Suite","http://de.wikipedia.org/wiki/JTS_Topolog","http://en.wikipedia.org/wiki/JTS_Topolog","http://en.wikipedia.org/wiki/JTS_Topology_Suite","http://es.wikipedia.org/wiki/Java_Topology_Suite","yago-res:JTS Topology Suite"],"name":"JTS Topology Suite","categories":["Application programming interfaces","Free software programmed in Java (programming language)","Geometric algorithms"],"tag_line":"The Java Topology Suite (JTS) is an open source Java software library that provides an object model for Euclidean planar linear geometry together with a set of fundamental geometric functions."}}
,{"_index":"throwtable","_type":"algorithm","_id":"geometric-modeling","_score":0,"_source":{"description":"Geometric modeling is a branch of applied mathematics and computational geometry that studies methods and algorithms for the mathematical description of shapes.\nThe shapes studied in geometric modeling are mostly two- or three-dimensional, although many of its tools and principles can be applied to sets of any finite dimension. Today most geometric modeling is done with computers and for computer-based applications. Two-dimensional models are important in computer typography and technical drawing. Three-dimensional models are central to computer-aided design and manufacturing (CAD/CAM), and widely used in many applied technical fields such as civil and mechanical engineering, architecture, geology and medical image processing.\nGeometric models are usually distinguished from procedural and object-oriented models, which define the shape implicitly by an opaque algorithm that generates its appearance. They are also contrasted with digital images and volumetric models which represent the shape as a subset of a fine regular partition of space; and with fractal models that give an infinitely recursive definition of the shape. However, these distinctions are often blurred: for instance, a digital image can be interpreted as a collection of colored squares; and geometric shapes such as circles are defined by implicit mathematical equations. Also, a fractal model yields a parametric or implicit model when its recursive definition is truncated to a finite depth.\nNotable awards of the area are the John A. Gregory Memorial Award and the Bezier award.\n^ Handbook of Computer Aided Geometric Design\n^ http://geometric-modelling.org\n^ http://www.solidmodeling.org/bezier_award.html","alt_names":[],"name":"Geometric modeling","categories":["All articles needing additional references","All articles with unsourced statements","All stub articles","Applied mathematics stubs","Articles needing additional references from August 2014","Articles with unsourced statements from August 2014","Computer-aided design","Geometric algorithms"],"tag_line":"Geometric modeling is a branch of applied mathematics and computational geometry that studies methods and algorithms for the mathematical description of shapes."}}
,{"_index":"throwtable","_type":"algorithm","_id":"centroidal-voronoi-tessellation","_score":0,"_source":{"description":"In geometry, a centroidal Voronoi tessellation (CVT) is a special type of Voronoi tessellation or Voronoi diagrams. A Voronoi tessellation is called centroidal when the generating point of each Voronoi cell is also its mean (center of mass). It can be viewed as an optimal partition corresponding to an optimal distribution of generators. A number of algorithms can be used to generate centroidal Voronoi tessellations, including Lloyd's algorithm for K-means clustering.\nGersho's conjecture, proven for one and two dimensions, says that \"asymptotically speaking, all cells of the optimal CVT, while forming a tessellation, are congruent to a basic cell which depends on the dimension.\" In two dimensions, the basic cell for the optimal CVT is a regular hexagon.\nCentroidal Voronoi tessellations are useful in data compression, optimal quadrature, optimal quantization, clustering, and optimal mesh generation. Many patterns seen in nature are closely approximated by a Centroidal Voronoi tessellation. Examples of this include the Giant's Causeway, the cells of the cornea, and the breeding pits of the male tilapia.\nA weighted centroidal Voronoi diagrams is a CVT in which each centroid is weighted according to a certain function. For example, a grayscale image can be used as a density function to weight the points of a CVT, as a way to create digital stippling.","alt_names":["centroidal Voronoi tessellation","* In two dimensions the basic cell for the","Centroidal Voronoi Diagram","Centroidal Voronoi tessellation","Centroidal Voronoi tessellation (CVT)","Centroidal Voronoi tessellation - Wikipedia, the free encyclopedia","Centroidal Voronoi tessellation - Wikipedia, the free encyclopedia ...","Centroidal Voronoi tessellation Wikipedia the free encyclopedia","Centroidal Voronoi tessellations","Wikipedia article Centroidal Voronoi tessellation","Wikipedia article on Centroidal Voronoi tessellation","Wikipedia entry for Centroidal Voronoi tessellation","as shown in these 3 different boundaries for","http://en.Liarpedia.org/wiki/Centroidal_Voronoi_tessellation","http://en.wikipedia.org/wiki/Centroidal_","http://en.wikipedia.org/wiki/Centroidal_Voronoi_tessellation","yago-res:Centroidal Voronoi tessellation","“Centroidal Voronoi tessellation - Wikipedia, the free”, en.wikipedia"],"name":"Centroidal Voronoi tessellation","categories":["CS1 maint: Explicit use of et al.","Diagrams","Discrete geometry","Geometric algorithms"],"tag_line":"In geometry, a centroidal Voronoi tessellation (CVT) is a special type of Voronoi tessellation or Voronoi diagrams."}}
,{"_index":"throwtable","_type":"algorithm","_id":"minkowski-portal-refinement","_score":0,"_source":{"description":"The Minkowski Portal Refinement collision detection algorithm is a technique for determining whether two convex shapes overlap.\nThe algorithm was created by Gary Snethen in 2006 and was first published in Game Programming Gems 7. The algorithm was used in Tomb Raider: Underworld and other games created by Crystal Dynamics and its sister studios within Eidos Interactive.\nMPR, like its cousin GJK, relies on shapes that are defined using support mappings. This allows the algorithm to support a limitless variety of shapes that are problematic for other algorithms. Support mappings require only a single mathematical function to represent a point, line segment, disc, cylinder, cone, ellipsoid, football, bullet, frustum or most any other common convex shape. Once a set of basic primitives have been created, they can easily be combined with one another using operations such as sweep, shrink-wrap and affine transformation.\nUnlike GJK, MPR does not provide the shortest distance between separated shapes. However, according to its author, MPR is simpler, more numerically robust and handles translational sweeping with very little modification. This makes it well-suited for games and other real-time applications.","alt_names":["Minkowski Portal Refinement","Minkowski Portal Refinement - Wikipedia, the free encyclopedia","Minkowski Portal Refinement by Wikipedia","Wikipedia article on Minkowski Portal Refinement","Wikipedia entry for Minkowski Portal Refinement","XenoCollide","http://en.wikipedia.org/wiki/Minkowski_Portal_Refinement","http://en.wikipedia.org/wiki/XenoCollide","yago-res:Minkowski Portal Refinement"],"name":"Minkowski Portal Refinement","categories":["All stub articles","Convex geometry","Geometric algorithms","Geometry stubs"],"tag_line":"The Minkowski Portal Refinement collision detection algorithm is a technique for determining whether two convex shapes overlap."}}
,{"_index":"throwtable","_type":"algorithm","_id":"warnock-algorithm","_score":0,"_source":{"description":"The Warnock algorithm is a hidden surface algorithm invented by John Warnock that is typically used in the field of computer graphics. It solves the problem of rendering a complicated image by recursive subdivision of a scene until areas are obtained that are trivial to compute. In other words, if the scene is simple enough to compute efficiently then it is rendered; otherwise it is divided into smaller parts which are likewise tested for simplicity.\nThis is a divide and conquer algorithm with run-time of , where n is the number of polygons and p is the number of pixels in the viewport.\nThe inputs are a list of polygons and a viewport. The best case is that if the list of polygons is simple, then draw the polygons in the viewport. Simple is defined as one polygon (then the polygon or its part is drawn in appropriate part of a viewport) or a viewport that is one pixel in size (then that pixel gets a color of the polygon closest to the observer). The continuous step is to split the viewport into 4 equally sized quadrants and to recursively call the algorithm for each quadrant, with a polygon list modified such that it only contains polygons that are visible in that quadrant.","alt_names":["Algorytm Warnocka","Es gibt ein einziges umgebendes Polygon, aber kein","Warnock Algorithm","Warnock algorithm","Warnock algorithm - Wikipedia, the free encyclopedia","Warnock-Algorithmus","Warnock-Algorithmus – Wikipedia","Wikipedia article Algorytm Warnocka","Wikipedia article Warnock algorithm","Wikipedia article on Warnock algorithm","Wikipedia entry for Warnock algorithm","Wikipedia-Artikel Warnock-Algorithmus","de:Warnock-Algorithmus","http://de.wikipedia.org/wiki/Warnock-Alg","http://de.wikipedia.org/wiki/Warnock-Algorithmus","http://en.wikipedia.org/wiki/Warnock_alg","http://en.wikipedia.org/wiki/Warnock_algorithm","http://pl.wikipedia.org/wiki/Algorytm_Warnocka","yago-res:Warnock algorithm"],"name":"Warnock algorithm","categories":["All stub articles","Computer graphics algorithms","Computer programming stubs"],"tag_line":"The Warnock algorithm is a hidden surface algorithm invented by John Warnock that is typically used in the field of computer graphics."}}
,{"_index":"throwtable","_type":"algorithm","_id":"roam","_score":0,"_source":{"description":"Real-time optimally adapting mesh (ROAM), is a continuous level of detail algorithm that optimizes terrain meshes. On modern computers, sometimes it is more effective to send a small amount of unneeded polygons to the GPU, rather than burden the CPU with LOD (Level of Detail) calculations—making algorithms like geomipmapping more effective than ROAM. This technique is used by graphics programmers in order to produce high quality displays while being able to maintain real-time frame rates. Algorithms such as ROAM exist to provide a control over scene quality versus performance in order to provide HQ scenes while retaining real-time frame rates on hardware. ROAM largely aims toward terrain visualization, but various elements from ROAM are difficult to place within a game system.\nTo assist regional geological mapping, more abundant and visualized expression forms are highly needs. Thus, the 3D terrain model is adopted as the carrier for the demands in many correlative fields. Based on the regular grid DEM (Digital Elevation Model) in DRGS, ROAM algorithm is applied to create a more dynamic model, which will give consideration to the importance of different features and select correspondence level of detail.","alt_names":["- ROAM :","...more on Wikipedia about ROAM","ROAM","ROAM - Wikipedia, the free e...","ROAM - Wikipedia, the free encyclopedia","ROAM in Wikipedia","Wikipedia article ROAM","Wikipedia article on ROAM","Wikipedia entry for ROAM","en.wikipedia.org/wiki/ROAM","http://en.wikipedia.org/wiki/ROAM","yago-res:ROAM"],"name":"ROAM","categories":["All stub articles","Computer graphics algorithms","Computer graphics stubs","Computer science stubs"],"tag_line":"Real-time optimally adapting mesh (ROAM), is a continuous level of detail algorithm that optimizes terrain meshes."}}
,{"_index":"throwtable","_type":"algorithm","_id":"list-of-numerical-computational-geometry-topics","_score":0,"_source":{"description":"List of numerical computational geometry topics enumerates the topics of computational geometry that deals with geometric objects as continuous entities and applies methods and algorithms of nature characteristic to numerical analysis. This area is also called \"machine geometry\", computer-aided geometric design, and geometric modelling.\nSee List of combinatorial computational geometry topics for another flavor of computational geometry that states problems in terms of geometric objects as discrete entities and hence the methods of their solution are mostly theories and algorithms of combinatorial character.","alt_names":["...more on Wikipedia about List of numerical computational","List of numerical computational geometry topics","List of numerical computational geometry topics - Wikipedia :: The","List of numerical computational geometry topics - Wikipedia, the","Wikipedia (List of numerical computational geometry topics)","Wikipedia article ''List of numerical computational geometry topics","Wikipedia article List of numerical computational geometry topics","Wikipedia article on List of numerical computational geometry","Wikipedia entry for List of numerical computational geometry","http://en.wikipedia.org/wiki/List_of_numerical_computational_geometry_topics"],"name":"List of numerical computational geometry topics","categories":["Geometric algorithms","Mathematics-related lists"],"tag_line":"List of numerical computational geometry topics enumerates the topics of computational geometry that deals with geometric objects as continuous entities and applies methods and algorithms of nature characteristic to numerical analysis."}}
,{"_index":"throwtable","_type":"algorithm","_id":"digital-differential-analyzer-(graphics-algorithm)","_score":0,"_source":{"description":"In computer graphics, a digital differential analyzer (DDA) is hardware or software used for linear interpolation of variables over an interval between start and end point. DDAs are used for rasterization of lines, triangles and polygons. In its simplest implementation, the DDA algorithm interpolates values in interval by computing for each xi the equations xi = xi−1+1/m, yi = yi−1 + m, where Δx = xend − xstart and Δy = yend − ystart and m = Δy/Δx","alt_names":[],"name":"Digital differential analyzer (graphics algorithm)","categories":["All articles lacking in-text citations","Articles lacking in-text citations from June 2011","Articles with example C code","Computer graphics algorithms","Digital geometry"],"tag_line":"In computer graphics, a digital differential analyzer (DDA) is hardware or software used for linear interpolation of variables over an interval between start and end point."}}
,{"_index":"throwtable","_type":"algorithm","_id":"simulated-annealing","_score":0,"_source":{"description":"Simulated annealing (SA) is a probabilistic technique for approximating the global optimum of a given function. Specifically, it is a metaheuristic for approximate global optimization in a large search space. It is often used when the search space is discrete (e.g., all tours that visit a given set of cities). For problems where finding the precise global optimum is less important than finding an acceptable global optimum in a fixed amount of time, simulated annealing may be preferable to alternatives such as brute-force search or gradient descent.\nThe name and inspiration come from annealing in metallurgy, a technique involving heating and controlled cooling of a material to increase the size of its crystals and reduce defects. Both are attributes of the material that depend on its thermodynamic free energy. Heating and cooling the material affects both the temperature and the thermodynamic free energy. While the same amount of cooling brings the same decrease in temperature, the rate of cooling dictates the magnitude of decrease in the thermodynamic free energy, with slower cooling producing a bigger decrease. Simulated annealing interprets slow cooling as a slow decrease in the probability of accepting worse solutions as it explores the solution space. Accepting worse solutions is a fundamental property of metaheuristics because it allows for a more extensive search for the optimal solution.\nThe method was independently described by Scott Kirkpatrick, C. Daniel Gelatt and Mario P. Vecchi in 1983, and by Vlado Černý in 1985. The method is an adaptation of the Metropolis–Hastings algorithm, a Monte Carlo method to generate sample states of a thermodynamic system, invented by M.N. Rosenbluth and published by N. Metropolis et al. in 1953.","alt_names":["Restarts","(adaptive) simulated annealing","- Simulated Annealing","- Simulated annealing :","-> Read the article about 'Simulated annealing'","...Wikipedia Recuit simulé","...Wikipedia Symulowane wyżarzanie","...mehr auf Wikipedia über Simulierte Abkühlung","...more on Wikipedia about Simulated annealing","1.1 The basic iteration","1.2 The neighbours of a state","1.3 Acceptance probabilities","1.3 Transition probabilities","1.4 The annealing schedule","1.5 Convergence to optimum","2 In plain English","2 演算步骤","3 Pseudo-code","3 Selecting the parameters","3.1 Diameter of the search graph","3.1 Saving the best solution seen","3.2 Transition probabilities","3.3 Acceptance probabilities","3.4 Efficient candidate generation","3.5 Barrier avoidance","3.6 Cooling schedule","4 Restarts","4 Selecting the parameters","4.1 State neighbours","4.1 Transition probabilities","4.2 Annealing schedule","4.2 Transition probabilities","4.2.1 Simulated quenching and tuning","4.2.2 Thermodynamic Simulated Annealing","4.3 Annealing schedule","4.3 State neighbours","4.3.1 Simulated quenching and tuning","4.3.2 Thermodynamic Simulated Annealing","5 Related methods","5 Restarts","6 Related methods","Algoritmo de recocido simulado","Algoritmo de recocido simulado - Wikipedia, la enciclopedia libre","Annealing schedule simulation","Arrefecimento Simulado - Wikipedia","Benzetilmiş tavlama","Benzetilmiş tavlama - Vikipedi","Enfriamiento Simulado","Enfriamiento simulado","Glühen simmulated","Pics or it didn't happen","Programın Kullandığı algoritmayla ilgili bilgi için tıklayın","Pseudo Code for SA algorithm","Recocido Simulado","Recocido simulado","Recuit simul? - Wikip?dia","Recuit simulé","Recuit simulé - Wikipedia","Recuit simulé - Wikipédia","Recuit simulé - Wikipédia http://fr.wikipedia.org/wiki","Resfriamento/Têmpera Simulada","Ricottura simulata","SA @ Wikipedia","SA at Wikipedia","Selecting the parameters","Simmulated Annealing","Simulated Anealing","Simulated Annealing","Simulated Annealing (SA)","Simulated Annealing (Simulierte Abkühlung)","Simulated Annealing (Symulowane Wyżarzanie)","Simulated Annealing (wikipedia link)","Simulated Annealing - Wikipedia","Simulated Annealing - Wikipedia- /w/opensearch_desc.php title= Wikipedia","Simulated Annealing @ Wikipedia","Simulated Annealing Algorithm","Simulated Annealing Wikipedia The Free Encyclopedia","Simulated Annealing algorithm","Simulated Annealing in Wikipedia","Simulated Annealing in wikipedia","Simulated Annealing on Wikipedia.","Simulated Annealing,","Simulated Annealing.","Simulated Annealing..","Simulated Annealing?","Simulated Annealling (SA)","Simulated annealing","Simulated annealing (Recocido simulado)","Simulated annealing - Wikipedia","Simulated annealing - Wikipedia bahasa Indonesia, ensiklopedia bebas","Simulated annealing - Wikipedia, la enciclopedia libre","Simulated annealing - Wikipedia, the free encyclopedia","Simulated annealing - Wikipedia, the free encyclopedia wikipedia.org","Simulated annealing Algorithm","Simulated annealing Wikipedia the free encyclopedia","Simulated annealing Wikipedia, the ...","Simulated annealing from Wikipedia","Simulated annealing – Wikipedia, the free encyclopedia","Simulated annealing – Wikipé...","Simulated annealing – Wikipédia, a enciclopédia livre","Simulated annealing:","Simulated annealing; it is used under the","Simulated annealling","Simulated-Annealing","SimulatedAnnealing","Simulated_annealing","Simuleret Hydraulik","Simuleret Udglødning","Simuleret udglødning - Wikipedia, den f...","Simulierte Abk?hlung ? Wikipedia","Simulierte Abkühlung","Simulierte Abkühlung - Wikipedia","Simulierte Abkühlung ? Wikipedia","Simulierte Abkühlung – Wikipedia","Simulované ochlazování","Simulované žíhání","Simulované žíhání - Wikipedie","Symulowane wyzarzanie – Wikipedia, wolna encyklopedia","Symulowane wyżarzanie","Symulowane wyżarzanie – Wikipedia, wolna encyklopedia","Symulowanego Wyżarzania","Symulowanego wyżarzanie","Szimulált hűtésről részletesen itt olvashatsz.","View Simulated annealing on Wikipedia","Vikipedi'deki Benzetilmiş tavlama","What is the overview of Simulated annealing algorithms","Wiki – Simulated Annealing","Wikipaedia:","Wikipedia : Simulated annealing","Wikipedia : 焼きなまし法","Wikipedia Simulated annealing","Wikipedia article Algoritmo de recocido simulado","Wikipedia article Recuit simulé","Wikipedia article Simulated Annealing","Wikipedia article Simulated annealing","Wikipedia article Simulated_annealing","Wikipedia article on simulated annealing","Wikipedia article Алгоритм имитации отжига","Wikipedia entry for Simulated annealing","Wikipedia l'articolo Simulated Annealing","Wikipedia-Artikel Simulated Annealing","Wikipedia-Artikel Simulated annealing","Wikipedia-Artikel Simulierte Abkühlung","Wikipedia-Seite zu 'Simulierte Abkühlung'","Wikipedia: Simulated Annealing","Wikipedia: Simulated annealing","Wikipedia: Simulierte Abkühlung","Wikipedia:Ricottura_simulata","Wikipedia:Simulated_Annealing","Wikipedia:Simulated_annealing","Wikipedia:simulated annealing","Wikipediaで「シッミュレーティド・アニーリング」を調べる","Wikipediaで「擬似焼きなまし法」を調べる","Wikipediaで「焼きなまし法」を調べる","Wikipédia artigo Simulated annealing","Wikkipedia-Simulated Annealing","a type of simulated annealing","add a little","add a little inertia to your rolling ball","advanced math techniques","algorithm she used","algorithme de recuit simulé","algoritmo de temple simulado","an introduction to simulated annealing","annealing method","annealing optimization","annealing optimizations","annealing simmulated","annealing simulado","annealing simulato","annealing नकली","ar:تخمير محاكى","arrefecimento simulado","article on simulated annealing,","artículo de Wikipedia Simulated annealing","cs:Simulované žíhání","da:Simuleret Udglødning","da:Simuleret udglødning","de.wikipedia.org/wiki/Simulierte_Abk%C3%BChlung","de.wikipedia.org/wiki/Simulierte_Abkühlung","de:Simulierte Abkühlung","di ricottura simulata","e http://en.wikipedia.org/wiki/Simulated_annealing","el Templado Simulado","en.wikipedia.org/...Simulated_annealing","en.wikipedia.org/wiki/Simulated_annea...","en.wikipedia.org/wiki/Simulated_annealing","en:Simulated Annealing","en:Simulated annealing","es:Algoritmo de recocido simulado","es:Simulated annealing","fa:الگوریتم تبرید شبیهسازی شده","fr:Recuit simulé","good neighboring state","http://cs.wikipedia.org/wiki/Simulovan%C3%A9_","http://da.wikipedia.org/wiki/Simuleret_Udgl%C3%B8dning","http://de.wikipedia.org/wiki/Simulated_Annealing","http://de.wikipedia.org/wiki/Simulated_annealing","http://de.wikipedia.org/wiki/Simulierte_","http://de.wikipedia.org/wiki/Simulierte_Abk%C3%BChlung","http://de.wikipedia.org/wiki/Simulierte_Abkühlung","http://en.wikipedia....lated_Annealing","http://en.wikipedia....lated_annealing","http://en.wikipedia.org/wiki/Simulated annealing","http://en.wikipedia.org/wiki/Simulated_","http://en.wikipedia.org/wiki/Simulated_Annealing","http://en.wikipedia.org/wiki/Simulated_a","http://en.wikipedia.org/wiki/Simulated_anneal...","http://en.wikipedia.org/wiki/Simulated_annealing","http://en.wikipedia.org/wiki/Simulated_annealing#Pseudocode","http://en.wikipedia.org/wiki/Simulated_annealing#Related_methods","http://en.wikipedia.org/wiki/Simulated_annealing.","http://en.wikipedia.org/wiki/Simulated_annealing~~V","http://en.wikipedia.org/wiki/Simulated_annealling","http://en.wikipedia.org/wiki/Simulated_a…","http://en.wikipedia.org/wiki/simulated_annealing (","http://es.wikipedia.org/wiki/Algoritmo_de_recocido_simulado","http://es.wikipedia.org/wiki/Simulated_annealing","http://fr.wikipedia.org/wiki/Recuit_simul%C3%A9","http://fr.wikipedia.org/wiki/Recuit_simulé","http://it.wikipedia.org/wiki/Simulated_Annealing","http://nl.wikipedia.org/wiki/Simulated_annealing","http://pl.wikipedia.org/wiki/Symulowane_wy%C5%BCarzanie","http://pl.wikipedia.org/wiki/Symulowane_wy%C5%BCażanie","http://pt.wikipedia.org/wiki/Simulated_annealing","http://ru.wikipedia.org/wiki/Алгоритм_имитации_отжига","http://tr.wikipedia.org/wiki/Benzetilmi%C5%9F_tavlama","id:Simulated annealing","it:Simulated Annealing","ja:焼きなまし法","ko:담금질 기법","ko:담금질기법","le recuit simulé","m0r3 inf0rm47i0n","make a probabilistic move based on the temperature","many other approaches","my metaphor","mô phỏng làm cho deo?","nl:Simulated annealing","other algorithms based on nature","pl:Symulowane wyżarzanie","pseudo-code for simulated annealing","pt:Simulated annealing","random killings","recocido simulado","recocido simulado?","recozimento simulado","recozimento simulado?","recuit simulÃ©","recuit simulé","recuit simulé?","recuits simulés","ricottura simulata","ricottura simulata?","ru:Алгоритм имитации отжига","simlulated annealing","simmulated annealing","simmulated gloeien","simmulated recocido","simmulated udglødning","simmulated žíhání","simmulated отжига","simmulated退火","simualted annealing","simulare “annealing”","simulasi anil?","simulated anealing","simulated annealing","simulated annealing (отжиг т.е.)","simulated annealing algorithm","simulated annealing on wikipedia","simulated annealing technique","simulated annealing,","simulated annealing:","simulated annealling","simulated thermal annealing","simulated-annealing","simulated_annealing","simuleeritud karastamise","simuleret Hydraulik","simuleret udglødning","simulierte Abkühlung","simulierter Abkühlung","simuloitu jäähdytys","simuloitua jäähdytystä","simulované žíhanie","simulované žíhání","simulovaného žíhania","stepwise approximations","symulowane wyżarzanie","symulowanego wyżarzania","tekaistu mellotus","temple simulado","tr:Benzetilmiş tavlama","ttp://en.wikipedia.org/wiki/Simulated_annealing)","uk:Алгоритм імітації відпалу","un algoritmo probabilista muy popular","w:simulated annealing","wikipedia on simulated annealing","zh:模拟退火","Ð Ð»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼ Ð¸Ð¼Ð","Алгоритм имитации отжига","Алгоритм имитации отжига — В...","Алгоритм имитации отжига — Википедия","Алгоритм імітації відпалу","Имитации отжига","Имитация отжига","алгоритм имитации отжига","алгоритма отжига","имитации отжига","имитации отжига?","имитация отжига","метод имитации отжига","метод отжига","методе отжига","методу имитации отжига","моделирование отжига","моделируемого отжига","псевдокод в википедии","решение задачи глобальной оптимизации","статья в wikipedia Алгоритм имитации отжига","تبرید یا شبیهسازی حرارتی","नकली annealing","नकली एनीलिंग","การ หลอม จำลอง","การหลอมจำลอง","อบจำลอง","ủ mô phỏng","“simulated annealing","「焼きなまし法」をWikipediaで調べる","アニーリング（SA）","アニールsimmulated","シッミュレーティド・アニーリング","シミュレーテッドアニーリング","シミュレーテッドアニーリングは、","シミュレーテッドアニーリングを","擬似焼きなまし法","模拟煺火","模拟退火","模拟退火- 维基百科，自由的百科全书","模拟退火算法","模拟退火算法（Simulated annealing）","模擬退火","模擬退火- 維基百科，自由的百科全書","模擬退火法","焼きなまし法","焼きなまし法 (simulated annealing)","焼きなまし法 - Wikipedia","焼きなまし法 simulated annealing","焼きなまし法-wikipedia","焼きなます","焼き鈍し法","維基百科的文章“ 模拟煺火”","維基百科的文章“ 模拟退火”","維基百科的文章“ 模擬退火”","近似技术","담금질 기법","모의 어닐링의","시뮬레이션을 어닐링","시뮬레이티드 어닐링","시뮬레이티드 어닐링(simulated annealing)","위키 피 디아 문서 담금질 기법","위키 피 디아 문서 시뮬레이티드 어닐링"],"name":"Simulated annealing","categories":["All articles needing additional references","All articles with unsourced statements","Articles needing additional references from December 2009","Articles with inconsistent citation formats","Articles with unsourced statements from June 2011","Heuristic algorithms","Monte Carlo methods","Optimization algorithms and methods"],"tag_line":"Simulated annealing (SA) is a probabilistic technique for approximating the global optimum of a given function."}}
,{"_index":"throwtable","_type":"algorithm","_id":"franco-p.-preparata","_score":0,"_source":{"description":"Franco P. Preparata (born December 1935) is a computer scientist, the An Wang Professor, Emeritus, of Computer Science at Brown University.\nHe is best known for his 1985 book \"Computational Geometry: An Introduction\" into which he blended salient parts of M. I. Shamos' doctoral thesis (Shamos appears as a co-author of the book). This book, which represents a snap-shot of the disciplines as of 1985, has been for many years the standard textbook in the field, and has been translated into four foreign Languages (Russian, Japanese, Chinese, and Czech). He has made several contributions to the computational geometry, the most recent being the notion of \"algorithmic degree\" as a key feature to control robust implementations of geometric algorithms.\nIn addition, Preparata has worked in many other areas of, or closely related to, computer science.\nHis initial work was in coding theory, where he (independently and simultaneously) contributed the Berlekamp-Preparata codes (optimal convolution codes for burst-error correction) and the Preparata codes, the first known systematic class of {\\em nonlinear} binary codes, with higher information content than corresponding linear BCH codes of the same length. Thirty years later these codes have been found relevant to quantum coding theory [citation].\nIn 1967, he substantially contributed to a model of system-level fault diagnosis, known today as the PMC (Preparata-Metze-Chien) model, which is a main issue in the design of highly dependable processing systems. This model is still the object of intense research today (as attested by the literature).\nOver the years, he was also active in research in parallel computation and VLSI theory. His 1979 paper (with J. Vuillemin), still highly cited, presented the cube-connected-cycles (CCC), a parallel architecture that optimally emulates the hypercube interconnection. This interconnection was closely reflected in the architecture of the CM2 of Thinking Machines Inc., the first massive-parallel system in the VLSI era. His 1991 paper with Zhou and Kang on interconnection delays in VLSI was awarded the 1993 \"Darlington Best Paper Award\" by the IEEE Circuits and Systems Society. In the late nineties, (in joint work with G. Bilardi) he confronted the problem of the physical limitations (space and speed) of parallel computation, and formulated the conclusion that mesh connections are ultimately the only scalable massively parallel architectures.\nMore recently the focus of his research has been Computational Biology. Among other results, he contributed (with E. Upfal) a novel approach to DNA Sequencing by Hybridization, achieving sequencing lengths that are the square of what was previously known, which has attracted media coverage.\nThe unifying character of these results in diverse research areas is the methodological approach, based on the construction of precise mathematical models and the use of sophisticated mathematical techniques.\nPreparata was born in Italy in December, 1935. He received a doctorate from the University of Rome, Italy in 1959. After a postdoctorate at CNR and several years of working in industry, he joined the faculty of the University of Illinois at Urbana-Champaign in 1965, where he achieved the rank of Professor in 1970. He stayed at the UIUC for many years, advising 16 Ph.D. students there. He received his Italian Libera Docenza in 1969. In 1991, Preparata moved from Illinois to Brown University where he has remained active in research, teaching, and student advising until his retirement at the end of 2013. He is the author (or co-author) of three books and nearly 250 articles. In 1997, the University of Padova awarded Preparata an honorary doctorate in Information Engineering. Preparata is an IEEE Fellow (1978),an ACM Fellow (1993), and was a Fellow of the Japan Society for the Advancement of Science.","alt_names":["- Franco P. Preparata :","Franco P Preparata","Franco P. Preparata","Franco P. Preparata - Wikipedia, the free encyclopedia","Franco Preparata","Preparata, F. P.","Preparata, F.P.","Preparata, Franco P.","Wikipedia article Franco P. Preparata","Wikipedia article Franco Preparata","Wikipedia article about Franco P. Preparata","Wikipedia entry for Franco P. Preparata","by Franco Preparata","http://en.wikipedia.org/wiki/Franco P. Preparata","http://en.wikipedia.org/wiki/Franco_P._P","http://en.wikipedia.org/wiki/Franco_P._Preparata","http://en.wikipedia.org/wiki/Franco_Preparata","see Franco P. Preparata's Wikipedia entry »","yago-res:Franco P. Preparata"],"name":"Franco P. Preparata","categories":["1935 births","American computer scientists","Brown University faculty","Fellow Members of the IEEE","Fellows of the Association for Computing Machinery","Italian computer scientists","Living people","Researchers in geometric algorithms","Theoretical computer scientists","Wikipedia articles with BNF identifiers","Wikipedia articles with ISNI identifiers","Wikipedia articles with VIAF identifiers"],"tag_line":"Franco P. Preparata (born December 1935) is a computer scientist, the An Wang Professor, Emeritus, of Computer Science at Brown University."}}
,{"_index":"throwtable","_type":"algorithm","_id":"xiaolin-wu's-line-algorithm","_score":0,"_source":{"description":"Xiaolin Wu's line algorithm is an algorithm for line antialiasing, which was presented in the article An Efficient Antialiasing Technique in the July 1991 issue of Computer Graphics, as well as in the article Fast Antialiasing in the June 1992 issue of Dr. Dobb's Journal.\nBresenham's algorithm draws lines extremely quickly, but it does not perform anti-aliasing. In addition, it cannot handle any cases where the line endpoints do not lie exactly on integer points of the pixel grid. A naive approach to anti-aliasing the line would take an extremely long time. Wu's algorithm is comparatively fast, but is still slower than Bresenham's algorithm. The algorithm consists of drawing pairs of pixels straddling the line, each coloured according to its distance from the line. Pixels at the line ends are handled separately. Lines less than one pixel long are handled as a special case.\nAn extension to the algorithm for circle drawing was presented by Xiaolin Wu in the book Graphics Gems II. Just like the line drawing algorithm is a replacement for Bresenham's line drawing algorithm, the circle drawing algorithm is a replacement for Bresenham's circle drawing algorithm.","alt_names":["Wu's","Wu's algorithm","'See elsewhere' section","...more on Wikipedia about Xiaolin Wu's line algorithm","Algorithme de tracé de segment de Xiaolin Wu","Algoritmo de Xiaolin Wu","Here's link for Wu's lines.","Learn about Xiaolin Wu's line algorithm>>>","Wikipedia article ''Xiaolin Wu's line algorithm''","Wikipedia article Xiaolin Wu's line algorithm","Wikipedia article about Xiaolin Wu's line algorithm","Wikipedia article Алгоритм Ву","Wikipedia sur Algorithme de tracé de segment de","Wu Antialiasing","Wu algorithm","Wu algoritmus","Wu antialiasing","Wu line algorithm","Wu line antialiasing algorithm","Wu lines","Wu's Line Algorithm","Wu's algorithm.","Wu's algoritm","Wu's line algorithm","Wu's line-drawing algorithm","Wu-Algorithmus","Wu-algoritme","Wuさんのアルゴリズムが","Xiaolin Wu","Xiaolin Wu algorithm","Xiaolin Wu algorithm for drawing lines","Xiaolin Wu algoritmus","Xiaolin Wu s line algorithm Wikipedia the free","Xiaolin Wu のアンチエイリアスライン","Xiaolin Wu&#39;s line algorithm - Wikipedia, the","Xiaolin Wu's","Xiaolin Wu's Anti-alias Lines","Xiaolin Wu's Line Algorithm","Xiaolin Wu's algorithm","Xiaolin Wu's algoritme","Xiaolin Wu's anti-aliased line algorithm","Xiaolin Wu's line algorithm","Xiaolin Wu's line algorithm - Wikipedia :: The free encyclopedia","Xiaolin Wu's line algorithm - Wikipedia, the free","Xiaolin Wu's line algorithm - Wikipedia, the free encyclopedia","Xiaolin Wu's line algorithm [Wikipedia]","Xiaolin Wu-Algorithmus","Xiaolin-Wu's line algorithm (wikipedia)","Xiaolin_Wu's line algorithm","algorithme de Xiaolin Wu","algorithme de tracé de segment de Xiaolin Wu","algorytm Wu","algorytm Wu Xiaolin","anti-aliased line","antialiased line-drawing","article Xiaolin Wu's line algorithm","di Wu algoritmo Xiaolin","el algoritmo de Wu","el algoritmo de Wu Xiaolin","en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm","en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm","es:Algoritmo de Xiaolin Wu","http://en.wikiped...u's line algorithm","http://en.wikipedia.org/wiki/Xiaol [...] _algorithm","http://en.wikipedia.org/wiki/Xiaolin Wu's line","http://en.wikipedia.org/wiki/Xiaolin...line_algorithm","http://en.wikipedia.org/wiki/Xiaolin_ Wu%27s_line_algorithm","http://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm","http://en.wikipedia.org/wiki/Xiaolin_Wu'...","http://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm","http://en.wikipedia.org/wiki/Xiaolin_Wu'…","http://es.wikipedia.org/wiki/Algoritmo_de_Xiaolin_Wu","http://fr.wikipedia.org/wiki/Algorit..._de_Xiaolin_Wu","http://ru.wikipedia.org/wiki/Алгоритм_Ву","l'algoritmo di Wu","pseudo codice","pseudo kod","pseudo-koden","ru:Алгоритм Ву","ttp://en.wikipedia.org/wiki/Xiaolin_Wu's_line_algorithm","uk:Алгоритм Ву","Алгоритм Ву","Алгоритм Ву 1","Алгоритма Ву","алгоритм Ву","алгоритм Ксиаолина Ву","алгоритм Сяолинь Ву (Xiaolin Wu)","алгоритма Ву","растеризация с антиалиасингом","吴的算法","呉のアンチエイリアシング","小林武的算法","暁呉のアルゴリズム"],"name":"Xiaolin Wu's line algorithm","categories":["All articles lacking in-text citations","Articles lacking in-text citations from January 2013","Articles with example pseudocode","Computer graphics algorithms"],"tag_line":"Xiaolin Wu's line algorithm is an algorithm for line antialiasing, which was presented in the article An Efficient Antialiasing Technique in the July 1991 issue of Computer Graphics, as well as in the article Fast Antialiasing in the June 1992 issue of Dr. Dobb's Journal."}}
,{"_index":"throwtable","_type":"algorithm","_id":"leonidas-j.-guibas","_score":0,"_source":{"description":"Leonidas John Guibas (Greek: Λεωνίδας Γκίμπας) is a professor of computer science at Stanford University, where he heads the geometric computation group and is a member of the computer graphics and artificial intelligence laboratories. Guibas was a student of Donald Knuth at Stanford, where he received his Ph.D. in 1976. He has worked for several industrial research laboratories, and joined the Stanford faculty in 1984. He was program chair for the ACM Symposium on Computational Geometry in 1996, is a Fellow of the ACM and the IEEE, and was awarded the ACM - AAAI Allen Newell Award for 2007 “for his pioneering contributions in applying algorithms to a wide range of computer science disciplines.“ He has Erdős number 2 due to his collaborations with Boris Aronov, Andrew Odlyzko, János Pach, Richard M. Pollack, Endre Szemerédi, and Frances Yao. The research contributions he is known for include finger trees, red-black trees, fractional cascading, the Guibas–Stolfi algorithm for Delaunay triangulation, an optimal data structure for point location, the quad-edge data structure for representing planar subdivisions, Metropolis light transport, and kinetic data structures for keeping track of objects in motion.","alt_names":["- Leonidas J. Guibas :","Guibas","Guibas a","Guibas, L.","Guibas, L. J.","Guibas, Leonidas J.","L. G. Guibas","L.J. Guibas","Leidas J. Guibas","Leo Guibas","Leonidas J. Guibas","Leonidas J. Guibas - Wikipedia, the free encyclopedia","Leonidas John Guibas","Leonidas John Guibas - Wikipdia","Leonidas John Guibas - Wikipédia","Leonidas_J._Guibas","Who is Leonidas J. Guibas","Wikipedia article L.J. Guibas","Wikipedia article Leonidas J. Guibas","Wikipedia article Leonidas John Guibas","Wikipedia article on Leonidas J. Guibas","Wikipedia entry for Leonidas J. Guibas","el:Λεωνίδας Γκίμπας","fr:Leonidas John Guibas","http://el.wikipedia.org/wiki/Λεωνίδας_Γκίμπας","http://en.wikipedia.org/wiki/Leonidas_J._Guibas","http://fr.wikipedia.org/wiki/Leonidas_John_Guibas","Γκίμπας","Λεωνίδας Γκίμπας","άρθρο Leonidas J. Guibas"],"name":"Leonidas J. Guibas","categories":["American computer scientists","Articles containing Greek-language text","Fellow Members of the IEEE","Fellows of the Association for Computing Machinery","Greek computer scientists","Living people","Researchers in geometric algorithms","Stanford University Department of Computer Science faculty","Stanford University School of Engineering faculty","Stanford University alumni","Year of birth missing (living people)"],"tag_line":"Leonidas John Guibas (Greek: Λεωνίδας Γκίμπας) is a professor of computer science at Stanford University, where he heads the geometric computation group and is a member of the computer graphics and artificial intelligence laboratories."}}
,{"_index":"throwtable","_type":"algorithm","_id":"roberto-tamassia","_score":0,"_source":{"description":"Roberto Tamassia is a computer scientist, the Plastech Professor of Computer Science at Brown University, and since 2007 has been chair of the Brown Computer Science department. His research specialty is in the design and analysis of algorithms for graph drawing, computational geometry, and computer security; he is also the author of several textbooks.","alt_names":["- Roberto Tamassia :","R. Tamassia","Roberto Tamassia","Roberto Tamassia - Wikipedia, the free encyclopedia","Roberto Tamassia on wikipedia.org","Roberto Tamassia; it is used under the","Tamassia","Tamassia, R.","Tamassia, Roberto","What are awards and honors of Roberto Tamassia","Wikipedia article Roberto Tamassia","Wikipedia article Roberto_Tamassia","Wikipedia article about Roberto Tamassia","Wikipedia article on Roberto Tamassia","http://en.Liarpedia.org/wiki/Roberto_Tamassia","http://en.wikipedia.org/wiki/Roberto Tamassia","http://en.wikipedia.org/wiki/Roberto_Tamassia","yago-res:Roberto Tamassia"],"name":"Roberto Tamassia","categories":["American computer scientists","Brown University faculty","Fellow Members of the IEEE","Fellows of the American Association for the Advancement of Science","Fellows of the Association for Computing Machinery","Graph drawing people","Italian computer scientists","Living people","People associated with computer security","Researchers in geometric algorithms","University of Illinois at Urbana–Champaign alumni","Year of birth missing (living people)"],"tag_line":"Roberto Tamassia is a computer scientist, the Plastech Professor of Computer Science at Brown University, and since 2007 has been chair of the Brown Computer Science department."}}
,{"_index":"throwtable","_type":"algorithm","_id":"john-reif","_score":0,"_source":{"description":"John H. Reif (born 1951) is an American academic, and Professor of Computer Science at Duke University, who has made contributions to large number of fields in computer science: ranging from algorithms and computational complexity theory to robotics and to game theory.","alt_names":["John Reif","- John Reif :","John H. Reif","John Reif - Wikipedia, the free encyclopedia","John Reif - Wikipedia, the free encyclopedia wikipedia.org","John Reif Wikipedia the free encyclopedia","John Reif Wikipedia the free encyclopedia - result","John_Reif","Reif, J.","Reif, John","Reif, John H.","Wikepedia's Citation","Wikipedia article John Reif","Wikipedia article about John Reif","Wikipedia entry for John Reif","en.wikipedia.org/wiki/John_Reif","http://en.wikipedia.org/wiki/John Reif","http://en.wikipedia.org/wiki/John_Reif","http://en.wikipedia.org/wiki/John_Reif →","yago-res:John Reif"],"name":"John Reif","categories":["1951 births","American academics","DNA nanotechnology","Duke University faculty","Fellow Members of the IEEE","Fellows of the American Association for the Advancement of Science","Fellows of the Association for Computing Machinery","Harvard University alumni","Harvard University faculty","Living people","Researchers in geometric algorithms","Theoretical computer scientists","Tufts University alumni"],"tag_line":"John H. Reif (born 1951) is an American academic, and Professor of Computer Science at Duke University, who has made contributions to large number of fields in computer science: ranging from algorithms and computational complexity theory to robotics and to game theory."}}
,{"_index":"throwtable","_type":"algorithm","_id":"heuristiclab","_score":0,"_source":{"description":"HeuristicLab   is a software environment for heuristic and evolutionary algorithms, developed by members of the Heuristic and Evolutionary Algorithm Laboratory (HEAL) at the University of Applied Sciences Upper Austria, Campus Hagenberg. HeuristicLab has a strong focus on providing a graphical user interface so that users are not required to have comprehensive programming skills to adjust and extend the algorithms for a particular problem. In HeuristicLab algorithms are represented as operator graphs and changing or rearranging operators can be done by drag-and-drop without actually writing code. The software thereby tries to shift algorithm development capability from the software engineer to the user and practitioner. Developers can still extend the functionality on code level and can use HeuristicLab's plug-in mechanism that allows them to integrate custom algorithms, solution representations or optimization problems.","alt_names":[],"name":"HeuristicLab","categories":["Heuristic algorithms"],"tag_line":"HeuristicLab   is a software environment for heuristic and evolutionary algorithms, developed by members of the Heuristic and Evolutionary Algorithm Laboratory (HEAL) at the University of Applied Sciences Upper Austria, Campus Hagenberg."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dynamic-time-warping","_score":0,"_source":{"description":"In time series analysis, dynamic time warping (DTW) is an algorithm for measuring similarity between two temporal sequences which may vary in time or speed. For instance, similarities in walking patterns could be detected using DTW, even if one person was walking faster than the other, or if there were accelerations and decelerations during the course of an observation. DTW has been applied to temporal sequences of video, audio, and graphics data — indeed, any data which can be turned into a linear sequence can be analyzed with DTW. A well known application has been automatic speech recognition, to cope with different speaking speeds. Other applications include speaker recognition and online signature recognition. Also it is seen that it can be used in partial shape matching application.\nIn general, DTW is a method that calculates an optimal match between two given sequences (e.g. time series) with certain restrictions. The sequences are \"warped\" non-linearly in the time dimension to determine a measure of their similarity independent of certain non-linear variations in the time dimension. This sequence alignment method is often used in time series classification. Although DTW measures a distance-like quantity between two given sequences, it doesn't guarantee the triangle inequality to hold.","alt_names":["- Dynamic time warping :","- wiki: Dynamic time warping","...more on Wikipedia about Dynamic time warping","Alineamiento temporal dinámico (DTW) (en inglés)","DTW algoritmus","Deformazione dinamico in fase","Deformação dinâmica em tempo","Dilatation temporelle","Distorsión de tiempo dinámica","Dynamic Time Fordrejning","Dynamic Time Warp","Dynamic Time Warping","Dynamic Time Warping (DTW)","Dynamic Time Warping Dinamica Tempo Orditura","Dynamic Time Warping Dynamic Time Warping","Dynamic Time Warping Dynamic Time deformācijas","Dynamic Time Warping Dynamic Time empenamento","Dynamic Time Warping Dynamische Tijd kromtrekken","Dynamic Time Warping Dynamisk Temne FÖRHALNING","Dynamic Time Warping Tiempo deformaciones dinámicas","Dynamic Time Warping Δυναμική Time warping","Dynamic Time Warping Динамическое время Сновальное","Dynamic Time Warping Динамічне час Сновальное","Dynamic Time Warping الديناميكية التيمن التشويه","Dynamic Time Warping गतिशील समय Warping","Dynamic Time Warping,","Dynamic Time verdraaien","Dynamic Time warping","Dynamic Time แปรปรวน","Dynamic time warping","Dynamic time warping - Wikipedia, the free encyclopedia","Dynamic time warping - Wikipedia, the free encyclopedia ...","Dynamic time warping - Wikipedia- /w/opensearch_desc.php title","Dynamic time warping by Wikipedia","Dynamic time warping – Wikipedia, the free encyclopedia","Dynamic time warping, DTW","Dynamic-Time-Warping","Dynamic-Time-Warping – Wikipedia","Dynamic_Time_Warping","Dynamické manipulaci s časem","Dynamiczne Deformacja Czas","Dynamische tijd warping","Déformation temporelle dynamique","Năng động Thời gian Mắc","Orditura Tempo dinamico","Temporal dinámico Distorsión","Time Warping distance","Time warping","Wikipedia article Dynamic time warping","Wikipedia article on Dynamic time warping","Wikipedia entry for Dynamic time warping","Wikipedia-Artikel Dynamic Time Warping","Wikipedia-Artikel Dynamic-Time-Warping","Wikipedia-Seite zu 'Dynamic Time Warping'","Wikipedia-Seite zu 'Dynamic-Time-Warping'","cong vênh thời gian năng động,","distorsión de tiempo dinámico","dynamic time warping","dynamic time warping (DTW)","dynamic time warping or what Ramsay and Silverman","dynamiczny wypaczenia czasu","dynamische tijd warping","déformation temporelle dynamique","en.wikipedia.org/...Dynamic_time_warping","en.wikipedia.org/wiki/Dynamic_time_wa...","en.wikipedia.org/wiki/Dynamic_time_warping","en:Dynamic Time Warping","en:Dynamic time warping","entortar tempo dinâmico","http://de.wikipedia.org/wiki/Dynamic-Time-Warping","http://de.wikipedia.org/wiki/Dynamic_Time_Warping","http://en.wikipedia.org/wiki/Dynamic_tim","http://en.wikipedia.org/wiki/Dynamic_time_war...","http://en.wikipedia.org/wiki/Dynamic_time_warping","http://en.wikipedia.org/wiki/Dynamic_time_warping Systems Software","http://en.wikipedia.org/wiki/Dynamic_time_warping.","http://en.wikipedia.org/wiki/Dynamic_tim…","http://it.wikipedia.org/wiki/Dynamic_time_warping","la déformation dynamique au moment","pt:Dynamic time warping","tempo di deformazione dinamica","time warping","warping waktu dinamis","warps in time","wiki: Dynamic time warping","Динамическая трансформация шкалы времени","Динамические деформации времени","Динамический Искривление времени","Динамическое время Искривление","динамическая трансформация шкалы времени,","गतिशील समय Warping","โค้ง เวลา ไดนามิก","そらせている動的な時間","ダイナミックタイムワーピングは、","力的陳舊樣式","动态时间弯曲","动态时间规整","动态的陈旧样式","動態時間彎曲","動態時間規整","動的なタイムワープ","動的時間ワーピングは、","動的時間伸縮は、","동적 시간 Warping는","동적인 뒤틀리는 시간","역동적인 시간을 워핑입니다"],"name":"Dynamic time warping","categories":["Articles with example pseudocode","CS1 maint: Explicit use of et al.","Dynamic programming","Machine learning algorithms","Time series analysis"],"tag_line":"In time series analysis, dynamic time warping (DTW) is an algorithm for measuring similarity between two temporal sequences which may vary in time or speed."}}
,{"_index":"throwtable","_type":"algorithm","_id":"weighted-majority-algorithm","_score":0,"_source":{"description":"In machine learning, Weighted Majority Algorithm (WMA) is a meta-learning algorithm used to construct a compound algorithm from a pool of prediction algorithms, which could be any type of learning algorithms, classifiers, or even real human experts. The algorithm assumes that we have no prior knowledge about the accuracy of the algorithms in the pool, but there are sufficient reasons to believe that one or more will perform well.\nAssume that the problem is a binary decision problem. To construct the compound algorithm, a positive weight is given to each of the algorithms in the pool. The compound algorithm then collects weighted votes from all the algorithms in the pool, and gives the prediction that has a higher vote. If the compound algorithm makes a mistake, the algorithms in the pool that contributed to the wrong predicting will be discounted by a certain ratio β where 0<β<1.\nIt can be shown that the upper bounds on the number of mistakes made in a given sequence of predictions from a pool of algorithms  is\n\nif one algorithm in  makes at most  mistakes.\nThere are many variations of the Weighted Majority Algorithm to handle different situations, like shifting targets, infinite pools, or randomized predictions. The core mechanism remain similar, with the final performances of the compound algorithm bounded by a function of the performance of the specialist (best performing algorithm) in the pool.","alt_names":["The weighted-majority algorithm","Weighted Majority","Weighted Majority Algorithm","Weighted Majority Algorithm - Wikipedia, the free encyclopedia","Weighted Majority Algorithm by Wikipedia","Weighted Majority Algorithmus","Weighted majority algorithm","Wikipedia article Weighted Majority Algorithm","Wikipedia article Weighted majority algorithm","Wikipedia entry for Weighted Majority Algorithm","Wikipedia: Weighted Majority Algorithm","http://en.wikipedia.org/wiki/Weighted_Ma","http://en.wikipedia.org/wiki/Weighted_Majority_Algorithm","the Wikipedia page on the Weighted Majority Algorithm","weighted majority algorithm"],"name":"Weighted Majority Algorithm","categories":["Machine learning algorithms"],"tag_line":"In machine learning, Weighted Majority Algorithm (WMA) is a meta-learning algorithm used to construct a compound algorithm from a pool of prediction algorithms, which could be any type of learning algorithms, classifiers, or even real human experts."}}
,{"_index":"throwtable","_type":"algorithm","_id":"t-distributed-stochastic-neighbor-embedding","_score":0,"_source":{"description":"t-distributed stochastic neighbor embedding (t-SNE) is a machine learning algorithm for dimensionality reduction developed by Laurens van der Maaten and Geoffrey Hinton. It is a nonlinear dimensionality reduction technique that is particularly well suited for embedding high-dimensional data into a space of two or three dimensions, which can then be visualized in a scatter plot. Specifically, it models each high-dimensional object by a two- or three-dimensional point in such a way that similar objects are modeled by nearby points and dissimilar objects are modeled by distant points.\nThe t-SNE algorithm comprises two main stages. First, t-SNE constructs a probability distribution over pairs of high-dimensional objects in such a way that similar objects have a high probability of being picked, whilst dissimilar points have an infinitesimal probability of being picked. Second, t-SNE defines a similar probability distribution over the points in the low-dimensional map, and it minimizes the Kullback–Leibler divergence between the two distributions with respect to the locations of the points in the map. Note that whilst the original algorithm uses the Euclidean distance between objects as the base of its similarity metric, this should be changed as appropriate.\nt-SNE has been used in a wide range of applications, including computer security research, music analysis, cancer research, and bioinformatics.","alt_names":[],"name":"T-distributed stochastic neighbor embedding","categories":["Machine learning algorithms"],"tag_line":"t-distributed stochastic neighbor embedding (t-SNE) is a machine learning algorithm for dimensionality reduction developed by Laurens van der Maaten and Geoffrey Hinton."}}
,{"_index":"throwtable","_type":"algorithm","_id":"matrix-multiplication-algorithm","_score":0,"_source":{"description":"Because matrix multiplication is such a central operation in many numerical algorithms, much work has been invested in making matrix multiplication algorithms efficient. Applications of matrix multiplication in computational problems are found in many fields including scientific computing and pattern recognition and in seemingly unrelated problems such counting the paths through a graph. Many different algorithms have been designed for multiplying matrices on different types of hardware, including parallel and distributed systems, where the computational work is spread over multiple processors (perhaps over a network).\nDirectly applying the mathematical definition of matrix multiplication gives an algorithm that takes time on the order of n3 to multiply two n × n matrices (Θ(n3) in big O notation). Better asymptotic bounds on the time required to multiply matrices have been known since the work of Strassen in the 1960s, but it is still unknown what the optimal time is (i.e., what the complexity of the problem is).\n\n","alt_names":[],"name":"Matrix multiplication algorithm","categories":["All articles containing potentially dated statements","Articles containing potentially dated statements from 2010","Matrix multiplication algorithms","Unsolved problems in computer science"],"tag_line":"Because matrix multiplication is such a central operation in many numerical algorithms, much work has been invested in making matrix multiplication algorithms efficient."}}
,{"_index":"throwtable","_type":"algorithm","_id":"kernel-methods-for-vector-output","_score":0,"_source":{"description":"Kernel methods are a well-established tool to analyze the relationship between input data and the corresponding output of a function. Kernels encapsulate the properties of functions in a computationally efficient way and allow algorithms to easily swap functions of varying complexity.\nIn typical machine learning algorithms, these functions produce a scalar output. Recent development of kernel methods for functions with vector-valued output is due, at least in part, to interest in simultaneously solving related problems. Kernels which capture the relationship between the problems allow them to borrow strength from each other. Algorithms of this type include multi-task learning (also called multi-output learning or vector-valued learning), transfer learning, and co-kriging. Multi-label classification can be interpreted as mapping inputs to (binary) coding vectors with length equal to the number of classes.\nIn Gaussian processes, kernels are called covariance functions. Multiple-output functions correspond to considering multiple processes. See Bayesian interpretation of regularization for the connection between the two perspectives.","alt_names":[],"name":"Kernel methods for vector output","categories":["Kernel methods for machine learning","Machine learning algorithms"],"tag_line":"Kernel methods are a well-established tool to analyze the relationship between input data and the corresponding output of a function."}}
,{"_index":"throwtable","_type":"algorithm","_id":"delay-gradient-congestion-control","_score":0,"_source":{"description":"In computer networking, delay-gradient congestion control refers to a class of congestion control algorithms, which react to the differences in round-trip delay time (RTT), as opposed to classical congestion control methods, which react to packet loss or an RTT threshold being exceeded. Such algorithms include CAIA Delay-Gradient (CDG) and TIMELY.\n^ Jonathan Corbet (20 May 2015). \"Delay-gradient congestion control\". LWN.net. \n^ a b David A. Hayes, Grenville Armitage (May 2011). Revisiting TCP congestion control using delay gradients. 10th International IFIP TC 6 Networking Conference (NETWORKING 2011). \n^ a b Radhika Mittal, Vinh The Lam, Nandita Dukkipati, Emily Blem, Hassan Wassel, Monia Ghobadi, Amin Vahdat, Yaogong Wang, David Wetherall, David Zats (2015). TIMELY: RTT-based Congestion Control for the Datacenter. SIGCOMM 2015. \n^ Grenville Armitage, Naeem Khademi (2013). Using Delay-Gradient TCP for Multimedia-Friendly ‘Background’ Transport in Home Networks. IEEE 38th Conference on Local Computer Networks (LCN 2013).","alt_names":[],"name":"Delay-gradient congestion control","categories":["All stub articles","Computer network stubs","Network performance","Network scheduling algorithms"],"tag_line":"In computer networking, delay-gradient congestion control refers to a class of congestion control algorithms, which react to the differences in round-trip delay time (RTT), as opposed to classical congestion control methods, which react to packet loss or an RTT threshold being exceeded."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hierarchical-fair-service-curve","_score":0,"_source":{"description":"The hierarchical fair-service curve (HFSC) is a network scheduling algorithm for a network scheduler proposed by Ion Stoica, Hui Zhang and T. S. Eugene from Carnegie Mellon University at SIGCOMM 1997\nIt is based on a QoS and CBQ. An implementation of HFSC is available in all operating systems based on the Linux kernel, such as e.g. OpenWrt, and also in DD-WRT, NetBSD 5.0, FreeBSD 8.0 and OpenBSD 4.6.\n\n","alt_names":[],"name":"Hierarchical fair-service curve","categories":["All stub articles","Network performance","Network scheduling algorithms","Network software stubs"],"tag_line":"The hierarchical fair-service curve (HFSC) is a network scheduling algorithm for a network scheduler proposed by Ion Stoica, Hui Zhang and T. S. Eugene from Carnegie Mellon University at SIGCOMM 1997\nIt is based on a QoS and CBQ."}}
,{"_index":"throwtable","_type":"algorithm","_id":"manifold-alignment","_score":0,"_source":{"description":"Manifold alignment is a class of machine learning algorithms that produce projections between sets of data, given that the original data sets lie on a common manifold. The concept was first introduced as such by Ham, Lee, and Saul in 2003, adding a manifold constraint to the general problem of correlating sets of high-dimensional vectors.","alt_names":[],"name":"Manifold alignment","categories":["Artificial intelligence","Machine learning algorithms"],"tag_line":"Manifold alignment is a class of machine learning algorithms that produce projections between sets of data, given that the original data sets lie on a common manifold."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ancient-egyptian-multiplication","_score":0,"_source":{"description":"In mathematics, ancient Egyptian multiplication (also known as Egyptian multiplication, Ethiopian multiplication, Russian multiplication, or peasant multiplication), one of two multiplication methods used by scribes, was a systematic method for multiplying two numbers that does not require the multiplication table, only the ability to multiply and divide by 2, and to add. It decomposes one of the multiplicands (generally the larger) into a sum of powers of two and creates a table of doublings of the second multiplicand. This method may be called mediation and duplation, where mediation means halving one number and duplation means doubling the other number. It is still used in some areas.\nThe second Egyptian multiplication and division technique was known from the hieratic Moscow and Rhind Mathematical Papyri written in the seventeenth century B.C. by the scribe Ahmes.\nAlthough in ancient Egypt the concept of base 2 did not exist, the algorithm is essentially the same algorithm as long multiplication after the multiplier and multiplicand are converted to binary. The method as interpreted by conversion to binary is therefore still in wide use today as implemented by binary multiplier circuits in modern computer processors.","alt_names":["peasant multiplication","Peasant multiplication","- Ancient Egyptian multiplication :","...Wikipedia Multiplicación por duplicación","...Wikipedia Technique de la multiplication en Égypte antique","...Wikipedia Technique de multiplication dite russe","...mehr auf Wikipedia über Russische Bauernmultiplikation","...more on Wikipedia about Peasant multiplication","Also includes Ancient Egyptian Multiplication Method (alternative algorithm","Ancient Egyptian Multiplication","Ancient Egyptian Multiplication on wikipedia","Ancient Egyptian Vermenigvuldigen","Ancient Egyptian method","Ancient Egyptian mnożenia","Ancient Egyptian multiplication","Ancient Egyptian multiplication - Wikipedia :: The free encyclopedia","Ancient Egyptian multiplication - Wikipedia, the free ...","Ancient Egyptian multiplication - Wikipedia, the free encyclopedia","Ancient Egyptian multiplication - Wikipedia, the free encyclopedia ...","Ancient Egyptian multiplication Wikipedia the free encyclopedia","Ancient Egyptian multiplication; it is used under the","Ancient_Egyptian_multiplication","Antico Egitto moltiplicazione","Antiguo Egipto multiplicación","Bauernmultiplikation: http://de.wikipedia.org/wiki/Russische_Bauernmultiplikation","Egyptian Doubling","Egyptian Multiplication","Egyptian algorithm","Egyptian algorithm algorithm(wikipedia)","Egyptian algorithm(wikipedia)","Egyptian multiplication","Egyptians used binary","Multiplicació per duplicació","Multiplicació per duplicació - Viquipèdia","Multiplicación por Duplicación","Multiplicación por duplicación","Multiplicación por duplicación - Wikipedia, la enciclopedia libre","Multiplication égyptienne","Multiplikation, die man üblicherweise in der Grundschule","Nga Nông dân cửu.","Peasant Algorithm and Ancient Egyptian Multiplication","Peasant multiplication - Wikipedia, the free encyclopedia","Peasant_multiplication","Petani Rusia Perkalian.","Rechentricks","Russian Peasant ...","Russian Peasant Multiplication","Russian Peasant multiplication","Russian peasant multiplication","Russian peasants' algorithm","Russian/Peasant multiplication","Russie Multiplication des paysans.","Russische Bauernmuliplikation","Russische Bauernmultiplikation","Russische Bauernmultiplikation – Wikipedia","Russische_Bauernmultiplikation","Russischen Bauernmultiplikation","TIL About Ancient Egyptian multiplication, aka Ethiopian multiplication","Technique de la multiplication dans l'Égypte ancienne","Technique de la multiplication dans l'Égypte antique","Technique de la multiplication en Égypte antique","Technique de multiplication dite russe","Technique de multiplication dite russe - Wikipédia","The Egyptian Method","The decomposition","What is Russian peasant algorithm's example?","What is the example of Ancient egyptian multiplication","What is the example of Egyptian multiplication?","What is the example of Russian peasant multiplication","Wikipedia article Ancient Egyptian multiplication","Wikipedia article Egyptian multiplication","Wikipedia article Multiplicação por duplicação","Wikipedia article Peasant multiplication","Wikipedia article Russian peasant multiplication","Wikipedia article Russische Bauernmultiplikation","Wikipedia article Technique de la multiplication dans l","Wikipedia article on Ancient Egyptian multiplication","Wikipedia article on Duplicación y mediación","Wikipedia article on Peasant multiplication","Wikipedia article Египатско множење","Wikipedia entry for Ancient Egyptian multiplication","Wikipedia-Artikel Bauernmultiplikation","Wikipedia-Artikel Russische Bauernmultiplikation","Wikipedia-Seite zu 'Russische Bauernmultiplikation'","Wikipedia: Russische_Bauernmultiplikation","altägyptischen Multiplikation","ancient Egyptian multiplication","ancient egyptian","ancient multiplication method","artigo da Wikipédia Multiplicação por duplicação","artículo de Wikipedia Duplicación y mediación","boerenvermenigvuldigen","ca:Multiplicació per duplicació","contadina russa Moltiplicazione.","d) Ancient Egyptian multiplication","de.wikipedia.org/wiki/Russische_Bauernmultiplikation","de:Russische Bauernmultiplikation","duplation","e) Peasant multiplication","en.wikipedia.org/...ncient_Egyptian_multiplication","en.wikipedia.org/wiki/Ancient_Egyptian_multiplication","en:Ancient Egyptian multiplication","en:Ancient Egyptian multiplication#Peasant multiplication","es.wikipedia.org/wiki/Multiplicaci%C3%B3n_por_duplicaci%C3","es:multiplicación por duplicación","fr:Technique de la multiplication en Égypte antique","fr:Technique de multiplication dite russe","gamle egyptiske Multiplikation","http://de.wikipedia.org/wiki/Bauernmultiplikation","http://de.wikipedia.org/wiki/Ru ssische_Bauernmultiplikation","http://de.wikipedia.org/wiki/Russisc...ikation#Beweis","http://de.wikipedia.org/wiki/Russisc...multiplikation","http://de.wikipedia.org/wiki/Russische_ ... iplikation","http://de.wikipedia.org/wiki/Russische_Bauernmultiplikation","http://de.wikipedia.org/wiki/Russische_B…","http://el.wikipedia.org/wiki/Πολλαπλασιασμός_αλά_Ρωσικά","http://el.wikipedia.org/wiki/Πολλαπλασιασμός_αλά_ρωσικά","http://en.wikipedia.org/wiki/Ancien..._multiplication","http://en.wikipedia.org/wiki/Ancient...multiplication","http://en.wikipedia.org/wiki/Ancient_Eg ... iplication","http://en.wikipedia.org/wiki/Ancient_Egyptian_multiplication","http://en.wikipedia.org/wiki/Ancient_Egyptian_multiplication#Peasant_multiplication","http://en.wikipedia.org/wiki/Ancient_Egyptian_multiplication#The_decom...","http://en.wikipedia.org/wiki/Ancient_Egyptian_multiplication#The_table","http://en.wikipedia.org/wiki/Egyptian_multiplication","http://en.wikipedia.org/wiki/Peasant_multiplication","http://en.wikipedia.org/wiki/Peasant_multiplication#Peasant_multiplication","http://es.wikipedia.org/wiki/Multipl...plicaci%C3","http://es.wikipedia.org/wiki/Multiplica ... aci%C3","http://es.wikipedia.org/wiki/Multiplicaci%C3%B3n_por_duplicaci","http://fr.wikipedia....tion_dite_russe","http://fr.wikipedia.org/wiki/Techn [...] te_antique","http://fr.wikipedia.org/wiki/Techniq...ion_dite_russe","http://fr.wikipedia.org/wiki/Technique_ ... dite_russe","http://fr.wikipedia.org/wiki/Technique_ ... te_antique","http://fr.wikipedia.org/wiki/Technique_de_la_multiplication_dans_l%27%C3","http://fr.wikipedia.org/wiki/Technique_de_la_multiplication_dans_l'%C3%89gypte_antique","http://fr.wikipedia.org/wiki/Technique_de_la_multiplication_en_%C3%89gypte_antique","http://fr.wikipedia.org/wiki/Technique_de_multiplication_dite_russe","ko:고대 이집트 곱셈법","la multiplicación de Rusia campesina.","la multiplicación por duplicación","leur façon","m &Element; &Nopf;","method of shifting and adding","multiplicaci³#N por duplicaci³#N","multiplicación en el Antiguo Egipto","multiplicación por duplicación","multiplication russe","método ruso","pt:Multiplicação por duplicação","russische Bauernmultiplikation","russischen Bauern Multiplikation.","russischen Bauernmultiplikation","russo Peasant Multiplicação.","sr:Египатско множење","starověké egyptské násobení","technique de multiplication dans l'Égypte antique","technique de multiplication en Égypte antique","techniques de multiplication","the Russian Peasant Algorithm, a quick way to","ìEgyptian Multiplicationî","Πολλαπλασιασμός αλά ρωσικά","Πολλαπλασιασμός αλά ρωσικά - Βικιπαίδεια","Египатско множење","Русский Крестьянские умножения.","древнеегипетской умножения","еще в 1700 году до н. э.","сдвигов и сложений","प्राचीन मिस्र के गुणा","รัสเซีย ชาวไร่ คูณ.","“Egyptian Multiplication”","ロシアの農民の乗算","俄国农民乘法","俄羅斯農民乘法","古代エジプトの乗算","고대 이집트 곱셈법","러시아어 농민 곱셈","，被称为"],"name":"Ancient Egyptian multiplication","categories":["All articles lacking in-text citations","All articles needing cleanup","Ancient Egyptian literature","Articles lacking in-text citations from February 2011","Articles needing cleanup from February 2011","Cleanup tagged articles without a reason field from February 2011","Egyptian fractions","Egyptian mathematics","Mathematics manuscripts","Multiplication","Number theoretic algorithms","Wikipedia pages needing cleanup from February 2011"],"tag_line":"In mathematics, ancient Egyptian multiplication (also known as Egyptian multiplication, Ethiopian multiplication, Russian multiplication, or peasant multiplication), one of two multiplication methods used by scribes, was a systematic method for multiplying two numbers that does not require the multiplication table, only the ability to multiply and divide by 2, and to add."}}
,{"_index":"throwtable","_type":"algorithm","_id":"round-robin-scheduling","_score":0,"_source":{"description":"Round-robin (RR) is one of the algorithms employed by process and network schedulers in computing. As the term is generally used, time slices are assigned to each process in equal portions and in circular order, handling all processes without priority (also known as cyclic executive). Round-robin scheduling is simple, easy to implement, and starvation-free. Round-robin scheduling can also be applied to other scheduling problems, such as data packet scheduling in computer networks. It is an Operating System concept.\nThe name of the algorithm comes from the round-robin principle known from other fields, where each person takes an equal share of something in turn.","alt_names":["RoundRobin","ラウンドロビン方式","Round-Robin-Verfahren","...Wikipedia Planificación Round-robin","...Wikipedia Round robin","...mehr auf Wikipedia über Round Robin (Informatik)","...more on Wikipedia about Round-robin scheduling","1 Process scheduling","2 Data packet scheduling","4. Round-Robin","Aplicación en Sistemas Operativos","DNS-RoundRobin","Data packet scheduling","Definición de Planificación Round-robin más completo","L'articolo wiki","Learn about Round-robin scheduling>>>","NOT round robin","Planificacion Round-robin","Planificación Round-Robin","Planificación Round-robin","Planificación Round-robin - Wikipedia, la enciclopedia libre","RR (Round Robin)","RR 스케줄링","Red Robin Scheduling","Robin-round","Ronda Robin","Round Robin (Informatik)","Round Robin (Informatik) - Wikipedia","Round Robin (Informatik) – Wikipedia","Round Robin (RR) scheduling","Round Robin ?","Round Robin Harmonogram","Round Robin Planlægning","Round Robin Prinzip","Round Robin Schedule - 7 Team","Round Robin Scheduling","Round Robin Scheduling?","Round Robin load balancer","Round Robin planning","Round Robin policy","Round Robin scheduler","Round Robin планирования","Round Robin(RR)","Round Robin-Verfahren","Round Robing Scheduling","Round robin scheduling","Round-","Round-Robin Algorithmus","Round-Robin p","Round-Robin scheduling (RR scheduling)","Round-Robin-Algorithmus","Round-Robin_(Informatik)","Round-roben scheduling","Round-robin (informatique)","Round-robin (informatique) - Wikip?dia","Round-robin (informatique) - Wikipédia","Round-robin (informatique) toujours de wikipedia","Round-robin (алгоритм)","Round-robin (алгоритм) — Википедия","Round-robin Load Balancing","Round-robin scheduling","Round-robin scheduling - Wikipedia :: The free encyclopedia","Round-robin scheduling - Wikipedia, the free encyclopedia","Round-robin scheduling - Wikipedia, the free encyclopedia ...","Round-robin scheduling From Wikipedia","Round-robin scheduling; it is used under the","Round-robin_scheduling","RoundRobin-Verfahren","Round_Robin_(Informatik)","Roundrobin scheduling","Rundlauf-Verfahren","Wikipedia : ラウンドロビン・スケジューリング","Wikipedia article Round-Robin scheduling","Wikipedia article Round-robin scheduling","Wikipedia article on Planificación Round-robin","Wikipedia article on Round-robin scheduling","Wikipedia entry for Round-robin scheduling","Wikipedia-Artikel Round Robin (Informatik)","Wikipedia-Artikel Round-Robin (Informatik)","Wikipedia-Seite zu 'Round Robin (Informatik)'","Wikipedia-Seite zu 'Round-Robin (Informatik)'","Wikipedia: Round Robin","Wikipediaで「ラウンドロビンスケジューリング」を調べる","Wikipediaで「ラウンドロビン・スケジューリング」を調べる","Wikipediaで「ラウンドロビン方式」を調べる","[8] Round Robin","algoritma round-robin.","algoritmo Round Robin","algoritmo de Round-Robin","artículo de Wikipedia Planificación Round-Robin","artículo de Wikipedia Planificación Round-robin","de.wikipedia.org/wik...d_Robin_(Informatik)","didistribusikan secara round-robin","en.wikipedia.org/wiki/Round-robin_scheduling","en:Round-robin scheduling","fr:Round-robin (informatique)","http://cs.wikipedia.org/wiki/Round-robin_scheduling","http://de.wikipedia.org/wiki/Round-Robin_(Informatik","http://de.wikipedia.org/wiki/Round_R...8Informatik%29","http://de.wikipedia.org/wiki/Round_Robi ... ormatik%29","http://de.wikipedia.org/wiki/Round_Robin_ ...","http://de.wikipedia.org/wiki/Round_Robin_%28Informatik%29","http://de.wikipedia.org/wiki/Round_Robin_(Informatik)","http://el.wikipedia.org/wiki/Round-Robin","http://el.wikipedia.org/wiki/Round-Robin_scheduling","http://el.wikipedia.org/wiki/Χρονοπρογραμματισμός_εξυπηρέτησης_εκ_περιτροπής","http://em.wikipedia.org/wiki/Round-robinscheduling","http://en.wikipedia.org/wiki/Round-robin scheduling","http://en.wikipedia.org/wiki/Round-robin_","http://en.wikipedia.org/wiki/Round-robin_schedulin g","http://en.wikipedia.org/wiki/Round-robin_scheduling","http://en.wikipedia.org/wiki/Round-robin_scheduling;","http://en.wikipedia.org/wiki/Round−robin_scheduling","http://es.wikipedia.org/wiki/Planifi...3n_Round-robin","http://es.wikipedia.org/wiki/Planificac ... ound-robin","http://es.wikipedia.org/wiki/Planificaci%C3%B3n_Round","http://es.wikipedia.org/wiki/Planificacion Round-robin","http://es.wikipedia.org/wiki/Planificación_Round-Robin","http://et.wikipedia.org/wiki/Round_Robin","http://fr.wikipedia.org/wiki/Round [...] ormatique)","http://fr.wikipedia.org/wiki/Round-robi ... matique","http://fr.wikipedia.org/wiki/Round-robin_%28informatique","http://fr.wikipedia.org/wiki/Round-robin_(informatique","http://ja.wikipedia.org/wiki/ラウンドロビン・スケジューリング","http://pl.wikipedia.org/wiki/Round_robin","http://ru.wikipedia.org/wiki/Round-robin_%28","http://ru.wikipedia.org/wiki/Round-robin_(%D0","http://ru.wikipedia.org/wiki/Round-robin_(алгоритм","http://sl.wikipedia.org/wiki/Round_robin","http://sv.wikipedia.org/wiki/Round_Robin","http://sv.wikipedia.org/wiki/Round_robin","link zu round robin","método Round Robin","planificación Round-robin","planificación por turno rotatorio","rou nd-robin","round robin load balancing","round robin scheduler","round-robin algorithm","round-robin order","round-robin schedule","round-robin scheduling","round-robin scheduling algorithm","round-robin scheduling algorithms","round-robin shedule","round-robin thread scheduler","sistema Round-Robin","ttp://en.wikipedia.org/wiki/Round-robin_scheduling","Википедии статью Round-robin (алгоритм)","Планирование Round-robin","сему алгоритму","「ラウンドロビン方式」をWikiで調べる","ウィキペディアの記事 ラウンドロビン・スケジューリング","ラウンドロビンアルゴリズム","ラウンドロビンスケジューリング","ラウンドロビン・アルゴリズム","ラウンドロビン・スケジューリング","ラウンドロビン・スケジューリング - Wikipedia","라운드 로빈 스케줄링","위키 피 디아 문서 RR 스케줄링","위키 피 디아 문서 라운드 로빈 스케줄링","위키 피 디아 문서 라운드로빈 스케줄링","ﾗｳﾝﾄﾞﾛﾋﾞﾝ・ｽｹｼﾞｭｰﾘﾝｸﾞ-wikipedia","ﾗｳﾝﾄﾞﾛﾋﾞﾝ方式-wikipedia"],"name":"Round-robin scheduling","categories":["All articles needing additional references","Articles needing additional references from April 2015","Network scheduling algorithms","Processor scheduling algorithms"],"tag_line":"Round-robin (RR) is one of the algorithms employed by process and network schedulers in computing."}}
,{"_index":"throwtable","_type":"algorithm","_id":"leaky-bucket","_score":0,"_source":{"description":"The leaky bucket is an algorithm used in packet switched computer networks and telecommunications networks. It can be used to check that data transmissions, in the form of packets, conform to defined limits on bandwidth and burstiness (a measure of the unevenness or variations in the traffic flow). It can also be used as a scheduling algorithm to determine the timing of transmissions that will comply with the limits set for the bandwidth and burstiness: see network scheduler. The leaky bucket algorithm is also used in leaky bucket counters, e.g. to detect when the average or peak rate of random or stochastic events or stochastic processes exceed defined limits.\nA version of the leaky bucket, the Generic Cell Rate Algorithm, is recommended for Asynchronous Transfer Mode (ATM) networks in Usage/Network Parameter Control at User–Network Interfaces or Inter-Network Interfaces or Network-Network Interfaces to protect a network from excessive traffic levels on connections routed through it. The Generic Cell Rate Algorithm, or an equivalent, may also be used to shape transmissions by a Network Interface Card onto an ATM network (i.e. on the user side of the User-Network Interface), e.g. to levels below the levels set for Usage/Network Parameter Control in the network to prevent it taking action to further limit that connection.","alt_names":["en.wikipedia.org/wiki/Leaky...","Leaky bucket","leaky bucket","( en )Leaky bucket","- Leaky bucket :","-> Read more about Leaky bucket","-> Read the article about 'Leaky bucket'","...mehr auf Wikipedia über Leaky Bucket","...more on Wikipedia about Leaky bucket","Automobile traffic analogy","Figure 2: Traffic policing with a leaky bucket","I'm a bucket's half full kind o","Le seau pe","Leaky - Bucket - Algorithmus - Wikipedia","Leaky Bucket","Leaky Bucket (QoS)","Leaky Bucket Algorithm","Leaky Bucket algorithm","Leaky Bucket approach","Leaky Bucket â�“ Wikipedia, wolna encyklopedia","Leaky Bucket – Wikipedia, wolna encyklopedia","Leaky bucket - Wikipedia, the free encyclopedia","Leaky bucket Wikipedia the free encyclopedia","Leaky bucket rate limiting algorithm explained","Leaky bucket; it is used under the","Leaky-Bucket-","Leaky-Bucket-Algorithmus","Leaky-Bucket-Algorithmus bei der wikipedia","Leaky-Bucket-Algorithmus â€“ Wikipedia","Leaky-Bucket-Algorithmus – Wikipedia","LeakyBucket","Leaky_Bucket bei der wikipedia","Leaky_bucket","Luis Botelho","Pesquisar leaky bucket na Wikipedia Portugal","Seau perc? - Wikip?dia","Seau percé","Seau percé - Wikipédia","The leaky-bucket algorithm","Traffic shaping algorithms","What are the uses of Leaky Bucket?","Wikipedia (Leaky bucket)","Wikipedia article ''Leaky bucket''","Wikipedia article Leaky Bucket","Wikipedia article Leaky bucket","Wikipedia entry for Leaky bucket","Wikipedia sur Seau percé","Wikipedia-Artikel Leaky Bucket","Wikipedia-Artikel Leaky-Bucket-Algorithmus","Wikipediaで「リーキーバケット」を調べる","bacia-com-agua1","balde furado","con goteras cubo","concept of operation","cubeta con goteo","de:Leaky-Bucket-Algorithmus","delay variation","drip drip drip drippy drippy drip drop","děravé vědro","ember bocor","emission interval","en.wikipedia.org/...Leaky_bucket","fugas balde","http://de.wikipedia.org/wiki/Leaky-Bucke","http://de.wikipedia.org/wiki/Leaky-Bucket-Algorithmus","http://de.wikipedia.org/wiki/Leaky_Bucket","http://en.wikipedia.org/wiki/Leaky_bucke","http://en.wikipedia.org/wiki/Leaky_bucket","http://en.wikipedia.org/wiki/Leaky_bucke…","http://fr.wikipedia.org/wiki/Seau_perc%C3%A9","http://pl.wikipedia.org/wiki/Leaky_Bucket","ja:リーキーバケット","l'article de Wikipédia Seau percé","leaky bucket algorithm","leaky bucket#Maximum Burst Size","leaky bucket: delay variation tolerance","leaky buckets","leaky-bucket","lekke emmer","maximum burst size","oncept of operation f","pl:Leaky Bucket","pt:Leaky Bucket","seau percé","seau qui fuit","the leaky bucket algorithm,","the leaky bucket as a meter","the leaky bucket as a queue","utætte spand","xô leaky","Ένα πολύ καλό άρθρο της wikipedia σχετικά με","Дырявые ведра или что такое burst","Дырявые ведра или что такое burst?","дырявое ведро","ถังรั่ว","“Leaky bucket - Wikipedia, the free encyclopedia”, en.wikipedia","バケット最大","リーキーバケット","リーキーバケット - Wikipedia","漏出バケット","漏桶","새는 양동이","ﾘｰｷｰﾊﾞｹｯﾄ-wikipedia"],"name":"Leaky bucket","categories":["Network scheduling algorithms"],"tag_line":"The leaky bucket is an algorithm used in packet switched computer networks and telecommunications networks."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pollard's-rho-algorithm-for-logarithms","_score":0,"_source":{"description":"Pollard's rho algorithm for logarithms is an algorithm introduced by John Pollard in 1978 to solve the discrete logarithm problem, analogous to Pollard's rho algorithm to solve the integer factorization problem.\nThe goal is to compute  such that , where  belongs to a cyclic group  generated by . The algorithm computes integers , , , and  such that . Assuming, for simplicity, that the underlying group is cyclic of order , we can calculate  as a solution of the equation .\nTo find the needed , , , and  the algorithm uses Floyd's cycle-finding algorithm to find a cycle in the sequence , where the function  is assumed to be random-looking and thus is likely to enter into a loop after approximately  steps. One way to define such a function is to use the following rules: Divide  into three disjoint subsets of approximately equal size: , , and . If  is in  then double both  and ; if  then increment , if  then increment .","alt_names":["Pollard's rho algorithm for logarithms","-> Read more about Pollard's rho algorithm for logarithms","Learn about Pollard's rho algorithm for logarithms>>>","Pollard%27s_rho_algorithm_for_logarithms","Pollard's rho algorithm (for logarithms)","Pollard's rho algorithm for logarithms - Wikipedia ...","Pollard's rho algorithm for logarithms - Wikipedia :: The free","Pollard's rho algorithm for logarithms - Wikipedia, the","Pollard's rho algorithm for logarithms - Wikipedia, the free","What is Pollard rho algorithm for logarithms's example","Wikipedia article ''Pollard's rho algorithm for logarithms''","Wikipedia article Pollard's rho algorithm for logarithms","en.wikipedia.org/wiki/Pollard's_rho_algorithm_for_logarithms","en:Pollard's rho algorithm for logarithms","en:Pollard\\'s rho algorithm for logarithms","http://en.wikipedia.org/wiki/Pollard %27s_rho_algorithm_for_logarithms","http://en.wikipedia.org/wiki/Pollard%27 ? logarithms","http://en.wikipedia.org/wiki/Pollard%27 … logarithms","http://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm_for_logarithms","http://en.wikipedia.org/wiki/Pollard's_rho_algorithm_for_logarithms","http://en.wikipedia.org/wiki/Pollard...for_logarithms","pollard's-rho algorithm","rho algorithm","rho algorithm for logarithms","x i = α a i β b i","Ρ-метод Полларда ...","Ρ-метод Полларда дискретного логарифмирования","ρ-метод Полларда","ρ-метода","Википедии статью Ρ-метод Полларда дискретного логарифмирования","ро-алгоритм Полларда"],"name":"Pollard's rho algorithm for logarithms","categories":["Logarithms","Number theoretic algorithms"],"tag_line":"Pollard's rho algorithm for logarithms is an algorithm introduced by John Pollard in 1978 to solve the discrete logarithm problem, analogous to Pollard's rho algorithm to solve the integer factorization problem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cipolla's-algorithm","_score":0,"_source":{"description":"In computational number theory, Cipolla's algorithm is a technique for solving a congruence of the form\n\nwhere , so n is the square of x, and where  is an odd prime. Here  denotes the finite field with  elements; . The algorithm is named after Michele Cipolla, an Italian mathematician who discovered it in 1907.\n\n","alt_names":["Cipolla's algorithm","Cipolla's algorithm - Wikipedia, the free ...","Cipolla's algorithm - Wikipedia, the free encyclopedia","Wikipedia article Cipolla's algorithm","en.wikipedia.org/wiki/Cipolla%27s_algorithm","http://en.wikipedia.org/wiki/Cipolla %27s_algorithm","http://en.wikipedia.org/wiki/Cipolla%27s_algorithm","http://en.wikipedia.org/wiki/Cipolla's_algorithm"],"name":"Cipolla's algorithm","categories":["Articles containing proofs","Modular arithmetic","Number theoretic algorithms"],"tag_line":"In computational number theory, Cipolla's algorithm is a technique for solving a congruence of the form\n\nwhere , so n is the square of x, and where  is an odd prime."}}
,{"_index":"throwtable","_type":"algorithm","_id":"gradient-method","_score":0,"_source":{"description":"In optimization, gradient method is an algorithm to solve problems of the form\n\nwith the search directions defined by the gradient of the function at the current point. Examples of gradient method are the gradient descent and the conjugate gradient.","alt_names":[],"name":"Gradient method","categories":["First order methods","Gradient methods","Numerical linear algebra","Optimization algorithms and methods"],"tag_line":"In optimization, gradient method is an algorithm to solve problems of the form\n\nwith the search directions defined by the gradient of the function at the current point."}}
,{"_index":"throwtable","_type":"algorithm","_id":"k-server-problem","_score":0,"_source":{"description":"The k-server problem is a problem of theoretical computer science in the category of online algorithms, one of two abstract problems on metric spaces that are central to the theory of competitive analysis (the other being metrical task systems). In this problem, an online algorithm must control the movement of a set of k servers, represented as points in a metric space, and handle requests that are also in the form of points in the space. As each request arrives, the algorithm must determine which server to move to the requested point. The goal of the algorithm is to keep the total distance all servers move small, relative to the total distance the servers could have moved by an optimal adversary who knows in advance the entire sequence of requests.\nThe problem was first posed by Mark Manasse, Lyle A. McGeoch and Daniel Sleator (1990). The most prominent open question concerning the k-server problem is the so-called k-server conjecture, also posed by Manasse et al. This conjecture states that there is an algorithm for solving the k-server problem in an arbitrary metric space and for any number k of servers that has competitive ratio at least k. Manasse et al. were able to prove their conjecture when k = 2, and for more general values of k when the metric space is restricted to have exactly k+1 points. Chrobak and Larmore (1991) proved the conjecture for tree metrics. The special case of metrics in which all distances are equal is called the paging problem because it models the problem of page replacement algorithms in memory caches, and was also already known to have a k-competitive algorithm (Sleator and Tarjan 1985). Fiat et al. (1990) first proved that there exists an algorithm with finite competitive ratio for any constant k and any metric space, and finally Koutsoupias and Papadimitriou (1995) proved that Work Function Algorithm (WFA) has competitive ratio 2k - 1. However, despite the efforts of many other researchers, reducing the competitive ratio to k or providing an improved lower bound remains open as of 2014. The most common believed scenario is that the Work Function Algorithm is k-competitive. To this direction, in 2000 Bartal and Koutsoupias showed that this is true for some special cases (if the metric space is a line, a weighted star or any metric of k+2 points).\nIn 2011, a randomized algorithm with competitive bound Õ(log2k log3n) was found.","alt_names":["- K-server problem :","K server problem","K-server conjecture.","K-server conjecture..","K-server problem","K-server problem - Wikipedia, the free encyclopedia","K-server problem - Wikipedia, the free encyclopedia ...","K-server problem →","K-server problem; it is used under the","K-server_problem","Kserver problem","What is K-server problem's example","Wikipedia article K-server problem","Wikipedia article on K-server problem","http://en.wikipedia.org/wiki/K-server_problem","k-server problem","moving-server","server problem","yago-res:K-server problem"],"name":"K-server problem","categories":["All articles containing potentially dated statements","Articles containing potentially dated statements from 2014","Online algorithms","Unsolved problems in computer science"],"tag_line":"The k-server problem is a problem of theoretical computer science in the category of online algorithms, one of two abstract problems on metric spaces that are central to the theory of competitive analysis (the other being metrical task systems)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"splitting-circle-method","_score":0,"_source":{"description":"In mathematics, the splitting circle method is a numerical algorithm for the numerical factorization of a polynomial and, ultimately, for finding its complex roots. It was introduced by Arnold Schönhage in his 1982 paper The fundamental theorem of algebra in terms of computational complexity (Technical report, Mathematisches Institut der Universität Tübingen). A revised algorithm was presented by Victor Pan in 1998. An implementation was provided by Xavier Gourdon in 1996 for the Magma and PARI/GP computer algebra systems.","alt_names":["...Wikipedia Méthode du cercle de séparation","...more on Wikipedia about Splitting circle method","Basic numerical observation","Details of the analytical construction","Finding a good circle","How is Splitting circle method's general description","Méthode du cercle de séparation","Méthode du cercle de séparation - Wikipédia","Splitting circle","Splitting circle method","Splitting circle method - Wikipedia, the free encyclopedia","Trennkreisverfahren","Trennkreisverfahren - Wikipedia","Trennkreisverfahren bei Wikipedia","Wikipedia article Splitting circle method","Wikipedia entry for Splitting circle method","Wikipedia sur Méthode du cercle de séparation","Wikipedia-Artikel Trennkreisverfahren","de:Trennkreisverfahren","en.wikipedia.org/wiki/Splitting_circle_method","en:Splitting circle method","fr:Méthode du cercle de séparation","http://de.wikipedia.org/wiki/Trennkreisv","http://de.wikipedia.org/wiki/Trennkreisverfahren","http://en.wikipedia.org/wiki/Splitting circle method","http://en.wikipedia.org/wiki/Splitting_c","http://en.wikipedia.org/wiki/Splitting_circle_method","http://fr.wikipedia.org/wiki/Méthode_du_cercle_de_séparation","p &Element; &Copf; [ X ]","p ( x ) = x n + p n - 1 x","splitting circle method","yago-res:Splitting circle method"],"name":"Splitting circle method","categories":["Root-finding algorithms"],"tag_line":"In mathematics, the splitting circle method is a numerical algorithm for the numerical factorization of a polynomial and, ultimately, for finding its complex roots."}}
,{"_index":"throwtable","_type":"algorithm","_id":"inverse-quadratic-interpolation","_score":0,"_source":{"description":"In numerical analysis, inverse quadratic interpolation is a root-finding algorithm, meaning that it is an algorithm for solving equations of the form f(x) = 0. The idea is to use quadratic interpolation to approximate the inverse of f. This algorithm is rarely used on its own, but it is important because it forms part of the popular Brent's method.","alt_names":["-> Read more about Inverse quadratic interpolation","...more on Wikipedia about Inverse quadratic interpolation","Explanation of the method","Interpolation quadratique inverse","Inverse Quadratic Method","Inverse quadratic interpolation","Inverse quadratic interpolation - Wikipedia, the free encyclopedia","Inverse quadratic interpolation - Wikipedia, the free encyclopedia ...","What is behaviour of Inverse quadratic interpolation","What is behaviour of Inverse quadratic interpolation?","Wikipedia article Inverse quadratic interpolation","Wikipedia entry for Inverse quadratic interpolation","en.wikipedia.org/wiki/Inverse_quadratic_interpolation","fr:Interpolation quadratique inverse","http://en.wikipedia.org/wiki/Inverse..._interpolation","http://en.wikipedia.org/wiki/Inverse_qua","http://en.wikipedia.org/wiki/Inverse_quadratic_interpolation","http://en.wikipedia.org/wiki/Inverse_qua…","http://fr.wikipedia.org/wiki/Interp...ratique_inverse","interpolation quadratique inverse","inverse quadratic interpolation","inverse quadratic interpolation.","inverse quadratic method","x n + 1 = f n - 1 f n","yago-res:Inverse quadratic interpolation"],"name":"Inverse quadratic interpolation","categories":["Root-finding algorithms"],"tag_line":"In numerical analysis, inverse quadratic interpolation is a root-finding algorithm, meaning that it is an algorithm for solving equations of the form f(x) = 0."}}
,{"_index":"throwtable","_type":"algorithm","_id":"durand–kerner-method","_score":0,"_source":{"description":"In numerical analysis, the Durand–Kerner method, established 1960–66 and named after E. Durand and Immo Kerner, also called the method of Weierstrass, established 1859–91 and named after Karl Weierstrass, is a root-finding algorithm for solving polynomial equations. In other words, the method can be used to solve numerically the equation\nƒ(x) = 0\nwhere ƒ is a given polynomial, which can be taken to be scaled so that the leading coefficient is 1.","alt_names":[],"name":"Durand–Kerner method","categories":["Root-finding algorithms"],"tag_line":"In numerical analysis, the Durand–Kerner method, established 1960–66 and named after E. Durand and Immo Kerner, also called the method of Weierstrass, established 1859–91 and named after Karl Weierstrass, is a root-finding algorithm for solving polynomial equations."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sidi's-generalized-secant-method","_score":0,"_source":{"description":"Sidi's generalized secant method is a root-finding algorithm, that is, a numerical method for solving equations of the form  . The method was published by Avram Sidi.\nThe method is a generalization of the secant method. Like the secant method, it is an iterative method which requires one evaluation of  in each iteration and no derivatives of . The method can converge much faster though, with an order which approaches 2 provided that  satisfies the regularity conditions described below.\n\n","alt_names":[],"name":"Sidi's generalized secant method","categories":["Root-finding algorithms"],"tag_line":"Sidi's generalized secant method is a root-finding algorithm, that is, a numerical method for solving equations of the form  ."}}
,{"_index":"throwtable","_type":"algorithm","_id":"simultaneous-perturbation-stochastic-approximation","_score":0,"_source":{"description":"Simultaneous perturbation stochastic approximation (SPSA) is an algorithmic method for optimizing systems with multiple unknown parameters. It is a type of stochastic approximation algorithm. As an optimization method, it is appropriately suited to large-scale population models, adaptive modeling, simulation optimization, and atmospheric modeling. Many examples are presented at the SPSA website http://www.jhuapl.edu/SPSA. A comprehensive recent book on the subject is Bhatnagar et al. (2013). An early paper on the subject is Spall (1987) and the foundational paper providing the key theory and justification is Spall (1992).\nSPSA is a descent method capable of finding global minima, sharing this property with other methods as simulated annealing. Its main feature is the gradient approximation that requires only two measurements of the objective function, regardless of the dimension of the optimization problem. Recall that we want to find the optimal control  with loss function :\n\nBoth Finite Differences Stochastic Approximation (FDSA) and SPSA use the same iterative process:\n\nwhere  represents the  iterate,  is the estimate of the gradient of the objective function  evaluated at , and  is a positive number sequence converging to 0. If  is a p-dimensional vector, the  component of the symmetric finite difference gradient estimator is:\nFD: \n1 ≤i ≤p, where  is the unit vector with a 1 in the  place, and is a small positive number that decreases with n. With this method, 2p evaluations of J for each  are needed. Clearly, when p is large, this estimator loses efficiency.\nLet now  be a random perturbation vector. The  component of the stochastic perturbation gradient estimator is:\nSP: \nRemark that FD perturbs only one direction at a time, while the SP estimator disturbs all directions at the same time (the numerator is identical in all p components). The number of loss function measurements needed in the SPSA method for each  is always 2, independent of the dimension p. Thus, SPSA uses p times fewer function evaluations than FDSA, which makes it a lot more efficient.\nSimple experiments with p=2 showed that SPSA converges in the same number of iterations as FDSA. The latter follows approximately the steepest descent direction, behaving like the gradient method. On the other hand, SPSA, with the random search direction, does not follow exactly the gradient path. In average though, it tracks it nearly because the gradient approximation is an almost unbiased estimator of the gradient, as shown in the following lemma.","alt_names":["4fbebfe08a2343634659dbc52cec ...","Simultaneous perturbation Stochastic approximation - Wikipedia ...","Simultaneous perturbation Stochastic approximation ...","Simultaneous perturbation stochastic approximation","Simultaneous perturbation stochastic approximation - Wikipedia ...","Simultaneous perturbation stochastic approximation - Wikipedia :: The free encyclopedia","Simultaneous perturbation stochastic approximation - Wikipedia, the ...","Simultaneous perturbation stochastic approximation ...","What is Simultaneous perturbation stochastic approximation","Wikipedia article Simultaneous perturbation stochastic approximation","Wikipedia entry for Simultaneous perturbation stochastic approximation","http://en.wikipedia.org/wiki/Simultaneous_perturbation_stochastic_approximation","simultaneous perturbation SA","simultaneous perturbations","yago-res:Simultaneous perturbation stochastic approximation"],"name":"Simultaneous perturbation stochastic approximation","categories":["Numerical climate and weather models","Optimization algorithms and methods","Stochastic algorithms"],"tag_line":"Simultaneous perturbation stochastic approximation (SPSA) is an algorithmic method for optimizing systems with multiple unknown parameters."}}
,{"_index":"throwtable","_type":"algorithm","_id":"negamax","_score":0,"_source":{"description":"Negamax search is a variant form of minimax search that relies on the zero-sum property of a two-player game.\nThis algorithm relies on the fact that max(a, b) = −min(−a, −b) to simplify the implementation of the minimax algorithm. More precisely, the value of a position to player A in such a game is the negation of the value to player B. Thus, the player on move looks for a move that maximizes the negation of the value of the position resulting from the move: this successor position must by definition have been valued by the opponent. The reasoning of the previous sentence works regardless of whether A or B is on move. This means that a single procedure can be used to value both positions. This is a coding simplification over minimax, which requires that A select the move with the maximum-valued successor while B selects the move with the minimum-valued successor.\nIt should not be confused with negascout, an algorithm to compute the minimax or negamax value quickly by clever use of alpha-beta pruning discovered in the 1980s. Note that alpha-beta pruning is itself a way to compute the minimax or negamax value of a position quickly by avoiding the search of certain uninteresting positions.\nMost adversarial search engines are coded using some form of negamax search.\n\n","alt_names":["Negamax","-> Leggi l'articolo completo su Negamax","-> Read more about Negamax","...more on Wikipedia about Negamax","Alpha-Beta NegaMax","MiniMax, NegaMax, NegaScout","Nega-Max","NegaMax","Negamax - Wikipedia","Negamax - Wikipedia, la enciclopedia libre","Negamax - Wikipedia, the free encyclopedia","Negamax Regret","Negamax Wikipedia, the free ...","Negamax alpha-beta pruning algorithm","Negamax pseudocode per Wikipedia","Negamax version","Negamax |","Negamax 方式。其原理就是每层都是取下一层结果的负值的最大值。 所有Minimax 搜索都可以做到安全的上下界剪枝，称为","Negamax+AlphaBeta","NégaMax","Wikipedia article ''Negamax''","Wikipedia article Negamax","Wikipedia article on Negamax","Wikipedia entry for Negamax","Wikipedia:Negamax","\\max(a,b) = -\\min(-a,-b)","en.wikipedia.org/wiki/Negamax","es:Negamax","http://en.wikipedia.org/wiki/Negamax","http://en.wikipedia.org/wiki/Negamaxを","http://es.wikipedia.org/wiki/Negamax","http://it.wikipedia.org/wiki/Negamax","it:Negamax","max(a,b) = − min( − a, − b)","negamax","negamax convention","negamax()","wikipedia:Negamax"],"name":"Negamax","categories":["Articles with example pseudocode","Game artificial intelligence","Optimization algorithms and methods"],"tag_line":"Negamax search is a variant form of minimax search that relies on the zero-sum property of a two-player game."}}
,{"_index":"throwtable","_type":"algorithm","_id":"levenberg–marquardt-algorithm","_score":0,"_source":{"description":"In mathematics and computing, the Levenberg–Marquardt algorithm (LMA), also known as the damped least-squares (DLS) method, is used to solve non-linear least squares problems. These minimization problems arise especially in least squares curve fitting.\nThe LMA is used in many software applications for solving generic curve-fitting problems. However, as for many fitting algorithms, the LMA finds only a local minimum, which is not necessarily the global minimum. The LMA interpolates between the Gauss–Newton algorithm (GNA) and the method of gradient descent. The LMA is more robust than the GNA, which means that in many cases it finds a solution even if it starts very far off the final minimum. For well-behaved functions and reasonable starting parameters, the LMA tends to be a bit slower than the GNA. LMA can also be viewed as Gauss–Newton using a trust region approach.\nThe algorithm was first published in 1944 by Kenneth Levenberg, while working at the Frankford Army Arsenal. It was rediscovered in 1963 by Donald Marquardt who worked as a statistician at DuPont and independently by Girard, Wynn and Morrison.","alt_names":[],"name":"Levenberg–Marquardt algorithm","categories":["All articles with specifically marked weasel-worded phrases","Articles with specifically marked weasel-worded phrases from July 2015","Least squares","Optimization algorithms and methods","Pages with citations lacking titles","Statistical algorithms"],"tag_line":"In mathematics and computing, the Levenberg–Marquardt algorithm (LMA), also known as the damped least-squares (DLS) method, is used to solve non-linear least squares problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dykstra's-projection-algorithm","_score":0,"_source":{"description":"Dykstra's algorithm is a method that computes a point in the intersection of convex sets, and is a variant of the alternating projection method (also called the projections onto convex sets method). In its simplest form, the method finds a point in the intersection of two convex sets by iteratively projecting onto each of the convex set; it differs from the alternating projection method in that there are intermediate steps. A parallel version of the algorithm was developed by Gaffke and Mathar.\nThe method is named after R. L. Dykstra who proposed it in the 1980s.\nA key difference between Dykstra's algorithm and the standard alternating projection method occurs when there is more than one point in the intersection of the two sets. In this case, the alternating projection method gives some arbitrary point in this intersection, whereas Dykstra's algorithm gives a specific point: the projection of r onto the intersection, where r is the initial point used in the algorithm,","alt_names":["Dykstra's projection algorithm","Dykstra's projection algorithm - Wikipedia, the free encyclopedia","Dykstra's projection algorithm by Wikipedia","en.wikipedia.org/wiki/Dykstra's_projection_algorithm","http://en.wikipedia.org/wiki/Dykstra%27s_projection_algorithm"],"name":"Dykstra's projection algorithm","categories":["Convex geometry","Optimization algorithms and methods"],"tag_line":"Dykstra's algorithm is a method that computes a point in the intersection of convex sets, and is a variant of the alternating projection method (also called the projections onto convex sets method)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"big-m-method","_score":0,"_source":{"description":"In operations research, the Big M method is a method of solving linear programming problems using the simplex algorithm. The Big M method extends the power of the simplex algorithm to problems that contain \"greater-than\" constraints. It does so by associating the constraints with large negative constants which would not be part of any optimal solution, if it exists.","alt_names":["Big M method","Big M method - Wikipedia, the free encyclopedia","Big m method","Método de la Gran M","Método de la Gran M - Wikipedia, la enciclopedia","artículo de Wikipedia Metodo de la Gran M","artículo de Wikipedia Método de la Gran M","big M method","http://en.wikipedia.org/wiki/Big_M_method","http://es.wikipedia.org/wiki/M%C3%A9todo_de_la_Gran_M"],"name":"Big M method","categories":["All articles needing expert attention","Articles needing expert attention from March 2011","Articles needing expert attention with no reason or talk parameter","Articles needing unspecified expert attention","Linear algebra","Operations research","Optimization algorithms and methods"],"tag_line":"In operations research, the Big M method is a method of solving linear programming problems using the simplex algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fernandez’s-method","_score":0,"_source":{"description":"Fernandez's method (FB) is a method which is used in the multiprocessing scheduling algorithm. It is actually used to improve the quality of the lower bounding schemes which are adopted by branch and bound algorithms for solving multiprocessor scheduling problem. Fernandez's problem derives a better lower bound than HF,and propose a quadratic-time algorithm from calculating the bound. It is known that a straightforward calculation of FB takes O time, since it must examine O combinations each of which takes O time in the worst case.","alt_names":[],"name":"Fernandez’s method","categories":["All Wikipedia articles needing context","All articles lacking sources","All articles with links needing disambiguation","All orphaned articles","All pages needing cleanup","Articles lacking sources from April 2012","Articles with links needing disambiguation from December 2013","Optimization algorithms and methods","Orphaned articles from April 2012","Wikipedia articles needing context from April 2012","Wikipedia introduction cleanup from April 2012"],"tag_line":"Fernandez's method (FB) is a method which is used in the multiprocessing scheduling algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sequential-minimal-optimization","_score":0,"_source":{"description":"Sequential minimal optimization (SMO) is an algorithm for solving the quadratic programming (QP) problem that arises during the training of support vector machines. It was invented by John Platt in 1998 at Microsoft Research. SMO is widely used for training support vector machines and is implemented by the popular LIBSVM tool. The publication of the SMO algorithm in 1998 has generated a lot of excitement in the SVM community, as previously available methods for SVM training were much more complex and required expensive third-party QP solvers.","alt_names":[],"name":"Sequential minimal optimization","categories":["Optimization algorithms and methods","Support vector machines"],"tag_line":"Sequential minimal optimization (SMO) is an algorithm for solving the quadratic programming (QP) problem that arises during the training of support vector machines."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fourier–motzkin-elimination","_score":0,"_source":{"description":"Fourier–Motzkin elimination, also known as the FME method, is a mathematical algorithm for eliminating variables from a system of linear inequalities. It can output real solutions.\nThe algorithm is named after Joseph Fourier and Theodore Motzkin.\n\n","alt_names":[],"name":"Fourier–Motzkin elimination","categories":["All articles lacking in-text citations","All articles to be expanded","Articles lacking in-text citations from November 2014","Articles needing translation from German Wikipedia","Articles to be expanded from September 2013","Optimization algorithms and methods","Pages using web citations with no URL","Pages with no translate target","Real algebraic geometry"],"tag_line":"Fourier–Motzkin elimination, also known as the FME method, is a mathematical algorithm for eliminating variables from a system of linear inequalities."}}
,{"_index":"throwtable","_type":"algorithm","_id":"randomized-algorithm","_score":0,"_source":{"description":"A randomized algorithm is an algorithm that employs a degree of randomness as part of its logic. The algorithm typically uses uniformly random bits as an auxiliary input to guide its behavior, in the hope of achieving good performance in the \"average case\" over all possible choices of random bits. Formally, the algorithm's performance will be a random variable determined by the random bits; thus either the running time, or the output (or both) are random variables.\nOne has to distinguish between algorithms that use the random input to reduce the expected running time or memory usage, but always terminate with a correct result (Las Vegas algorithms) in a bounded amount of time, and probabilistic algorithms, which, depending on the random input, have a chance of producing an incorrect result (Monte Carlo algorithms) or fail to produce a result either by signalling a failure or failing to terminate.\nIn the second case, random performance and random output, the term \"algorithm\" for a procedure is somewhat questionable. In the case of random output, it is no longer formally effective. However, in some cases, probabilistic algorithms are the only practical means of solving a problem.\nIn common practice, randomized algorithms are approximated using a pseudorandom number generator in place of a true source of random bits; such an implementation may deviate from the expected theoretical behavior.","alt_names":["randomized algorithm","Randomized algorithm","probabilistic algorithms","- Derandomization :","- Randomized algorithm :","-> Read more about Randomized algorithm","-> Read the article about 'Randomized algorithm'","...Wikipedia Algoritmo probabilístico","...mehr auf Wikipedia über Randomisierter Algorithmus","...more on Wikipedia about Randomized algorithm","4.1 Quicksort","4.2 Randomized incremental constructions in geometry","4.3 Graph cuts","5 Derandomization","6 Where randomness helps","600px-Karger_Basic.jpg","8)Randomized Algorithms","ALGORITMOS PROBABILISTAS","Adversarial input","Algorisme probabilístic","Algorismes probabil","Algorismes probabilístics","Algorithme probabiliste","Algorithme probabiliste - Wikipédia","Algoritmo aleatorio","Algoritmo aleatorios","Algoritmo probabilista","Algoritmo probabilista - Wikipedia","Algoritmo probabilista - Wikipedia, la enciclopedia libre","Algoritmo probabilístico","Algoritmo probabilístico - Wikipédia, a enciclopédia livre","Algoritmo probabilístico – Wikipédia, a enciclopédia livre","Algoritmo randomizado","Algoritmos Aleatorizados","Algoritmos probabilísticas","Algoritmos probabilístico","Algoritmos probabilísticos","Algorytm probabilistyczny â�“ Wikipedia, wolna encyklopedia","Algorytm probabilistyczny – Wikipedia, wolna encyklopedia","Computational complexity theory models randomized algorithms as probabilistic","Derandomization","Gerandomiseerde Algorithm","Hazardigita algoritmo - Vikipedio","How to apply for Probabilistic complexity theory","How to apply for Randomized algorithm","Learn about Randomized algorithm>>>","Nicht- deterministischer Algorithmus","Pravděpodobnostní algoritmy","Probabilistic (Randomized) Algorithm","Probabilistic algorithm","Probabilistic algorithms","Probabilistic complexity","Probabilistic complexity theory","Probabilistic computational complexity","Probabilistic_algorithm","Probabilistischen Algorithmus","Probabilistischer Algorithmus","Probabilistischer Algorithmus - Wikipedia","Probabilistischer_Algorithmus","RANDOMIZED ALGORITHMS","Randamized Algorithm","Random algorithm","Randomised Algorithms","Randomised algorithm","Randomiseret algoritme","Randomisierte Algorithmen","Randomisierten Algorithmus","Randomisierter Algorithmus","Randomisierter Algorithmus - Wikipedia","Randomisierter Algorithmus – Wikipedia","Randomisierter_Algorithmus","Randomized Algorithm","Randomized Algorithm - Wikipedia","Randomized Algorithms","Randomized algorithm - Wikipedia :: The free encyclopedia","Randomized algorithm - Wikipedia, the free encyclopedia","Randomized algorithm Wikipedia the free encyclopedia","Randomized algorithm Wikipedia the free encyclopedia - result","Randomized algorithm from Wikipedia","Randomized algorithm; it is used under the","Randomized algorithmmakes","Randomized algorithms","Randomized algorithms; it is used under the","Randomized complexity","Randomized computation","Randomized ขั้น ตอน วิธี","Randomized_algorithm","Randomized_algorithms","Randomizzati Algorithm","Stochastischer Algorithmus - Wikipedia","Stochastischer_Algorithmus","Thuật toán ngẫu nhiên","Utente:Alan Zucconi/SandBox I","Utente:Alan Zucconi/SandBox_I","Utente:J.J. Alan/Sandbox III","Utente:J.J. Alan/Sandbox_III","UtenteAlan Zucci/SandBox I","Wikipedia (Algoritmo probabilístico)","Wikipedia - randomized algorithms","Wikipedia : 乱択アルゴリズム","Wikipedia article Algorithme probabiliste","Wikipedia article Algoritmo probabilista","Wikipedia article Algoritmo probabilístico","Wikipedia article Derandomization","Wikipedia article Hazardigita algoritmo","Wikipedia article Pravděpodobnostní algoritmy","Wikipedia article Probabilistic algorithm","Wikipedia article Randomized algorithm","Wikipedia article Randomized algorithms","Wikipedia article on Algoritmo probabilista","Wikipedia article on Algoritmo probabilístico","Wikipedia article on Algoritmos probabilistas","Wikipedia article on Algoritmos probabilísticos","Wikipedia article on Probabilistic algorithm","Wikipedia article on Randomized algorithm","Wikipedia article אלגוריתם אקראי","Wikipedia article সম্ভাবনাভিত্তিক অ্যালগোরিদম","Wikipedia article ขั้นตอนวิธีแบบสุ่ม","Wikipedia entry for Randomized algorithm","Wikipedia-Artikel Probabilistischer Algorithmus","Wikipedia-Artikel Randomisierter Algorithmus","Wikipedia-Artikel Randomisierter_Algorithmus","Wikipedia-Artikel Stochastischer Algorithmus","Wikipedia-Seite zu 'Probabilistischer Algorithmus'","Wikipedia-Seite zu 'Randomisierter Algorithmus'","Wikipedia-Seite zu 'Stochastischer Algorithmus'","Wikipediaで「乱択アルゴリズム」を調べる","Wikipedia日本語版 - 乱択アルゴリズム","algoritmi randomizzati","algoritmo probabilístico","algoritmos aleatórios","algoritmos probabilistas","algorytm probabilistyczny","algorytmami probabilistycznymi","algorytmem probabilistycznym","algorytmu probabilistycznego","algorytmy probabilistyczne","artigo da Wikipédia Algoritmo probabilístico","artículo de Wikipedia Algoritmo probabilista","artículo de Wikipedia Algoritmo probabilístico","artículo de Wikipedia Algoritmos probabilistas","artículo de Wikipedia Algoritmos probabilísticos","bn:সম্ভাবনাভিত্তিক অ্যালগোরিদম","ca:Algorisme probabilístic","cs:Pravděpodobnostní algoritmy","de.wikipedia.org/wiki/Randomisierter_Algorithmus","de:Randomisierter Algorithmus","derandomization","derandomized","derandomizes","en.wikipedia.org/wiki/Randomized_algo...","en.wikipedia.org/wiki/Randomized_algorithm","en.wikipedia.org/wiki/Randomized_algorithm#Derandomization","en.wikipedia.org/wiki/Randomized_algorithm#Quicksort","en.wikipedia.org/wiki/Randomized_algorithms","en:Randomized algorithms","eo:Hazardigita algoritmo","es:Algoritmo probabilista","fr:Algorithme probabiliste","he:אלגוריתם אקראי","http://bit.ly/lsJx0t","http://ca.wikipedia.org/wiki/Algorisme_probabil%C3%ADstic","http://de.wikipedia.org/wiki/Probabilis ... lgorithmus","http://de.wikipedia.org/wiki/Probabilistischer_Algorithmus","http://de.wikipedia.org/wiki/Randomisierter_Algorithmus","http://en.Liarpedia.org/wiki/Randomized_algorithm","http://en.wikipedia....mized_algorithm","http://en.wikipedia.org/wiki/Probabilistic_algorithm","http://en.wikipedia.org/wiki/Randomized_algorithm","http://en.wikipedia.org/wiki/Randomized_algorithm#Computational_complexity","http://en.wikipedia.org/wiki/Randomized_algorithm#Derandomization","http://en.wikipedia.org/wiki/Randomized_algorithm)","http://en.wikipedia.org/wiki/Randomized_algorithms","http://eo.wikipedia.org/wiki/Probableca_algoritmo","http://es.wikipedia.org/wiki/Algoritmo_probabilista","http://fr.wikipedia.org/wiki/Algorithme_probabiliste","http://pl.wikipedia.org/wiki/Algorytm_probabilistyczny","ja:乱択アルゴリズム","ko:확률적 알고리즘","l'article de Wikipédia Algorithme probabiliste","metody probabilistyczne","pl:Algorytm probabilistyczny","pravděpodobnostních algoritmů","probabilistic (almost surely) service guarantees","probabilistic algorithm","probabilistic complexity theory","probabilistic programs","probabilistic techniques","probabilistische Algorithmen","probabilistischen Algorithmen","pt.wikipedia.org/wiki/Alg…","pt:Algoritmo probabilístico","randoized","random algorithms","randomise","randomiserede algoritmer","randomisierte Algorithmus","randomisierte algorithmen","randomisierten Algorithmen","randomisés","randomized algorithm on wikipedia","randomized algorithm wikipedia the free encyclopedia","randomized algorithms","randomized algorithms,","randomized algorithms.","randomized algorithms:","randomized complexity","randomized generator","randomized or probabilistic algorithms","randomized verification algorithm","randomizzati","statistically bound","th:ขั้นตอนวิธีแบบสุ่ม","w:Randomized algorithms","wikipedia:乱択アルゴリズム","zh:随机化算法","Вероятностный алгоритм","рандомизиран алгоритъм","рандомизированных","אלגוריתם אקראי","אלגוריתם אקראי – ויקיפדיה","אלגוריתם אקראי.","אלגוריתם לאס-וגאס","אלגוריתמים אקראיים","אלגוריתמים הסתברותיים","ויקיפדיה - 'אלגוריתם אקראי'","לא דטרמיניסטי (אקראי)","यादृच्छिक एल्गोरिथ्म","यादृच्छिक एल्गोरिदम","সম্ভাবনাভিত্তিক অ্যালগোরিদম","সম্ভাবনাভিত্তিক অ্যালগোরিদম ...","ขั้นตอนวิธีแบบสุ่ม","ขั้นตอนวิธีแบบสุ่ม - วิกิพีเดีย","อัลกอริทึมแบบสุ่ม - วิกิพีเดีย","“Randomized algorithm - Wikipedia, the free encyclopedia”, en.wikipedia","「乱択アルゴリズム」をWikipediaで調べる","の資質","ウィキペディアの記事 確率的アルゴリズム","乱択アルゴリズム","乱択アルゴリズム - Wikipedia","乱択アルゴリズム -wikipedia","乱択アルゴリズム(wikipedia)","乱択アルゴリズム(確率的アルゴリズム) - Wikipedia","乱択ｱﾙｺﾞﾘｽﾞﾑ","乱択ｱﾙｺﾞﾘｽﾞﾑ-wikipedia","乱数算法","無作為化アルゴリズム","確率的アルゴリズム","確率的アルゴリズム - Wikipedia","確率的ｱﾙｺﾞﾘｽﾞﾑ-wikipedia","維基百科的文章“ 随机化算法”","维基百科的文章“ 随机化算法”","随机化算法","随机化算法- 维基百科，自由的百科全书","随机算法","隨機化演算法- 維基百科，自由的百科全書","隨機算法","무작위 알고리즘","확률적 알고리즘","확률적 알고리즘 - 위키백과, 우리 모두의 백과사전"],"name":"Randomized algorithm","categories":["Analysis of algorithms","Probabilistic complexity theory","Randomized algorithms","Stochastic algorithms"],"tag_line":"A randomized algorithm is an algorithm that employs a degree of randomness as part of its logic."}}
,{"_index":"throwtable","_type":"algorithm","_id":"tabu-search","_score":0,"_source":{"description":"Tabu search, created by Fred W. Glover in 1986 and formalized in 1989, is a metaheuristic search method employing local search methods used for mathematical optimization.\nLocal (neighborhood) searches take a potential solution to a problem and check its immediate neighbors (that is, solutions that are similar except for one or two minor details) in the hope of finding an improved solution. Local search methods have a tendency to become stuck in suboptimal regions or on plateaus where many solutions are equally fit.\nTabu search enhances the performance of local search by relaxing its basic rule. First, at each step worsening moves can be accepted if no improving move is available (like when the search is stuck at a strict local mimimum). In addition, prohibitions (henceforth the term tabu) are introduced to discourage the search from coming back to previously-visited solutions.\nThe implementation of tabu search uses memory structures that describe the visited solutions or user-provided sets of rules. If a potential solution has been previously visited within a certain short-term period or if it has violated a rule, it is marked as \"tabu\" (forbidden) so that the algorithm does not consider that possibility repeatedly.","alt_names":["- Tabu search :","...Wikipedia Recherche tabou","...mehr auf Wikipedia über Tabu-Suche","...more on Wikipedia about Tabu search","1 Basic details","2 Example: Traveling salesman problem","4 More links","Busca Tabu","Busca tabu","Busqueda tabu","Búsqueda Tabu","Búsqueda Tabú","Búsqueda tabú","Búsqueda tabú - Wikipedia, la enciclopedia libre","Example: Traveling salesman ...","Example: Traveling salesman problem","La búsqueda no determinista o tabú","Pesquisa tabu","Pesquisa tabu ? Wikip?dia, a enciclop?dia livre","Pesquisa tabu – Wikipédia, a enciclopédia livre","Przeszukiwanie tabu – Wikipedia, wolna encyklopedia","Read More tabu search wikipedia the free encyclopedia","Recherche tabou","Recherche tabou - Wikip?dia","Recherche tabou - Wikipédia","Source Wikipedia.org Arcticle - Tabu search","Taboo search","Tabu Cari","Tabu Search","Tabu Search (Przeszukiwanie Tabu)","Tabu Search - Wikipedia","Tabu Search - Wikipedia, The Free Encyclopedia","Tabu Search bei Wikipedia","Tabu search","Tabu search - Wikipedia","Tabu search - Wikipedia :: The free encyclopedia","Tabu search - Wikipedia, the free encyclopedia","Tabu search Wikipedia the free encyclopedia","Tabu search Wikipedia the free encyclopedia - result","Tabu search on wikipedia.org","Tabu search; it is used under the","Tabu-Suche","Tabu-Suche - Wikipedia","Tabu-Suche Wikipedia","Tabu-Suche bei Wikipedia","Tabu-Suche bei der wikipedia","Tabu-Suche – Wikipedia","TabuSearch","Tabu_Search","Tabu_Search bei der wikipedia","Tabu_search","Tabusuche","Tabusuche - Wikipedia","Tabusuche bei Wikipedia","Tabusuche bei der wikipedia","Tabu…","The TABU Battle system?","Wiki page for Tabu Search","Wikipedia Tabu-Suche","Wikipedia article Pesquisa tabu","Wikipedia article Przeszukiwanie tabu","Wikipedia article Taboo search","Wikipedia article Tabu search","Wikipedia article about Tabu search","Wikipedia article on Búsqueda tabú","Wikipedia article on Tabu search","Wikipedia entry for Tabu search","Wikipedia l'articolo Tabu search","Wikipedia-Artikel Tabu Search","Wikipedia-Artikel Tabu-Suche","Wikipedia-Artikel Tabusuche","Wikipedia-Seite zu 'Tabu Search'","Wikipedia-Seite zu 'Tabu-Suche'","Wikipedia: Tabu Search","Wikipedia:Tabu_search","Wikipediaで「タブー探索」を調べる","Wikipédia artigo Pesquisa tabu","artículo de Wikipedia Busqueda Tabu","artículo de Wikipedia Búsqueda tabú","busca tabu","búsqueda tabú","de.wikipedia.org/wiki/Tabu-Suche","de:Tabu-Suche","en.wikipedia.org/Tabu_search","en.wikipedia.org/wiki/Tabu_search","es:Búsqueda tabú","fa:الگوریتم جستجوی ممنوعه","fr:Recherche tabou","http://de.wikipedia.org/wiki/Tabu-Suche","http://de.wikipedia.org/wiki/Tabu_Search","http://en.wikipedia....iki/Tabu_search","http://en.wikipedia.org/wiki/Taboo_search","http://en.wikipedia.org/wiki/Tabu search","http://en.wikipedia.org/wiki/Tabu_s...","http://en.wikipedia.org/wiki/Tabu_search","http://en.wikipedia.org/wiki/Tabu_search.","http://es.wikipedia.org/wiki/B%C3%BAsqueda_tab","http://es.wikipedia.org/wiki/Busqueda_tabu","http://fr.wikipedia.org/wiki/Recherche_tabou","http://it.wikipedia.org/wiki/Tabu_search","http://nl.wikipedia.org/wiki/Tabu_search","http://pl.wikipedia.org/wiki/Przeszukiwanie_tabu","http://pl.wikipedia.org/wiki/Pżeszukiwanie_tabu","http://pt.wikipedia.org/wiki/Pesquisa_tabu","http://www.cs.sandia.gov/opt/survey/ts","it:Tabu search","ja:タブーサーチ","more yes","nl:Tabu search","pl:Przeszukiwanie tabu","pt:Pesquisa tabu","recherche avec tabous","taboo search","tabu search","tabu search algorithm","tabu search wikipedia the free encyclopedia","tabu search,","w:Tabu search","wikipedia on TS","zh:禁忌搜索","Табу поиска","الگوریتم جستجوی ممنوعه - ویکیپدیا","तब्बू खोज","ค้นหา ห้าม","タブーサーチ","タブーサーチ - Wikipedia","タブーサーチ tabu search","タブー探索","タブ探索","禁忌搜尋法","禁忌搜索","維基百科的文章“ 禁忌搜索”","금기 검색","ﾀﾌﾞｰｻｰﾁ-wikipedia"],"name":"Tabu search","categories":["1989 introductions","Optimization algorithms and methods"],"tag_line":"Tabu search, created by Fred W. Glover in 1986 and formalized in 1989, is a metaheuristic search method employing local search methods used for mathematical optimization."}}
,{"_index":"throwtable","_type":"algorithm","_id":"new-york-state-identification-and-intelligence-system","_score":0,"_source":{"description":"The New York State Identification and Intelligence System Phonetic Code, commonly known as NYSIIS, is a phonetic algorithm devised in 1970 as part of the New York State Identification and Intelligence System (now a part of the New York State Division of Criminal Justice Services). It features an accuracy increase of 2.7% over the traditional Soundex algorithm.","alt_names":["...more on Wikipedia about New York State Identification","Learn about New York State Identification and Intelligence","NYIIS","NYSIIS","NYSIIS Code","NYSIIS algorithm","NYSIIS,","NYSIIS-name-coding","New York State Identification and Intelligence Syste","New York State Identification and Intelligence System","New York State Identification and Intelligence System - Wikipedia","New York State Identification and Intelligence System ...","New York State Identification and Intelligence System Phonetic","Wikipedia article NYSIIS","Wikipedia article New York State Identification and Intelligence","Wikipedia article New york state identification and intelligence","Wikipedia entry for New York State Identification and","en.wikipedia.org/...cation_and_Intelligence_System","http://en.wikipedia.org/wiki/NYSIIS","http://en.wikipedia.org/wiki/New_Yor...gence_Sys tem","http://en.wikipedia.org/wiki/New_Yor...ligence_System","http://en.wikipedia.org/wiki/New_York_Stat...lligence_System","http://en.wikipedia.org/wiki/New_York_State_I...","http://en.wikipedia.org/wiki/New_York_State_Identification_and_Intell...","http://en.wikipedia.org/wiki/New_York_State_Identification_and_Intelli...ce_Syst","http://en.wikipedia.org/wiki/New_York_State_Identification_and_Intelligence_System","n16:New_York_State_Identification_and_Intelligence_System","soundex、NYSIIS、","soundex，NYSIIS，"],"name":"New York State Identification and Intelligence System","categories":["Phonetic algorithms"],"tag_line":"The New York State Identification and Intelligence System Phonetic Code, commonly known as NYSIIS, is a phonetic algorithm devised in 1970 as part of the New York State Identification and Intelligence System (now a part of the New York State Division of Criminal Justice Services)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"uobyqa","_score":0,"_source":{"description":"UOBYQA (Unconstrained Optimization BY Quadratic Approximation) is a numerical optimization algorithm by Michael J. D. Powell. It is also the name of Powell's Fortran 77 implementation of the algorithm.\nUOBYQA solves unconstrained optimization problems without using derivatives, which makes it a derivative-free algorithm. The algorithm is iterative, and exploits trust region technique. On each iteration, the algorithm establishes a quadratic model  by interpolating the objective function at  points, and then minimizes  within a trust region.\nAfter UOBYQA, Powell developed NEWUOA, which also solves unconstrained optimization problems without using derivatives. In general, NEWUOA is much more efficient than UOBYQA and is capable of solving much larger problems (with up to several hundreds of variables). A major difference between them is that NEWUOA constructs quadratic models by interpolating the objective function at much less than  points ( by default). For general usage, NEWUOA is recommended to replace UOBYQA.\nThe UOBYQA software is distributed under The GNU Lesser General Public License (LGPL).\n\n","alt_names":[],"name":"UOBYQA","categories":["Optimization algorithms and methods"],"tag_line":"UOBYQA (Unconstrained Optimization BY Quadratic Approximation) is a numerical optimization algorithm by Michael J. D. Powell."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rabin–karp-algorithm","_score":0,"_source":{"description":"In computer science, the Rabin–Karp algorithm or Karp–Rabin algorithm is a string searching algorithm created by Richard M. Karp and Michael O. Rabin (1987) that uses hashing to find any one of a set of pattern strings in a text. For text of length n and p patterns of combined length m, its average and best case running time is O(n+m) in space O(p), but its worst-case time is O(nm). In contrast, the Aho–Corasick string matching algorithm has asymptotic worst-time complexity O(n+m) in space O(m).\nA practical application of the algorithm is detecting plagiarism. Given source material, the algorithm can rapidly search through a paper for instances of sentences from the source material, ignoring details such as case and punctuation. Because of the abundance of the sought strings, single-string searching algorithms are impractical.","alt_names":[],"name":"Rabin–Karp algorithm","categories":["Hashing","String matching algorithms"],"tag_line":"In computer science, the Rabin–Karp algorithm or Karp–Rabin algorithm is a string searching algorithm created by Richard M. Karp and Michael O. Rabin (1987) that uses hashing to find any one of a set of pattern strings in a text."}}
,{"_index":"throwtable","_type":"algorithm","_id":"commentz-walter-algorithm","_score":0,"_source":{"description":"In computer science, the Commentz-Walter algorithm is a string searching algorithm invented by Beate Commentz-Walter. Like the Aho–Corasick string matching algorithm, it can search for multiple patterns at once. It combines ideas from Aho–Corasick with the fast matching of the Boyer–Moore string search algorithm. For a text of length n and maximum pattern length of m, its worst-case running time is O(mn), though the average case is often much better.\nGNU grep implements a string matching algorithm very similar to Commentz-Walter.","alt_names":["Commentz-Walter algorithm"],"name":"Commentz-Walter algorithm","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","String matching algorithms"],"tag_line":"In computer science, the Commentz-Walter algorithm is a string searching algorithm invented by Beate Commentz-Walter."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hunt–mcilroy-algorithm","_score":0,"_source":{"description":"In computer science, the Hunt–McIlroy algorithm is a solution to the longest common subsequence problem. It was one of the first non-heuristic algorithms used in diff. To this day, variations of this algorithm are found in incremental version control systems, wiki engines, and molecular phylogenetics research software.\nThe research accompanying the final version of Unix diff, written by Douglas McIlroy, was published in the 1976 paper \"An Algorithm for Differential File Comparison\", co-written with James W. Hunt, who developed an initial prototype of diff.\n\n","alt_names":[],"name":"Hunt–McIlroy algorithm","categories":["Algorithms on strings","Combinatorics","Dynamic programming"],"tag_line":"In computer science, the Hunt–McIlroy algorithm is a solution to the longest common subsequence problem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rate-monotonic-scheduling","_score":0,"_source":{"description":"In computer science, rate-monotonic scheduling (RMS) is a scheduling algorithm used in real-time operating systems (RTOS) with a static-priority scheduling class. The static priorities are assigned on the basis of the cycle duration of the job: the shorter the cycle duration is, the higher is the job's priority.\nThese operating systems are generally preemptive and have deterministic guarantees with regard to response times. Rate monotonic analysis is used in conjunction with those systems to provide scheduling guarantees for a particular application.\n\n","alt_names":["-> Read the article about 'Rate-monotonic scheduling'","-monótona programación Tasa","...Wikipedia Rate-monotonic scheduling","...mehr auf Wikipedia über Rate Monotonic Scheduling","...more on Wikipedia about Rate-monotonic scheduling","6). http://en.wikipedia.org/","70dcb86e2140c9baa550f1c063cc","Algoritmo rate-monotonic - Wikipedia (en)","Avoiding priority ...","Avoiding priority inversion","Fixed Priority","Kurzy-monotónní plánování","Liu & Layland (1973)","More Rate Monotonic Scheduling","RM 스케줄링","Rate Monotonic","Rate Monotonic (RM)","Rate Monotonic Analysis","Rate Monotonic Analysis (RMA)","Rate Monotonic Scheduling","Rate Monotonic Scheduling ? Wikipedia","Rate Monotonic Scheduling – Wikipedia","Rate Monotonic Scheduling 鈥�Wikipedia","Rate monotonic scheduling","Rate monotonic scheduling Wikipedia the free encyclopedia","Rate-Monotonic Analysis","Rate-Monotonic Scheduling","Rate-Monotonic Scheduling Algorithm","Rate-monitoring scheduling","Rate-monoton schemaläggning","Rate-monotone Terminplanung","Rate-monotone planning","Rate-monotonen Scheduling","Rate-monotonic scheduling","Rate-monotonic scheduling - ...","Rate-monotonic scheduling - Wikip?dia","Rate-monotonic scheduling - Wikipedia, the free encyclopedia","Rate-monotonic scheduling - Wikipedia, the free encyclopedia ...","Rate-monotonic scheduling - Wikipédia","Rate-monotonic scheduling @ Wikipedia","Rate-monotonic scheduling; it is used under the","Rate-monotonic_scheduling","Rate_Monotonic_Scheduling","Ratemonotonic scheduling Wikipedia the free encyclopedia","What is Rate-monotonic scheduling's example","Wikipedia : レートモノトニックスケジューリング","Wikipedia article Rate Monotonic Scheduling","Wikipedia article Rate-monotonic scheduling","Wikipedia article on Rate-Monotonic Scheduling","Wikipedia entry for Rate-monotonic scheduling","Wikipedia sur Rate Monotonique","Wikipedia-Artikel Rate Monotonic Scheduling","Wikipedia-Seite zu 'Rate Monotonic Scheduling'","cs:Plánování RMS (rate monotonic scheduling)","cs:Rate monotonic scheduling","en:Rate-monotonic scheduling","fr.wikipedia.org/wiki/Rate-monotonic_scheduling","http://cs.wikipedia.org/wiki/Rate_monotonic_scheduling","http://de.wikipedia.org/wiki/Rate_Monoto","http://de.wikipedia.org/wiki/Rate_Monotonic_Scheduling","http://en.wikipedia....onic_scheduling","http://en.wikipedia.org/wiki/Rate-monoto","http://en.wikipedia.org/wiki/Rate-monotonic_scheduling","http://en.wikipedia.org/wiki/Rate-monoto…","http://en.wikipedia.org/wiki/Rate_Monotonic_Scheduling","http://en.wikipedia.org/wiki/Rate−monotonic_scheduling","http://en.wikipedia.org/wiki/Rate−monotonic_scheduling)","http://en.wikipedia.org/wiki/Rate−monotonic_scheduling,","http://fr.wikipedia.org/wiki/Rate-monotonic_scheduling","http://ja.wikipedia.org/wiki/レートモノトニックスケジューリング","ko:비율 단조 스케줄링","le taux d'ordonnancement monotone","ompared to fixed priority scheduling techniques like","rate monotonic","rate monotonic algorithm (RMA)","rate monotonic analysis","rate monotonic assignment","rate monotonic scheduling","rate-monotonic","rate-monotonic analysis","rate-monotonic scheduling","rate-monotoon scheduling","see monotonic-rate scheduling","tarief-monotone scheduling","taxa monotônica agendamento","velocità monotona scheduling","скорости монотонного планирования","скорость-монотонная планирования","ウィキペディアの記事 レートモノトニックスケジューリング","ジに付属のレート単調スケジューリン","レートモノトニック スケジューラ","レートモノトニックスケジューリング","レートモノトニックスケジューリング - Wikipedia","レートモノトニックスケジューリング(Rate-Monotonic Scheduling, RMS","速率单调调度","비율 단조 스케줄링","위키 피 디아 문서 RM 스케줄링","위키 피 디아 문서 Rms","ﾚｰﾄﾓﾉﾄﾆｯｸｽｹｼﾞｭｰﾘﾝｸﾞ","ﾚｰﾄﾓﾉﾄﾆｯｸｽｹｼﾞｭｰﾘﾝｸﾞ-wikipedia"],"name":"Rate-monotonic scheduling","categories":["All articles with unsourced statements","Articles with unsourced statements from October 2007","Processor scheduling algorithms","Real-time computing"],"tag_line":"In computer science, rate-monotonic scheduling (RMS) is a scheduling algorithm used in real-time operating systems (RTOS) with a static-priority scheduling class."}}
,{"_index":"throwtable","_type":"algorithm","_id":"las-vegas-algorithm","_score":0,"_source":{"description":"In computing, a Las Vegas algorithm is a randomized algorithm that always gives correct results; that is, it always produces the correct result or it informs about the failure. In other words, a Las Vegas algorithm does not gamble with the correctness of the result; it gambles only with the resources used for the computation. A simple example is randomized quicksort, where the pivot is chosen randomly, but the result is always sorted. The usual definition of a Las Vegas algorithm includes the restriction that the expected run time always be finite, when the expectation is carried out over the space of random information, or entropy, used in the algorithm. An alternative definition requires that a Las Vegas algorithm always terminate (be effective), but it may output a symbol not part of the solution space to indicate failure in finding a solution.\nLas Vegas algorithms were introduced by László Babai in 1979, in the context of the graph isomorphism problem, as a stronger version of Monte Carlo algorithms. Las Vegas algorithms can be used in situations where the number of possible solutions is relatively limited, and where verifying the correctness of a candidate solution is relatively easy while actually calculating the solution is complex.\nThe name refers to the city of Las Vegas, Nevada, which is well known within the United States as an icon of gambling.","alt_names":["...mehr auf Wikipedia über Las-Vegas-Algorithmus","...more on Wikipedia about Las Vegas algorithm","Algorisme de Las Vegas","Algorithme de Las Vegas","Algorithme de Las Vegas - Wikipédia","Algoritmo de Las Vegas","Algoritmo de Las Vegas - Wikipedia, la enciclopedia libre","Algoritmy “Las Vegas”","Las Vegas Algorithm","Las Vegas Algorithms","Las Vegas Algortihm","Las Vegas algorithm","Las Vegas algorithm - Simple English Wikipedia, the free","Las Vegas algorithm - Wikipedia :: The free encyclopedia","Las Vegas algorithm - Wikipedia on Ask.com","Las Vegas algorithm - Wikipedia, the free encyclopedia","Las Vegas algorithm - Wikipedia, the free encyclopedia ...","Las Vegas algorithm | Ask.com Encyclopedia","Las Vegas algorithms","Las Vegas construction","Las Vegas method","Las-Vegas Verfahren","Las-Vegas-Algorithmen","Las-Vegas-Algorithmus","Las-Vegas-Algorithmus - Wikipedia","Las-Vegas-Algorithmus – Wikipedia","Las_Vegas_algorithm","Wikipedia article Las Vegas algorithm","Wikipedia article on Algoritmo de Las Vegas","Wikipedia article on Las Vegas algorithm","Wikipedia entry for Las Vegas algorithm","Wikipedia-Artikel Las-Vegas-Algorithmus","Wikipedia-Seite zu 'Las-Vegas-Algorithmus'","Wikipediaで「ラスベガス法」を調べる","ZPP = RP ∩ co - RP ,","algorithme de Las Vegas","algoritmo de Las Vegas","artículo de Wikipedia Algoritmo de Las Vegas","ca:Algorisme de Las Vegas","de:Las-Vegas-Algorithmus","en.wikipedia.org/wiki/Las_Vegas_algorithm","es:Algoritmo de Las Vegas","eventually find the right solution","fr:Algorithme de Las Vegas","http://de.wikipedia.org/wiki/Las-Vegas-A","http://de.wikipedia.org/wiki/Las-Vegas-Algorithmus","http://en.wikipedia....Vegas_algorithm","http://en.wikipedia.org/wiki/Las Vegas algorithm","http://en.wikipedia.org/wiki/Las_Vegas_a","http://en.wikipedia.org/wiki/Las_Vegas_algorithm","http://es.wikipedia.org/wiki/Algoritmo_de_Las_Vegas","http://fr.wikipedia.org/wiki/Algorithme_de_Las_Vegas","ja:ラスベガス法","l'algorithme probabiliste de Las Vegas","las vegas algorithms","ru:Лас-Вегас (алгоритм)","simple:Las Vegas algorithm","thuật toán Las Vegas","w:en:Las Vegas algorithm","wikipedia entry for Las Vegas algorithms","Википедии статью Лас-Вегас (алгоритм)","Лас-Вегас (алгоритм)","ラスベガス法","ラスベガス法 - Wikipedia","ﾗｽﾍﾞｶﾞｽ法-wikipedia"],"name":"Las Vegas algorithm","categories":["Randomized algorithms"],"tag_line":"In computing, a Las Vegas algorithm is a randomized algorithm that always gives correct results; that is, it always produces the correct result or it informs about the failure."}}
,{"_index":"throwtable","_type":"algorithm","_id":"multilevel-feedback-queue","_score":0,"_source":{"description":"In computer science, a multilevel feedback queue is a scheduling algorithm. Solaris 2.6 Time-Sharing (TS) scheduler implements this algorithm. The Mac OS X and Microsoft Windows schedulers can both be regarded as examples of the broader class of multilevel feedback queue schedulers. This scheduling algorithm is intended to meet the following design requirements for multimode systems:\nGive preference to short jobs.\nGive preference to I/O bound processes.\nSeparate processes into categories based on their need for the processor.\nThe Multi-level Feedback Queue scheduler was first developed by Fernando J. Corbató et al. in 1962, and this work, along with other work on Multics, led the ACM to award Corbató the Turing Award.","alt_names":["- Multilevel feedback queue :","-> Read the article about 'Multilevel feedback queue'","...more on Wikipedia about Multilevel Feedback Queue","Learn about Multilevel feedback queue>>>","MLFQ","Multi level feedback queue","Multi-level Feedback Queue","Multilevel Feedback Queue","Multilevel Feedback Queue - Wikipedia","Multilevel Feedback Queue in","Multilevel Feedback Queue – Wikipedia","Multilevel Queue Scheduling","Multilevel Queue scheduling","Multilevel feedback queue","Multilevel feedback queue - Wikipedia, the free encyclopedia","Multilevel feedback queue; it is used under the","Multilevel_Feedback_Queue","Multilevel_feedback_queue","Múltiples colas","Planificación mediante colas multinivel","Viacúrovňové so spätnou väzbou","Wikipedia article Multilevel Feedback Queue","Wikipedia article Multilevel feedback queue","Wikipedia article on Multilevel feedback queue","Wikipedia-Artikel Multilevel Feedback Queue","Wikipedia-Seite zu 'Multilevel Feedback Queue'","Wikipediaで「多段フィードバックキュー」を調べる","de:Multilevel Feedback Queue","en:Multilevel Feedback Queue","http://de.wikipedia.org/wiki/Multilevel_","http://de.wikipedia.org/wiki/Multilevel_Feedback_Queue","http://em.wikipedia.org/wiki/Multilevelfeedback_#queue","http://en.Liarpedia.org/wiki/Multilevel_feedback_queue","http://en.wikipedia.org/wiki/Multilevel_Feedback_Queue","http://en.wikipedia.org/wiki/Multilevel_feedback_queu","http://en.wikipedia.org/wiki/Multilevel_feedback_queue","http://es.wikipedia.org/wiki/Planificaci%C3%B3n_mediante_colas_multinivel","ja:多段フィードバックキュー","multi-level feedback queue scheduling","multilevel feedback queue","multilevel-feedback-queue","sv:Multilevel Feedback Queue","více-úrovňové zpětné vazby","多段フィードバックキュー","多段フィードバックキュー - Wikipedia","多段ﾌｨｰﾄﾞﾊﾞｯｸｷｭｰ-wikipedia"],"name":"Multilevel feedback queue","categories":["Processor scheduling algorithms"],"tag_line":"In computer science, a multilevel feedback queue is a scheduling algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fair-share-scheduling","_score":0,"_source":{"description":"Fair-share scheduling is a scheduling algorithm for computer operating systems in which the CPU usage is equally distributed among system users or groups, as opposed to equal distribution among processes.\nOne common method of logically implementing the fair-share scheduling strategy is to recursively apply the round-robin scheduling strategy at each level of abstraction (processes, users, groups, etc.) The time quantum required by round-robin is arbitrary, as any equal division of time will produce the same results.\nThis was first developed by Judy Kay and Piers Lauder through their research at Sydney University in the 1980s.","alt_names":["- Fair-share scheduling :","-> Read more about Fair-share scheduling","-> Read the article about 'Fair-share scheduling'","...more on Wikipedia about Fair-share scheduling","Fair Share","Fair Share Scheduling","Fair Share Wiki","Fair share scheduling","Fair-Share-Scheduling","Fair-Share-Scheduling in","Fair-Share-Scheduling â€“ Wikipedia","Fair-Share-Scheduling – Wikipedia","Fair-share scheduling","Fair-share scheduling - Wikipedia, the free encyclopedia","Wikipedia article Fair-share scheduling","Wikipedia entry for Fair-share scheduling","Wikipedia-Artikel Fair-Share-Scheduling","article Fair-share scheduling","en.wikipedia.org/wiki/Fair-share_sche...","en:Fair-share scheduling","fair and efficient","fair-share scheduler","fair-share scheduling","http://de.wikipedia.org/wiki/Fair-Share-","http://de.wikipedia.org/wiki/Fair-Share-Scheduling","http://en.wikipedia.org/wiki/Fair-share_","http://en.wikipedia.org/wiki/Fair-share_scheduling","scheduling fair-share","yago-res:Fair-share scheduling"],"name":"Fair-share scheduling","categories":["All articles needing additional references","Articles needing additional references from June 2012","Processor scheduling algorithms"],"tag_line":"Fair-share scheduling is a scheduling algorithm for computer operating systems in which the CPU usage is equally distributed among system users or groups, as opposed to equal distribution among processes."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lottery-scheduling","_score":0,"_source":{"description":"Lottery Scheduling is a probabilistic scheduling algorithm for processes in an operating system. Processes are each assigned some number of lottery tickets, and the scheduler draws a random ticket to select the next process. The distribution of tickets need not be uniform; granting a process more tickets provides it a relative higher chance of selection. This technique can be used to approximate other scheduling algorithms, such as Shortest job next and Fair-share scheduling.\nLottery scheduling solves the problem of starvation. Giving each process at least one lottery ticket guarantees that it has non-zero probability of being selected at each scheduling operation.","alt_names":["- Lottery scheduling :","Lotterie-Scheduling","Lotterie-Scheduling - Wikipedia","Lotterie-Scheduling in","Lotterie-Scheduling – Wikipedia","Lottery Scheduling","Lottery scheduling","Lottery scheduling - Wikipedia, the free encyclopedia","Lottery scheduling; it is used under the","Lottery_Scheduling","Lottery_scheduling","What is Lottery Scheduling's implementation","Wikipedia (Lottery scheduling)","Wikipedia article Lottery Scheduling","Wikipedia article Lottery scheduling","Wikipedia article on Lottery scheduling","Wikipedia entry for Lottery scheduling","Wikipedia-Artikel Lotterie-Scheduling","http://de.wikipedia.org/wiki/Lotterie-Sc","http://de.wikipedia.org/wiki/Lotterie-Scheduling","http://en.wikipedia.org/wiki/Lottery Scheduling","http://en.wikipedia.org/wiki/Lottery_Sch","http://en.wikipedia.org/wiki/Lottery_Scheduling","http://en.wikipedia.org/wiki/Lottery_scheduling","lottery raidscheduling","lottery scheduler","lottery scheduling"],"name":"Lottery scheduling","categories":["Processor scheduling algorithms"],"tag_line":"Lottery Scheduling is a probabilistic scheduling algorithm for processes in an operating system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fifo-(computing-and-electronics)","_score":0,"_source":{"description":"FIFO is an acronym for first in, first out, a method for organizing and manipulating a data buffer, where the oldest (first) entry, or 'head' of the queue, is processed first. It is analogous to processing a queue with first-come, first-served (FCFS) behaviour: where the people leave the queue in the order in which they arrive.\nFCFS is also the jargon term for the FIFO operating system scheduling algorithm, which gives every process central processing unit (CPU) time in the order in which it is demanded.\nFIFO's opposite is LIFO, last-in-first-out, where the youngest entry or 'top of the stack' is processed first.\nA priority queue is neither FIFO or LIFO but may adopt similar behaviour temporarily or by default.\nQueueing theory encompasses these methods for processing data structures, as well as interactions between strict-FIFO queues.","alt_names":[],"name":"FIFO (computing and electronics)","categories":["All articles needing additional references","Articles needing additional references from March 2015","Cybernetics","Inter-process communication","Queue management","Scheduling algorithms","Wikipedia articles with GND identifiers"],"tag_line":"FIFO is an acronym for first in, first out, a method for organizing and manipulating a data buffer, where the oldest (first) entry, or 'head' of the queue, is processed first."}}
,{"_index":"throwtable","_type":"algorithm","_id":"shortest-seek-first","_score":0,"_source":{"description":"Shortest seek first (or shortest seek time first) is a secondary storage scheduling algorithm to determine the motion of the disk's arm and head in servicing read and write requests.\n\n","alt_names":["SSTF","(SSTF)","- Shortest seek first :","...more on Wikipedia about Shortest seek first","Learn about Shortest seek first>>>","Shortest Time Seek First","Shortest seek first","Shortest seek first - Wikipedia, the free encyclopedia","Shortest seek first - Wikipedia, the free encyclopedia ...","Shortest seek first algorithm","Shortest seek first: Analysis","Shortest seek first: Description","Shortest seek time first","Shortest seek time first - Wikipedia, la enciclopedia libre","What is analysis of Shortest seek first","Wikipedia article SSTF","Wikipedia article Shortest seek first","Wikipedia article on Shortest seek first","Wikipedia entry for Shortest seek first","[9] SSTF","artículo de Wikipedia Shortest seek first","en:Shortest seek first","http://en.Liarpedia.org/wiki/Shortest_seek_first","http://en.wikipedia.org/wiki/Shortest_se","http://en.wikipedia.org/wiki/Shortest_seek_first","http://es.wikipedia.org/wiki/Shortest_seek_time_first","yago-res:Shortest seek first"],"name":"Shortest seek first","categories":["All articles lacking sources","Articles lacking sources from December 2009","Disk scheduling algorithms"],"tag_line":"Shortest seek first (or shortest seek time first) is a secondary storage scheduling algorithm to determine the motion of the disk's arm and head in servicing read and write requests.\n\n"}}
,{"_index":"throwtable","_type":"algorithm","_id":"search-algorithm","_score":0,"_source":{"description":"In computer science, a search algorithm is an algorithm for finding an item with specified properties among a collection of items which are coded into a computer program, that look for clues to return what is wanted. The items may be stored individually as records in a database; or may be elements of a search space defined by a mathematical formula or procedure, such as the roots of an equation with integer variables; or a combination of the two, such as the Hamiltonian circuits of a graph.","alt_names":["http://es.wikipedia.org/wiki/B%C3%BAsqu","search engine algorithms","algoritmos de busca","Búsqueda binaria","search algorithm","search algorithms","algoritmi di ricerca","uninformed search","Suchverfahren","keyword search","Suchalgorithmus","- Search algorithm :","-> Read the article about 'Search algorithm'","...Wikipedia Algorithme de recherche","...Wikipedia Algoritmo di ricerca","...Wikipedia Búsqueda binaria","...mehr auf Wikipedia über Suchverfahren","1 Classes of search algorithms","1 Pencarian uninformed","1. Search algorithm - Wikipedia, the free encyclopedia","1.1 For explicitly stored databases","1.1 Pencarian List","1.2 For virtual search spaces","1.2 Pencarian Pohon","1.3 For sub-structures of a given structure","1.3 Pencarian Graf","1.4 For quantum computers","1.4 Pencarian Graf","2 Pencarian Informed","3 Pencarian Adversarial","4 Pemenuhan Kendala","4 Pencarian Interpolasi","5 Pencarian Interpolasi","5Falgorithms http://en.wikipedia.org/wiki/Search%","5Falgorithms% http://en.wikipedia.org/wiki/Search","6 Jenis Lain","65. Search algorithm - Wikipedia, the free encyclopedia","8. Search algorithm - Wikipedia, the free encyclopedia","<b>Search b> algorithm - Wikipedia, the free encyclopedia","?p???s? p??ß??µ?t?? (te???t","?p???s? p??ί??µ?t?? (te???t","Adversarial search","Algorithme de recherche","Algorithme de recherche - Wikipédia","Algorithmes de recherche","Algoritma Pencarian","Algoritma Pencarian - Wikipedia Bahasa Indonesia, Ensiklopedia Bebas","Algoritma pencarian","Algoritma pencarian - Wikipedia","Algoritma pencarian - Wikipedia bahasa Indonesia ...","Algoritma pencarian - Wikipedia bahasa Indonesia, ensikloped...","Algoritma pencarian - Wikipedia bahasa Indonesia, ensiklopedia bebas","Algoritma pencarian Wikipedia bahasa Indonesia","Algoritma pencarian Wikipedia bahasa Indonesia, ensiklopedia bebas","Algoritmi di ricerca","Algoritmo de Busca","Algoritmo de b?squeda - Wikipedia, la enciclopedia libre","Algoritmo de busca","Algoritmo de busca - Wikipédia, a enciclopédia livre","Algoritmo de busca – Wikipédia, a enciclopédia livre","Algoritmo de búsqueda","Algoritmo de búsqueda - Wikipedia, la enciclopedia libre","Algoritmo di ricerca","Algoritmo di ricerca - Wikipedia","Algoritmos de Búsqueda","Arama algoritmalarında","Arama algoritması -","Busqueda Binaria","Búsqueda Binaria","Classes of search algorithms","Di ricerca","From Wikipedia, the free encyclopedia. Classification, summaries of","Game searching","Giải thuật tìm kiếm","Giải thuật tìm kiếm - Wikipedia tiếng Việt","Giải thuật tìm kiếm – Wikipedia tiếng Việt","Hakualgoritmi","Hakualgoritmi – Wikipedia","Heuristic search","Informed Search @ Wikipedia","Informed search","Informed search algorithm","Keresőalgoritmus","Learn about Search algorithm>>>","Linkverzeichnissen (auch Webverzeichnis oder Webkatalog)","More information on search results >>","Most false positives can be attributed to the","Read More About search algorithm wikipedia the free","Read More about search algorithm wikipedia the free","Read More search algorithm wikipedia the free encyclopedia","Ricerca Ricorsiva. Ricerca binaria (detta anche ricerca dicotomica","SEarCH","SEarcH","Search Algorithm","Search Algorithm - Wikipedia, The Free Encyclopedia","Search Algorithm Website thumb","Search Algorithm Wikipedia The Free Encyclopedia","Search Algorithm en.wikipedia.org/wiki/Search_algorithm","Search Algorithm wiki","Search Algorithm...","Search Algorithms","Search Engine Algorithm","Search algorithm","Search algorithm - Wikipedia :: The free encyclopedia","Search algorithm - Wikipedia, the free encyclopedi...","Search algorithm - Wikipedia, the free encyclopedia","Search algorithm - Wikipedia, the free encyclopedia In computer","Search algorithm - Wikipedia, the free encyclopediaIn computer","Search algorithm Wiki","Search algorithm Wikipedia the free encyclopedia","Search algorithm Wikipedia the free encyclopedia - result","Search algorithm's","Search algorithm; it is used under the","Search algorithms","Search algorithms - Wikipedia, the free encyclopedia","Search functions","Search(Search Algorithm)","Search_algorithm","Search_algorithms","Searchalgorithm - Wikipedia, the free encyclopedia","Searching algorithm","Suchalgorithmen w","Suchalgorithmus - Wikipedia","Sucharithmetik","Suchstrategie","Suchstrategie - Wikipedia","Suchstrategien","Suchverfahren (Wikipedia)","Suchverfahren - Wikipedia","Suchverfahren ? Wikipedia","Suchverfahren – Wikipedia","Uninformed Search","Uninformed Search @ Wikipedia","Uninformed search","Uninformed_search","Vyhledávací algoritmus","Where is everything?","Wiki link on Search Algorithms","Wikipedia (Algoritmo de busca)","Wikipedia - Search Algorithm","Wikipedia - 検索","Wikipedia : Adversarial search","Wikipedia : Search algorithm","Wikipedia : 検索","Wikipedia Búsqueda binaria","Wikipedia Search algorithms","Wikipedia Suchverfahren","Wikipedia article Algorithme de recherche","Wikipedia article Algoritma pencarian","Wikipedia article Algoritmo de busca","Wikipedia article Algoritmo de búsqueda","Wikipedia article Keyword search","Wikipedia article Search algorithm","Wikipedia article Search algorithms","Wikipedia article Search_algorithm","Wikipedia article Uninformed search","Wikipedia article on Algoritmo de búsqueda","Wikipedia article on Algoritmos de búsqueda","Wikipedia article on Búsqueda binaria","Wikipedia article on Keyword search","Wikipedia article অনুসন্ধান অ্যালগোরিদম","Wikipedia l'articolo Algoritmo di ricerca","Wikipedia page for 検索","Wikipedia's Search algorith page","Wikipedia-Artikel Suchalgorithmus","Wikipedia-Artikel Suchstrategie","Wikipedia-Artikel Suchverfahren","Wikipedia-Seite zu 'Suchalgorithmus'","Wikipedia-Seite zu 'Suchstrategie'","Wikipedia-Seite zu 'Suchverfahren'","Wikipedia: Search algorithm","Wikipedia: Searching Algorithm","Wikipediaで「探索」を調べる","Wikipediaで「探索アルゴリズム」を調べる","Wikipediaで「検索」を調べる","Wikipedia日本語版 - 検索","Wikipedia（探索）","Wikipedia（検索）","Wikipédia artigo Algoritmo de busca","Zoekalgoritme","Zoekalgoritme - Wikipedia","Zoekalgoritme Wikipedia","Zoeken in lijsten","[Click here to visit Search Algorithm]","ak mengetahui pencarian","algorithme de recherche","algorithmes de recherche","algorithmic search","algorithms for searching","algoritma pencarian","algoritma pencarian wikipedia bahasa indonesia","algoritmo de busca","algoritmo di ricerca","algoritmos computacionais de busca","algoritmos dos buscadores","artigo da Wikipédia Algoritmo de busca","artículo de Wikipedia Algoritmo de búsqueda","artículo de Wikipedia Búsqueda binaria","artículo de Wikipedia Búsqueda dicotómica","artículo sobre búsqueda de la wikipedia","bilgisiz","busca algorítmica","busca,","busqueda binaria","busqueda dicotomica","búsqueda dicotómica","constraint satisfaction search","de recherche,","de.wikipedia.org/wiki/Suchstrategie","de:Suchverfahren","de:Suchverfahren#Suche in Graphen","en.wikipedia.org/...Search_algorithm","en.wikipedia.org/wiki/Keyword_search","en.wikipedia.org/wiki/Search_algorithm","en.wikipedia.org/wiki/Search_algorithm#Informed_search","engines algorithm","es:Algoritmo de búsqueda","es:Búsqueda dicotómica","f search algorithm","fa:الگوریتم جستجو","fazer uma busc","fazer uma busca","fi:Hakualgoritmi","fr:Algorithme de recherche","giải thuật tìm kiếm","he:אלגוריתם חיפוש","http://de.wikipedia.org/wiki/Su chalgorithmus","http://de.wikipedia.org/wiki/Su chverfahren#Einfache_Suchalgori","http://de.wikipedia.org/wiki/Suchal","http://de.wikipedia.org/wiki/Suchalgorithmus","http://de.wikipedia.org/wiki/Suchalgorit…","http://de.wikipedia.org/wiki/Suchstrategie","http://de.wikipedia.org/wiki/Suchverfahr","http://de.wikipedia.org/wiki/Suchverfahren","http://de.wikipedia.org/wiki/Suchverfahren#Heuristische_.28Informierte","http://de.wikipedia.org/wiki/Suchverfahr…","http://el.wikipedia.org/wiki/Αλγόριθμοι_αναζήτησης","http://el.wikipedia.org/wiki/Αλγόριθμος_αναζήτησης","http://el.wikipedia.org/wiki/Επίλυση_προβλημάτων_(τεχνητή_νοημοσύνη)","http://en.wikipedia....arch_algorithms","http://en.wikipedia.org/wiki/Keyword_search","http://en.wikipedia.org/wiki/Search% 5Falgorithm","http://en.wikipedia.org/wiki/Search% 5Falgorithms","http://en.wikipedia.org/wiki/Search%5Falgorithm","http://en.wikipedia.org/wiki/Search%5Falgorithms","http://en.wikipedia.org/wiki/Search_algorithm","http://en.wikipedia.org/wiki/Search_algorithm#Classes_of_search_algorithms","http://en.wikipedia.org/wiki/Search_algorithm#Uninformed_search","http://en.wikipedia.org/wiki/Search_algorithms","http://en.wikipedia.org/wiki/Search_algorithms#Informed_search","http://en.wikipedia.org/wiki/Search_algo…","http://en.wikipedia.org/wiki/Search％5Falgorithm","http://en.wikipedia.org/wiki/Search％の5Falgorithm","http://en.wikipedia.org/wiki/Uninformed_search","http://es.wikipedia.org/wiki/Algoritmo_de_b%C3%BAsqueda","http://es.wikipedia.org/wiki/B%C3%BAsqueda_binaria","http://es.wikipedia.org/wiki/B%C3%BAsqueda_dicot","http://fi.wikipedia.org/wiki/Hakualgoritmi","http://fr.wikipedia.org/wiki/Algorithme_de_recherche","http://id.wikipedia.org/wiki/Algoritma_pencarian","http://id.wikipedia.org/wiki/Algoritma_p…","http://it.wikipedia.org/wiki/Algoritmo_di_ricerca","http://ja.wikipedia.org/wiki/検索","http://nl.wikipedia.org/wiki/Zoekalgorit","http://nl.wikipedia.org/wiki/Zoekalgoritme","http://pt.wikipedia.org/wiki/Algoritmo_de_busca","http://www.de.wikipedia.org/wiki/Suchverfahren","id.wikipedia.org/wiki/Algoritma_pencarian","id:Algoritma pencarian","informed search","informed search algorithm","informierten Suchalgorithmen","it:Algoritmo di ricerca","ja.wikipedia.org/wiki/検索","ja:探索","la búsqueda algorítmica","list of search algorithms","list search","manier van zoeken","mhtiroglA hcraeS","ninformed search th","nl:Zoekalgoritme","oversearching","pencarian,","pt:Algoritmo de busca","ricerca non informata","ricerca,","search algo","search algorit","search algorith","search algorithm - Wikipedia, the free encyclopedia","search algorithm wikipedia the encyclopedia","search algorithm wikipedia the free encyclopedia","search engine's algorithm","search pseudocode","search techniques","search_algorithm#For_virtual_search_spaces","searching algorithms","suchen,","suchverfahren","system for finding what you like","tìm kiếm,","uniformierten","vi:Giải thuật tìm kiếm","w:Search algorithm","w:検索","wikipedia article on search algorithms","wikipediaで「検索」を検索","zoekalgoritme","zoekalgoritmen","zoekproblemen","Επίλυση προβλημάτων (τεχνητή νοημοσύνη)","Επίλυση προβλημάτων (τεχνητή νοημοσύνη) - Βικιπαίδεια","Επίλυση προβλημάτων ...","поиск,","поисковых алгоритмах","אלגוריתם חיפוש","الگوریتم جستجو - ویکیپدیا","خوارزميات البحث","ค้นหา,","「探索」をWikiで調べる","「探索アルゴリズム」をWikiで調べる","「検索」","「検索」についてWikipediaで調査","「検索」をWikipediaで調べる","「検索」をWikiで調べる","『検索』の解説","の検索","ウィキペディアの記事 探索アルゴリズム","ウィキペディアの記事 検索","探索 - Wikipedia","探索 - wikipedia","探索 -wikipedia","探索アルゴリズム","探索アルゴリズム - Wikipedia","探索空間","探索ｱﾙｺﾞﾘｽﾞﾑ-wikipedia","搜尋演算法(search algorithm)","搜尋演算法（search algorithm）","検索 - Wikipedia","検索 - wikipedia (書きかけ項目)","検索 -wikipedia","検索-wikipedia","検索とは","検索方法","検索（ウィキペディア）","死 KI besch ? ftigt sich h ? ufig mit","탐색","＊情報検索＊"],"name":"Search algorithm","categories":["All Wikipedia articles needing context","All articles lacking sources","All articles needing expert attention","All pages needing cleanup","Articles lacking sources from December 2014","Articles needing expert attention from December 2014","Computer science articles needing expert attention","Search algorithms","Wikipedia articles needing context from December 2014","Wikipedia introduction cleanup from December 2014"],"tag_line":"In computer science, a search algorithm is an algorithm for finding an item with specified properties among a collection of items which are coded into a computer program, that look for clues to return what is wanted."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dancing-links","_score":0,"_source":{"description":"In computer science, dancing links is the technique suggested by Donald Knuth to efficiently implement his Algorithm X. Algorithm X is a recursive, nondeterministic, depth-first, backtracking algorithm that finds all solutions to the exact cover problem. Some of the better-known exact cover problems include tiling, the n queens problem, and Sudoku.\nThe name dancing links stems from the way the algorithm works, as iterations of the algorithm cause the links to \"dance\" with partner links so as to resemble an \"exquisitely choreographed dance.\" Knuth credits Hiroshi Hitotsumatsu and Kōhei Noshita with having invented the idea in 1979, but it is his paper which has popularized it.","alt_names":["dancing links","'DLX' o 'dancing links'","...mehr auf Wikipedia über Tanz der Kanten","...more on Wikipedia about Dancing Links","Bailando Enlaces - Wikipedia, la enciclopedia libre","Ballant Enllaços - Viquipèdia lliure","DLX的","Dancing Enlaces - Wikipedia, a enciclopedia libre","Dancing Link","Dancing Linkek - Wikipédia, a szabad enciklopédia","Dancing Linker - Wikipedia, den frie encyklopedi","Dancing Linki - Wikipedia, wolna encyklopedia","Dancing Links","Dancing Links (A very useful hack by Knuth","Dancing Links (ou DLX)","Dancing Links - Wikipedia :: The free encyclopedia","Dancing Links - Wikipedia, Enciklopedia e Lirë","Dancing Links - Wikipedia, den frie encyklopædi","Dancing Links - Wikipedia, der freien Enzyklopädie","Dancing Links - Wikipedia, ensiklopedia bebas","Dancing Links - Wikipedia, l'enciclopedia libera","Dancing Links - Wikipedia, l'encyclopédie libre","Dancing Links - Wikipedia, the free encyclopedia","Dancing Links - Wikipedia, vapaa tietosanakirja","Dancing Links - Wikipedija, l-enċiklopedija ħielsa","Dancing Links - Wikipédia, a enciclopédia livre","Dancing Links Algorithm","Dancing Links Wikipedia the free encyclopedia","Dancing Links algorithm","Dancing Links algorithm (DLX)","Dancing Links algorithm as described at Wikipedia","Dancing Links algorithm by Knuth","Dancing Links or DLX","Dancing Links technique","Dancing Links – Wikipedia, the free encyclopedia","Dancing Links,","Dancing Links, or DLX","Dancing Links.","Dancing Links: Header","Dancing Links; it is used under the","Dancing Liên kết - Wikipedia tiếng Việt","Dancing Länkar - Wikipedia, den fria encyklopedin","Dancing enlaces","Dancing legami","Dancing link","Dancing links","Dancing links algorithm as sudoku solver","Dancing liên kết","Dancing ссылками,","Dancing-Links","DancingLink","Dancing_Links","Dancing_Links wikipedia","Dans Bağlantılar - Vikipedi, özgür ansiklopedi","Dejošana Saites - Vikipēdija, brīvā enciklopēdija","Don Knuth's Dancing Links approach","Donald Knuth solution was a little nerd ....ier","Donald Knuth's Dancing Links Algorithm","Hacker News: Dancing Links (A very useful hack","Itt (Dancing Links cikk a wikipedian)","Knuth's DLX.","Knuth's Dancing Links","Knuth's Dancing Links Algorithm","Knuth's dancing link list","Link-uri dans - Wikipedia, enciclopedia liberă","Linki Dancing","Odkazy tanec - Wikipedie, otevřená encyklopedie","Taneční Odkazy","Tanz der Kanten","Tanz der Kanten - Wikipedia","Tanz der Kanten – Wikipedia","Tanz-Links","Tanz-Links).","Tanzen Links","Wikipedia article Dancing Links","Wikipedia entry for Dancing Links","Wikipedia-Artikel Tanz der Kanten","Wikipedia-Eintrag zu Dancing Links","Wikipedia:Dancing Links","baile Enlaces","balli link).","cet algorithme","dacing links","dancing links algorithm","dancing links paper","dancing links wikipedia the free encyclopedia","dancing links;","dancinglinks","danse des liens","dansen koppelingen","dança links).","de linkjes dansen tegenwoordig","des liens de danse","el baile enlaces).","en.wikipedia.org/...Dancing_Links","en.wikipedia.org/wiki/Dancing_Links","enlaces baile","http://de.wikipedia.org/wiki/Tanz_der_Ka","http://de.wikipedia.org/wiki/Tanz_der_Kanten","http://en.wikipedia....i/Dancing_Links","http://en.wikipedia.org/wiki/Dancing_Lin","http://en.wikipedia.org/wiki/Dancing_Lin...","http://en.wikipedia.org/wiki/Dancing_Links","http://en.wikipedia.org/wiki/Dancing_Links.","http://en.wikipedia.org/wiki/Dancing_Lin…","http://en.wikipedia.org/wiki/Dancing_links","http://en.wikipedia.org/wiki/dancing_links","la danse des liens).","link danza","link menari","links dança","links เต้น","liên kết khiêu vũ","menari link).","nhảy múa liên kết).","tanec odkazy","tančícími propoji","tecnica dei Dancing Links","«Dancing Links»","Χορεύοντας Σύνδεσμοι - Βικιπαίδεια, την ελεύθερη εγκυκλοπαίδεια","ДЛКС","Танцы Ссылки","Танцы Ссылки Материал из Википедии - свободной энциклопедии","Танці Посилання Матеріал з Вікіпедії - вільної енциклопедії","танцы ссылками).","танцы ссылки","רוקדים קישורים - מתוך ויקיפדיה, האנציקלופדיה החופשית","การ เต้นรำ ลิงค์","เต้นรำ ลิงก์).","ダンスのリンク","ダンスリンク- Wikipedia、フリー百科事典","ダンスリンクは","リンクをダンス","リンクを踊る","的DLx","舞蹈鏈接","舞蹈链接","舞蹈链接-维基百科，自由的百科全书","跳舞環節","跳舞的联系","跳舞的聯繫","踊りのリンク","링크가 춤과","링크가 춤을)","춤 링크","춤 링크 - 위키백과, 자유 백과 사전"],"name":"Dancing Links","categories":["Articles containing video clips","Donald Knuth","Linked lists","Search algorithms","Sudoku"],"tag_line":"In computer science, dancing links is the technique suggested by Donald Knuth to efficiently implement his Algorithm X. Algorithm X is a recursive, nondeterministic, depth-first, backtracking algorithm that finds all solutions to the exact cover problem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hopscotch-hashing","_score":0,"_source":{"description":"Hopscotch hashing is a scheme in computer programming for resolving hash collisions of values of hash functions in a table using open addressing. It is also well suited for implementing a concurrent hash table. Hopscotch hashing was introduced by Maurice Herlihy, Nir Shavit and Moran Tzafrir in 2008. The name is derived from the sequence of hops that characterize the table's insertion algorithm.\nThe algorithm uses a single array of n buckets. For each bucket, its neighborhood is a small collection of nearby consecutive buckets (i.e. one with close indexes to the original hashed bucket). The desired property of the neighborhood is that the cost of finding an item in the buckets of the neighborhood is close to the cost of finding it in the bucket itself (for example, by having buckets in the neighborhood fall within the same cache line). The size of the neighborhood must be sufficient to accommodate a logarithmic number of items in the worst case (i.e. it must accommodate log(n) items), but only a constant number on average. If some bucket's neighborhood is filled, the table is resized.\nIn hopscotch hashing, as in cuckoo hashing, and unlike in linear probing, a given item will always be inserted-into and found-in the neighborhood of its hashed bucket. In other words, it will always be found either in its original hashed array entry, or in one of the next H-1 neighboring entries. H could, for example, be 32, the standard machine word size. The neighborhood is thus a \"virtual\" bucket that has fixed size and overlaps with the next H-1 buckets. To speed the search, each bucket (array entry) includes a \"hop-information\" word, an H-bit bitmap that indicates which of the next H-1 entries contain items that hashed to the current entry's virtual bucket. In this way, an item can be found quickly by looking at the word to see which entries belong to the bucket, and then scanning through the constant number of entries (most modern processors support special bit manipulation operations that make the lookup in the \"hop-information\" bitmap very fast).\nHere is how to add item x which was hashed to bucket i:\nIf the entry i is empty, add x to i and return.\nStarting at entry i, use a linear probe to find an empty entry at index j.\nIf the empty entry's index j is within H-1 of entry i, place x there and return. Otherwise, entry j is too far from i. To create an empty entry closer to i, find an item y whose hash value lies between i and j, but within H-1 of j. Displacing y to j creates a new empty slot closer to i. Repeat until the empty entry is within H-1 of entry i, place x there and return. If no such item y exists, or if the bucket i already contains H items, resize and rehash the table.\nThe idea is that hopscotch hashing \"moves the empty slot towards the desired bucket\". This distinguishes it from linear probing which leaves the empty slot where it was found, possibly far away from the original bucket, or from cuckoo hashing that, in order to create a free bucket, moves an item out of one of the desired buckets in the target arrays, and only then tries to find the displaced item a new place.\nTo remove an item from the table, one simply removes it from the table entry. If the neighborhood buckets are cache aligned, then one could apply a reorganization operation in which items are moved into the now vacant location in order to improve alignment.\nOne advantage of hopscotch hashing is that it provides good performance at very high table load factors, even ones exceeding 0.9. Part of this efficiency is due to using a linear probe only to find an empty slot during insertion, not for every lookup as in the original linear probing hash table algorithm. Another advantage is that one can use any hash function, in particular simple ones that are close-to-universal.","alt_names":["Hopscotch hashing","Hopscotch hashing - Wikipedia, the free encyclopedia","hopscotch hashing","hopscotch_hashing","http://en.wikipedia.org/wiki/Hopscotch_hashin...","http://en.wikipedia.org/wiki/Hopscotch_hashing"],"name":"Hopscotch hashing","categories":["Hashing","Search algorithms"],"tag_line":"Hopscotch hashing is a scheme in computer programming for resolving hash collisions of values of hash functions in a table using open addressing."}}
,{"_index":"throwtable","_type":"algorithm","_id":"search-game","_score":0,"_source":{"description":"A search game is a two-person zero-sum game which takes place in a set called the search space. The searcher can choose any continuous trajectory subject to a maximal velocity constraint. It is always assumed that neither the searcher nor the hider has any knowledge about the movement of the other player until their distance apart is less than or equal to the discovery radius and at this very moment capture occurs. As mathematical models, search games can be applied to areas such as hide-and-seek games that children play or representations of some tactical military situations. The area of search games was introduced in the last chapter of Rufus Isaacs' classic book \"Differential Games\" and has been developed further by Shmuel Gal  and Steve Alpern.\nWhat is the best way to search a stationary target in a graph? A natural strategy is to find a minimal closed curve L that covers all the arcs of the graph. (L is called a Chinese postman tour). Then, traverse L with probability 1/2 for each direction. This strategy seems to work well if the graph is Eulerian. In general, this random Chinese postman tour is indeed an optimal search strategy if and only if the graph consists of a set of Eulerian graphs connected in a tree-like structure. A misleadingly simple example of a graph not in this family consists of two nodes connected by three arcs. The random Chinese postman tour (equivalent to traversing the three arcs in a random order) is not optimal. The optimal way to search these three arcs is surprisingly complicated [2] .\nThe princess and monster game deals with a moving target.\nSearching unbounded domains is also interesting. In general, the reasonable framework, as in the case of an online algorithm, is to use a normalized cost function (called the competitive ratio in Computer Science literature). The minimax trajectory for problems of these types is always a geometric sequence (or exponential function for continuous problems). This result yields an easy method to find the minimax trajectory by minimizing over a single parameter (the generator of this sequence) instead of searching over the whole trajectory space. This tool has been used for the linear search problem, i.e., finding a target on the infinite line, which has attracted much attention over several decades and has been analyzed as a search game. It has also been used to find a minimax trajectory for searching a set of concurrent rays. Optimal searching in the plane is performed by using exponential spirals. Searching a set of concurrent rays was later re-discovered in Computer Science literature as the 'cow-path problem'.","alt_names":[],"name":"Search game","categories":["Game theory","Search algorithms"],"tag_line":"A search game is a two-person zero-sum game which takes place in a set called the search space."}}
,{"_index":"throwtable","_type":"algorithm","_id":"stack-search","_score":0,"_source":{"description":"Stack search (also known as Stack decoding algorithm) is a search algorithm similar to beam search. It can be used to explore tree-structured search spaces and is often employed in Natural language processing applications, such as parsing of natural languages, or for decoding of error correcting codes where the technique goes under the name of sequential decoding.\nStack search keeps a list of the best n candidates seen so far. These candidates are incomplete solutions to the search problems, e.g. partial parse trees. It then iteratively expands the best partial solution, putting all resulting partial solutions onto the stack and then trimming the resulting list of partial solutions to the top n candidates, until a real solution (i.e. complete parse tree) has been found.\nStack search is not guaranteed to find the optimal solution to the search problem. The quality of the result depends on the quality of the search heuristic.","alt_names":["Stack search","Stack search - Wikipedia :: The free encyclopedia","Stack search - Wikipedia, the free encyclopedia","Stack search; it is used under the","Wikipedia article Stack search","Wikipedia article on Stack search","Wikipedia entry for Stack search","http://en.wikipedia.org/wiki/Stack_searc","http://en.wikipedia.org/wiki/Stack_search","stack search","yago-res:Stack search"],"name":"Stack search","categories":["All stub articles","Computing stubs","Search algorithms"],"tag_line":"Stack search (also known as Stack decoding algorithm) is a search algorithm similar to beam search."}}
,{"_index":"throwtable","_type":"algorithm","_id":"exponential-search","_score":0,"_source":{"description":"In computer science, an exponential search (also called doubling search or galloping search) is an algorithm, created by Jon Bentley and Andrew Chi-Chih Yao in 1976, for searching sorted, unbounded/infinite lists. There are numerous ways to implement this with the most common being to determine a range that the search key resides in and performing a binary search within that range. This takes O(log i) where i is the position of the search key in the list, if the search key is in the list, or the position where the search key should be, if the search key is not in the list.\nExponential search can also be used to search in bounded lists. Exponential search can even out-perform more traditional searches for bounded lists, such as binary search, when the element being searched for is near the beginning of the array. This is because exponential search will run in O(log i) time, where i is the index of the element being searched for in the list, whereas binary search would run in O(log n) time, where n is the number of elements in the list.","alt_names":[],"name":"Exponential search","categories":["Search algorithms"],"tag_line":"In computer science, an exponential search (also called doubling search or galloping search) is an algorithm, created by Jon Bentley and Andrew Chi-Chih Yao in 1976, for searching sorted, unbounded/infinite lists."}}
,{"_index":"throwtable","_type":"algorithm","_id":"best-bin-first","_score":0,"_source":{"description":"Best bin first is a search algorithm that is designed to efficiently find an approximate solution to the nearest neighbor search problem in very-high-dimensional spaces. The algorithm is based on a variant of the kd-tree search algorithm which makes indexing higher-dimensional spaces possible. Best bin first is an approximate algorithm which returns the nearest neighbor for a large fraction of queries and a very close neighbor otherwise.","alt_names":[],"name":"Best bin first","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Search algorithms"],"tag_line":"Best bin first is a search algorithm that is designed to efficiently find an approximate solution to the nearest neighbor search problem in very-high-dimensional spaces."}}
,{"_index":"throwtable","_type":"algorithm","_id":"yds-algorithm","_score":0,"_source":{"description":"YDS is a scheduling algorithm for dynamic speed scaling processors which minimizes the total energy consumption. It was named after and developed by Yao et al. There is both an online and an offline version of the algorithm.","alt_names":[],"name":"YDS algorithm","categories":["All articles needing expert attention","All articles that are too technical","Articles needing expert attention from July 2013","Processor scheduling algorithms","Real-time computing","Wikipedia articles that are too technical from July 2013"],"tag_line":"YDS is a scheduling algorithm for dynamic speed scaling processors which minimizes the total energy consumption."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pagerank","_score":0,"_source":{"description":"PageRank is an algorithm used by Google Search to rank websites in their search engine results. PageRank was named after Larry Page, one of the founders of Google. PageRank is a way of measuring the importance of website pages. According to Google:\n\nPageRank works by counting the number and quality of links to a page to determine a rough estimate of how important the website is. The underlying assumption is that more important websites are likely to receive more links from other websites.\n\nIt is not the only algorithm used by Google to order search engine results, but it is the first algorithm that was used by the company, and it is the best-known.","alt_names":["Buradan da","bővebb infó itt","узнать можно здесь","Google Juice","Google's algorithm","detay","algoritmo di Google","the same method","zapraszam do lektury","fr.wikipedia.org/wiki/Pag…","Weitere Infos!","sabe o que é isso?","L'algorithme","PR7","PRs","ne parla","Google search algorithm","http://en.wikipedia.org/wiki/Pag...","are based","رنک","PageRank,","variety of factors","3.2 Damping factor","link analysis algorithm","PR 10","search ranking","Medir","4.7 Other uses","Google's Pagerank","page ranks","wyszukiwarce Google","ganz gut erklärt","en.wikipedia.org/wiki/Pag…","Google algorithm","Page Rank","PageRank™","page rank","page ranking","PageRank","Google Page Rank","PageRank - Wikipedia, the free encyclopedia","Pagerank","pagerank","#1Rank","'Page Rank'","'PageRank","'PageRank'","'Pagerank' in Wikipedia","'Pagerank'.","'idea geniale","( Pagerank nedir? )","(= Page Rank)","(? klik hier)","(Page Rank – PR","(Page Rank)","(PageRank)","(PageRank,","(Redirected from Google rank) Jump to: navigation, search","(See Page)","(baca ensiklopedia tentang pagerank).","(extraits traduits)","(http://it.wikipedia.org/wiki/PageRank","(http://pl.wikipe","(link analysis algorithm)","(mehr dazu in der Wikipedia)","(page)ranking","(pagerank)","(siehe Pagerankformel)","(ver articulo)","(ответ)","(ссылка: Пример)","(什麼是PageRank?)","*Extraído de Wikipedia","*PageRank","*pagerank",", http://de.wikipedia.org/wiki/PageRank",", pangkat","- PR","- PageRank :","- google PageRank AlgorithM-En.wikipedia.orG","-> Leggi l'articolo completo su PageRank","-> Read the article about 'PageRank'","-Google-PageRank","-en.wikipedia.org/wiki/PageRank...","... Pagerank A Wikipédiából, a szabad enciklopédiából.","...Wikipedia PageRank","...mehr auf Wikipedia über PageRank","...more on Wikipedia about PageRank","//PageRank//","/wiki/PageRank","1 Elementi generali","1 Google e o PageRank","1) Wikipedia explanation of Page Rank (can be","1.1 Manipulación","10 Relevant patents","11 Relevant patents","12 year old algorithm","2 A Wikipédia e o PageRank™ do Google","2 PageRank algorithm","2 Propriété intellectuelle","2 Sayfa değeri","2 Visualizzazione del grado di popolarità di un","2.1 Simplified PageRank algorithm","2.2 PageRank algorithm including damping factor","3 Algoritma","3 Determinar o PageRank™","3 Formula semplificata","3 Güncellenmesi","3 La course aux liens","3 PageRank variations","3.1 Google Toolbar","3.1 Simplified algorithm","3.2 Google directory PageRank","3.3 Computation","3.3 False or spoofed PageRank","3.3.1 Iterative","3.3.2 Algebraic","3.3.3 Power Method","3.3.4 Efficiency","3.4 Manipulating PageRank","3.5 Other uses of PageRank","4 Google's rel='nofollow' proposal","4 Pagerank Analizi","4 Principaux critères du score d'une page","4 Random surfer model","4.1 Google Toolbar","4.2 Dış Bağlantılar","4.2 SERP Rank","4.3 Google directory PageRank","4.4 False or spoofed PageRank","4.5 Manipulating PageRank","4.6 The intentional surfer model","400px-pageranks-example_svg1","4ª semana de Diciembre","5 Alur waktu","5 Google PageRank Update History","5 Google's rel=nofollow option","5 Le TrustRank","500 million variables","6 Google's rel=nofollow option","6 Removal from Google Webmaster Tools","6 nofollow","6039","6682：ページランク - Wikipedia","7 Futur PageRank","7 Removal from Google Webmaster Tools","8 La balise Canonical","<< wiki >>","> Here \\u0026lt;","> de.wikipedia.org/wiki/PageRank (Was ist Pagerank",">>Olvass!",">Aca<",">Pagerank",">Read here<","?Qué es PageRank?","A Google PageRank","A PageRank-ról bővebben a Wikipédiában olvashat ide","A Pagerankról","A pagerankról","A thorough explanation of PageRank technology","A thuiscint go bhfuil PageRank cliceáil anseo","ALGORITMO PAGERANK","AQui","About Google Page Rank","Abschnitt Manipulation und Kritik beachten","Aca algo mas de Info","According to Google, each additional web site your","Algorithme de Google","Algorithmen von Google","Algorithmus - und damit zusammenhängend der PageRank","Algoritma PageRank","Algoritmo de Google","Algoritmo di Google","Algoritmus výpočtu pageranku","An explanation of PageRank","Apa itu PageRank?","Article sur le Page Rank de Wikipedia >>","Article sur le PageRank","Artikel Pagerank","Artikel Wikipedia Rankingwert","Auch Abschnitt Manipulation beachten","Ausführliche Erklärung PR","BACA DISINI Untuk dapat mendownload pagerank silahkan","Begrip PageRank is kliek hier","Best Damn Explanation of Pagerank","Blog Boliviano con Page Rank 5","Bookmark/Search this post with","But Google's PageRank","Bővebben a PageRankról itt.","Check PageRank","Check this Wikipedia article.","Cito la Wikipedia","Clicca QUI per sapere cos'è il Page","Click for more information regarding Google PageRank","Click here for more Page Rank information","ClickRank","Clikka qui per avere la definizione di LINK","Co je to PageRank","Co to jest Page Rank?","Come cita la fonte Wikipedia","Come funziona il page rank?","Comment fonctionne le moteur de recherche Google?","Comprendre le PageRank est cliquez ici","Continue to http://es.wikipedia.org/wiki/Pag","Cos'è il Page Rank ? Clicca qui >>","Cos'è il Pagerank","Cosa E' IL PageRank?","Czym jest PageRank i opis działania","DEN ALGORITHMUS","De berekening","DeWikiPedia:PageRank","Deall PageRank yn cliciwch yma","Definición de PageRank más completo","Definición de Pagerank en la Wikipedia","Definitie PageRank","Definition PageRank bei Wikipedia","Definition Pagerank","Definition des Page Rank Algorithmus aus dem Wikipedia","Definition of Page Rank (PR) by Wikipedia","Definizione su wikipedia","Der Algorithmus wurde von Larry Page daher der","Der Google Pagerank Algorithmus","Der PageRank","Der PageRank-Algorithmus","Der PageRank-Algorithmus ist ein Verfahren, eine Menge","Der PageRank-Algorithmus:","Details about PageRank on Wiki","Display Pagerank","Déf. de PageRank","Définition du Page Rank","Définition du PageRank","Définition du ranking","Définition du terme « PageRank » sur Wikipédia","Définition sur Wikipédia de PageRank [fr]","E che ne so io","El PageRank","El PageRank de Google (II)","El PageRank en Wiki","El sistema PageRank","El sistema PageRank era utilizado por el popular","El sistema PageRank es utilizado por Google","En Wikipedia puedes averiguarlo","En savoir plus sur le page rank (PR","Encyclopédie : PageRank - Wikipédia","Entendemento PageRank é, prema aquí","Entendimento PageRank é, clique aqui","Erklärung des PR auf Wikipedia","Ermittlung des Pageranks","Estuda um pouquinho o pagerank","Explanation of Google PageRank System (Wikipedia)","Explanation of Google's Pagerank System","Explicación del PageRank en Wikipedia","Explication complète du calcul du PageRank en anglais","Fehim PageRank huwa ikklikkja hawn","Few disagree with that guidepost","Fila de Página","Find posts tagged 'PageRank' in Wikipedia (English)","Fixed for the none clog wear'ers.","For search engine optimization purposes, some companies offer","Forstå PageRank er å klikke her","Forståelse PageRank er at klikke her","Full PageRank Definition","Full explanation of the calculation of PageRank","Förståelse PageRank är klicka här","GOOGLE PAGE RANK","GOOGLE PAGERANK","GOOGLEページランク","GP = Google PageRank","GPR (Google Page Rank)","Garfield y la de Kleinberg","Gewichtung bzw. Popularität einer Webseite","Go to this page to find out more","Goggle PR","Google - Pagerank","Google 4 Feb 2008 Posted in:","Google Algorithms","Google Algorithmus","Google PR","Google PR (PageRank)","Google PR on Wiki","Google PR值","Google Page Rage(PR","Google Page Rang","Google Page Rank 4","Google Page Rank 5","Google Page Rank 6","Google Page Rank >>","Google Page Rank Algorithm","Google Page Rank Calculation","Google Page Rank Erläuterung","Google Page Rank Explained","Google Page Rank Nedir?","Google Page Rank [3]","Google Page Rank algorithm","Google Page Rank berechnet,","Google Page Rank berekent","Google Page Rank explained","Google Page Rank fogalmáról","Google Page Rank here","Google Page Rank information","Google Page Rank nedir?","Google Page Rank počíta,","Google Page Rank počítá,","Google Page Rank you can here","Google Page Rank'","Google Page Rank(PR)","Google Page Rank,","Google Page Rank.","Google Page Ranking","Google Page Rankings","Google Page Ranks","Google Page Rank®","Google Page rank","Google Page rank algorithm","Google Page ranking","Google Page ranks","Google Page-Rank","Google Page-Rank-weighted","Google PageRank","Google PageRank (PR)","Google PageRank - Wikipedia","Google PageRank 10","Google PageRank 4","Google PageRank 6","Google PageRank Algorithm","Google PageRank Algorithm Visualized","Google PageRank Algorithmus","Google PageRank Checker - Check Google page rank of","Google PageRank Checker Tool","Google PageRank Explained","Google PageRank Search Algorithm","Google PageRank TM","Google PageRank algorithm","Google PageRank algoritme","Google PageRank at Wikipedia","Google PageRank explained","Google PageRank from Wikipedia","Google PageRank on Wikipedia","Google PageRank on this Wikipedia article.","Google PageRank page ranking algorithm - SEO list high","Google PageRank ™","Google PageRank ５ になりました！","Google PageRank&S482;","Google PageRank(PR) — это числовая величина, характеризующая «важность","Google PageRank,","Google PageRank, система,","Google PageRank-Algorithmus","Google PageRank.","Google PageRank: 5","Google PageRank: 6","Google PageRanks","Google PageRanku","Google PageRank®","Google PageRank™","Google PageRank™ algorithm","Google PageRankとは","Google PageRankの詳細はウィキペディアで確認してください","Google Pagerak","Google Pagerank","Google Pagerank (PR)","Google Pagerank (TM)","Google Pagerank (Wikipedia)","Google Pagerank (“PR”)","Google Pagerank 1 Vermiş!","Google Pagerank 5","Google Pagerank 6","Google Pagerank Algorithm","Google Pagerank Algorithm on Wikipedia","Google Pagerank system","Google Pagerank technology.","Google Pagerank'","Google Pagerank.","Google Pagerank:","Google Pagerank?","Google Pageranking","Google Pagerank™ (Wikipedia)","Google Popularity Page Rank","Google Rank","Google Rank bilgisi","Google Ranking","Google SEO and PageRank","Google Seiten Bewertung","Google Toolbar 's PageRank","Google Toolbar PageRank","Google Toolbar Pagerank","Google Toolbar Pagerank-u","Google actually favors older web pages","Google algo","Google algorythm","Google and Bing view links as “votes of","Google and Page Rank here","Google appears to have the exclusive license on","Google aprēķina Page Rank","Google aprēķina Page Rank,","Google apskaičiuoja Page Rank","Google beregner Page Rank","Google beregner Sideplacering","Google beräknar Sidrankning","Google calcola Page Rank","Google calcola il Page Rank,","Google calcula Page Rank,","Google calcula el Page Rank,","Google calcula l'Page Rank,","Google calculates Page Rank","Google calculează Page Protopopiat","Google chooses","Google describes PageRank","Google determines PageRank","Google es basa en un mètode científic bàsic","Google has always been a links driven search","Google indexará el dominio del blog","Google izračuna Page Rank","Google izračunava Stranica Rank","Google laskee PageRank","Google like simplicity","Google love","Google loves them and give them high PageRank","Google makes it to no.1 on Alexa","Google menghitung Page Rank","Google page rank","Google page rank.","Google page rank: 0","Google page rank: 1","Google page rank: 2","Google page rank: 3","Google page rank: 4","Google page rank: 5","Google page ranking","Google page rankings (at least in the past","Google page-ranking","Google page-rankings","Google pagerank","Google pagerank a wikipedián","Google pagerank algorithm","Google pageranks","Google rank","Google ranking","Google ranking (PR)","Google ranking algorithm","Google rankings","Google ranks web pages","Google score","Google search ranking","Google skal prioritere søgeresultate","Google was founded on the basis that the","Google által is használt,","Google изчислява Page ранг,","Google изчислява Страница ранг,","Google рассчитывает Page Rank,","Google розраховує Page Rank,","Google อัลกอลิทึ่ม","Google 페이지 순위지만","Google'i PageRank","Google's 'Page-Rank'","Google's PR","Google's Page Rank","Google's Page Rank Algorithm","Google's Page Rank Formula","Google's Page Rank System","Google's Page Rank algorithm","Google's Page Rank works","Google's Page Ranking algorithm","Google's PageRank","Google's PageRank (PR)","Google's PageRank System","Google's PageRank TM","Google's PageRank algorith","Google's PageRank algorithm","Google's PageRank algorithm.","Google's PageRank calculations","Google's PageRank i","Google's PageRank on Wikipedia","Google's PageRank page ranking algorithm","Google's PageRank system","Google's PageRank,","Google's PageRank™","Google's Pagerank System","Google's Pagerank system","Google's Pank Rank Algorithm","Google's brand of citation analysis","Google's famous search algorithm","Google's famous, and much publicized, PageRank algorithm","Google's founders would be well versed with","Google's listings","Google's page rank","Google's page rank algorithm is recursive","Google's page ranking","Google's page ranking algorithm","Google's page ranking system","Google's page-rank","Google's pagerank","Google's pagerank algorithm","Google's ranking algorithm","Google's ranking of sites is based on webmasters","Google's search algorithm","Google's search algorithm draws heavily from a technique","Google's search algorithms","Google's search engine algorithms","Google's search results","Google's trillion dollar PageRank formula","Google's view of the importance of a webpage","Google-Algorithmen","Google-Page-Rank","Google-PageRank","Google-PageRank-Verfahrens","Google-PageRanks","Google-Pagerank","Google-Pagerank*","Google-Pagerank-Algorithmus","Google-Pagerank?","Google-Pageranks","Google-Pagerank™","Google-Ranking","Google-ranking","Google-score","Google. Page rank","Google: Page Rank","GoogleJuice","GooglePage rank","GooglePageRank","GooglePageRankとは・・・","GooglePagerank","Googlealgorithmus","Googlen PageRank","Googlen PageRank-algoritmiin","Googlepagerank","Googlepageranking","Googles Page Rank","Googles PageRank","Googles PageRank System,","Googles Pagerank","Googles RageRank link analysis algorithm","Googles måde at indeksere og fremvise","Googles uovertrufne teknologi","Google® PageRank™","Google™ PageRank","GoogleのPageRank","GoogleのPageRankを","Googleのページランク","Googleページランク","Googleページランク（PageRank）","Google的PageRank","Google의 페이지 순위지만","Googleﾍﾟｰｼﾞﾗﾝｸ（PageRank）","Googlov algoritem PageRank","Graph theory in Google's PageRank","Grundlagen des Pagerank","Grundlegendes PageRank ist klicken Sie hier","Grundprinzipien der Vorgehensweise werden sehr gut bei der","Güncellenmesi","Gооglе-PR","HREF44","Ha nem tudod mi az a PageRank, akkor","Hehehe..","Here you go guthix.","Het PageRank","Hier erfährt man was Pagerank ist","High Page Rank","High Pagerank definition","High-PR","How Google really works","Http://en.wikipedia.org/wiki/PageRank","Hva er PageRank (PR)?","I stedet for kvalitetssikret informasjon, får man populære","Il Pagerank","Info Page Rank","Informationen zum PageRank Algorithmus","Infos zum PageRank bei Wikipedia","Interessantes aus dem Wikipedia Verzeichnis über das Page","Internetwoordenboek","Inzicht PageRank is klik hier","It's easy to find.","It's far from perfect","Itung-itungan nya Mas Larry","Jak funguje pagerank?","Kaj je PageRank?","Kim's Private Blog einen PR von Eins!","Klich hier für mehr infos","Konpreyansyon pajrank se klike isit la","Konzept des PageRank","Kuptimi PageRank është të klikoni këtu","L'algoritmo di indicizzazione di Google","L'article Wikipedia sur le Pagerank (en français","L'article sur le Page Rank","La cognizione del dolore","La page Wikipédia de PageRank","Larry Page and Sergey","Le PR a changé le 20.01.2011","Le Page Rank","Le PageRank","Le PageRank sur Wikipedia","Le PageRank sur Wikipédia","Le Pagerank défini par Wikipedia","Le ranking selon Wikipedia","Learn About Page Rank","Learn about PageRank>>>","Learn more about PageRank","Lees hier meer over pagerank","Lees meer over de techniek achter PageRank.","Lees meer over pagerank op Wikipedia","Leia aqui sobre o assunto","Les mer om PageRank her","Lesen Sie den Rest","Link (info)","Link to PageRank – Wikipedia, the free encyclopedia »","Link to PageRank – Wikipédia, a enciclopédia livre »","LinkRank","Linkability","Lisätietoa PageRankista löytyy Wikipediasta.","Local Score Value","Lue Google ja Pagerank.","Lue loput","Läs mer om Pagerank här","Läs resten","Maggiori approfondimenti sul PageRank - Wikipedia","Maggiori dettagli puoi leggerli su Wikipedia","Mais informação em Wikipedia","Make sure to understand page Ranking","Manipulation von Web-Rankings","Markov decision chains","Mas informacion ...","Mas o que é PageRank?","Meer info over Pagerank","Mehr zum Page Rank bei Wikipedia","Mehr zum PageRank","Mengutip dari Wikipedia:","Merci toi là-bas","Meu PageRank","Mi Az A Pagerank?","Mi az a PageRank?","Mi az a pagerank?","More Source on Wiki","More about PageRank","More about pagerank","More on Google Pagerank","More on Page Rank","More on PageRank here.","More on pagerank here","More understand about PR","Más de PageRank en wikipedia","Más detalles …","Más información sobre el Page Rank","Más sobre el Pagerank (Wikipedia)","Mõistmise PageRank on kliki siia","Nl article on PageRank","Not 12 months old but a Google Page","Não sabe o que é pageranck? Click Aqui","Não sabe o que é pagerank? Click Aqui","Nós somos PR4 no Google!","O PageRank w Wikipedii","O PageRank w wikipedii","O que significa PageRank?!","O que é Page rank?","O que é PageRank","O que é PageRank?","O que é Pagerank, clique para mais informações","O que é o Google Page Rank","O que é o PageRank?","O que é pagerank?","Odkaz #1159 zaslal(a) tom","Oldalak rangsora","Om Google PageRank på Wikipedia","Om du vil fordype deg i PageRank ...","One of the measures","P R ( A ) = P R ( B ) + P R","P R ( A ) = P R ( B ) L ( B","P+Rank","P5 rank","PAGE RANK","PAGE RANKING","PAGE-RANK","PAGERANK","PAGERANK 4","PR ( Page Rank)","PR (Page Rank)","PR (PageRank)","PR (page rank)","PR (pagerank)","PR 6","PR 8","PR = page rank","PR >>>","PR Google","PR algorithm","PR de 4","PR de Google","PR hasn't been manipulated","PR is thought to be a logarithmic function","PR listalla","PR number","PR o PagueRank, puedes consultarlo en Wikipedia","PR on Wikipedia","PR pozice","PR rang","PR rangering","PR reitingą","PR strona linkująca przekazuje linkowanej.","PR update","PR visiten la wikipedia aqui.","PR website","PR čin","PR κατάταξης","PR ранг","PR*","PR-Rank","PR-rang","PR. 2.0","PR0 à PR3","PR3+","PR7 rank","PRDeze pagerank kan niet worden berekent.","PRank","PRのランク","PRのランクが","PR的描述","Pag-unawa sa PageRank ay i-click dito","PagRank","Pagarank","Page Ran","Page Range","Page Rangking","Page Rank (O que é?)","Page Rank (PR)","Page Rank (Wikipedia)","Page Rank (wie Google seine Bewertung von Seiten","Page Rank - Wikipedia","Page Rank - Wikipedia, the free encyclopedia","Page Rank 1","Page Rank 10","Page Rank 4","Page Rank 4+","Page Rank 5","Page Rank Algorithm","Page Rank Defined","Page Rank Explained","Page Rank Formula","Page Rank Google","Page Rank Google de Popularidad","Page Rank System","Page Rank Wiki","Page Rank Wikipedia","Page Rank [PR]","Page Rank algorithm","Page Rank algoritme","Page Rank algoritmo","Page Rank by Wiki","Page Rank database","Page Rank de Google","Page Rank definition","Page Rank del Sito Internet","Page Rank di Google","Page Rank diye bilinen algoritma nasıl çalışıyor","Page Rank explained","Page Rank is based on a form of","Page Rank of 7","Page Rank of the domain.","Page Rank on Wikipedia","Page Rank problem","Page Rank technology","Page Rank w pl","Page Rank жжот","Page Rank در ویکی پدیا دانشنامه آزاد","Page Rank – Wikipedia","Page Rank 就如wikipedia","Page Rank'ą","Page Rank(페이지 랭크)","Page Rank,","Page Rank-Algorithmus","Page Rank-Algorithmus.","Page Rank-algoritme","Page Rank-ul","Page Rank.","Page Rank.”","Page Rank:","Page Ranked","Page Rankia","Page Ranking","Page Ranking Algorithms","Page Ranking Algorithms.","Page Ranking algorithm","Page Ranks","Page Ranku","Page Rank™","Page le Rampe","Page rank","Page rank 1","Page rank 2","Page rank algorithm","Page rank system","Page rank xplained","Page rank/wiki","Page ranking","Page ranks","Page ranks explanation","Page อันดับ.","Page- Rank","Page-Rank","Page-Rank definições via Wikipedia","Page-Rank,","Page-Rank-Algorithmus","Page-Rank-Formel","Page-Rank-Verfahren","Page-Ranking","Page-rank","Page-rankul - definitie","Page-rankul – definitie","PageLank","PagePank","PageRANK","PageRak de Google","PageRan","PageRan k - Wikipedia, the free encyclopedia","PageRang","PageRank (Google)","PageRank (PR)","PageRank (Wikipedia)","PageRank (de Google)","PageRank (named after Larry Page himself) was the","PageRank (on Wikipedia)","PageRank (w-pedia)","PageRank (wikipedia)","PageRank (или PR)","PageRank (פייג'ראנק)","PageRank - From Wikipedia, the free encyclopedia","PageRank - Vikipedi","PageRank - Vikipedi - Wikipedia","PageRank - Viquipèdia","PageRank - WikiPedia Article.","PageRank - Wikip?dia","PageRank - Wikipdia","PageRank - Wikipeadia","PageRank - Wikipedia","PageRank - Wikipedia Indonesia, ensiklopedia bebas berbahasa Indonesia","PageRank - Wikipedia bahasa Indonesia, ensiklopedia bebas","PageRank - Wikipedia, The Free Encyclopedia","PageRank - Wikipedia, den fria encyklopedin","PageRank - Wikipedia, die freie Enzyklopädie","PageRank - Wikipedia, entziklopedia askea.","PageRank - Wikipedia, l'encyclopédie libre","PageRank - Wikipedia, la enciclopedia libre","PageRank - Wikipedia, the f...","PageRank - Wikipedia, the fr...","PageRank - Wikipedia, the free","PageRank - Wikipedia, the free ...","PageRank - Wikipedia, the free encyclo","PageRank - Wikipedia, the free encyclopedia (via Diigo)","PageRank - Wikipedia, the free encyclopedia ...","PageRank - Wikipedia, the free encyclopedia 1","PageRank - Wikipedia, the free encyclopedia Page C has","PageRank - Wikipedia, the free encyclopedia PageRank is a","PageRank - Wikipedia, the free encyclopedia@@AMEPARAM@@/wiki/File","PageRank - Wikipedia, the free encyclopediaPageRank is a","PageRank - Wikipedia, the free encyclopediaThe algorithm may","PageRank - Wikipedia, the free enc…","PageRank - Wikipedia, wolna encyklopedia","PageRank - Wikipedia,...","PageRank - Wikipedie","PageRank - Wikipedie - Wikipedia","PageRank - Wikipedie, otevřená encyklopedie","PageRank - WikipÃ©dia","PageRank - WikipÃĐdia","PageRank - Wikipédia","PageRank - Wikipédia http://fr.wikipedia.org/wiki/PageRank","PageRank - Wikipédia, a enciclopédia livre","PageRank - Wik…","PageRank - description","PageRank - history","PageRank - 維å?�ç?��§ �¼?è?�ç�ç","PageRank - 維基百科,自由的百科全書","PageRank - 維基百科，自由的百科全書","PageRank - 维基百科,自由的百科全书","PageRank - 维基百科，自由的百科全书","PageRank -- Wikipedia, the free encyclopedia","PageRank -...","PageRank / Ranking (Wikipedia)","PageRank 2","PageRank 3","PageRank 4","PageRank 6","PageRank :","PageRank <http://en.wikipedia.org/wiki/PageRank>","PageRank = 4","PageRank ? Wikipedia","PageRank @ Wikipedia","PageRank Algorithm","PageRank Algorithmus","PageRank Article on Wikipedia","PageRank Basics","PageRank By Wikipedia","PageRank Defined","PageRank Definition","PageRank Definition from WikiPedia","PageRank From Wikipedia","PageRank From Wikipedia, the free encyclopedia","PageRank Google","PageRank Google System,","PageRank Google ranking report / Google rankings tips / Google","PageRank Information","PageRank Link Analysis","PageRank Score","PageRank TM","PageRank TM (Wikipedia)","PageRank Technology","PageRank Update","PageRank WiKi","PageRank Wiki","PageRank Wikipedia","PageRank Wikipedia - Example.jpg","PageRank Wikipedia Page","PageRank Wikipedia The Free Encyclopedia","PageRank Wikipedia article","PageRank Wikipedia bahasa Indonesia ensiklopedia bebas","PageRank Wikipedia de vrije encyclopedie","PageRank Wikipedia la enciclopedia libre","PageRank Wikipedia la enciclopedia libre - result","PageRank Wikipedia page","PageRank Wikipedia the free encyclopedia","PageRank Wikipedia the free encyclopedia - result","PageRank Wikipedia the free encyclopedia.","PageRank Wikipedia, the free encyclopedia","PageRank Wikipedia- Artikel","PageRank [3]","PageRank [Wikipedia]","PageRank akili ni bonyeza hapa","PageRank algoritem","PageRank algorithm","PageRank algorithm explained","PageRank algorithms","PageRank algoritme","PageRank algoritmo","PageRank alogorithm","PageRank analysis","PageRank and Standford.","PageRank and friends","PageRank and search engine results. According to Google","PageRank article","PageRank article on Wikipedia","PageRank at WikiPedia","PageRank at Wikipedia","PageRank auf Wikipedia","PageRank bases relevancy","PageRank bei Wikipedia","PageRank beregning","PageRank button","PageRank by Google","PageRank by WikiPedia","PageRank by Wikipedia.org","PageRank centrality","PageRank clic","PageRank của Google","PageRank d","PageRank d'une page web","PageRank da Wikipedia","PageRank dari wikipedia","PageRank de /kooolman.net/","PageRank de /kooolman.net/audioblog/","PageRank de /kooolman.net/blog/","PageRank de /kooolman.net/photoblog/","PageRank de /kooolman.net/videoblog/","PageRank de Google","PageRank de Google.","PageRank de google","PageRank de la wikipedia.","PageRank de uma página web","PageRank de una página web","PageRank defined by wiki","PageRank definition at Wikipedia","PageRank der Google-Toolbar","PageRank described by Wikipedia","PageRank di Google","PageRank di una pagina web","PageRank dihitung Berdasarkan skala 1-10","PageRank do Google","PageRank définition sur Wikipédia","PageRank ed il grado di popolarità di un","PageRank einer Webseite","PageRank einer Webseite,","PageRank eines Web-Seite,","PageRank en Google","PageRank en Wikipedia","PageRank enligt Wikipedia","PageRank equation","PageRank es la comprensión, haga clic aquí","PageRank esta devaluado","PageRank explained on Wikipedia","PageRank explanation article is here","PageRank formula","PageRank formula at Wikipedia","PageRank formulae","PageRank from Google","PageRank from Wikipedia","PageRank from the Wikipedia entry on the topic","PageRank funguje (slovensky)","PageRank goodness","PageRank her","PageRank here","PageRank hos Wikipedia","PageRank http://en.wikipedia.org/wiki/PageRank","PageRank in Google","PageRank in Wikipedia","PageRank information from Wikipedia","PageRank introduction article","PageRank is a family of algorithms for assigning","PageRank is a link analysis algorithm","PageRank is an algorithm","PageRank is here","PageRank kod domena i stranica","PageRank link analysis","PageRank link analysis algorithm","PageRank mechanism","PageRank method","PageRank na Wikipedia","PageRank na Wikipedii","PageRank of 6","PageRank of a web page","PageRank of five or higher","PageRank of woo sites","PageRank on Google","PageRank on Wikipedia","PageRank on the Wiki","PageRank on wikipedia.org","PageRank page","PageRank patent","PageRank på Wikipedia","PageRank really","PageRank relies on the uniquely democratic nature of","PageRank scale","PageRank score (authority)","PageRank segun wikipedia","PageRank signal","PageRank stranice","PageRank su Wikipedia","PageRank su Wikipedia.","PageRank sur WikiPedia","PageRank sur Wikipedia","PageRank sur wikipedia","PageRank system","PageRank technique","PageRank technology","PageRank tıklayınız olduğunu anlamak","PageRank ukazateľ","PageRank van een webpagina","PageRank verbessern","PageRank w","PageRank w Wikipedii","PageRank was developed at Stanford University by Larry","PageRank wiki PL","PageRank wikipedia","PageRank zero","PageRank |","PageRank â€“ Wikipedia","PageRank â�“ Wikipedia, wolna encyklopedia","PageRank è calcolato da Google","PageRank és la comprensió, feu clic aquí","PageRank μιας ιστοσελίδας","PageRank Википедия — свободная энциклопедия","PageRank в Википедии","PageRank вЂ” Р'РёРєРёРїРµРґРёСЏ","PageRank веб-страницу,","PageRank веб-страницы","PageRank е разбирање кликнете тука","PageRank из Википедии","PageRank от Wikipedia","PageRank – Der Artikel bei Wikipedia","PageRank – Vikipedia","PageRank – Vikipedija","PageRank – Wiki","PageRank – Wikipedia","PageRank – Wikipedia, the free encyclopedia","PageRank – Wikipedia, wolna encyklopedia","PageRank – Wikipedia_ the free encyclopedia","PageRank – Wikipédia, a enciclopédia livre","PageRank – Википедия","PageRank – ויקיפדיה","PageRank – 维基百科，自由的百科全书","PageRank — opis w Wikipedii","PageRank — Википедия","PageRank — Вікіпедія","PageRank — Уикипедия","PageRank 为何？","PageRank 為何？","PageRank#Complex","PageRank&trade;","PageRank'","PageRank'ai","PageRank'giem","PageRank's","PageRank(DE)","PageRank(EN)","PageRank(PR)","PageRank(TM)","PageRank(Wikipedia）","PageRank(tm)(r)(lol)(ymmv)","PageRank(维基百科)","PageRank, Wikipedia has a good article","PageRank, also der Popularität einer Site","PageRank, i","PageRank, ou PR","PageRank, índice desenvolvido pelo Google","PageRank-","PageRank-Algorithmus","PageRank-Artikel","PageRank-Beschreibung (deutsche Wikipedia)","PageRank-Beschreibung (englische Wikipedia)","PageRank-Bewertung","PageRank-Eintrag","PageRank-Erklärung auf wikipedia","PageRank-System","PageRank-Verfahren","PageRank-Wert","PageRank-Wikipedia","PageRank-algorithm","PageRank-algoritme","PageRank-algoritmen","PageRank-alogritmen","PageRank-arvosta","PageRank-come","PageRank-como","PageRank-et (PR)","PageRank-formules","PageRank-je","PageRank-like","PageRank-like algorithm","PageRank-systeem","PageRank-system","PageRank-technologie","PageRank-u","PageRank-подобные","PageRank.","PageRank/Google algorithm","PageRank:","PageRank: 3","PageRank: Google Toolbar","PageRank: Google directory PageRank","PageRank: History","PageRank:Le PageRank","PageRank?","PageRankAlgorythmus","PageRankOr","PageRankSites Checker ~ Check your PageRank, Alexa Ranking","PageRankTM (PR)","PageRankTool.net - Check Google Page Rank from various","PageRankWikipedia","PageRankWikipedia, the free encycloped","PageRank_Google","PageRank`a","PageRanka","PageRanke","PageRanked","PageRankem","PageRanken","PageRankers","PageRankiem","PageRankille","PageRankin","PageRanking","PageRanking (PR)","PageRanking at Wikipedia","PageRankom","PageRanks","PageRanks from Google","PageRanksystem von Google (Wikipedia)","PageRanku","PageRanku na Wikipediji","PageRankul descris de Wikipedia","PageRank®","PageRankо","PageRank™ (Wikipedia)","PageRank™ Algorithmus bei Wikipedia","PageRank™ algorithm","PageRank™ at WIKI","PageRank™ explained","PageRank™ چیست؟","PageRankが","PageRankとは －Wikipedia","PageRankとは？","PageRankについて","PageRankの","PageRankはnofollow属性がついたリンクを無視するようになっている","PageRankは、","PageRankはここをクリックしているの理解","PageRankはページのウェブ","PageRankふう","PageRankを","PageRank再次從4升到5","PageRank在wiki中的解釋","PageRank定義","PageRank是点击这里了解","PageRank是點擊這裡了解","PageRank演算","PageRank演算法","PageRank的","PageRank的Wiki解釋XD http://zh.wikipedia","PageRank算法","PageRank順","PageRank가","PageRank는","PageRank는 여기를 클릭 이해하는","PageRank는 페이지의 웹","PageRank를","PageRank（ページランク）","PageRank（ページ順位）","PageWank™ algowithm","Page_Rank","Page_rank","Pagekank","PagerRank","Pagerang bei Google","Pagerank (PR)","Pagerank - Uitleg","Pagerank - Wikipedia","Pagerank - Wikipedia, The Free","Pagerank - Wikipedia, The Free Encyclopedia","Pagerank - the key to Google's success","Pagerank 5","Pagerank 7","Pagerank Algorithmus","Pagerank Algorithmus'","Pagerank Google","Pagerank Statistik","Pagerank Sur Wikipedia","Pagerank Wiki","Pagerank Wikipedia","Pagerank Wikipedia The Free Encyclopedia","Pagerank a jeho výpočet - Wikipedia","Pagerank algorithm","Pagerank algoritmust","Pagerank at Wikipedia","Pagerank auf Wikipedia","Pagerank bei Wikipedia","Pagerank bot's","Pagerank clique aqui","Pagerank damper","Pagerank de Google","Pagerank di Google","Pagerank di Wikipedia","Pagerank diagram or Death Metal band logo?","Pagerank do Google","Pagerank en Wikipedia","Pagerank erklärt von Wikipedia","Pagerank in Google","Pagerank index","Pagerank is a complex algorithm","Pagerank nedir?","Pagerank on WikiPedia","Pagerank op WikiPedia","Pagerank selon wikipédia","Pagerank soll überbewertet sein :-)","Pagerank system","Pagerank ve Wiki","Pagerank | Wikipedia, la enciclopedia libre.","Pagerank!","Pagerank(PR)","Pagerank, Google","Pagerank-Algorithmus","Pagerank-Algorithmus von Google","Pagerank-Algorythmus","Pagerank-Einbuße","Pagerank-Funktion auf Wikipedia","Pagerank-Verfahren","Pagerank-Wert","Pagerank-algoritm","Pagerank.","Pagerank?","Pagerank? Read about the development here","Pagerankdämpfer","Pagerankerklärung Wikipedia","Pageranking","Pagerankings","Pageranks","Pageranku","Pagerank™","Pagerankアルゴリズム","Pagerank知識普及、算法及其他","Pagerank知识普及、算法及其他","Pagernaku","PagueRank de Google","PangeRank","Pengertian Page Rank","Pengertian Pagerank adalah klik di sini","Pengertian Pagerank adalah klik disini","Place page's ranking","Plus d'information sur cet indice","Plus d'informations sur le PageRank","Pochopenie PageRank je tu","Pochopení PageRank je zde","Popularität ihrer Webseiten","Posicionamiento en Internet","Posted On 11.12.09","Potenziamento Del PageRank","Pr:","Pr: 0","Pr: 1","Pr: 2","Pr: 3","Pr: 4","Pr: 5","Pra entender melhor sobre PageRank","Prečítajte si zvyšok","Problems?","Puteti citi continuarea informatiilor preluate de pe wikipedia","Přečtěte si zbytek","QUÉ ES EL PAGE RANK EN WIKIPEDIA","Qu'est ce que le PR ???","Qu'est ce que le PageRank ?","Qu'est que le pagerank","Qu'est-ce que pagerank ?","Que es Page rank? Click aqui","Que es el pagerank según wikipedia?","Quesque c'est le PageRank ? >>","Qué es PageRank ¿?","Qué es el PageRank","Qué es el PageRank de Google","Qué es el rango de página?","RF Cafe - Google PageRank Diagram","RF Cafe: Google PageRank equation PR(p_i) = \\frac","Random Surfer Model","Random surfer model","Rank Page","Rank of 8 out of 10","Rank-Technologie","Ranking (PageRank) PR Wikipedia","Ranking Page'a","Ranking stron","Ranking-Algorithmus","Ranking:","Razumevanje PageRank je, kliknite tukaj","Razumijevanje je PageRank kliknite ovdje","Read More About pagerank - wikipedia the free encyclopedia","Read More About pagerank wikipedia the free encyclopedia","Read More about pagerank wikipedia the free encyclopedia","Read More at Wiki... Technorati :","Read More pagerank wikipedia la enciclopedia libre","Read More pagerank wikipedia the free encyclopedia","Read More pagerank wikipedia the free encyclopedia ...","Read More pagerank – wikipedia","Read definition here!","Read more about Google PageRank","Read more about Page Rank at Wikipedia.","Read more about PageRank","Read more about google page rank","Read more about page rank","Read more about the Google PageRank algorithm on","Read the Wikipedia article on PageRank.","Recipe's popularity","Refer to Wikipedia if you wanna know more","SEO Friendly Link","Sabe mais aqui","Saiba mais sobre PageRank","Sayfa DeÄŸeri","Sayfa Değeri","Sayfa değeri","Sayıların Anlamı ve PageRank Hakkında Daha Fazla Bilgi","Search Engine Optimization - PageRank","Search Engine Page Rank","Search Engine Results Page (SERP) Rank","Search Rank","Search ranking","See Complex Algorithm","See further explanation","Seite verwiesen wurde.","Seitenrang-Patentformel","Selanjutnya baca disini","Shu yerde","Simple Page Rank Example","Simplified algorithm","Skaityti likusią","So You Want A High Search Engine Ranking","Source of text and more information.","Supratimas PageRank spauskite čia","TIL the Page in PageRank does not refer","Technologie von Google","The PageRank Algorithm or Mechanism will arrange that","The PageRank Formula","The PageRank algorithm","The PageRank algorithm was designed specifically with this","The PageRank value for a page u is","The Pagerank Wiki Page","The Wikipedia article for page rank","The Wikipedia entry on Pagerank.","The Wikipedia page on the subject","The google algorithm","The intentional surfer model","The numerical weight that it assigns to any","The page rank","The page rank of the page.","The wikipedia Article on Pagerank","Their algorithm","Thema 'PageRank'","Thema PageRank","They reinvent searching","This PageRank","To learn more about PageRank visit Wikipedia","Tonteria","Toobar PR","Toolbar PageRank","Tous savoir sur le classement des sites sur","Trang Đánh giá thuật toán","Tìm hiểu về PageRank là bấm vào đây","Uitleg Google Page Rank","Um Pagerank á Wikipedia","Una definizione accademica del PageRank","Und hier nochmals eine Erläuterung bei Wiki","Vad är PageRank?","Veja definição completa","Verbete PageRank","View Pagerank on Wikipedia","Viki Pagerank","Vikipedi Doğum Pagerank ve","Vikipedi PageRank","Visitez la page Wikipedia si vous n'y","Vocabulário (26)","Více informací o PageRanku","Více o PageRanku..","WHY IS GOOGLE PAGE RANK IMPORTANT?:","WIKI 里有Page rank的算法","WIKIPEDIA PageRank","WIKIPÉDIE","WP: PageRank","Was ist PageRank?","Was ist Pagerank?","Was ist der Google-Pagerank?","Was ist der Pagerank ( Wikipedia )","Was ist ein Google Pagerank?","Was ist ein PageRank?","Wat is een pagerank?","Web Page Ranking Algorithm","Webdesign Berlin · PageRank","Webページのページランク","Wg definicji z Wikipedii","What Is Google PageRank?","What is Google Page Rank","What is Google Page Rank?","What is Google PageRank?","What is Page Rank ?","What is Page Rank anyway?","What is Page Rank?","What is PageRank","What is PageRank From Wiki","What is PageRank?","What is PageRank? A PR rating?","What is PageRank? do we need it??","What is Pagerank?","What is a Page Rank?","What is a Pagerank","What is a pagerank","What is google page rank?","What is link trading?","What is page rank","What is page rank?","What is the PageRank ? >>","What is the description of PageRank Algorithm?","What is the history of Google search algorithm","What's a “page rank” and how can I","While just one of many factors that determine","Wie erzeugt Google eine Rangfolge der gefundenen Internetquellen","Wiki - PageRank","Wiki Artikel zu Pagerank","Wiki Page Rank","Wiki Page rank.","Wiki PageRank","Wiki PageRank Info","Wiki PageRank definition","Wiki article on Page rank","Wiki om Pageranks","Wiki on Page Rank","Wiki on PageRank","Wiki on PageRank, Google's algorythim","Wiki-PageRank","Wiki: PageRank","Wiki: Pagerank","WikiPedia (PageRang)","WikiPedia PageRank","WikiPedia PageRank Algorithm","WikiPedia PrageRank Page","WikiPedia's Explanation of PageRank","WikiPedia's article on PageRank","Wiki_Google","Wikipeadia Page Rank","Wikipedia - Der PageRank","Wikipedia - Der PageRank --- Webseitenvorschau","Wikipedia - Page Rank","Wikipedia - PageRank","Wikipedia - Pagerank","Wikipedia / google pagerank","Wikipedia : PageRank","Wikipedia : http://en.wikipedia.org/wiki/PageRank","Wikipedia : ページランク","Wikipedia Article on Page Rank","Wikipedia Article on PageRank","Wikipedia Artikel zum Thema PageRank Algorithmus","Wikipedia Eintrag zum Google Pagerank","Wikipedia Eintrag zum PageRank von Google","Wikipedia Entry On Pagerank","Wikipedia Entry for Pagerank","Wikipedia Explains Pagerank for Websites","Wikipedia PR","Wikipedia Page Rank","Wikipedia PageRank","Wikipedia PageRank Entry","Wikipedia PageRank Erklärung","Wikipedia PageRank article","Wikipedia PageRank article.","Wikipedia PageRank definition","Wikipedia PageRank entry","Wikipedia PageRank leirás","Wikipedia PageRank page","Wikipedia Pagerank (EN)","Wikipedia Pagerank (NL)","Wikipedia Pagerank Article","Wikipedia about Pagerank","Wikipedia article PageRank","Wikipedia article Pagerank","Wikipedia article about PR is what you need","Wikipedia article about PageRank","Wikipedia article about Pagerank","Wikipedia article on Page Rank","Wikipedia article on Page rank","Wikipedia article on PageRank","Wikipedia article onPageRank","Wikipedia article regarding PageRank","Wikipedia article ترتيب الصفحة","Wikipedia article पेजरैंक","Wikipedia article பேஜ் தரவரிசை","Wikipedia article పేజ్ రాంక్","Wikipedia article เพจแรงก์","Wikipedia artikel omkring PageRank","Wikipedia ausgezeichneten Artikel","Wikipedia dedicata a PageRank","Wikipedia definition of Page Rank","Wikipedia definition of PageRank","Wikipedia describe PageRank in some detail","Wikipedia entry for Page Rank","Wikipedia entry for PageRank","Wikipedia entry on Page Rank","Wikipedia entry on PageRank","Wikipedia even knows the algorithms of the PageRank","Wikipedia explains this in much greater detail","Wikipedia for pagerank","Wikipedia for the definition.","Wikipedia har i deres omtale","Wikipedia has a much better description of PageRank","Wikipedia has a short outline of it","Wikipedia hält sogar die Algorithmen des PageRank","Wikipedia in Bahasa","Wikipedia inglese sul PR","Wikipedia l'articolo Page rank","Wikipedia l'articolo PageRank","Wikipedia l'articolo Pagerank","Wikipedia link of PageRank","Wikipedia menyediakannya","Wikipedia o Page Ranku","Wikipedia om PageRank","Wikipedia om PageRank (norsk)","Wikipedia on Google's PageRank system","Wikipedia on Page Rank","Wikipedia on Page Ranking","Wikipedia on PageRank","Wikipedia on Pagrank","Wikipedia on how Google PageRank","Wikipedia on pagerank","Wikipedia on the page rank algorithm","Wikipedia over PageRank","Wikipedia page for PageRank","Wikipedia page on Page Rank","Wikipedia page on PageRank","Wikipedia page on Pagerank","Wikipedia stranicu o PR","Wikipedia tried to explain PageRank","Wikipedia vonatkozó részében","Wikipedia zum PageRank","Wikipedia zum Thema ...","Wikipedia zum Thema Pagerank","Wikipedia zum Thema …","Wikipedia » Pagerank","Wikipedia über den PageRank","Wikipedia – Google Page Rank","Wikipedia – PageRank","Wikipedia – PageRank™","Wikipedia – Pagerank","Wikipedia –PageRank","Wikipedia の PageRank のページ","Wikipedia'daki PageRank makalesi","Wikipedia's 'PageRank' entry","Wikipedia's PageRank","Wikipedia's PageRank entry","Wikipedia's article on PR","Wikipedia's article on Page Rank","Wikipedia's article on PageRank","Wikipedia's article on pagerank","Wikipedia's authoritative treatment","Wikipedia's description of PageRank.","Wikipedia's description of the PageRank algorithm","Wikipedia's entry about Page Rank","Wikipedia's entry for PageRank","Wikipedia's entry on PageRank","Wikipedia's explanation of Page Rank","Wikipedia's page on PageRank","Wikipedia's page on it.","Wikipedia's pagerank page","Wikipedia's simplifcation of Page Rank","Wikipedia's very extensive page of information about Google","Wikipedia, Page Rank","Wikipedia, PageRank","Wikipedia, PageRank szócikk","Wikipedia, the free Encyklopedia","Wikipedia-Artikel PageRank","Wikipedia-Artikel Pagerank","Wikipedia-Artikel zum Pagerankverfahren","Wikipedia-Seite zu 'Pagerank'","Wikipedia-Seite zum PageRank","Wikipedia.org/wiki/PageRank","Wikipedia/Pagerank","Wikipedia: Google Page Rank","Wikipedia: Google PageRank","Wikipedia: Page Rank","Wikipedia: Page Ranking","Wikipedia: PageRand","Wikipedia: PageRank","Wikipedia: PageRank Algorithm","Wikipedia: PageRank Manipulation","Wikipedia: PageRank Webseite Bildschirmabbild","Wikipedia: PageRank de.wikipedia.org/wiki/Pagerank","Wikipedia: PageRank http://de.wikipedia.org/wiki/Pagerank","Wikipedia: PageRank «","Wikipedia: PageRank?","Wikipedia: Pagerank","Wikipedia::Pagerank","Wikipedia:PageRank","Wikipedia:ページランク","Wikipediaból","Wikipedias sida om PageRank","Wikipediaで「PageRank」を調べる","Wikipediaで「ページランク」を調べる","Wikipediaでは「ページランク」","Wikipediaドイツ版 - PageRank","Wikipediaフランス語版 - PageRank","Wikipediaフランス語版 - page rank","Wikipedia中国語版 - PageRank","Wikipedia日本語版 - PageRank","Wikipedia日本語版 - ページランク","Wikipedia的优秀文章","Wikipedia的優秀文章","Wikipedia英語版 - PageRank","Wikipedia英語版 - page rank","Wikipedia（ページランク）","Wikipedie: PageRank","Wikipidea om PageRank.","Wikipédia - Page Rank","Wikipédia artigo GoogleBot","Wikipédia artigo Googlebot","Wikipédia artigo Page Rank","Wikipédia artigo Page rank","Wikipédia artigo PageRank","Wikipédia artigo Pagerank","Wikipédia uma descrição mais científica do PageRank","Wikipédia-PageRank","Wikipédiából, a szabad lexikonból: PageRank","WikiのPageRank説明","Więcej o pagerank...","Więcej o samym PageRank'u","Ymmärtäminen PageRank klikkaa tästä","Zde některé více info","Zrozumienie PageRank jest kliknij tutaj","Zu Wikipedia PageRank","Zufallssurfer-Modell","[Altre Fonti]","[COLOR=#0000ff]Wikipedia's page on it[/COLOR].","[Google's Page Rank]","[Lebih Lanjut.......]","[PageRank]","[PageRanku neco precist]","[Pagerank]","[Pr]","[Wikipedia: PageRank]","[size=14]View this[/size]","[url]http://de.wikipedia.org/wiki/PageRank","[بج-كليمب]","[ويكيبيديا : الموقع]","[豆知識]PageRank，又稱頁面排名","^ 相关链接 今日要闻","_8A%8D%A8%9D%AA%8D%1B%8D","a Google Page Rank","a PageRank results from a ballot among all","a complex formula","a good Page Rank","a high page rank","a higher pagerank","a link is a vote","a link іѕ a vote","a spiegazione di Wikipedia )","a tractable way to use the web's link","about backward links","actualización del PageRank","age Rank","ageRan","ageRank","agerank Algorithmus","aici - Wikipedia - engleza","aici - Wikipedia - romana","algoritam za rangiranje web sajtova na rezultuju?im","algoritam za rangiranje web sajtova na rezultujućim stranicama","algorithm at","algorithm at Google","algorithme de Google","algorithme de classement","algorithme de classement de la page","algorithme du PageRank","algorithme du PageRank de Google","algorithme employé par Google","algorithme fondateur","algorithme secret","algorithmes de pertinence bass sur la popularit","algorithmes de pertinence basés sur la popularité","algorithmes du Pagerank","algorithmic aggregation of links","algorithms and theories not for the faint hearted","algoritma Page Rank","algoritma peringkat","algoritmi di page rank","algoritmo Page Rank","algoritmo PageRank","algoritmo Pagerank","algoritmo Pagerank de Google","algoritmo de Google","algoritmo del Google Pagerank","algoritmo del PageRank","algoritmo di ranking","algoritmo do google","algoritmo maluco","algoritmos de busca eletrônica","algoritms un shēma","algoritmului simplificat","algoritmus Page Rank","algoritmus PageRanku","algorytmem Page'a","algorytmen for link analyse","algorytmie Page Rank","algorytmu Page Rank","algorytmu PageRank","allez voir là !","already effectively does that","an entry about PageRank","an excellent page on Wikipedia","analyze links on the web","analyzes web pages","anche wikipedia parla del pagerank","and you can read about it and look","angsorolási algoritmusai","aquí ho explica","ar:ترتيب الصفحة","article PageRank","article Pagerank","article about Pagerank on Wikipedia","article on PageRank","artigo da Wikipedia sobre o PageRank","artikel yang sangat baik itu Wikipedia","artikeln på Wikipedia om PageRank","artículo de Wikipedia Page rank","artículo de Wikipedia PageRank","artículo de Wikipedia Pagerank","as far as most people understand","aspect verdâtre","aunque algo matemático","automatisk definere “relevans”","açıklamayı","baca selengkapnya »","baca sisanya","basahin ang mga natitirang","basic indicator of a site's popularity","best page rank","better page status","better rankings","bevorzugt von Google","bg:PageRank","boost their relevance","boost traffic","buraya TIKLA","buying domain with high PR","by Markov chain probabilities","by creating IP called PageRank among others","by gaining backlinks or being a backlink","bài viết xuất sắc của Wikipedia","c'est quoi le pagerank?","ca:PageRank","ca:Rang de pàgina","calcola Google Page Rank,","calcul complicat","calculează Google Page Protopopiat","can view here","ce l'ho più lungo","citation link","citeste restul","classement PR","classement par pertinence","clever algorithms","clic aqui para leer más","clic aqui para leer más ...","clique aqui para entender o que isso significa","clk here","coming up with PageRank algorithm","complete algorithm here","complex algorithm behind PageRank","complex and proprietary algorithm","complex mathematical algorithm involving the hyperlinks between web","complex mathematical model","complicated linking formula","comprehensive information about PageRank","conceito de PageRank","construction du page rank).","corresponding Wikipedia-article.","cos'è il Page Rank?","covered by numerous patents","cs.wikipedia.org/wiki/PageRank","cs:PageRank","czytaj resztę","các trang xếp","céim leathanach","da http://it.wikipedia.org/wiki/PageRank","de Google PageRank","de Google pagerank","de PageRank","de calculer Page Rank Google,","de engelstalige wikipediapagina","de.wikipedia.org/ wiki/PageRank","de.wikipedia.org/PageRank","de.wikipedia.org/wiki/PageRank","de.wikipedia.org/wiki/Pagerank","de:PageRank","defenisi pagerank","define Page Rank","definició de Pagerank de la Viquipèdia","definisi PR di Wikipedia","definition of page rank","definiçao em Wikipedia","deliberately so","dem Page-Rank-Verfahren","der Pagerank","description of pagerank","descubre pinchando aqui lo que es el pagerank","det klassiska nätverksexemplet på Wikipedia","detailed explanation on google's page rank from wikipedia","detailed history and description of PageRank","details of the algorithm","di halaman ini","di lembaran ini","di sini frenzz...","dieses Link","do not count for calculating the pagerank anymore","doing a Google","dominar la publicidad mundial","du brevet du PageRank","du pageran","définition chez Wikipédia","définition du PageRank","définition pagerank","e Page Ran","e PageRan","e PageRank)","e Pagerank de Google.","e http://en.wikipedia.org/wiki/PageRank","eccellente articolo di Wikipedia","een soort standaardformule","ego-rank","eigen-problem","eine Reihe von Formeln","el PAGERANK","el PageRank","el algoritmo Page Rank de Google","el algoritmo que se usa no tiene nada","el algoritmo usado por Google","emnet på wikipedia","emprestada da wikipedia","en fonction des liens qui pointent vers votre","en komplicerad formel","en savoir plus sur le PageRank","en.wikipedia > wiki/PageRank","en.wikipedia.org ---- PageRank - Wikipedia, the free encyclopedia","en.wikipedia.org/ wiki/PageRank","en.wikipedia.org/.../PageRank","en.wikipedia.org/PageRank","en.wikipedia.org/Page_rank","en.wikipedia.org/wiki/PageRank","en.wikipedia.org/wiki/PageRank#Damping_factor","en.wikipedia.org/wiki/PageRank#Google_Toolbar","en.wikipedia.org/wiki/PageRank#Simplified_algorithm","en.wikipedia.org/wiki/PageRank...","en.wikipedia.org/wiki/Page_Rank","en.wikipedia.org/wiki/Page_rank","en.wikipedia.org/wiki/Pagerank","en.wikipedia:PageRank","en:PageRank","en:PageRank#Google's rel=nofollow proposal","engine do Google","engine ranking","entry about PageRank","entrée Wikipedia sur Pagerank","erläuterungen zum pagerank","es ist ziemlich gut dokumentiert","es.wikipedia.org/Page_rank","es.wikipedia.org/wiki/PageRank","es.wikipedia.org/wiki/PageRank#Algoritmo","es.wikipedia.org/wiki/Pag…","es:PageRank","ese PageRank","esta guía de Wikipedia","este enlace en Wikipedia como complemento (click aquí","eu:PageRank","every link is a vote","exact page rank formula","excelente artigo no Wikipedia","explaining Pagerank here","explains page rank","explanation of Google's ranking algorithm","explanation of Pagerank on Wikipedia","explicación del pagerank","extraoficial","extremely complicated formula on Wikipedia","fa:رتبه صفحه","famous search breakthrough","fi:PageRank","fila de la página","filtres intelligents","find out more about PageRank","fonctionnement de l'algorithme du Page Rank","form the basis of Google PageRank","formula de calcul","formula del Page Rank","formula del pagerank","formula for PageRank","formula for page rank.","formula semplificata","formula works","fr.wikipedia.org/wiki/PageRank","fr:PageRank","frequently linked to","freqüentemente linkado","functioneaza Page Rankul puteti gasi aici","fundamentally superior design","få högre page rank","gasiti un articol destul de exact si bine","genom att få bakåtlänkar eller vara en länk","good PR","good article on page rank","good explanation of PageRank","google PR","google PageRank","google juice","google page rank","google page rank documentation source","google page rankom","google pagerank","google pagerank here","google patented algorithm","google rank","google ranking","google search problem","google will use image pagerank to improve image","google's PageRank algorithm","google's page rank tool","google's pagerank","google's pagerank system","google's ranking algorithm","google-pagerank-300x240.jpg","google-ranking","googlerank","googleranking","googles page rank","googleには「ページランク」っていう仕組みがあるのですが、","googlowskiego PageRanku tm","googlowym pagerank'u","gorithm (","guglovo lestvico","habit of returning pages that are years out","hace 3 meses","halfway corrects itself","have some PR","he:PageRank","heavily correlated","hi:पेजरैंक","hier (Page Rank)","hier finden (Wikipedia-Artikel)","hier op neer","high PR","high lightText12'> high lightVerbose12'> PageRank - Wikipedia, the free","high page rank","higher page rank","hjelper faktisk Google med å forbedre søkene sine","hoe het werkt","hoge Pageran","how Google Page Rank works","how Google's PageRank works","how PageRank works","how ranking works on Google","how the PageRank of a page is being","http:...//nl.wikipedia.org/wiki/Pagerank","http://ar.wikipedia.org/wiki/ترتيب_الصفحة","http://bg.wikipedia.org/wiki/PageRank","http://bit.ly/bCSnFf","http://cs.wikipedia.org/wiki/PageRank","http://cs.wikipedia.org/wiki/Pagerank","http://cs.wikipedia.org/wiki/P​ageRank","http://de.wikipedia.org/wiki/Pa geRank","http://de.wikipedia.org/wiki/Pa geRank#Der_PageRank","http://de.wikipedia.org/wiki/Pa gerank","http://de.wikipedia.org/wiki/PageR...","http://de.wikipedia.org/wiki/PageRan...nk-Algorithmus","http://de.wikipedia.org/wiki/PageRank","http://de.wikipedia.org/wiki/PageRank#D ... lgorithmus","http://de.wikipedia.org/wiki/PageRank#Geschichte","http://de.wikipedia.org/wiki/PageRank#Manipulation","http://de.wikipedia.org/wiki/PageRank...","http://de.wikipedia.org/wiki/Pageran...nk-Algorithmus","http://de.wikipedia.org/wiki/Pagerank","http://de.wikipedia.org/wiki/Pagerank#Der_...ank","http://de.wikipedia.org/wiki/P​ageRank","http://de.wikipedia.org/wi​ki/PageRank","http://en.wikiped...i/PageRank","http://en.wikipedia .org/wiki/ PageRank","http://en.wikipedia....#Google_Toolbar","http://en.wikipedia....eRank#Algorithm","http://en.wikipedia....ollow.22_option","http://en.wikipedia.org/wi ki/PageRank","http://en.wikipedia.org/wiki/ PageRank","http://en.wikipedia.org/wiki/P...Rank","http://en.wikipedia.org/wiki/Pa geRank","http://en.wikipedia.org/wiki/PageRa","http://en.wikipedia.org/wiki/PageRan","http://en.wikipedia.org/wiki/PageRan...27.22_proposal","http://en.wikipedia.org/wiki/PageRan...Rank_algorithm","http://en.wikipedia.org/wiki/PageRan...Update_History","http://en.wikipedia.org/wiki/PageRan...ating_PageRank","http://en.wikipedia.org/wiki/PageRan...ctory_PageRank","http://en.wikipedia.org/wiki/PageRan...ebmaster_Tools","http://en.wikipedia.org/wiki/PageRan...fied_algorithm","http://en.wikipedia.org/wiki/PageRan...llow.22_option","http://en.wikipedia.org/wiki/PageRan...olbar_PageRank","http://en.wikipedia.org/wiki/PageRan...oofed_PageRank","http://en.wikipedia.org/wiki/PageRan...ote-Vaughn09","http://en.wikipedia.org/wiki/PageRank","http://en.wikipedia.org/wiki/PageRank (http://en","http://en.wikipedia.org/wiki/PageRank z","http://en.wikipedia.org/wiki/PageRank – cite_note-0","http://en.wikipedia.org/wiki/PageRank#Algebraic","http://en.wikipedia.org/wiki/PageRank#Algorithm","http://en.wikipedia.org/wiki/PageRank#Buying_text_links","http://en.wikipedia.org/wiki/PageRank#Complex)","http://en.wikipedia.org/wiki/PageRank#Computation","http://en.wikipedia.org/wiki/PageRank#Damping_factor","http://en.wikipedia.org/wiki/PageRank#Deprecation","http://en.wikipedia.org/wiki/PageRank#Description","http://en.wikipedia.org/wiki/PageRank#External_links","http://en.wikipedia.org/wiki/PageRank#False_or_spoofed_PageRank","http://en.wikipedia.org/wiki/PageRank#Goog....27.22","http://en.wikipedia.org/wiki/PageRank#Goog..._Update_History","http://en.wikipedia.org/wiki/PageRank#Google....","http://en.wikipedia.org/wiki/PageRank#Google.27s_","http://en.wikipedia.org/wiki/PageRank#Google.27s_rel","http://en.wikipedia.org/wiki/PageRank#Google_Toolbar","http://en.wikipedia.org/wiki/PageRank#Google_Toolbar.","http://en.wikipedia.org/wiki/PageRank#History","http://en.wikipedia.org/wiki/PageRank#Oth…","http://en.wikipedia.org/wiki/PageRank#PageRank_algorithm","http://en.wikipedia.org/wiki/PageRank#PageRank_algorithm_including_damping_factor","http://en.wikipedia.org/wiki/PageRank#PageRank_uses_links_as_.22votes","http://en.wikipedia.org/wiki/PageRank#Prediction","http://en.wikipedia.org/wiki/PageRank#Removal_from_Google_Webmaster_Tools","http://en.wikipedia.org/wiki/PageRank#S ... _algorithm","http://en.wikipedia.org/wiki/PageRank#S ... hm_details","http://en.wikipedia.org/wiki/PageRank#SERP_Rank","http://en.wikipedia.org/wiki/PageRank#Simplified_PageRank_algorithm","http://en.wikipedia.org/wiki/PageRank#Simplified_algorithm","http://en.wikipedia.org/wiki/PageRank#Some_algorithm_details","http://en.wikipedia.org/wiki/PageRank#The_intentional_surfer...","http://en.wikipedia.org/wiki/PageRank#The_intentional_surfer_model","http://en.wikipedia.org/wiki/PageRank#Va…","http://en.wikipedia.org/wiki/PageRank#cite_note- googletechnology","http://en.wikipedia.org/wiki/PageRank#cite_note-7","http://en.wikipedia.org/wiki/PageRank#cite_note-googletechnology","http://en.wikipedia.org/wiki/PageRank#cite_note-originalpaper","http://en.wikipedia.org/wiki/PageRank)","http://en.wikipedia.org/wiki/PageRank,","http://en.wikipedia.org/wiki/PageRank, A","http://en.wikipedia.org/wiki/PageRank.","http://en.wikipedia.org/wiki/PageRank. . .","http://en.wikipedia.org/wiki/PageRank...","http://en.wikipedia.org/wiki/PageRankSebuah","http://en.wikipedia.org/wiki/PageRan…Update_History","http://en.wikipedia.org/wiki/Page_Rank","http://en.wikipedia.org/wiki/Page_Rank#Simplified_algorithm","http://en.wikipedia.org/wiki/Page_Rank)","http://en.wikipedia.org/wiki/Page_rank","http://en.wikipedia.org/wiki/Page_rank#Google_Toolbar_PageRank","http://en.wikipedia.org/wiki/Page_rank)","http://en.wikipedia.org/wiki/Page_rank.","http://en.wikipedia.org/wiki/Pageran...ebmaster_Tools","http://en.wikipedia.org/wiki/Pageran...oofed_PageRank","http://en.wikipedia.org/wiki/Pagerank","http://en.wikipedia.org/wiki/Pagerank#Computation","http://en.wikipedia.org/wiki/Pagerank#Description","http://en.wikipedia.org/wiki/Pagerank#Google_Toolbar_PageRank","http://en.wikipedia.org/wiki/Pagerank#Power_Method","http://en.wikipedia.org/wiki/Pagerank#See_also","http://en.wikipedia.org/wiki/Pagerank#Simplified_algorithm","http://en.wikipedia.org/wiki/P​ageRank","http://en.wikipedia.org/wi​ki/PageRank","http://es.wikipedia.org/wiki/PageRa","http://es.wikipedia.org/wiki/PageRank","http://es.wikipedia.org/wiki/PageRank Información específica","http://es.wikipedia.org/wiki/PageRank...","http://es.wikipedia.org/wiki/Page_r","http://es.wikipedia.org/wiki/Page_rank","http://es.wikipedia.org/wiki/Pageran...s_del_PageRank","http://es.wikipedia.org/wiki/Pagerank","http://es.wikipedia.org/wiki/P​ageRank","http://eu.wikipedia.org/wiki/PageRank","http://fi.wikipedia.org/wiki/PageRank","http://fi.wikipedia.org/wiki/PageRank...","http://fr.wikipedia.org/wiki/PageRan","http://fr.wikipedia.org/wiki/PageRank","http://fr.wikipedia.org/wiki/PageRank.","http://fr.wikipedia.org/wiki/PageRank...","http://fr.wikipedia.org/wiki/Page_Rank","http://fr.wikipedia.org/wiki/Page_rank","http://fr.wikipedia.org/wiki/Pagerank","http://fr.wikipedia.org/wiki/P​ageRank","http://he.wikipedia.org/wiki/PageRank","http://hu.wikipedia.org/wiki/PageRan...C3.ADt","http://hu.wikipedia.org/wiki/PageRank","http://hu.wikipedia.org/wiki/Pagerank","http://id.wikipedia.org/wiki/PageRan","http://id.wikipedia.org/wiki/PageRank","http://id.wikipedia.org/wiki/PageRank#Algoritma","http://id.wikipedia.org/wiki/Page_Rank","http://ide.wikipedia.org/wiki/PageRank","http://is.gd/kbmWNq","http://it.wikipedia.org/wiki/P ageRan k","http://it.wikipedia.org/wiki/Page rank","http://it.wikipedia.org/wiki/PageRank","http://it.wikipedia.org/wiki/PageRank#Formula_semplificata","http://it.wikipedia.org/wiki/PageRank#Visualizzazione_del_grado_di_popolarit.C3","http://it.wikipedia.org/wiki/PageRank...","http://it.wikipedia.org/wiki/Page_rank","http://it.wikipedia.org/wiki/Pagerank","http://it.wikipedia.org/wiki/P​ageRank","http://it.wikipedia.​org/wiki/PageRank","http://ja.wikipedia.org/wiki/ページランク","http://kk.wikipedia.org/wiki/PageRank","http://lt.wikipedia.org/wiki/Pag...","http://lt.wikipedia.org/wiki/PageRank","http://lt.wikipedia.org/wi​ki/PageRank","http://nl.wikipedia.org/wiki/PageRank","http://nl.wikipedia.org/wiki/PageRank...","http://nl.wikipedia.org/wiki/Pagerank","http://no.wikipedia.org/wiki/PageRank","http://pl.wikipedia.org/wiki/PageRa...","http://pl.wikipedia.org/wiki/PageRank","http://pl.wikipedia.org/wiki/PageRank...","http://pl.wikipedia.org/wiki/Page_Rank","http://pl.wikipedia.org/wiki/Page_rank","http://pl.wikipedia.org/wiki/Pagerank","http://pt.wikipedia.org/wiki/Googlebot","http://pt.wikipedia.org/wiki/PageRank","http://pt.wikipedia.org/wiki/PageRank.","http://pt.wikipedia.org/wiki/PageRank...","http://pt.wikipedia.org/wiki/Page_Rank","http://pt.wikipedia.org/wiki/Pagerank","http://ro.wikipedia.org/wiki/PageRank","http://ru.wikipedia.org/wiki/PageRank","http://ru.wikipedia.org/wiki/PageRank#.D0.98","http://ru.wikipedia.org/wiki/PageRank...","http://ru.wikipedia.org/wiki/Page_Rank","http://ru.wikipedia.org/wiki/P​ageRank","http://sk.wikipedia.org PageRank","http://sk.wikipedia.org/wiki/PageRank","http://sk.wikipedia.org/wiki/P​ageRank","http://sk.wikipedia.org/wi​ki/PageRank","http://sv.wikipedia.org/wiki/PageRank","http://sv.wikipedia.org/wiki/PageRank...","http://sv.wikipedia.org/wiki/Pagerank","http://th.wikipedia.org/wiki/เพจแรงก์","http://tr.wikipedia.org/wiki/PageRank","http://tr.wikipedia.org/wiki/PageRank...","http://tr.wikipedia.org/wiki/Pagerank","http://tr.wikipedia.org/wiki/pagerank","http://uk.wikipedia.org/wiki/PageRank","http://www.de.wikipedia.org/wiki/PageRank","http://www.es.wikipedia.org/wiki/PageRank","http://www.eurolinkva.com/goto/aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYWdlUmFuaw==","http://www.sitepoint.com/forums/showthread.php?t","http://zh.wikipedia.org/wiki/PageRank","http://zh.wikipedia.org/wiki/PageRank#PageRank.E7","http://zh.wikipedia.org/wiki/PageRank...","http://zh.wikipedia.org/zh-cn/PageRank","http://zh.wikipedia.org/zh-tw/PageRank","http://zh.wikipedia.org/zh/PageRank","http:id.wikipedia.org","http:……//nl.wikipedia.org/wiki/Pagerank","httpXGGenFwikipedi—ForgGwikiG€—ge‚—nk","hu.wikipedia > wiki/PageRank","hu.wikipedia.org/wiki/PageRank","hu.wikipedia.org/wiki/Pagerank","hu:PageRank","hævet sidens pagerank","ia. http://en.wikipedia.org/wiki/PageRank.","id.wikipedia.org/wiki/PageRank","id:PageRank","ikely be like Google","ikipedia.org/wiki/%E3%83%9A%","il PageRank è un valore di indicizzazione","il wikipedia","image in this Wikipedia entry","important links between","improve our page ranks","improves your rank","in den Augen der Suchmaschine","in pagerank","in-depth description of PageRank","index the links and rank web page","indexa o conteúdo da web levando em consideração","indice certes limité mais réel","indice officiel de Google","indice ufficiale di Google","info z Wikipédie (en)","info z Wikipédie (sk)","ingewikkelde formule","internetes kereséssel","irrelevant in Google's pagerank algorithm","isn't even owned by Google","ist hier gut erklärt","it here it","it.wikipedia.org/PageRank","it.wikipedia.org/wiki/PageRank","it:PageRank","its algorithm","its page rank","izračunava Google Page Rank","ja:ページランク","je na Wikipedii","k, en.wikipedia.org/wiki/PageRank","kadahilanan, ranggo","kinakalkula ng Google Page Rank","kk:PageRank","klassifiki","kn:ಪೇಜ್ರ್ಯಾಂಕ್","ko:페이지랭크","komplexen Algorithmus","komplexen Formel","koymuslar","l'algo PageRank de Google","l'algorithme PageRank","l'algorithme Pagerank de Google","l'algorithme d'analyse des liens","l'algorithme initial défini par Larry Page","l'article de Wikipédia PageRank","l'article de Wikipédia Pagerank","l'attribut rel='nofollow'","l'omonimo parametro","la definición en ingles","la manera com Google calcula el Page Rank","la pagina esplicativa su wikipedia","la recette miracle n'a pas l'air","la visibilitÃ© du blog","la visibilité du blog","lapu.","large scale sparse matrix diagonalization","lasīt atpūtas","le Page Rank (définition wikipédia)","le PageRank","le Pagerank","le Pagerank. dont ils avaient la licence exclusive","le fameux PageRank","le pagerank","le pagerank de Google","le système du pagerank","learn more about Page Rank here.","leer el resto","lees de rest","lehekülje auaste","leia a explicação na Wikipédia","ler o resto","lever af links","lidt om pagerank her","limited part of the equation","link Reputation","link analysis algorhitm","link analysis algorithm that assigns a numerical weighting","link analysis can be read here","link based numerical algorithm","link la wikipedia care explica notiunea","link ranking","link reputation","link value","linkekraft","links are votes","listings on Google","llegir la resta","llegó PageRank y sus algoritmos malditos","look how complicated PageRank is","los algoritmos que utiliza Google","lt.wikipedia.org/wiki/PageRank","lt:PageRank","læse mere om PageRank her","læse resten","main algorithm","mais info sobre a importância do pagerank","mais info...","manipular el Page Rank","manipulate page rankings","manipulate search rankings","manipulering av ranking","mas info aki xD","mathematical advance","mathematische Page-Rank-Formel","mayor visibilidad en la web","mbak/mas Wiki","me he ido a la wiki","measure of website authority","measure random clicking of users","meer informatie over de Google pagerank","meglio noto come Page Rank","mesure de la qualité d'une page selon","með því að ná backlinks eða vera bakslag","mi is ez?","mide la cantidad de link entrantes a un","minibanner2.gif","misplaced links","mit Link-Geld statt mit Qualität","more frequently searched","more on PageRank","mullisti webin","mungkin informasi ini bisa membuat kamu mabok","muy bien!","myspace code is a bot","más que el PageRank","měřiče návštěvnosti","n Page","n27:PageRank","najdete např. zde","nderstandable explanation of PageRank","nifty data distillates","nl.wikipedia > wiki/PageRank","nl.wikipedia.org/wiki/Pag...","nl.wikipedia.org/wiki/PageRank","nl:PageRank","no:PageRank","nofollowの説明 Wikipedia","nofolow","not just for Google anymore!","not to focus","notre algorithme PageRank","numeris","nájdete na","o Google calcula Page Rank,","o PageRank","o PageRanku na Wikipedii","o PageRanku na Wikipédii","o artigo na WikiPedia","o que é PR?","o que é Pagerank clique aqui","o que é pagerank?","oMeuHost.com","oblicza Google Page Rank,","obligatory Wiki page","obtained a ranking","official index of Google","offiziellen Index von Google","om PR på wikipedia","online search engine","opbygge PR i 2 måneder","original pagerank formula","outbound links and pagerank","pAge RaNQoO","page Rank","page Rank de Google","page Rank>page Rank","page rank 6","page rank Google","page rank [Wikipédia (fr)]","page rank algo","page rank algorithm","page rank algorithm including a dampening factor","page rank chez Google","page rank chez google","page rank de google","page rank example","page rank for searching","page rank loss","page rank of 2","page rank of Wikipedia","page rank system","page rank weer omlaag","page rank wiki","page rank!","page rank'","page rank)","page rank-nya","page rank.","page ranked","page ranking factors","page ranking formula","page rankings","page rankom","page rankov","page ranku","page rankul","page wikipedia consacrée au PageRank","page's rank","page-rank","page-rank algorithm","page-rank-ul","page-ranky","pageRank","pageran","pagerank (PR)","pagerank - Wikipedia, the free encyclopedia","pagerank 4","pagerank Google","pagerank algorithm","pagerank at wikipedia","pagerank calculation","pagerank de google","pagerank di Google","pagerank en Google","pagerank en google","pagerank en la Wikipedia","pagerank est connu","pagerank google","pagerank in Google","pagerank in wiki","pagerank in wikipedia","pagerank merupakan","pagerank nedir ?","pagerank nedir?","pagerank no entiende de calidad literaria","pagerank o rango di una pagina.","pagerank the free encyclopedia","pagerank value","pagerank wikipedia the encyclopedia","pagerank wikipedia the free encyclopedia","pagerank | PageRank - Wikipedia, the free encyclopedia","pagerank | PageRank – Wikipedia","pagerank ın wiki de bir hesaplanma şekli var","pagerank 公式說明","pagerank's","pagerank(PR)","pagerank*","pagerank-a","pagerank-en-wp","pagerank-sortering","pagerank-wikipedia","pagerank-wp","pagerank.","pagerank?","pagerank_google","pageranka","pageranked","pagerankem","pageranki","pageranking","pagerankingen","pageranklı","pagerankning","pageranks","pageranku","pagevo hodnocení","pagină.","pajerrank","parametru PageRank","part public","partial to web sites that stand the test","passé","patented algorithm Google uses","patrz definicja","peitsjRank","peringkat PR","peringkat halaman","pertinance","pertinenz","peu plus loin","picture of circles and arrows","pl.wikipedia.org/wiki/PageRank","pl.wikipedia.org/wiki/Page_Rank","pl.wikipedia.org/wiki/Page_rank","pl.wikipedia.org/wiki/Pagerank","pl:PageRank","play a roll","poczyta o PageRank","política de pagerank de google","popularity driven databases","por gañar backlinks ou sendo un backlink","potenti algoritmi di Google","pour le classement des sites internet dans Google","počíta Google Page Rank,","počítá Google Page Rank,","pr explanation","pr больше 10 не бывает","pr6'lık","pr9","preberite ostalo","prend fin en 2011","pretty detailed description","principaux critères","pročitati ostatak","prvotní PageRank algoritmus na Wikipedii","prvotný PageRank algoritmus na Wikipédii","pt.wikipedia.org/wiki/PageRank","pt:Googlebot","pt:PageRank","published formula","pueden consultarlo aquí","puslapį.","pàgina.","página da Wikipédia sobre Page Rank","pâgerank","pètsjRank","quality of those links","que es el pagerank aqui lo puedes ver","qui c'è una piccola spiegazione","radhë faqe","raking de paginas","random surfer model","random surfing, pageranking mechanism","rang PR","ranggo","ranggo ng pahina","rangking web","rango PR","rango de relaciones públicas","rango di PR","rangul PR","rangul de PR","rangul pagina","rangú","rank content","rank di google","rank highly","rank of your page","rank pages","rank pagina","rank web pages","rankeados","ranked immer noch so","rankem","rankig","ranking algorithm","ranking de Google","ranking de página","ranking pages","ranking search results by inbound links","ranking*","rankings with Google","re rank","read more about Google's PageRank on Wikipedia","read more about Page Ranks here","read more about PageRank","read more on page rank","read the full Wikipedia entry for PageRank","read this excellent article.","referencias bibliográficas científicas","relativ simples Verfahren","relevance and readership statistics,","relevant links","removed PageRank","resposta mastigada","ro:PageRank","rovnice googlu","ru.wikipedia.org/wiki/Pag..","ru.wikipedia.org/wiki/PageRank","ru:PageRank","rules of PageRank","saber más sobre el Pagerank","said Wikipedia.Com","schijnt te zijn","se PageRan","search indexing algorithm","search parameters","search-rank algorithm","secondo un ordine ben preciso","see the full post on Wikipedia page","segretissimo algoritmo","selengkapnya di sini","siden.","sideplacering","sidrankning","sijoitukseen Googlen hakutuloksissa","simplified PR algorithm","simplified PageRank","simplified algorithm","sistema de relevância nas buscas","sistema di pageranking","sivu listalla","sivua.","sk:PageRank","so much power in aggregate","some approaches","some details of how its search engine works","some mysterious algorithm","son célèbre algorithme Pagerank","spiegazione matematica del pagerank","stated by Susan Moskwa at Google","stationary distribution of the markov matrix","statut Page Rank","story of PageRank","stranicu.","stronę.","stránce.","summary of Page Rank on Wikipedia","sursa documentatie google page rank","sv:Pagerank","síðuröðunar","sökindex","ta:பேஜ் தரவரிசை","taught everyone else","te habrías encontrado con esto","te:పేజ్ రాంక్","tells us the importance of a page on","tentang PageRank","teorien bag pagerank","th:เพจแรงก์","that works.","the Page Rank algorithm","the PageRank Algorithm","the algorithm Google uses to determine webpage rank","the algorithm at the heart of Google","the brilliant PageRank algorithm","the concept of PageRank","the invention of Pagerank","the link in Wikipedia to the source page","the little number","the pagerank algorithm","the process that Google uses","the wonders of Google's search algorithm","the wonders of Googleâ€™s search algorithm","thegetpr.net | Get Page Rank | Get backlink | Pagerank","this article complete with equations","this is precisely how PageRank works","this wikipedia article about the page rank","thousands of links on many sites","thumbnails Wikipedia PageRank","thuật toán xếp hạng","toolbar pagerank","top rangkin 2","tr.wikipedia.org/wiki/PageRank","tr:PageRank","trademark owned by Google","ttp://it.wikipedia.org/wiki/Page_rank","ttp://ja.wikipedia.org/wiki/PageRank","tính toán của Google Trang Đánh giá,","týchto stránkach","uitgebreidere definitie vind","uitgebreidere definitie vind je op Wikipedia","uk:PageRank","um Pagerank","un PageRank de 6","un algoritmo patentado en 1999","un alto pagerank","un article sur le PageRank","un enlace, un voto","un excelente artículo de Wikipedia","un excellent article de Wikipedia","un pagerank élevé","una fórmula sumamente eficiente","una fórmula tan secreta como la de la","understand what PR is","une définition du Pagerank","une entrée sur PageRank","usa o PageRank para indexar seus resultados","valore 1","ved å få backlinks eller være en tilbakekobling","ver concepto de Page Rank","ver definción en Wikipedia","ver definición Wikipedia","ver definición de PageRank en Wikipedia","veřejný","voce PR su Wikipedia","votes d'approbations","více o této problematice","více zdroj Wikipedie","w:PageRank","w:Pagerank","waardering in Google - mede van invloed op de","waardering in Google – mede van invloed op de","web pages have a page rank","web rank","website's rank","website's ranking","what is pagerank (wikipedia)","what you're really after.","wiki answers","wiki is never wrong! (but this is what","wiki pedia page rank","wikipedia - PageRank","wikipedia > ページランク","wikipedia Ar","wikipedia Artikel zum Pagerank","wikipedia PageRank","wikipedia definitia","wikipedia definition for more detailed information.","wikipedia has an explanation on PageRank","wikipedia page on Page Ranks","wikipedia page rank","wikipedia sobre el ranking de google","wikipedia sur le pagerank","wikipedia tetang perhitungan pagerank.","wikipedia – PageRank","wikipedia ページランク","wikipedia, pr или PageRank","wikipedia.org - pagerank","wikipedia.org PageRank","wikipedia.org/wiki/PageRank","wikipedia.org_PageRank","wikipedia: page rank","wikipedia:PageRank","wikipedia:PageRank#SERP_Rank","wikipedia:ページランク","wikipediaでも参照してもらう","wikipedia・ページランク","wikipedia：ぺージランク","wikipidia ar","wikipidia en","wikiページランクとは","wiki介紹PageRank","wikki explanation of PR","wiskundige manier","word-for-word from wikipedia","wp:PageRank","xếp hạng trang","y PageRank","y PageRank,","zakaj potrebujete boljši Google Page Rank?","zeer goed","zh:PageRank","zufälligerweise","« Page rank »","« PageRank »","«پیچرنگ گوگل» (Google PageRank)","´PageRank´","» Más información Google Page ranking.","» PageRank","» Pagerank (by wikipedia)","» Wikipedia zum Thema Pagerank","»Page ranka«","¿Que es PageRank?","¿Que es el PageRank?","¿Qué es PageRank?","¿Qué es el PageRank?","¿Qué es el pagerank?","¿qué es PageRank?","¿qué es el Pagerank?","Âted ¥Ãp negilm¤Ãn reggyb mhitohgak¶Ãs agilgnurpsru","Âtrats doog a eb thgim knaRegaP tuoba gnidaeR","ÂĽrĂłdÂło: Wikipedia","Înţelegerea PageRank este să faceţi clic aici","à fort pagerank","és un algorisme de can Google","índice oficial do Google","í�˜ì ´ì§€ëží ¬ - ì�„í‚¤ë°±ê³¼","đọc phần còn lại","Što bolji Google Page Rank","Λήμμα από το Βικιπαίδεια για τον αλγόριθμο PageRank","διαβάστε το υπόλοιπο","ευαγγελίζεται μέσω του Wikipedia","κατάταξη PR","σελίδα.","τάξη σελίδων","τι είναι το Pagerank;","το σύστημα PageRank","υπολογίζει η Google Page Rank,","Википедии статью Google PageRank","Википедии статью Page Rank","Википедии статью PageRank","Википедии статью Pagerank","Гугъл PR","Информация в википедии о PageRank","Истоцник>>","Источник информации wikipedia.org","Мануал по PageRank","Он будет расти","Описание алгоритма PageRank","Оценување страници","Паге Ранк","ПагеРанк","Пейдж ранк/pagerank","Пейджранк","Подробнее о Google PageRank на Википедии","Понимание PageRank является нажмите здесь","Предполага се, че Google PR-ът се влияе","Пузомерка такая от Гугла","Разумевање ПагеРанк је кликните овде","Разуменне PageRank з'яўляецца націсніце тут","Ранг алгоритм Page","Розуміння PageRank є натисніть тут","Спорный","Статья о PageRank на Wikipedia","Статья о сервисе PageRank в Википедии","Статья про PageRank на википедии","Страниц-взоберитесь","Узнать.","Что такое Google PageRank?","Что такое PR читать тут","Что такое PR читать тут :)","Что такое PR?","Что такое PageRank","Что такое PageRank?","Шкала учета PR от 0 до 10.","Што е PageRank","алгоритм PageRank","алгоритм расчета авторитетности страницы","алгоритма PageRank","алгоритма ранжирования","алгоритму PageRank","было это более 10 лет назад","вики почитать","всезнающей википедии","гугле пэйдж ранком","гугловский PageRank","израчунава Гоогле Паге Ранк","индекс цитирования.","индекса цитирования страниц","на цій","не снесли","о PageRank","обновляющемся довольно редко","объяснения Pagerank в Википедии.","односе са јавношћу рангу","он вот он","пейдж","пейджранка","по известной формуле расчета","подробное описание и характеристики","позиция на страницата","прекрасную статью Википедии","про PR","прочети останалата","прочитати остатак","пэйдж-ранком","пэйджранк","ранг алгоритм страницу","ранг на Гугл","ранг на страница","ранга PR","рангу PR","ранка сайта","рейтинг страниц","рэйтынг старонак","рэйтынгу","система принятая","сложную формулу","страницу.","теорию PageRank","формула для PageRank","формулата за присвояване на PageRank","формули за изчисляване на PageRank","формулу вычисления своего PageRank","хттп://ен.википедиа.орг/вики/Паге_ранк","хттп://ен.википедиа.орг/вики/ПагеРанк","читати відпочинку","читать отдыха","что такое PR","что такое PR в Википедии по данной ссылке","אלגוריתם החיפוש של גוגל","אלגוריתם השקלול","גוגל פייג'ראנק","דירוג הדף","האלגוריתם המקורי לחישוב PR","הנוסחה המתמטית","הערך של PageRank בויקיפדיה","להמשך המאמר- וויקיפדיה","מחשבת Google Page דירוג","מחשבת Google דף דירוג","מלנקקים אליך","סמיילים מוזרים שאמורים להסביר הכל","פּאַגעראַנק","פארשטאנד פּאַגעראַנק איז גיט דאָ","פייג' ראנק","פייג'רנק","פירוט - ויקי","קרא את שאר","اضغـط هـنـا","البيج رانك","البيج رانك Pagerank","البيج رانك pagerank","الصفحه.","المرتبة رقم","الموقع من صفحة على شبكة الإنترنت","الموقع من صفحة ويب","باغرانك","بيج رانك","ترتيب الصفحة","ترتيب الصفحة (بيج رانك)","ترتيب الصفحة - ويكيبيديا، ال...","ترتيب الصفحة - ويكيبيديا، الموسوعة ...","ترتيب الصفحة - ويكيبيديا، الموسوعة الحرة","ترتيب الصفحة*(بيج رانك)","ترتيب النتائج","تصنيف الصفحات","تصنيف الصفحة","تصنيف الصفحة جوجل تحسب","تصنيف الصّفحة","جوجل الموقع","دخول ويكيبيديا","در مورد پیج رنک بیشتر بدانید","رابط باللغة الانكليزية","رتبة PR","رتبة صفحة","رتبه بندی","رتبه درک است اینجا را کلیک کنید","رتبه صفحه","رتبه صفحه - ویکیپدیا","رتبهی گوگلی","رندوم سورفير موديل","صفحة اللغة العربية","صفحة رتبة","صيغة معقدة","فرمول رنک","فهم الموقع هو اضغط هنا","قراءة بقية","قوقل بيج رانك هنا .","مجموعات الموقع.","مصدر للمعلومات","مقال ويكيبديا الكامل عن البيج رانك","هذا المقال المطول في ويكيبديا","هذا الموضوع في ويكيبيديا","پیج رنک","پیج رنک چیست؟","پیج رنک گوگل","پیج رینک","गूगल पेज रैंक","पृष्ठस्तर","पेज रैंक","पेज वरीयता","पेजरेंक","पेजरेंक को समझना यहां क्लिक करें","पेजरैंक","पेजरैंक - विकिपीडिया","গুগল পেজর্যাঙ্ক","পেইজ র্যাংক ৭","পেইজর্যাংক","கூகிள் பக்க வரிசை","கூகிள் பேஜ் ரேங்க்","பேஜ் தரவரிசை","பேஜ் தரவரிசை - தமிழ் விக்கிப்பீடியா (tamil Wikipedia)","பேஜ் தரவரிசை - தமிழ் விக்கிப்பீடியா ...","పేజ్ రాంక్","పేజ్ రాంక్ - వికీపీడియా","పేజ్_రాంక్","ಪೇಜ್ರ್ಯಾಂಕ್","ಪೇಜ್ರ್ಯಾಂಕ್ - Wikipedia","ยอดเยี่ยมบทความของวิกิพีเดีย","วิธีการจัดอันดับ","อันดับ algorithm หน้า","อันดับของ","อันดับของหน้า","เพจแรงก์","เพจแรงก์ - วิกิพีเดีย","ფეიჯრანკი","​​Pagerank","– PageRank explained","“Google Page Rank”","“Page Rank”","“PageRank - Wikipedia, the free encyclopedia”, en.wikipedia.org","“PageRank”","“Pagerank®”","“Pagerank”.","“friendrank”","“more than 500 million variables and 2 billion","“page rank”","“pagerank“","“pagerank”","“的PageRank” （","„Gugelis“","„PageRank“-Algorithmus","„Pagerank-Algorithmus“","※グーグル、ページランクについての解説","※ページランクとは・・・wiki","→→ページランクとは♪","∙ PageRank - Wikipedia, the...","∙ PageRank - Wikipédia","■ページランク - Wikipedia","● PageRank","● ページランク","●ページランクについての説明はこちらを参照","、PageRankを","》》ページランクとは","「PageRank」をWikipediaで調べる","「PageRank（ページランク）」","「pagerank」","「ページランク」","「ページランク」をWikipediaで調べる","「ページランク」をWikiで調べる","「ページ・ランク」アルゴリズム","『ページランク』","【GoogleページランクWiki】","がPageRank","がPageRankが","こちらのwikiの解説","のGoogle PageRankを","のPageRank","のPageRankの","のPageRankを","のPagerank","のエントリです。","のページランクは、","の素晴らしい記事を","は、ページのWeb上の","は（広報","ぺーじらんく","をTLDの","アルゴリズムの","ウィキで調べてみると","ウィキのページランクについての項目","ウィキペディア「ページランク」","ウィキペディアの記事 PageRank","ウィキペディアの記事 ページランク","ウィキペディア：ページランク","グーグルのページランク","グーグルページランク","グーグルページランクとは","ペイジランク","ページのランク","ページランク","ページランク - Wikipedia","ページランク - Wikipedia -","ページランク - Wikipedia ページランク (PageRank) とは、 ウェブページ の重要度を決定するための アルゴリズム","ページランク -- Wikipedia","ページランク -- wikipedia","ページランク -Wikipedia","ページランク Wikipedia","ページランク – Wikipedia","ページランク – wikipedia","ページランク(wikipedia）","ページランク-Wikipedia","ページランク-wikipedia-","ページランクWiki","ページランク[ウィキペディア（Wikipedia）]","ページランク‐Wikipedia","ページランクとは","ページランクとは - Wikipedia","ページランクとは（ウィキペディアより）","ページランクとは？","ページランクについて ウェキペディア","ページランクについての解説はこちら","ページランクについての説明はコチラ","ページランクについてはこちら","ページランクについて詳しい説明","ページランクに関するwiki","ページランクを","ページランクアルゴリズム","ページランク出典: フリー百科事典『ウィキペディア（Wikipedia）』","ページランク（PR）","ページランク（PageRank）","ページランク（PageRank）の説明はこちら","ページランク（Wikipedia）","ページランク（wikipedia）","ページランク（ウィキペディア）","ページ・ランク","ランクアルゴリズムウィキペディア","ランク付けのしくみ","リンクが票となる","一个Web网页的PageRank，","一个Web页的PageRank","一个网页的PageRank","什么是Page Rank","什麼是PageRank","什麼是pagerank","佩奇排名","关于pr的详细算法介绍","原文來自於Wikipedia","对谷歌官方指数","影响力指数*","排名算法","搜寻排名介绍","搜尋排名介紹","有料リンク","松山の電車を使ってみよう！記事編集開始！！クリックチェック！","每差距一分代表網頁的重要性","的PageRank","的PageRank。","的PageRank类似","的PageRank를","的PageRank，","的Pagerank","的에는PageRank","的은PageRank","看看維基百科怎麼介紹PR","維基百科-PageRank","維基百科PageRank條目","維基百科Pagerank","維基百科之PageRank","維基百科對於PageRank的解釋","維基百科的PageRank","維基百科的pagerank條目","維基百科的文章“ 网页级别”","網頁排名","網頁排名算法","網頁級別","维基百科-PageRank","维基百科Google PageRank词条","维基百科上的说明","维基百科对pagerank的解释","维基百科的文章“ 网页级别”","网页排名","网页排名算法","网页级别","複雑な数式","見Wiki 上的PageRank","见Wiki 上的PageRank","讀其餘","计算网页排名谷歌","读其余","谷歌的PageRank","谷歌評論PageRankが","页面排名","구글 Page Rank","구글 페이지 랭크","구글 페이지랭크","구글 페이지랭크(Google PageRank)","구글의 PageRank","구글의 PageRank에","구글의 페이지 랭크","구글의 페이지랭크","구글의 페이지랭크(Pagerank)방식","나머지 부분을","디아가 : 페이지 랭크 ]","랭 크","랭크","랭크 (PageRank","문서들의 의미를 추론하고, 그 중요도를 판단하는 도구","순위 알고리즘","영문 위키 페이지에서 찾아보면","웹 페이지의 페이지 랭크 (PageRank)","위키 피 디아 문서 PageRank","위키 피 디아 문서 페이지랭크","위키 피 디아의 우수한 기사를","페 이 지 랭 크 （網頁級別） 를","페이지 랭크","페이지 랭크 (PageRank)","페이지 랭크 (PageRank) 를","페이지 랭크 (PageRank)는","페이지 랭크 (PageRank)를","페이지 랭크와 같은","페이지 랭크의","페이지 순위","페이지 순위 알고리즘","페이지 순위를","페이지랭크","페이지랭크 - 위키백과, 우리 모두의 백과사전","페이지랭크 PageRank 알고리즘","페이지랭크(PageRank)","한국 위키백과에선","홍보 순위","＜参考＞Wikipedia ページランク","ﾍﾟｰｼﾞﾗﾝｸ","ﾍﾟｰｼﾞﾗﾝｸ(PageRank)の説明はこちら","ﾍﾟｰｼﾞﾗﾝｸ(ｳｨｷﾍﾟﾃﾞｨｱ)","ﾍﾟｰｼﾞﾗﾝｸ-wikipedia"],"name":"PageRank","categories":["All Wikipedia articles in need of updating","All articles lacking reliable references","All articles with unsourced statements","American inventions","Articles lacking reliable references from October 2012","Articles with example MATLAB/Octave code","Articles with inconsistent citation formats","Articles with unsourced statements from June 2013","Articles with unsourced statements from November 2015","Articles with unsourced statements from October 2015","Crowdsourcing","Google Search","Internet search algorithms","Link analysis","Markov models","Pages containing cite templates with deprecated parameters","Pages with URL errors","Reputation management","Search engine optimization","Wikipedia articles in need of updating from February 2014"],"tag_line":"PageRank is an algorithm used by Google Search to rank websites in their search engine results."}}
,{"_index":"throwtable","_type":"algorithm","_id":"iterative-proportional-fitting","_score":0,"_source":{"description":"The iterative proportional fitting procedure (IPFP, also known as biproportional fitting in statistics, RAS algorithm in economics and matrix raking or matrix scaling in computer science) is an iterative algorithm for estimating cell values of a contingency table such that the marginal totals remain fixed and the estimated table decomposes into an outer product.\nFirst introduced by Deming and Stephan in 1940 (they proposed IPFP as an algorithm leading to a minimizer of the Pearson X-squared statistic, which it does not, and even failed to prove convergence), it has seen various extensions and related research. A rigorous proof of convergence by means of differential geometry is due to Fienberg (1970). He interpreted the family of contingency tables of constant crossproduct ratios as a particular (IJ − 1)-dimensional manifold of constant interaction and showed that the IPFP is a fixed-point iteration on that manifold. Nevertheless, he assumed strictly positive observations. Generalization to tables with zero entries is still considered a hard and only partly solved problem.\nAn exhaustive treatment of the algorithm and its mathematical foundations can be found in the book of Bishop et al. (1975). The first general proof of convergence, built on non-trivial measure theoretic theorems and entropy minimization, is due to Csiszár (1975). Relatively new results on convergence and error behavior have been published by Pukelsheim and Simeone (2009) . They proved simple necessary and sufficient conditions for the convergence of the IPFP for arbitrary two-way tables (i.e. tables with zero entries) by analysing an -error function.\nOther general algorithms can be modified to yield the same limit as the IPFP, for instance the Newton–Raphson method and the EM algorithm. In most cases, IPFP is preferred due to its computational speed, numerical stability and algebraic simplicity.","alt_names":[],"name":"Iterative proportional fitting","categories":["Categorical data","Statistical algorithms"],"tag_line":"The iterative proportional fitting procedure (IPFP, also known as biproportional fitting in statistics, RAS algorithm in economics and matrix raking or matrix scaling in computer science) is an iterative algorithm for estimating cell values of a contingency table such that the marginal totals remain fixed and the estimated table decomposes into an outer product."}}
,{"_index":"throwtable","_type":"algorithm","_id":"block-cipher-mode-of-operation","_score":0,"_source":{"description":"In cryptography, a mode of operation is an algorithm that uses a block cipher to provide an information service such as confidentiality or authenticity. A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block. A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block.\nMost modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV has to be non-repeating and, for some modes, random as well. The initialization vector is used to ensure distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. Block ciphers have one or more block size(s), but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the last part of the data be padded to a full block if it is smaller than the current block size. There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher.\nHistorically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.\n\n","alt_names":[],"name":"Block cipher mode of operation","categories":["Block cipher modes of operation","Cryptographic algorithms"],"tag_line":"In cryptography, a mode of operation is an algorithm that uses a block cipher to provide an information service such as confidentiality or authenticity."}}
,{"_index":"throwtable","_type":"algorithm","_id":"key-schedule","_score":0,"_source":{"description":"In cryptography, the so-called product ciphers are a certain kind of ciphers, where the (de-)ciphering of data is done in \"rounds\". The general setup of each round is the same, except for some hard-coded parameters and a part of the cipher key, called a subkey. A key schedule is an algorithm that, given the key, calculates the subkeys for these rounds.","alt_names":["Subkey","(Key-Scheduling Algorithm)","- Key schedule :","- Key scheduling :","-> Read more about Key schedule","...Wikipedia Key schedule","...more on Wikipedia about Key schedule","Gestore della chiave","Gestore della chiave - Wikipedia","Key Schedule Simple English Wikipedia The Free Encyclopedia","Key Scheduling","Key schedule","Key schedule - Simple English Wikipedia, the free encyclopedia","Key schedule - Wikipedia, the free encyclopedia","Key schedule - Wikipedia, the free encyclopedia The general","Key schedule - Wikipédia","Key schedule Simple English Wikipedia the free encyclopedia","Key schedule Wikipedia the free encyclopedia.","Key schedule from Wikipedia","Key schedule; it is used under the","Key scheduling","Key_schedule","Programació de claus","Wikipedia article ''Key schedule''","Wikipedia article Key schedule","Wikipedia article Key scheduling","Wikipedia article Subkey","Wikipedia article on Key schedule","Wikipedia entry for Key schedule","Wikipedia:Gestore_della_chiave","Wikipedia:Schedulazione_della_chiave","ca:Programació de claus","en.wikipedia.org/wiki/Key_schedule","expansion de clef","gestore della chiave","http://ca.wikipedia.org/wiki/Programaci%C3%B3_de_claus","http://en.Liarpedia.org/wiki/Key_schedule","http://en.wikipedia.org/wiki/Key_schedul","http://en.wikipedia.org/wiki/Key_schedule","http://it.wikipedia.org/wiki/Gestore_della_chiave","http://it.wikipedia.org/wiki/Key_schedule","http://simple.wikipedia.org/wiki/Key_schedule","it:Gestore della chiave","key schedule","key schedule è","key schedule.","key schedules","key scheduling","key-schedule","key-scheduling","key-scheduling algorithm","keyschedule","l'article de Wikipédia Key schedule","programació de claus","simple.wikipedia.org/wiki/Key_schedule","simple:Key schedule","subkey","subkeys"],"name":"Key schedule","categories":["All articles needing additional references","Articles needing additional references from July 2008","Cryptographic algorithms"],"tag_line":"In cryptography, the so-called product ciphers are a certain kind of ciphers, where the (de-)ciphering of data is done in \"rounds\"."}}
,{"_index":"throwtable","_type":"algorithm","_id":"industrial-grade-prime","_score":0,"_source":{"description":"Industrial-grade primes (the term is apparently due to Henri Cohen) are integers for which primality has not been certified (i.e. rigorously proven), but they have undergone probable prime tests such as the Miller-Rabin primality test, which has a positive, but negligible, failure rate, or the Baillie-PSW primality test, which no composites are known to pass.\nIndustrial-grade primes are sometimes used instead of certified primes in algorithms such as RSA encryption, which require the user to generate large prime numbers. Certifying the primality of large numbers (over 100 digits for instance) is significantly harder than showing they are industrial-grade primes. The latter can be done almost instantly with a failure rate so low that it is highly unlikely to ever fail in practice. In other words, the number is believed to be prime with very high, but not absolute, confidence.\n\n","alt_names":["Industrial Grade Prime","Industrial grade prime","Industrial-Grade primes","Industrial-grade prime","Industrial-grade prime - Wikipedia, the free encyclopedia","Industrial-grade prime - Wikipedia, the free encyclopedia ...","Industrial-grade primes","Source Wikipedia.org Arcticle - Industrial-grade prime","Wikipedia article Industrial-grade prime","Wikipedia article Industrial-grade primes","Wikipedia article on Industrial-grade primes","Wikipedia entry for Industrial-grade prime","http://en.Liarpedia.org/wiki/Industrial-grade_prime","http://en.wikipedia.org/wiki/Industrial-grade_prime","industrial-grade primes","yago-res:Industrial-grade prime"],"name":"Industrial-grade prime","categories":["All stub articles","Cryptographic algorithms","Number theory stubs","Prime numbers"],"tag_line":"Industrial-grade primes (the term is apparently due to Henri Cohen) are integers for which primality has not been certified (i.e."}}
,{"_index":"throwtable","_type":"algorithm","_id":"synchronizer-(algorithm)","_score":0,"_source":{"description":"In computer science, a synchronizer is an algorithm that can be used to run a synchronous algorithm on top of an asynchronous processor network, so enabling the asynchronous system to run as a synchronous network.\nThe concept was originally proposed in (Awerbuch, 1985) along with three synchronizer algorithms named alpha, beta and gamma which provided different tradeoffs in terms of time and message complexity. Essentially, they are a solution to the problem of asynchronous algorithms (which operate in a network with no global clock) being harder to design and often less efficient than the equivalent synchronous algorithms. By using a synchronizer, algorithm designers can deal with the simplified \"ideal network\" and then later mechanically produce a version that operates in more realistic asynchronous cases.\n\n","alt_names":["Synchronizer (algorithm)","Synchronizer (algorithm) - Wikipedia, the free encyclopedia","Synchronizer algorithm","Synchronizer_(algorithm)","Wikipedia article on Synchronizer (algorithm)","Wikipedia entry for Synchronizer (algorithm)","Wikipedia:Synchronizer (algorithm)","http://en.wikipedia.org/wiki/Synchronizer_(algorithm)","yago-res:Synchronizer_(algorithm)"],"name":"Synchronizer (algorithm)","categories":["Distributed algorithms"],"tag_line":"In computer science, a synchronizer is an algorithm that can be used to run a synchronous algorithm on top of an asynchronous processor network, so enabling the asynchronous system to run as a synchronous network."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pr-cpa-advantage","_score":0,"_source":{"description":"The plaintext-recovery-under-chosen-plaintext-attack advantage (PR-CPA advantage) is defined as the probability that an algorithm with fixed computational resources can use a chosen-plaintext attack to decrypt a randomly selected message that has been encrypted with a symmetric cipher. It is regarded as a fundamental quantity in cryptography since every symmetric encryption scheme must obviously must have a very low PR-CPA advantage to be secure. Though having a low susceptibility to this sort of attack is a necessary condition for an encryption scheme's security, it is not sufficient to ensure security. This is because partial information about the plaintext can often be recovered (for example the least significant bit of the message).","alt_names":["- PR-CPA advantage :","PR-CPA advantage","PR-CPA advantage - Wikipedia, the free encyclopedia","Wikipedia article PR-CPA advantage","http://en.wikipedia.org/wiki/PR-CPA_advantage","http://goo.gl/fb/w0Rhh"],"name":"PR-CPA advantage","categories":["Cryptographic algorithms","Theory of cryptography"],"tag_line":"The plaintext-recovery-under-chosen-plaintext-attack advantage (PR-CPA advantage) is defined as the probability that an algorithm with fixed computational resources can use a chosen-plaintext attack to decrypt a randomly selected message that has been encrypted with a symmetric cipher."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ring-learning-with-errors-key-exchange","_score":0,"_source":{"description":"In cryptography, a public key exchange is a cryptographic algorithm which allows two parties to create and share a secret key which they use to encrypt messages between themselves. The Ring Learning with Errors Key Exchange (RLWE-KEX) is one of a new class of public key exchange algorithms that are designed to be secure against an adversary that possesses a quantum computer. This is important because all of the public key algorithms in use today are easily broken by a quantum computer and scientists are making steady progress toward creating such a computer. The RLWE-KEX is one of a set of Post Quantum cryptographic algorithms which are based on the difficulty of solving certain mathematical problems involving lattices. Unlike older lattice based cryptographic algorithms, the RLWE-KEX is provably reducible to a known hard problem in lattices.","alt_names":[],"name":"Ring learning with errors key exchange","categories":["All articles needing expert attention","All articles that are too technical","Articles needing expert attention from June 2015","CS1 errors: external links","Cryptographic algorithms","Wikipedia articles that are too technical from June 2015"],"tag_line":"In cryptography, a public key exchange is a cryptographic algorithm which allows two parties to create and share a secret key which they use to encrypt messages between themselves."}}
,{"_index":"throwtable","_type":"algorithm","_id":"scrypt","_score":0,"_source":{"description":"In cryptography, scrypt is a password-based key derivation function created by Colin Percival, originally for the Tarsnap online backup service. The algorithm was specifically designed to make it costly to perform large-scale custom hardware attacks by requiring large amounts of memory. In 2012, the scrypt algorithm was published by IETF as an Internet Draft, intended to become an informational RFC. A simplified version of scrypt is used as a proof-of-work scheme by a number of cryptocurrencies first implemented by an anonymous programmer called ArtForz in Tenebrix followed by Fairbrix and Litecoin soon.","alt_names":[],"name":"Scrypt","categories":["Cryptographic algorithms","Key derivation functions"],"tag_line":"In cryptography, scrypt is a password-based key derivation function created by Colin Percival, originally for the Tarsnap online backup service."}}
,{"_index":"throwtable","_type":"algorithm","_id":"shor's-algorithm","_score":0,"_source":{"description":"Shor's algorithm, named after mathematician Peter Shor, is a quantum algorithm (an algorithm that runs on a quantum computer) for integer factorization formulated in 1994. Informally it solves the following problem: given an integer N, find its prime factors.\nOn a quantum computer, to factor an integer N, Shor's algorithm runs in polynomial time (the time taken is polynomial in log N, which is the size of the input). Specifically it takes quantum gates of order O((log N)2(log log N)(log log log N)) using fast multiplication, demonstrating that the integer factorization problem can be efficiently solved on a quantum computer and is thus in the complexity class BQP. This is substantially faster than the most efficient known classical factoring algorithm, the general number field sieve, which works in sub-exponential time — about O(e1.9 (log N)1/3 (log log N)2/3). The efficiency of Shor's algorithm is due to the efficiency of the quantum Fourier transform, and modular exponentiation by repeated squarings.\nIf a quantum computer with a sufficient number of qubits could operate without succumbing to noise and other quantum decoherence phenomena, Shor's algorithm could be used to break public-key cryptography schemes such as the widely used RSA scheme. RSA is based on the assumption that factoring large numbers is computationally intractable. So far as is known, this assumption is valid for classical (non-quantum) computers; no classical algorithm is known that can factor in polynomial time. However, Shor's algorithm shows that factoring is efficient on an ideal quantum computer, so it may be feasible to defeat RSA by constructing a large quantum computer. It was also a powerful motivator for the design and construction of quantum computers and for the study of new quantum computer algorithms. It has also facilitated research on new cryptosystems that are secure from quantum computers, collectively called post-quantum cryptography.\nIn 2001, Shor's algorithm was demonstrated by a group at IBM, who factored 15 into 3 × 5, using an NMR implementation of a quantum computer with 7 qubits. After IBM's implementation, two independent groups, one at the University of Science and Technology of China, and the other one at the University of Queensland, have implemented Shor's algorithm using photonic qubits, emphasizing that multi-qubit entanglement was observed when running the Shor's algorithm circuits. In 2012, the factorization of 15 was repeated. Also in 2012, the factorization of 21 was achieved, setting the record for the largest number factored with a quantum computer. In April 2012, the factorization of 143 was achieved, although this used adiabatic quantum computation rather than Shor's algorithm. It was discovered in November 2014 that this adiabatic quantum computation in 2012 had in fact also factored larger numbers, the largest being 56153, which is currently the record for the largest integer factored on a quantum device.\n\n","alt_names":["integer factorization algorithm","achievable task","Shor's algorithm - Wikipedia, the free encyclopedia","Shor-Algorithmus","Shor's algorithm","http://en.wikipedia.org/wiki/Shor's_algorithm","Shor's Algorithm","-> Read the article about 'Shor's algorithm'","...Wikipedia Algorithme de Shor","...Wikipedia Algoritmo de Shor","...Wikipedia Algorytm faktoryzacji Shora","...mehr auf Wikipedia über Shor-Algorithmus","...more on Wikipedia about Shor's algorithm","1.1 Classical part","1.2 Quantum part: Period-finding subroutine:","2 Explanation of the algorithm","2.1 I. Obtaining factors from period","2.2 II. Finding the period","27s_algorithm% http://en.wikipedia.org/wiki/Shor","3 Modifications to Shor's Algorithm","8d88d9f17e4fb8c5e1e98c5a4a00a5 ...","About algorithm of Shora.","Algorisme de Shor","Algorithme de Shor","Algorithme de Shor - Wikip?dia","Algorithme de Shor - Wikipédia","Algorithmus von Shor","Algoritma Shora","Algoritmo de Shor","Algoritmo de Shor - Wikipedia, la enciclopedia libre","Algoritmo di Shor","Algoritmo di fattorizzazione di Shor","Algoritmo di fattorizzazione di Shor - Wikipedia","Algoritmo_de_Shor","Algorytm Shora","Algorytm faktoryzacji Shora â�“ Wikipedia, wolna encyklopedia","Algorytm faktoryzacji Shora – Wikipedia, wolna encyklopedia","Algorytmu Shora","Also, hello","Faktorierung","Für eine Zahl n benötigt man einen Quantencomputer","How to do Shors algorithm","How to: use a quantum computer to break","IBM and others","Mermin quantum computer science","O ( e ( log N ) 1 / 3 ( log log","PETER SHOR","Peter Shor's Quantum Factoring Algorithm","Primzahlfaktorisierung","Quantum Fctorization","Quantum computers can use Shor's algorithm","Schor algoritmusát","Schor's 1994 Quantum Factoring Algorithm","Schor's groundbreaking quantum algorithm for integer factorization","Shor Algorithm","Shor Algorithmus","Shor S Algorithm Wikipedia The Free Encyclopedia","Shor algorithm","Shor algorithm Wikipedia the free encyclopedia","Shor algrím","Shor s algorithm - Wikipedia, the free encyclopedia","Shor s algorithm Wikipedia the free encyclopedia","Shor s algorithm Wikipedia the free encyclopedia - result","Shor%27s_algorithm","Shor&#39;s algorythm","Shor's","Shor's Algorithm - Wikipedia, The Free Encyclopedia","Shor's Algorithm,","Shor's Alorithm","Shor's Quantum Algorithm for integer factorization","Shor's Quantum Factorization Algorithm","Shor's algorithm - Wikipedia :: The free encyclopedia","Shor's algorithm - Wikipedia, the free ...","Shor's algorithm - Wikipedia, the...","Shor's algorithm at Wikipedia","Shor's algorithm for quantum factorization","Shor's algorithm is a quantum algorithm (instructions for","Shor's algorithm on Wikipedia","Shor's algorithm while working at ATT Bell Labs","Shor's algorithm →","Shor's algorithm, an algorithm for factoring numbers, which","Shor's algorithm.","Shor's algoritme","Shor's algorythm","Shor's alogorithm","Shor's factoring algorighm","Shor's factoring algorithm","Shor's factorization","Shor's factorization algorithm","Shor's quantum algorithm","Shor's quantum factoring algorithm","Shor's_algorithm","Shor'scher Algorithmus","Shor-Algorithmus Wikipedia","Shor-Algorithmus – Wikipedia","Shor-algorithm","Shor-algoritmus","Shor`s algorithm","Shorin algoritmi","Shorov algoritam","Shorov algoritem","Shorovim algoritmom","Shors Algorithmus","Shors algorithm","Shors algoritme","Shorův algoritmus","Shor算法","Time Running Out for Public Key Encryption","Tkole se razbija število na faktorje.","Wiki: Shor's algorithm","Wikipedia Algoritmo de Shor","Wikipedia article Algorithme de Shor","Wikipedia article Shor's Algorithm","Wikipedia article Shor's algorithm","Wikipedia article Shors algorithm","Wikipedia article Алгоритм Шора","Wikipedia l'articolo Algoritmo di fattorizzazione di Shor","Wikipedia's page on Shor's Algorithm","Wikipedia-Artikel Shor'scher Algorithmus","Wikipedia-Artikel Shor-Algorithmus","Wikipedia-Seite zu 'Shor-Algorithmus'","a quantum computer could factor large numbers in","a r ≡ 1 ( mod N )","affinant des probabilités","algorisme quàntic","algorithme de Shor","algorithme de Shor (lien externe vers Wikipedia)","algorithmes quantiques","algoritm Shora","algoritme de Shor","algoritmo cuántico de factorización de Peter Shor","algoritmo de Peter Shor","algoritmo de Shor","algoritmo de factorización de Shor","algoritmo di Shor","algoritmo di fattorizzazione di Shor","algoritmo quantistico di fattorizzazione","algoritmus Shorův","algortimo de Shor","algorytm Shora","algorytm Shora jest","algorytm faktoryzacji Shora","algorytmu Shora","artículo de Wikipedia Algoritmo de Shor","ca:Algorisme de Shor","can factor large numbers in polynomial time","drastically increase","e371401fb0c1eec459fffa44f1c1e2 ...","efektívny rozklad na prvočísla","el algoritmo de Shor","en.wikipedia.org/...Shor%27s_algorithm","en.wikipedia.org/wiki/Shor%27s_algorithm","en.wikipedia.org/wiki/Shor's_algorithm","en.wikipedia.org/wiki/Shor's_algorithm#Quantum_part:_Period","en:Shor's algorithm","es.wikipedia.org/wiki/Algoritmo_de_Shor","factor large integers","factor large numbers using a quantum computer","factoralization","factoring integers very quickly","factorisation becomes as easy as multiplying two numbers","factorizaciones","factorization of huge numbers","fi:Shorin algoritmi","he:אלגוריתם שור","http//de.wikipedia.org/wiki/Shor-Algorithmus","http://ca.wikipedia.org/wiki/Algorisme_de_Shor","http://de.wikipedia.org/wiki/Sh or-Algorithmus","http://de.wikipedia.org/wiki/Shor-Algori","http://de.wikipedia.org/wiki/Shor-Algorithmus","http://de.wikipedia.org/wiki/Shor-Algori…","http://en.wikipedia.org/wiki/Shor% 27s_algorithm","http://en.wikipedia.org/wiki/Shor%27s_Algorithm","http://en.wikipedia.org/wiki/Shor%27s_al...","http://en.wikipedia.org/wiki/Shor%27s_algorithm","http://en.wikipedia.org/wiki/Shor%27s_algorithm#How_does_Shor","http://en.wikipedia.org/wiki/Shor%27s_algorithm#I","http://en.wikipedia.org/wiki/Shor%27s_algorithm#II","http://en.wikipedia.org/wiki/Shor%27s_algorithm#Quantum_part","http://en.wikipedia.org/wiki/Shor%27s_al…","http://en.wikipedia.org/wiki/Shor's_Algorithm","http://en.wikipedia.org/wiki/Shor's_algorithm.","http://en.wikipedia.org/wiki/Shor's_algorithm. . .","http://en.wikipedia.org/wiki/Shor's_algo…","http://en.wikipedia.org/wiki/Shor_algorithm","http://en.wikipedia.org/wiki/Shors_algorithm","http://es.wikipedia.org/wiki/Algoritmo_de_Shor","http://fr.wikipedia....orithme_de_Shor","http://fr.wikipedia.org/wiki/Algorithme_de_Shor","http://fr.wikipedia.org/wiki/Algorithme_de_shor","http://it.wikipedia.org/wiki/Algoritmo_ ... ne_di_Shor","http://it.wikipedia.org/wiki/Algoritmo_di_fattorizzazione_di_Shor","http://lt.wikipedia.org/wiki/%C5%A0oro_algoritmas","http://pl.wikipedia.org/wiki/A(...)m_Shora","http://pl.wikipedia.org/wiki/Algorytm_f ... acji_Shora","http://pl.wikipedia.org/wiki/Algorytm_faktoryzacji_Shora","http://pl.wikipedia.org/wiki/Algorytm_faktoryzacj…","http://ru.wikipedia.org/wiki/Алгоритм_Шо...","http://ru.wikipedia.org/wiki/Алгоритм_Шора","http://zh.wikipedia.org/zh/秀爾演算法","it:Algoritmo di fattorizzazione di Shor","kvantni algoritam za efikasno razbijanje RSA","kwantowy algorytm faktoryzacji","l'algorithme de Shor","l'algorithme de Shor utilisant les calculateurs quantiques","l'algorithme quantique existe déjà...[4]","l'algoritmo di Shor","l'algoritmo di fattorizzazione di Shor","less traditional methods","m) Shor`s algorithm","minare la robustezza degli algoritmi a chiave pubblica","ontbinden van getallen in priemfactoren","paper by Peter Shor","penses à quelque chose de particulier?","polinomiális időben tudnák törni","previously unbreakable encryption","primer algoritmo","prodigious feats","quantum algorithm that can factor large integers in","quantum computers become a reality","quantum factoring","recht flott","render current RSA cryptography obsolete","render today's best encryption essentially useless","shor's algorithm","someone came up with a clever way","test de Shor","the factors of 15","thuật toán lừng danh","un sabor del algoritmo de Shor","undermine the strength of public key algorithms","using an algorithm developed by Peter Shor at","using quantum methods","whole solution","wikipedia - algorithme de shor","wikipedia:en:Shor's_algorithm","zh:秀爾演算法","összetett számok prímtényezős felbontására való kvantumszámítógépes algoritmus","Šoro algoritmas","Šoro algoritmas – Vikipedija","Алгоритм Шора","Алгоритм Шора — Википедия","Алгоритма Шора","Википедии статью Алгоритм Шора","Еще тынц","Об алгоритме Шора.","Статья про алгоритм Шора в Википедии","Цитата Shor's algorithm was demonstrated in 2001 by","Шора","Я не програмёр.","алгоритм Шора","алгоритм разложения больших чисел на множители","алгоритм факторизации Шора","алгоритма Шора","алгоритму Шора","алгоритмы Шора","отдавна известни алгоритми","אלגוריתם שור","אלגוריתם שור – ויקיפדיה","ויקיפדיה - 'אלגוריתם שור'","الگوریتم Shor","الگوریتم شور","خوارزمية شوور","خوارزمية شوور - ويكيبيديا، الموسوعة الحرة","有名なアルゴリズム","秀爾演算法","绍尔","量子大数分解算法","量子質因數分解演算法","量子质因子分解算法","쇼어 알고리즘","쇼어의 알고리즘","위키 피 디아 문서 쇼어 알고리즘"],"name":"Shor's algorithm","categories":["All articles lacking in-text citations","All articles needing expert attention","All articles that are too technical","Articles containing proofs","Articles lacking in-text citations from September 2010","Articles needing expert attention from February 2014","Integer factorization algorithms","Post-quantum cryptography","Quantum algorithms","Quantum information science","Wikipedia articles that are too technical from February 2014"],"tag_line":"Shor's algorithm, named after mathematician Peter Shor, is a quantum algorithm (an algorithm that runs on a quantum computer) for integer factorization formulated in 1994."}}
,{"_index":"throwtable","_type":"algorithm","_id":"general-number-field-sieve","_score":0,"_source":{"description":"In number theory, the general number field sieve (GNFS) is the most efficient classical algorithm known for factoring integers larger than 100 digits. Heuristically, its complexity for factoring an integer n (consisting of  bits) is of the form\n\n(in L-notation), where ln is the natural logarithm. It is a generalization of the special number field sieve: while the latter can only factor numbers of a certain special form, the general number field sieve can factor any number apart from prime powers (which are trivial to factor by taking roots). When the term number field sieve (NFS) is used without qualification, it refers to the general number field sieve.\nThe principle of the number field sieve (both special and general) can be understood as an improvement to the simpler rational sieve or quadratic sieve. When using such algorithms to factor a large number n, it is necessary to search for smooth numbers (i.e. numbers with small prime factors) of order n1/2. The size of these values is exponential in the size of n (see below). The general number field sieve, on the other hand, manages to search for smooth numbers that are subexponential in the size of n. Since these numbers are smaller, they are more likely to be smooth than the numbers inspected in previous algorithms. This is the key to the efficiency of the number field sieve. In order to achieve this speed-up, the number field sieve has to perform computations and factorizations in number fields. This results in many rather complicated aspects of the algorithm, as compared to the simpler rational sieve.\nNote that log2 n is the number of bits in the binary representation of n, that is the size of the input to the algorithm, so any element of the order nc for a constant c is exponential in log n. The running time of the number field sieve is super-polynomial but sub-exponential in the size of the input.","alt_names":["GNFS","- General number field sieve :","- Number field sieve :","-> Read the article about 'General number field sieve","...mehr auf Wikipedia über Zahlkörpersieb","...more on Wikipedia about General number field sieve","1 Number fields","3 Improving polynomial choice","39461f4f001c50b5e58bbf0bc21d85 ...","5fc8238cc0765b74d96d3402dc88c5 ...","867d160f9127609f7ccef2395a2c ...","Algemene Number Field Sieve","Crivello dei campi di numeri generale","GNFS (General Number Field Sieve)","GNFS (general number field sieve)","GNFS – Wikipedia, wolna encyklopedia","GNFS(一般数体篩法)","Garbell sobre el cos de nombres generalitzat - Viquipèdia","General Number Field Sieve","General Number Field Sieve (GNFS, Zahlkörpersieb)","General Number Field Sieve - Wikipedia article","General Number Field Sieve - Wikipedia, The Free Encyclopedia","General Number Field sieve","General field number sieve","General number field sieve","General number field sieve (Factor numbers in super","General number field sieve - Wikipedia, the free encyclopedia","General_number_field_sieve","Generalized Number Field Sieve","Getallenlichamenzeef","Gittersieb","I need prime factors and fast!","Improving polynomial choice","Like this wiki article","Look for Pl:GNFS","NFS (number field sieve)","Number Field Sieve","Number Field Sieve (NFS)","Number field sieve","Number field sieve (NFS)","Number-Field Sieve","Number_Field_Sieve","Numero Generale di Sieve","Número de campo del tamiz","O e ( c + o ( 1 ) ) ( log n ) 1","Ogólnego sita ciała liczbowego","Pole Liczba ogólna Sieve","Read More general number field sieve wikipedia the","What is method of General Number Field Sieve","What is method of Sieving with large primes","Wikipedia article General Number Field Sieve","Wikipedia article General number field sieve","Wikipedia article Number Field Sieve","Wikipedia article on Number Field Sieve","Wikipedia article נפת שדה מספרים","Wikipedia-Artikel Gittersieb","Wikipedia-Artikel Zahlkörpersieb","Wikipedia-GNFS","Wikipedia-Seite zu 'Zahlkörpersieb'","Wikipedia-Zahlkörpersieb","Yleinen lukukuntaseula","Yleinen lukukuntaseula – Wikipedia","Zahlenfeldsieb","Zahlenkörpersieb","Zahlkoerpersieb","Zahlkörpersieb","Zahlkörpersieb in","Zahlkörpersieb – Wikipedia","Zahlkörpersiebs","a635d9f09b4fab22ebdf8f2643613 ...","algemene Number Field Sieve","almindelige nummer feltet si","best algorithms that we have","best classical algorithm","better methods","ca:Garbell sobre el cos de nombres generalitzat","campo número da peneira","campo peneira número","campo per il numero setaccio","champ de numéro de tamis","champ du numéro de tamis","classical factoring algorithm","crible algébrique généralisé","crible algébrique nombre","crible général de corps de nombres (GNFS)","crible général des corps","crible général des corps de nombres","crible sur le corps des nombres généralisés","crivello dei campi di numeri","de.wikipedia.org/wiki/Zahlk%C3%B6rpersieb","e general","en.wikipedia.org/wiki/Number_field_sieve","en.wikipedia.org/wiki/Number_field_sieve Information provided by","en:General number field sieve","en:Number field sieve","f) General number field sieve","fastest known factoring algorithm","fce2a243868a728734ca1d4828e8da ...","fi:Yleinen lukukuntaseula","general field sieve","general number field sieve","general number field sieve algorithm","general-purpose factoring","generale setaccio campo numero","getallenlichamenzeef","he:נפת שדה מספרים","het aantal veld zeef","http://de.wikipedia.org/wiki/Gittersieb","http://de.wikipedia.org/wiki/Zahlk%C3%B6rpersieb","http://en.wikipedi &hellip; _field_sieve","http://en.wikipedi … _field_sieve","http://en.wikipedia....ber_Field_Sieve","http://en.wikipedia....ber_field_sieve","http://en.wikipedia.org/wiki/General number field","http://en.wikipedia.org/wiki/General_Number_Field_Sieve","http://en.wikipedia.org/wiki/General_num","http://en.wikipedia.org/wiki/General_number_field_si","http://en.wikipedia.org/wiki/General_number_field_sieve","http://en.wikipedia.org/wiki/General_num…","http://en.wikipedia.org/wiki/Number_Field_Sieve","http://en.wikipedia.org/wiki/Number_field_sieve","http://fr.wikipedia.org/wiki/Algorit...res_généralisé","http://fr.wikipedia.org/wiki/Algorithme ... alis%C3","http://fr.wikipedia.org/wiki/Algorithme_de_factorisation_par_crible_sur_les_corps_de_nombres_g%C3%A9n","http://fr.wikipedia.org/wiki/Crible_g%C3%A9n","http://it.wikipedia.org/wiki/Crivello_dei_campi_di_numeri_generale","http://nl.wikipedia.org/wiki/Getallenlichamenzeef","http://pl.wikipedia.org/wiki/GNFS","it:Crivello dei campi di numeri generale","j) Zahlkörpersieb","l'algorithme de factorisation par crible sur les","l'article de Wikipédia Algorithme de factorisation par","lapangan nomor saringan","lĩnh vực số Sàng","nl:Getallenlichamenzeef","number field sieve","number sieve","numer pola sita","numero setaccio campo","nummer veld zeef","obecný číselné polní síto","ogólnego sito polu numeru","peneira campo de número","peneira número do campo","pl:GNFS","setaccio campo del numero","setaccio campo numero","setaccio numero di campo","sito polu numeru","special number field sieve method","speciale getallenlichamenzeef","tamis champ de numéro","tamis champ du numéro","tamiz de campo de número","tamiz general de campo numérico","the general number field sieve","the number field sieve","thereabout","våra bästa algoritmer för faktorisering","wiki/GNFS","wikipedia sobre GNFS.","číselné polní síto","Генеральный поле Номер сито","Число сито поле","общего решета числового поля","поле Номер сито","поле сито номер","сите номер области","числа сито поле","числовое поле сито","אלגוריתם נפת שדה המספרים","אלגוריתמים מתוחכמים","ויקיפדיה - 'נפת שדה מספרים'","נפת שדה המספרים","נפת שדה מספרים","נפת שדה מספרים – ויקיפדיה","सामान्य संख्या फील्ड छलनी","กระชอน ช่อง หมายเลข","一般数体篩","一般数域筛","数体ふるい","数体篩","数値フィールドのふるい","数域筛","數域篩","普通数域筛选法","普通数域筛选法- 维基百科，自由的百科全书","最良のアルゴリズム","番号のフィールドのふるい","番号フィールドはふるい","目前最好的算法","維基百科的文章“ 普通数域筛选法”","번호 필드 쪽에서"],"name":"General number field sieve","categories":["Integer factorization algorithms"],"tag_line":"In number theory, the general number field sieve (GNFS) is the most efficient classical algorithm known for factoring integers larger than 100 digits."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rsa-factoring-challenge","_score":0,"_source":{"description":"The RSA Factoring Challenge was a challenge put forward by RSA Laboratories on March 18, 1991 to encourage research into computational number theory and the practical difficulty of factoring large integers and cracking RSA keys used in cryptography. They published a list of semiprimes (numbers with exactly two prime factors) known as the RSA numbers, with a cash prize for the successful factorization of some of them. The smallest of them, a 100 decimal digit number called RSA-100 was factored by April 1, 1991, but many of the bigger numbers have still not been factored and are expected to remain unfactored for quite some time, however advances in quantum computers make this prediction uncertain due to Shor's algorithm.\nThe RSA challenges ended in 2007. RSA Laboratories stated: \"Now that the industry has a considerably more advanced understanding of the cryptanalytic strength of common symmetric-key and public-key algorithms, these challenges are no longer active.\"\nThe factoring challenge was intended to track the cutting edge in integer factorization. A primary application is for choosing the key length of the RSA public-key encryption scheme. Progress in this challenge should give an insight into which key sizes are still safe and for how long. As RSA Laboratories is a provider of RSA-based products, the challenge was used by them as an incentive for the academic community to attack the core of their solutions — in order to prove its strength.\nThe RSA numbers were generated on a computer with no network connection of any kind. The computer's hard drive was subsequently destroyed so that no record would exist, anywhere, of the solution to the factoring challenge.\nThe first RSA numbers generated, RSA-100 to RSA-500 and RSA-617, were labeled according to their number of decimal digits; the other RSA numbers (beginning with RSA-576) were generated later and labelled according to their number of binary digits.","alt_names":["RSA Factoring Challenge","- RSA Factoring Challenge :","-> Leggi tutto l'articolo su 'RSA Factoring Challenge","...Wikipedia Compétition de factorisation RSA","...more on Wikipedia about RSA Factoring Challenge","100000$","21.05.07","50 000 dollars","660 битов","829 bits",">> Sito Wikipedia <<","Actualité des nombres RSA factorisés par les informaticiens","Competició de la factorització RSA","Competición de factorización RSA","Competición de factorización RSA - Wikipedia, la enciclopedia libre","Competición_de_factorización_RSA","Compétition de factorisation RSA","Compétition de factorisation RSA - Wikipédia","Definición de Competición de factorización RSA más completo","It would take massive amounts of computational power","Now that the industry has a considerably more","RSA Challenge","RSA Factoring Challenge - Wikipedia","RSA Factoring Challenge - Wikipedia, the free encyclopedia","RSA Factoring Challenge - Wikipedia, the free encyclopedia ...","RSA Factoring Challenge ? Wikipedia","RSA Factoring Challenge Wikipedia the free encyclopedia","RSA Factoring Challenge page on Wikipedia","RSA Factoring Challenge – Wikipedia","RSA Factoring Challenges","RSA challenge","RSA factoring algorithms","RSA factoring challenge","RSA þáttunarkeppnin","RSA-576 - Wikipedia","RSA2048 challenge","RSA_Factoring_Challenge","Sfida RSA per la fattorizzazione","The RSA Factoring Challenge","The prizes and records","Wiki competencia RSA","Wikipedia article RSA Challenge","Wikipedia article RSA Factoring Challenge","Wikipedia article RSA factoring challenge","Wikipedia article about RSA Factoring Challenge","Wikipedia article on the RSA Challenge","Wikipedia entry for RSA Factoring Challenge","Wikipedia on RSA Factoring Challenge","Wikipedia sur Compétition de factorisation RSA","Wikipedia's RSA Factoring Challenge","Wikipedia-Artikel RSA Factoring Challenge","Wikipedia-Artikel RSA-576","Wikipedia-Artikel RSA-640","Wikipedia-Seite zu 'RSA Factoring Challenge'","artículo de Wikipedia Competición de factorización RSA","competencias de factorización RSA","competiciones de factorización","competiciones para resolver cifrados RSA","competició de factorització RSA","competición de factorización RSA","compétition de factorisation","de:RSA Factoring Challenge","de:RSA-576","decrypt RSA messages","desafio RSA","desafío RSA","en.wikipedia.org/...RSA_Factoring_Challenge","en.wikipedia.org/wiki/RSA_Factoring_Challenge","en:RSA Factoring Challenge","es:Competición de factorización RSA","factoring attack","factorisation des clefs RSA","factorizar una clave RSA de 1024 bits","fr:Compétition de factorisation RSA","have been broken","http://de.wikipedia.org/wiki/RSA-576","http://de.wikipedia.org/wiki/RSA_... _Challenge","http://de.wikipedia.org/wiki/RSA_Factori","http://de.wikipedia.org/wiki/RSA_Factoring_Challenge","http://en.wikipedi &hellip; SA_Challenge","http://en.wikipedi … SA_Challenge","http://en.wikipedia....oring_Challenge","http://en.wikipedia.org/wiki/RSA_Challenge","http://en.wikipedia.org/wiki/RSA_Fac...es_and_records","http://en.wikipedia.org/wiki/RSA_Fact...","http://en.wikipedia.org/wiki/RSA_Factor...","http://en.wikipedia.org/wiki/RSA_Factori","http://en.wikipedia.org/wiki/RSA_Factoring_Ch...","http://en.wikipedia.org/wiki/RSA_Factoring_Challenge","http://en.wikipedia.org/wiki/RSA_Factoring_Challenge#The_prizes_and_records","http://en.wikipedia.org/wiki/RSA_Factori…","http://en.wikipedia.org/wiki/RSA_factoring_challenge","http://es.wikipedia.org/wiki/Competici%C3%B3n_de_factorizaci","http://es.wikipedia.org/wiki/Competici%C…","http://fr.wikipedia.org/wiki/Comp%C3%A9tition_de_factorisation_RSA","http://it.wikipedia.org/wiki/RSA_Fa...nnotazioni","http://it.wikipedia.org/wiki/RSA_Factori...http://it","http://it.wikipedia.org/wiki/RSA_Factori...nnotazioni","http://it.wikipedia.org/wiki/RSA_Factoring_Challenge","http://pl.wikipedia.org/wiki/RSA_Factoring_Challenge","is 768 bits","it:RSA Factoring Challenge","largest known RSA key factored to date is","lista de desafios da RSA já desativada.","pl.wikipedia.org/wiki/RSA_Factoring_Challenge","pl:RSA Factoring Challenge","prévu pour 2012","the RSA Challenge numbers","una sfida","w:RSA Factoring Challenge","таблицу составить","知p,q"],"name":"RSA Factoring Challenge","categories":["1991 establishments in the United States","2007 disestablishments","Cryptography contests","Integer factorization algorithms","RSA Factoring Challenge"],"tag_line":"The RSA Factoring Challenge was a challenge put forward by RSA Laboratories on March 18, 1991 to encourage research into computational number theory and the practical difficulty of factoring large integers and cracking RSA keys used in cryptography."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lenstra-elliptic-curve-factorization","_score":0,"_source":{"description":"The Lenstra elliptic curve factorization or the elliptic curve factorization method (ECM) is a fast, sub-exponential running time algorithm for integer factorization which employs elliptic curves. For general purpose factoring, ECM is the third-fastest known factoring method. The second fastest is the multiple polynomial quadratic sieve and the fastest is the general number field sieve. The Lenstra elliptic curve factorization is named after Hendrik Lenstra.\nPractically speaking, ECM is considered a special purpose factoring algorithm as it is most suitable for finding small factors. Currently, it is still the best algorithm for divisors not greatly exceeding 20 to 25 digits (64 to 83 bits or so), as its running time is dominated by the size of the smallest factor p rather than by the size of the number n to be factored. Frequently, ECM is used to remove small factors from a very large integer with many factors; if the remaining integer is still composite, then it has only large factors and is factored using general purpose techniques. The largest factor found using ECM so far has 83 digits and was discovered on 7 September 2013 by R. Propper. Increasing the number of curves tested improves the chances of finding a factor, but they are not linear with the increase in the number of digits.","alt_names":["- Elliptic curve method :","-> Read the article about 'Lenstra elliptic curve factorization","...more on Wikipedia about Lenstra elliptic curve factorization","13a1126e6d5ed1d4c1bc8937f4b2c ...","Algoritme van Lenstra","Elliptic Curve Factorization","Elliptic Curve Method","Elliptic Curve Method (ECM)","Elliptic curve factorisation","Elliptic curve factorization","Elliptic curve method","Elliptic curve method (ECM)","Elliptische-Kurven-Methode","Factorisation en courbe elliptique de Lenstra","Frequently, ECM is used to remove small factors","Learn about Lenstra elliptic curve factorization>>>","Lenstra Elliptic Curve Factorization - Wikipedia, The Free Encyclopedia","Lenstra algorithm","Lenstra elliptic curve","Lenstra elliptic curve factorizati the free ...","Lenstra elliptic curve factorization","Lenstra elliptic curve factorization - Wikipedia ...","Lenstra elliptic curve factorization - Wikipedia, the free","Lenstra elliptic curve factorization - Wikipedia, the free ...","Lenstra elliptic curve factorization - Wikipedia, the free ... ...","Lenstra elliptic curve factorization - Wikipedia, the free encyclopedia","Lenstra elliptic curve factorization Wikipedia the free","Lenstra elliptic curve factorization method","Lenstra je elliptic křivka faktorizaci","Lenstra krzywej eliptycznej faktoryzacji","Lenstra's Elliptic Curve Factorization","Lenstra's elliptic curve algorithm","Lenstra's elliptic curve factorization","Lenstras elliptischen Kurve Faktorisierung","Lenstra的椭圆分解法","The elliptic curve method","Why does the algorithm work?","Wikipedia article Elliptic curve factorization","Wikipedia article Elliptic curve method","Wikipedia article Lenstra elliptic curve factorization","Wikipedia article on Elliptic curve factorization","Wikipedia article on Elliptic curve method","Wikipedia artikel Algoritme van Lenstra","Wikipedia entry for Lenstra elliptic curve factorization","a curva elíptica fatoração Lenstra","a53bbe377495d6d43fc56a111282c ...","algorithme de factorisation de","curvas elípticas de Lenstra","de elliptische kromme factorisatie Lenstra","der elliptischen Kurve Faktorisierung Lenstra","elliptic curve factorisation","elliptic curve factorization","elliptic curve method","elliptic curves in factorization","elliptikus görbékre alapuló faktorizációt","elliptische kromme Lenstra's factorisatie","en.wikipedia.org/wiki/Lenstra_elliptic_curve_factorization","en:Lenstra elliptic curve factorization","factorisation en courbe elliptique de Lenstra","factorización de la curva elíptica","fr:Factorisation en courbe elliptique de Lenstra","g) Lenstra elliptical curves factorizing","http://en.wikipedia.org/wiki/Elliptic curve factorization","http://en.wikipedia.org/wiki/Elliptic_curve_factorization","http://en.wikipedia.org/wiki/Elliptic_curve_method","http://en.wikipedia.org/wiki/Lenstra..._factorization","http://en.wikipedia.org/wiki/Lenstra_...rve_factorization","http://en.wikipedia.org/wiki/Lenstra_ell","http://en.wikipedia.org/wiki/Lenstra_elliptic...","http://en.wikipedia.org/wiki/Lenstra_elliptic_curve_factoriz[..]","http://en.wikipedia.org/wiki/Lenstra_elliptic_curve_factorization","http://en.wikipedia.org/wiki/Lenstra_elliptic_curve_factorization]","http://fr.wikipedia.org/wiki/Factori...que_de_Lenstra","http://fr.wikipedia.org/wiki/Factorisation_en_courbe_elliptique_de_Lenstra","http://nl.wikipedia.org/wiki/Algoritme_van_Lenstra","k) Lenstra elliptic curve algorithm","krzywej eliptycznej Lenstra faktoryzacji's","l'Lenstra courbe elliptique factorisation","la courbe elliptique factorisation de Lenstra","la curva ellittica di fattorizzazione di Lenstra","la curva ellittica fattorizzazione Lenstra","la curva elíptica de factorización Lenstra","la fattorizzazione curva ellittica Lenstra","lenstra elliptic curve factorization","llamado Elliptic Curve Method (ECM)","metodo delle curve ellittiche","méthode ECM","nl:Algoritme van Lenstra","něco z toho je popsáno ve Wikině","o Lenstra fatoração curva elíptica","one method of integer factorization","quello di Lenstra","rozkładu liczb złożonych na czynniki pierwsze","ru:Факторизация Ленстры с помощью эллиптических кривых","ru:Факторизация с помощью эллиптических кривых","tekijöihinjaossa","three (asymptotically) fastest factorization algorithms","кривой факторизации Ленстра эллиптических's","эллиптическая Ленстра факторизации кривой","эллиптической кривой факторизации Ленстра","レンストラの楕円曲線の分解を","椭圆曲线分解Lenstra","椭圆曲线的因子分解Lenstra","楕円曲線の因子分解Lenstra","楕円曲線分解レンストラ","研究椭圆曲线分解","𝐙 / n 𝐙"],"name":"Lenstra elliptic curve factorization","categories":["All articles containing potentially dated statements","Articles containing potentially dated statements from 2006","Finite fields","Integer factorization algorithms"],"tag_line":"The Lenstra elliptic curve factorization or the elliptic curve factorization method (ECM) is a fast, sub-exponential running time algorithm for integer factorization which employs elliptic curves."}}
,{"_index":"throwtable","_type":"algorithm","_id":"baton","_score":0,"_source":{"description":"BATON is a Type 1 block cipher in use since at least 1995 by the United States government to secure classified information.\nWhile the BATON algorithm itself is secret (as is the case with all algorithms in the NSA's Suite A), the public PKCS#11 standard includes some general information about how it is used. It has a 320-bit key and uses a 128-bit block in most modes, and also supports a 96-bit electronic codebook mode. 160 bits of the key are checksum material. It supports a \"shuffle\" mode of operation, like the NSA cipher JUNIPER. It may use up to 192 bits as an initialization vector, regardless of the block size.\nIn response to a Senate question about encrypted video links, NSA said that BATON could be used for encryption at speeds higher than those possible with Skipjack.\n^ PKCS #11 spec\n^ Senate Subcommittee on Technology and the Law: Hearing on the Administration's Key Escrow Encryption Standard","alt_names":["BATON","- BATON :","...more on Wikipedia about BATON","BATON - Wikipedia","BATON - Wikipedia, the free encyclopedia","BATON; it is used under the","Check BATON in Wikipedia","Learn about BATON>>>","Wikipedia article BATON","Wikipedia article about BATON","Wikipedia article on BATON","Wikipedia l'articolo BATON","article BATON","baton here","en.wikipedia.org/wiki/BATON","http://en.wikipedia.org/wiki/BATON","http://it.wikipedia.org/wiki/BATON","it:BATON","yago-res:BATON"],"name":"BATON","categories":["All stub articles","Block ciphers","Cryptography stubs","Type 1 encryption algorithms"],"tag_line":"BATON is a Type 1 block cipher in use since at least 1995 by the United States government to secure classified information."}}
,{"_index":"throwtable","_type":"algorithm","_id":"nsa-cryptography","_score":0,"_source":{"description":"The vast majority of the National Security Agency's work on encryption is classified, but from time to time NSA participates in standards processes or otherwise publishes information about its cryptographic algorithms. The NSA has categorized encryption items into four product types, and algorithms into two suites. The following is a brief and incomplete summary of public knowledge about NSA algorithms and protocols.","alt_names":["Suite A algorithms","- NSA cryptography :","-> Read more about NSA cryptography","-> Read the article about 'NSA cryptography'","...more on Wikipedia about NSA encryption algorithms","Algorithm Suites","NSA Cryptography","NSA Cryptography (examples of all types of encryption","NSA cryptographic algorithms","NSA cryptography","NSA cryptography -","NSA cryptography - Wikipedia, the free encyclopedi...","NSA cryptography - Wikipedia, the free encyclopedia","NSA cryptography; it is used under the","NSA encryption algorithms","NSA encryption algorithms - Wikipedia, the free encyclopedia","Type 2 Product","Type 3 Product","Type 4 Product","Wikipedia article NSA Cryptography","Wikipedia article NSA cryptography","Wikipedia article NSA encryption algorithms","Wikipedia article on NSA cryptography","Wikipedia entry for NSA cryptography","en.wikipedia.org/wiki/NS...ption_algorithms","en.wikipedia.org/wiki/NSA_C...","http://en.wikipedia.org/wiki/NSA_","http://en.wikipedia.org/wiki/NSA_Cryptog","http://en.wikipedia.org/wiki/NSA_Cryptography","http://en.wikipedia.org/wiki/NSA_Cryptog…","http://en.wikipedia.org/wiki/NSA_cryptography","http://en.wikipedia.org/wiki/NSA_encryption_algorithms","ttp://en.wikipedia.org/wiki/NSA_encryption_algorithms","чортова прорва"],"name":"NSA cryptography","categories":["All articles needing additional references","Articles needing additional references from February 2008","National Security Agency","National Security Agency cryptography","National Security Agency encryption devices","Type 1 encryption algorithms","Type 2 encryption algorithms","Type 3 encryption algorithms"],"tag_line":"The vast majority of the National Security Agency's work on encryption is classified, but from time to time NSA participates in standards processes or otherwise publishes information about its cryptographic algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"congruence-of-squares","_score":0,"_source":{"description":"In number theory, a congruence of squares is a congruence commonly used in integer factorization algorithms.","alt_names":["...Wikipedia Congruence de carrés","...more on Wikipedia about Congruence of squares","4533e7ac0327300106f3b9b052b ...","689de17b2ca5cf5cc4d29da6727ce ...","Congruence de carr?s - Wikip?dia","Congruence de carrés","Congruence de carrés - Wikipédia","Congruence of squares","Congruence of squares - Wikipedia, the free encyclopedia","Congruence of squares - Wikipedia, the free encyclopedia ...","Learn about Congruence of squares>>>","Legendre-Kongruenz","Legendre-Kongruenz bei der wikipedia","What is the derivation of Congruence of squares","What is the example of Congruence of squares","Wikipedia (Congruence of squares)","Wikipedia article ''Congruence of squares''","Wikipedia article Congruence of squares","Wikipedia article on Congruence of squares","Wikipedia entry for Congruence of squares","Wikipedia-Artikel Legendre-Kongruenz","Wikipedia-Seite zu 'Legendre-Kongruenz'","congruence of squares","congruence-of-squares","de:Legendre-Kongruenz","en.wikipedia.org/wiki/Congruence_of_squares","http://de.wikipedia.org/wiki/Legendre-Ko","http://de.wikipedia.org/wiki/Legendre-Kongruenz","http://en.wikipedia.org/wiki/Congruence_of_squares","l'article de Wikipédia Congruence De Carrés","l'article de Wikipédia Congruence de carres","l'article de Wikipédia Congruence de carrés","x 2 - y 2 = n","yago-res:Congruence of squares"],"name":"Congruence of squares","categories":["All articles lacking sources","Articles lacking sources from December 2009","Integer factorization algorithms","Modular arithmetic"],"tag_line":"In number theory, a congruence of squares is a congruence commonly used in integer factorization algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fuzzy-clustering","_score":0,"_source":{"description":"Data clustering is the process of dividing data elements into classes or clusters so that items in the same class are as similar as possible, and items in different classes are as dissimilar as possible. Depending on the nature of the data and the purpose for which clustering is being used, different measures of similarity may be used to place items into classes, where the similarity measure controls how the clusters are formed. Some examples of measures that can be used as in clustering include distance, connectivity, and intensity.\nIn hard clustering, data is divided into distinct clusters, where each data element belongs to exactly one cluster. In fuzzy clustering (also referred to as soft clustering), data elements can belong to more than one cluster, and associated with each element is a set of membership levels. These indicate the strength of the association between that data element and a particular cluster. Fuzzy clustering is a process of assigning these membership levels, and then using them to assign data elements to one or more clusters.\nOne of the most widely used fuzzy clustering algorithms is the Fuzzy C-Means (FCM) Algorithm (Bezdek 1981). The FCM algorithm attempts to partition a finite collection of  elements  into a collection of c fuzzy clusters with respect to some given criterion. Given a finite set of data, the algorithm returns a list of  cluster centres  and a partition matrix , where each element  tells the degree to which element  belongs to cluster . Like the K-means clustering, the FCM aims to minimize an objective function:\n\nwhere:\n\nThis differs from the k-means objective function by the addition of the membership values  and the fuzzifier , with . The fuzzifier  determines the level of cluster fuzziness. A large  results in smaller memberships  and hence, fuzzier clusters. In the limit , the memberships  converge to 0 or 1, which implies a crisp partitioning. In the absence of experimentation or domain knowledge,  is commonly set to 2.","alt_names":["Fuzzy c-means clustering","Fuzzy clustering","- Down-covered absorption :","FUZZY CLUSTERING","Fuzzy (C-means)","Fuzzy Cluster","Fuzzy c-means clustering.","Fuzzy clustering - Wikipedia, the free encyclopedia","Fuzzy clustering by Wikipedia","Fuzzy_clustering","METODO FUZZY CLUSTERING","Wikipedia article Fuzzy clustering","Wikipedia entry for Fuzzy clustering","en.wikipedia.org/wiki/Fuzzy_clustering","en:Fuzzy_clustering","fuzzy clusterin","fuzzy clustering","fuzzy clustering.","http://en.wikipedia.org/wiki/Fuzzy_clustering","yago-res:Fuzzy clustering","خوشه بندی فازی"],"name":"Fuzzy clustering","categories":["All articles lacking in-text citations","All articles needing cleanup","Articles lacking in-text citations from August 2009","Articles needing cleanup from October 2011","Articles with inconsistent citation formats","Cleanup tagged articles with a reason field from October 2011","Data clustering algorithms","Wikipedia pages needing cleanup from October 2011"],"tag_line":"Data clustering is the process of dividing data elements into classes or clusters so that items in the same class are as similar as possible, and items in different classes are as dissimilar as possible."}}
,{"_index":"throwtable","_type":"algorithm","_id":"k-means-clustering","_score":0,"_source":{"description":"k-means clustering is a method of vector quantization, originally from signal processing, that is popular for cluster analysis in data mining. k-means clustering aims to partition n observations into k clusters in which each observation belongs to the cluster with the nearest mean, serving as a prototype of the cluster. This results in a partitioning of the data space into Voronoi cells.\nThe problem is computationally difficult (NP-hard); however, there are efficient heuristic algorithms that are commonly employed and converge quickly to a local optimum. These are usually similar to the expectation-maximization algorithm for mixtures of Gaussian distributions via an iterative refinement approach employed by both algorithms. Additionally, they both use cluster centers to model the data; however, k-means clustering tends to find clusters of comparable spatial extent, while the expectation-maximization mechanism allows clusters to have different shapes.\nThe algorithm has a loose relationship to the k-nearest neighbor classifier, a popular machine learning technique for classification that is often confused with k-means because of the k in the name. One can apply the 1-nearest neighbor classifier on the cluster centers obtained by k-means to classify new data into the existing clusters. This is known as nearest centroid classifier or Rocchio algorithm.","alt_names":[],"name":"K-means clustering","categories":["All articles with unsourced statements","Articles with unsourced statements from March 2014","CS1 French-language sources (fr)","CS1 errors: external links","Data clustering algorithms","Statistical algorithms"],"tag_line":"k-means clustering is a method of vector quantization, originally from signal processing, that is popular for cluster analysis in data mining."}}
,{"_index":"throwtable","_type":"algorithm","_id":"alpha-algorithm","_score":0,"_source":{"description":"The α-algorithm is an algorithm used in process mining, aimed at reconstructing causality from a set of sequences of events. It was first put forward by van der Aalst, Weijters and Măruşter. Several extensions or modifications of it have since been presented, which will be listed below.\nIt constructs P/T nets with special properties (workflow nets) from event logs (as might be collected by an ERP system). Each transition in the net corresponds to an observed task.\n\n","alt_names":["Alpha Algorithm","Alpha algorithm","Alpha algorithm - Wikipedia, the free encyclopedia","Alpha algorithm by Wikipedia","Wikipedia article Alpha algorithm","Wikipedia article on Alpha algorithm","Wikipedia article on the Alpha Algorithm","alpha algorithm","http://en.wikipedia.org/wiki/Alpha_algorithm","yago-res:Alpha algorithm"],"name":"Alpha algorithm","categories":["All articles to be expanded","Articles to be expanded from May 2010","Data mining algorithms","Process mining"],"tag_line":"The α-algorithm is an algorithm used in process mining, aimed at reconstructing causality from a set of sequences of events."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cluster-weighted-modeling","_score":0,"_source":{"description":"In data mining, cluster-weighted modeling (CWM) is an algorithm-based approach to non-linear prediction of outputs (dependent variables) from inputs (independent variables) based on density estimation using a set of models (clusters) that are each notionally appropriate in a sub-region of the input space. The overall approach works in jointly input-output space and an initial version was proposed by Neil Gershenfeld.","alt_names":["- Cluster-weighted modeling :","Cluster-weighted modeling","Cluster-weighted modeling - Wikipedia, the free encyclopedia","Cluster-weighted modeling - Wikipedia, the free encyclopedia ...","Cluster-weighted modeling by Wikipedia","Cluster-weighted_modeling","Wikipedia article Cluster-weighted modeling","Wikipedia entry for Cluster-weighted modeling","en:Cluster-weighted modeling","http://en.wikipedia.org/wiki/Cluster-weighted_modeling"],"name":"Cluster-weighted modeling","categories":["Data clustering algorithms","Estimation of densities","Multivariate statistics"],"tag_line":"In data mining, cluster-weighted modeling (CWM) is an algorithm-based approach to non-linear prediction of outputs (dependent variables) from inputs (independent variables) based on density estimation using a set of models (clusters) that are each notionally appropriate in a sub-region of the input space."}}
,{"_index":"throwtable","_type":"algorithm","_id":"data-stream-clustering","_score":0,"_source":{"description":"In computer science, data stream clustering is defined as the clustering of data that arrive continuously such as telephone records, multimedia data, financial transactions etc. Data stream clustering is usually studied as a streaming algorithm and the objective is, given a sequence of points, to construct a good clustering of the stream, using a small amount of memory and time.","alt_names":["Data Stream Clustering","Data stream clustering","Data stream clustering - Wikipedia :: The free encyclopedia","Data stream clustering - Wikipedia, the free encyclopedia","Data stream clustering Wikipedia the free encyclopedia - result","Data stream clustering by Wikipedia","Wikipedia article on Data stream clustering","en:Data stream clustering","http://en.wikipedia.org/wiki/Data_stream_clustering"],"name":"Data stream clustering","categories":["Data clustering algorithms"],"tag_line":"In computer science, data stream clustering is defined as the clustering of data that arrive continuously such as telephone records, multimedia data, financial transactions etc."}}
,{"_index":"throwtable","_type":"algorithm","_id":"user:pakoch/sandbox","_score":0,"_source":{"description":"In applied mathematics, K-SVD is a dictionary learning algorithm for creating a dictionary for sparse representations, via a singular value decomposition approach. K-SVD is a generalization of the k-means clustering method, and it works by iteratively alternating between sparse coding the input data based on the current dictionary, and updating the atoms in the dictionary to better fit the data. K-SVD can be found widely in use in applications such as image processing, audio processing, biology, and document analysis.","alt_names":[],"name":"User:Pakoch/sandbox","categories":["Data clustering algorithms","Linear algebra","Norms (mathematics)"],"tag_line":"In applied mathematics, K-SVD is a dictionary learning algorithm for creating a dictionary for sparse representations, via a singular value decomposition approach."}}
,{"_index":"throwtable","_type":"algorithm","_id":"mean-shift","_score":0,"_source":{"description":"Mean shift is a non-parametric feature-space analysis technique for locating the maxima of a density function, a so-called mode-seeking algorithm. Application domains include cluster analysis in computer vision and image processing.","alt_names":[],"name":"Mean shift","categories":["Computer vision","Data clustering algorithms","Pages using citations with accessdate and no URL"],"tag_line":"Mean shift is a non-parametric feature-space analysis technique for locating the maxima of a density function, a so-called mode-seeking algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"c4.5-algorithm","_score":0,"_source":{"description":"C4.5 is an algorithm used to generate a decision tree developed by Ross Quinlan. C4.5 is an extension of Quinlan's earlier ID3 algorithm. The decision trees generated by C4.5 can be used for classification, and for this reason, C4.5 is often referred to as a statistical classifier.\nIt became quite popular after ranking #1 in the Top 10 Algorithms in Data Mining pre-eminent paper published by Springer LNCS in 2008.","alt_names":["- C4.5 algorithm :","...mehr auf Wikipedia über C4.5","...more on Wikipedia about C4.5 algorithm","Algorithm C4.5","Algorithme C4.5","Algorithme C4.5 - Wikip?dia","Algorithme C4.5 - Wikipédia","Algoritmo C4.5","Arbre C4.5","C 4.5","C4 5 algorithm Wikipedia the free encyclopedia","C4. 5 algorithm","C4.5","C4.5 (Decision Tree)","C4.5 - Wikipedia","C4.5 ? Wikipedia","C4.5 Algorithm","C4.5 Algorithmus","C4.5 algorithm","C4.5 algorithm (Extending the ID3 algorithm)","C4.5 algorithm - Wikipedia","C4.5 algorithm - Wikipedia :: The free encyclopedia","C4.5 algorithm - Wikipedia, the free ...","C4.5 algorithm - Wikipedia, the free encyclopedia","C4.5 algorithm - Wikipedia, the free encyclopedia ...","C4.5 algoritme","C4.5 algoritmus","C4.5 classifier","C4.5 decision tree algorithm","C4.5 et al.","C4.5 statistical decision tree classifier","C4.5 sur Wikipedia","C4.5 – Wikipedia","C4.5,","C4.5-Algorithmus","C4.5.","C4.5_algorithm","C4.5↑","C4.5について","C4.5算法","ID3 / C4.5","Improvements from ID3 ...","Improvements from ID3 algorithm","Induction of Decision Trees.","J. Ross Quinlan's C4.5 Decision Trees","J48 algorithm constructs decision trees","J48 algoritmen konstruerer beslutning træer","J48 алгоритм строит деревья решений","J48-Algorithmus konstruiert Entscheidungsbäume","J48-algoritme construeert beslisbomen","J48算法构造决策树","Quinlan's C4.5 algorithm","What is algorithm of C4.5 algorithm","Wikipedia article Algorithme C4.5","Wikipedia article C4.5","Wikipedia article C4.5 algorithm","Wikipedia article C5.0","Wikipedia article about C4.5","Wikipedia article on C4.5","Wikipedia article on C4.5 algorithm","Wikipedia entry for C4.5 algorithm","Wikipedia's definition of the C4.5 tree inducting","Wikipedia-Artikel C4.5","Wikipedia-Seite zu 'C4.5'","Wikipedia: C4.5","Wikipediaで「C4.5」を調べる","algoritmo C4.5","algorytm J48 konstrukcji drzew decyzyjnych","algorytmie C4.5","c4.5","c4.5 algorithm","c4.5 program","de:C4.5","e C4.5 algorith","en.wikipedia.org/...C4.5_algorithm","en.wikipedia.org/wiki/C4.5_algorithm","fr:Algorithme C4.5","http://de.wikipedia.org/wiki/C4.5","http://en.wikipedia.org/wiki/C4....","http://en.wikipedia.org/wiki/C4.5","http://en.wikipedia.org/wiki/C4.5 _algorithm","http://en.wikipedia.org/wiki/C4.5_algorithm","http://fr.wikipedia.org/wiki/Algorithme_C4.5","ja:C4.5","l'article de Wikipédia C4.5","lgoritmo C4.5","«C4.5 decision tree package (Quinlan 1993)»","не всегда.","、C4.5は","ウィキペディアの記事 C4.5","，C4.5","，C4.5，"],"name":"C4.5 algorithm","categories":["All NPOV disputes","All articles lacking in-text citations","Articles lacking in-text citations from July 2008","Classification algorithms","Decision trees","NPOV disputes from August 2011"],"tag_line":"C4.5 is an algorithm used to generate a decision tree developed by Ross Quinlan."}}
,{"_index":"throwtable","_type":"algorithm","_id":"id3-algorithm","_score":0,"_source":{"description":"In decision tree learning, ID3 (Iterative Dichotomiser 3) is an algorithm invented by Ross Quinlan used to generate a decision tree from a dataset. ID3 is the precursor to the C4.5 algorithm, and is typically used in the machine learning and natural language processing domains.","alt_names":["ID3 – Wikipedia","http://ja.wikipedia.org/wiki/ID3","ID3 - Wikipedia","- ID3 algorithm :","...mehr auf Wikipedia über ID3","...more on Wikipedia about ID3 algorithm","Algorithm ID3","Algorithme ID3","Algorithme ID3 - Wikip?dia","Algorithme ID3 - Wikipédia","Algoritmo ID3","Algoritmo ID3 - Wikipedia, la enciclopedia libre","Algoritmo id3","El algoritmo ID3 es utilizado dentro del ámbito","I E ( i ) = - ∑ j = 1 m f ( i","ID3 (Decision Trees)","ID3 (algoritme)","ID3 (алгоритм)","ID3 (алгоритм) — Википедия","ID3 ? Wikipedia","ID3 algorithm","ID3 algorithm - Wikipedia","ID3 algorithm - Wikipedia :: The free encyclopedia","ID3 algorithm - Wikipedia, the free encyclopedia","ID3 algorithm Wikipedia the free encyclopedia","ID3 algorithm by Wikipedia","ID3 algorithm →","ID3 decision tree","ID3-wikipedia","ID3: algorithm to optimize 'decision tables'","ID3???- ????,???????","ID3_algorithm","ID3とは？ (Wikipediaへのリンク)","ID3について","ID3算法- 维基百科，自由的百科全书","Id3 Algorithm","Iterative Dichomotiser","Iterative Dichotomiser 3","Iterative Dichotomiser 3 (ID3) algorithm","L'algorithme ID3","What is algorithm of ID3 algorithm","What is algorithm of ID3 algorithm?","Wikipedia : ID3","Wikipedia article Algorithme ID3","Wikipedia article ID3 algorithm","Wikipedia article on ID3 Algorithm","Wikipedia article on ID3 algorithm","Wikipedia entry for ID3 algorithm","Wikipedia-Artikel ID3","Wikipedia-Seite zu 'ID3'","Wikipediaで「ID3」を調べる","algorithm description on Wikipedia","algorytm ID3","artículo de Wikipedia Algoritmo ID3","artículo de Wikipedia Algoritmo id3","el:Αλγόριθμος ID3","en.wikipedia.org/...ID3_algorithm","en.wikipedia.org/wiki/ID3_algorithm","es:Algoritmo ID3","es:Algoritmo id3","http://ID3 Algorithm at Wiki","http://de.wikipedia.org/wiki/ID3","http://el.wikipedia.org/wiki/ID3_algorithm","http://el.wikipedia.org/wiki/Αλγόριθμος_ID3","http://en.wikipedia.org/wiki/ID3_algorit","http://en.wikipedia.org/wiki/ID3_algorithm","http://en.wikipedia.org/wiki/ID3_algorithm f","http://en.wikipedia.org/wiki/ID3_algorit…","http://es.wikipedia.org/wiki/Algoritmo_ID3","http://fr.wikipedia.org/wiki/Algorithme_ID3","http://nl.wikipedia.org/wiki/ID3_(algoritme)","http://zh.wikipedia.org/wiki/ID3%E7%AE","ja:ID3","nl:ID3 (algoritme)","ru:ID3 (алгоритм)","the ID3 algorithm","ttp://ja.wikipedia.org/wiki/ID3","w:ID3 (алгоритм)","zh:ID3算法","Αλγόριθμος ID3","Αλγόριθμος ID3 - Βικιπαίδεια","∙ Algorithme ID3 - Wikipédia","「ID3」をWikiで調べる","ウィキペディアの記事 ID3","維基百科的文章“ ID3算法”","维基百科的文章“ ID3算法”","計算例が紹介されているID3"],"name":"ID3 algorithm","categories":["Articles with example pseudocode","Classification algorithms","Decision trees"],"tag_line":"In decision tree learning, ID3 (Iterative Dichotomiser 3) is an algorithm invented by Ross Quinlan used to generate a decision tree from a dataset."}}
,{"_index":"throwtable","_type":"algorithm","_id":"compositional-pattern-producing-network","_score":0,"_source":{"description":"Compositional pattern-producing networks (CPPNs), are a variation of artificial neural networks (ANNs) which differ in their set of activation functions and how they are applied.\nWhile ANNs often contain only sigmoid functions and sometimes Gaussian functions, CPPNs can include both types of functions and many others. The choice of functions for the canonical set can be biased toward specific types of patterns and regularities. For example, periodic functions such as sine produce segmented patterns with repetitions, while symmetric functions such as Gaussian produce symmetric patterns. Linear functions can be employed to produce linear or fractal-like patterns. Thus, the architect of a CPPN-based genetic art system can bias the types of patterns it generates by deciding the set of canonical functions to include.\nFurthermore, unlike typical ANNs, CPPNs are applied across the entire space of possible inputs so that they can represent a complete image. Since they are compositions of functions, CPPNs in effect encode images at infinite resolution and can be sampled for a particular display at whatever resolution is optimal.\nCPPNs can be evolved through neuroevolution techniques such as NeuroEvolution of Augmenting Topologies (called CPPN-NEAT).\nCPPNs have been shown to be a very powerful encoding when evolving the following:\nNeural Networks, via the HyperNEAT algorithm\n2D images, on \"PicBreeder.org\"\n3D objects, on \"EndlessForms.com\"\nRobot Morphologies Rigid Robots Soft Robots","alt_names":["- CPPN :","- Compositional pattern-producing network :","CPPN","CPPNs","CPPNs on Wikipedia","Compositional Pattern Producing Networks","Compositional pattern producing network","Compositional pattern-producing network","Compositional pattern-producing network - Wikipedia, the free ...","Compositional pattern-producing network - Wikipedia, the free ... ...","Compositional pattern-producing network - Wikipedia, the free encyclopedia","Compositional pattern-producing network by Wikipedia","Compositional pattern-producing networks","Computational Pattern Producing Network","Wikipedia article CPPN","Wikipedia article Compositional pattern-producing network","Wikipedia entry for Compositional pattern-producing network","Wikipedia: Compositional pattern-producing network","compositional pattern producing networks","http://en.wikipedia.org/wiki/CPPN","http://en.wikipedia.org/wiki/Compositional_pattern-producing_network","yago-res:Compositional pattern-producing network"],"name":"Compositional pattern-producing network","categories":["Artificial neural networks","Classification algorithms"],"tag_line":"Compositional pattern-producing networks (CPPNs), are a variation of artificial neural networks (ANNs) which differ in their set of activation functions and how they are applied."}}
,{"_index":"throwtable","_type":"algorithm","_id":"boruta-(algorithm)","_score":0,"_source":{"description":"Boruta is an algorithm in the field of machine-learning, and more specifically, a feature-selection algorithm. The aim of the algorithm as presented in the original paper describing it is to find all relevant features (compare with minimal-optimal features set). The Boruta algorithm is not a stand-alone algorithm, but is implemented as a wrapper algorithm around the random-forest classification algorithm. In its essence, Boruta works in an iterative manner, and in each iteration the aim is to remove features which according to a statistical test, are less relevant than what is defined by the authors as a random probe. One of the fundamental components of Boruta is the use of shadow attributes. Shadow attributes are pseudo-features that are added to the information system, and produced by taking existing features from the original data-set and shuffling the values of those features between the original samples (data points). After generating the shadow attributes the procedure proceeds with building random-forest trees and comparing the Z-scores obtained by original features to Z-scores obtained by the shadow attributes. This comparison is the foundation for Boruta to decide whether a feature is important or not.\n\n High level pseudo-code:\n\n1.  Copy all variables (features)\n2.  Shuffle values in each feature\n3.  Run random-forest on the extended system (shuffled features), gather Z scores\n4.  Find maximum MSZA (max Z-score among shadow attributes)\n5.  Run random-forest on original features\n6.  Assign each original feature a hit if feature Z-score > MSZA\n7.  If Z-score <= MSZA, perform two-side equality test against MSZA\n8.  If Z-score < MSZA significantly, drop feature as unimportant\n9.  If Z-score > MSZA significantly, keep feature as important\n10. Repeat from step 5 until all importance is determined for all features or max RF runs have been reached","alt_names":[],"name":"Boruta (algorithm)","categories":["All articles needing additional references","All articles with topics of unclear notability","Articles needing additional references from March 2015","Articles needing additional references from September 2014","Articles with topics of unclear notability from March 2015","Classification algorithms","Decision trees","Ensemble learning"],"tag_line":"Boruta is an algorithm in the field of machine-learning, and more specifically, a feature-selection algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"multispectral-pattern-recognition","_score":0,"_source":{"description":"Multispectral remote sensing is the collection and analysis of reflected, emitted, or back-scattered energy from an object or an area of interest in multiple bands of regions of the electromagnetic spectrum (Jensen, 2005). Subcategories of multispectral remote sensing include hyperspectral, in which hundreds of bands are collected and analyzed, and ultraspectral remote sensing where many hundreds of bands are used (Logicon, 1997). The main purpose of multispectral imaging is the potential to classify the image using multispectral classification. This is a much faster method of image analysis than is possible by human interpretation.\nThe Iterative Self-Organizing Data Analysis Technique (ISODATA) algorithm used for Multispectral pattern recognition was developed by Geoffrey H. Ball and David J. Hall, working in the Stanford Research Institute in Menlo Park, CA. They published their findings in a technical report entitled: ISODATA, a novel method of data analysis and pattern classification (Stanford Research Institute, 1965). ISODATA is defined in the abstract as: 'a novel method of data analysis and pattern classification, is described in verbal and pictorial terms, in terms of a two-dimensional example, and by giving the mathematical calculations that the method uses. The technique clusters many-variable data around points in the data's original high- dimensional space and by doing so provides a useful description of the data.' (1965, pp v.)ISODATA was developed to facilitate the modelling and tracking of weather patterns.","alt_names":["- Multispectral pattern recognition :","Multispectral pattern recognition","Multispectral pattern recognition - Wikipedia, the free ...","Multispectral pattern recognition - Wikipedia, the free encyclopedia","Multispectral pattern recognition - Wikipedia, the free encyclopedia ...","Multispectral pattern recognition - Wikipedia, the free...","Multispectral_pattern_recognition","Wikipedia article Multispectral pattern recognition","Wikipedia entry for Multispectral pattern recognition","http://en.wikipedia.org/wiki/Multispectral_pattern_recognition","multispectral classification","yago-res:Multispectral pattern recognition"],"name":"Multispectral pattern recognition","categories":["Classification algorithms","Imaging"],"tag_line":"Multispectral remote sensing is the collection and analysis of reflected, emitted, or back-scattered energy from an object or an area of interest in multiple bands of regions of the electromagnetic spectrum (Jensen, 2005)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"gsp-algorithm","_score":0,"_source":{"description":"GSP Algorithm (Generalized Sequential Pattern algorithm) is an algorithm used for sequence mining. The algorithms for solving sequence mining problems are mostly based on the a priori (level-wise) algorithm. One way to use the level-wise paradigm is to first discover all the frequent items in a level-wise fashion. It simply means counting the occurrences of all singleton elements in the database. Then, the transactions are filtered by removing the non-frequent items. At the end of this step, each transaction consists of only the frequent elements it originally contained. This modified database becomes an input to the GSP algorithm. This process requires one pass over the whole database.\nGSP Algorithm makes multiple database passes. In the first pass, all single items (1-sequences) are counted. From the frequent items, a set of candidate 2-sequences are formed, and another pass is made to identify their frequency. The frequent 2-sequences are used to generate the candidate 3-sequences, and this process is repeated until no more frequent sequences are found. There are two main steps in the algorithm.\nCandidate Generation. Given the set of frequent (k-1)-frequent sequences F(k-1), the candidates for the next pass are generated by joining F(k-1) with itself. A pruning phase eliminates any sequence, at least one of whose subsequences is not frequent.\nSupport Counting. Normally, a hash tree–based search is employed for efficient support counting. Finally non-maximal frequent sequences are removed.","alt_names":["GSP Algorithm","GSP Algorithm - Wikipedia, the free encyclopedia","GSP Algorithm by Wikipedia","GSP Algorithm: Algorithm","Source Wikipedia.org Arcticle - GSP Algorithm","Wikipedia article GSP Algorithm","Wikipedia entry for GSP Algorithm","Wikipedia:GSP_Algorithm","http://en.wikipedia.org/wiki/GSP_Algorit","http://en.wikipedia.org/wiki/GSP_Algorithm","http://en.wikipedia.org/wiki/GSP_Algorithm."],"name":"GSP Algorithm","categories":["All articles lacking sources","Articles lacking sources from May 2007","Articles with example pseudocode","Data mining algorithms","Pages with citations lacking titles"],"tag_line":"GSP Algorithm (Generalized Sequential Pattern algorithm) is an algorithm used for sequence mining."}}
,{"_index":"throwtable","_type":"algorithm","_id":"margin-infused-relaxed-algorithm","_score":0,"_source":{"description":"Margin-infused relaxed algorithm (MIRA) is a machine learning algorithm, an online algorithm for multiclass classification problems. It is designed to learn a set of parameters (vector or matrix) by processing all the given training examples one-by-one and updating the parameters according to each training example, so that the current training example is classified correctly with a margin against incorrect classifications at least as large as their loss. The change of the parameters is kept as small as possible.\nA two-class version called binary MIRA simplifies the algorithm by not requiring the solution of a quadratic programming problem (see below). When used in a one-vs.-all configuration, binary MIRA can be extended to a multiclass learner that approximates full MIRA, but may be faster to train.\nThe flow of the algorithm looks as follows:\n\nThe update step is then formalized as a quadratic programming problem: Find , so that , i.e. the score of the current correct training  must be greater than the score of any other possible  by at least the loss (number of errors) of that  in comparison to .","alt_names":["Margin Infused Relaxed Algorithm","Margin Infused Relaxed Algorithm - Wikipedia, the free encyclopedia","Margin Infused Relaxed Algorithm by Wikipedia","http://en.wikipedia.org/wiki/Margin_Infused_Relaxed_Algorithm"],"name":"Margin Infused Relaxed Algorithm","categories":["Classification algorithms"],"tag_line":"Margin-infused relaxed algorithm (MIRA) is a machine learning algorithm, an online algorithm for multiclass classification problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"co-training","_score":0,"_source":{"description":"Co-training is a machine learning algorithm used when there are only small amounts of labeled data and large amounts of unlabeled data. One of its uses is in text mining for search engines. It was introduced by Avrim Blum and Tom Mitchell in 1998.","alt_names":["- Co-training :","Co training","Co-training","Co-training - Wikipedia, the free encyclopedia","Co-training by Wikipedia","Cotraining","Cotraining Wikipedia the free encyclopedia","Wikipedia article Co-training","Wikipedia article on Co-training","Wikipedia entry for Co-training","co-training","co-training algorithm","cotraining","en.wikipedia.org/Co-training","http://en.wikipedia.org/wiki/Co-training","yago-res:Co-training","همآموز"],"name":"Co-training","categories":["Classification algorithms"],"tag_line":"Co-training is a machine learning algorithm used when there are only small amounts of labeled data and large amounts of unlabeled data."}}
,{"_index":"throwtable","_type":"algorithm","_id":"alopex","_score":0,"_source":{"description":"ALOPEX (an acronym from \"ALgorithms Of Pattern EXtraction\") is a correlation based machine learning algorithm first proposed by Tzanakou and Harth in 1974.","alt_names":["ALOPEX","ALOPEX - Wikipedia, the free encyclopedia","ALOPEX by Wikipedia","ALOPEX in Wikipedia","ALOPEX |","Harth, E. & E. Tzanakou (1974). Alopex: a","R ,","Wikipedia article ALOPEX","article ALOPEX","http://en.wikipedia.org/wiki/ALOPEX"],"name":"ALOPEX","categories":["All stub articles","Artificial intelligence stubs","Artificial neural networks","Classification algorithms"],"tag_line":"ALOPEX (an acronym from \"ALgorithms Of Pattern EXtraction\") is a correlation based machine learning algorithm first proposed by Tzanakou and Harth in 1974."}}
,{"_index":"throwtable","_type":"algorithm","_id":"level-set-method","_score":0,"_source":{"description":"Level set methods (LSM) are a conceptual framework for using level sets as a tool for numerical analysis of surfaces and shapes. The advantage of the level set model is that one can perform numerical computations involving curves and surfaces on a fixed Cartesian grid without having to parameterize these objects (this is called the Eulerian approach). Also, the level set method makes it very easy to follow shapes that change topology, for example when a shape splits in two, develops holes, or the reverse of these operations. All these make the level set method a great tool for modeling time-varying objects, like inflation of an airbag, or a drop of oil floating in water.\n\nThe figure on the right illustrates several important ideas about the level set method. In the upper-left corner we see a shape; that is, a bounded region with a well-behaved boundary. Below it, the red surface is the graph of a level set function  determining this shape, and the flat blue region represents the xy-plane. The boundary of the shape is then the zero level set of , while the shape itself is the set of points in the plane for which  is positive (interior of the shape) or zero (at the boundary).\nIn the top row we see the shape changing its topology by splitting in two. It would be quite hard to describe this transformation numerically by parameterizing the boundary of the shape and following its evolution. One would need an algorithm able to detect the moment the shape splits in two, and then construct parameterizations for the two newly obtained curves. On the other hand, if we look at the bottom row, we see that the level set function merely translated downward. This is an example of when it can be much easier to work with a shape through its level set function than with the shape directly, where using the shape directly would need to consider and handle all the possible deformations the shape might undergo.\nThus, in two dimensions, the level set method amounts to representing a closed curve  (such as the shape boundary in our example) using an auxiliary function , called the level set function.  is represented as the zero level set of  by\n\nand the level set method manipulates  implicitly, through the function . This function  is assumed to take positive values inside the region delimited by the curve  and negative values outside.","alt_names":["level set methods","- Level set method :","-> Read more about Level set method","...mehr auf Wikipedia über Level-Set-Methode","...more on Wikipedia about Level set method","Level Set Method","Level Sets","Level set function","Level set method","Level set method - Wikipedia :: The free encyclopedia","Level set method - Wikipedia, the free encyclopedia","Level set method - Wikipedia, the free encyclopedia ...","Level set method Wikipedia the free encyclopedia","Level set method on wikipedia.org","Level-Set","Level-Set Methode","Level-Set-Methode","Level-Set-Methode Wikipedia","Level-Set-Methode bei der wikipedia","Level-Set-Methode – Wikipedia","Level-Set-Methode_mathematisch","Level-set method","Level_set_method","Levelset","Metoda poziomic","Metoda poziomic – Wikipedia, wolna encyklopedia","Méthode des surfaces de niveau","Niveaumengenmethode","The level set equation","Thumbnail of screenshot of Level set method - Wikipedia","What is the Level Set method?","What is the history of Level set method","Wikipedia (Level set method)","Wikipedia article Level set method","Wikipedia article about Level set method","Wikipedia article on Level set method","Wikipedia entry for Level set method","Wikipedia-Artikel Level-Set-Methode","Wikipedia-Artikel Niveaumengenmethode","Wikipedia-Seite zu 'Level-Set-Methode'","Wikipedia-Seite zu 'Niveaumengenmethode'","article Level set method","de:Level-Set-Methode","en.wikipedia.org/...Level_set_method","en:Level set method","http://de.wikipedia.org/wiki/Level-Set-M","http://de.wikipedia.org/wiki/Level-Set-Methode","http://en.wikipedia.org/wiki/Level set method","http://en.wikipedia.org/wiki/Level_set_m","http://en.wikipedia.org/wiki/Level_set_method","http://en.wikipedia.org/wiki/Level_set_method#Level_set_method","http://pl.wikipedia.org/wiki/Metoda_poziomic","http://zh.wikipedia.org/wiki/%E6%B0","is difficult to model","level set metho","level set method","level-set methods","level_set_method","pl:Metoda poziomic","zh:水平集方法","水平集方法","水平集方法- 维基百科，自由的百科全书"],"name":"Level set method","categories":["Articles containing video clips","Computational fluid dynamics","Computer graphics algorithms","Image processing","Mathematical optimization","Numerical analysis"],"tag_line":"Level set methods (LSM) are a conceptual framework for using level sets as a tool for numerical analysis of surfaces and shapes."}}
,{"_index":"throwtable","_type":"algorithm","_id":"prime-factor-fft-algorithm","_score":0,"_source":{"description":"The prime-factor algorithm (PFA), also called the Good–Thomas algorithm (1958/1963), is a fast Fourier transform (FFT) algorithm that re-expresses the discrete Fourier transform (DFT) of a size N = N1N2 as a two-dimensional N1×N2 DFT, but only for the case where N1 and N2 are relatively prime. These smaller transforms of size N1 and N2 can then be evaluated by applying PFA recursively or by using some other FFT algorithm.\nPFA should not be confused with the mixed-radix generalization of the popular Cooley–Tukey algorithm, which also subdivides a DFT of size N = N1N2 into smaller transforms of size N1 and N2. The latter algorithm can use any factors (not necessarily relatively prime), but it has the disadvantage that it also requires extra multiplications by roots of unity called twiddle factors, in addition to the smaller transforms. On the other hand, PFA has the disadvantages that it only works for relatively prime factors (e.g. it is useless for power-of-two sizes) and that it requires a more complicated re-indexing of the data based on the Chinese remainder theorem (CRT). Note, however, that PFA can be combined with mixed-radix Cooley–Tukey, with the former factorizing N into relatively prime components and the latter handling repeated factors.\nPFA is also closely related to the nested Winograd FFT algorithm, where the latter performs the decomposed N1 by N2 transform via more sophisticated two-dimensional convolution techniques. Some older papers therefore also call Winograd's algorithm a PFA FFT.\n(Although the PFA is distinct from the Cooley–Tukey algorithm, Good's 1958 work on the PFA was cited as inspiration by Cooley and Tukey in their famous 1965 paper, and there was initially some confusion about whether the two algorithms were different. In fact, it was the only prior FFT work cited by them, as they were not then aware of the earlier research by Gauss and others.)","alt_names":["...more on Wikipedia about Prime-factor FFT algorithm","38b0bf19fcb7c380d60a50b767cb38 ...","3eae5251c6a49b87e0d27c957062f9 ...",": Prime-factor FFT algorithm","Prime Factor Algorithm","Prime factor FFT algorithm","Prime-Factor","Prime-Factor FFT Algorithm","Prime-factor FFT algorithm","Prime-factor FFT algorithm - Wikipedia","Prime-factor FFT algorithm - Wikipedia :: The free encyclopedia","Prime-factor FFT algorithm - Wikipedia, the free encyclopedia","Prime-factor_FFT_algorithm","See http://en.wikipedia.org/wiki/Prime-factor_FFT_algorithm","What is algorithm of Prime-factor FFT algorithm","Wikipedia article ''Prime-factor FFT algorithm''","Wikipedia article Prime-factor FFT algorithm","Wikipedia article Prime-factor FFT algorithm.","Wikipedia entry for Prime-factor FFT algorithm","ac369515e631aa39df29dc0b4 ...","en:WP Prime-factor_FFT_algorithm","http://en.wikipedia.org/wiki/Prime-facto","http://en.wikipedia.org/wiki/Prime-factor_FFT_algorithm","http://en.wikipedia.org/wiki/Prime-factor_FFT_algorithm#Re","http://www.wikipedia.org/wiki/Prime-factor_FFT_ algorithm","prime factor algorithm","prime-factor FFT algorithm","prime-factor FFT algorithms","prime-factor algorithm","rime-factor algorithm c","zh:互質因子算法","互質因子算法","互质因子算法","維基百科的文章“ 互質因子算法”"],"name":"Prime-factor FFT algorithm","categories":["FFT algorithms"],"tag_line":"The prime-factor algorithm (PFA), also called the Good–Thomas algorithm (1958/1963), is a fast Fourier transform (FFT) algorithm that re-expresses the discrete Fourier transform (DFT) of a size N = N1N2 as a two-dimensional N1×N2 DFT, but only for the case where N1 and N2 are relatively prime."}}
,{"_index":"throwtable","_type":"algorithm","_id":"split-radix-fft-algorithm","_score":0,"_source":{"description":"The split-radix FFT is a fast Fourier transform (FFT) algorithm for computing the discrete Fourier transform (DFT), and was first described in an initially little-appreciated paper by R. Yavne (1968) and subsequently rediscovered simultaneously by various authors in 1984. (The name \"split radix\" was coined by two of these reinventors, P. Duhamel and H. Hollmann.) In particular, split radix is a variant of the Cooley-Tukey FFT algorithm that uses a blend of radices 2 and 4: it recursively expresses a DFT of length N in terms of one smaller DFT of length N/2 and two smaller DFTs of length N/4.\nThe split-radix FFT, along with its variations, long had the distinction of achieving the lowest published arithmetic operation count (total exact number of required real additions and multiplications) to compute a DFT of power-of-two sizes N. The arithmetic count of the original split-radix algorithm was improved upon in 2004 (with the initial gains made in unpublished work by J. Van Buskirk via hand optimization for N=64 [1] [2]), but it turns out that one can still achieve the new lowest count by a modification of split radix (Johnson and Frigo, 2007). Although the number of arithmetic operations is not the sole factor (or even necessarily the dominant factor) in determining the time required to compute a DFT on a computer, the question of the minimum possible count is of longstanding theoretical interest. (No tight lower bound on the operation count has currently been proven.)\nThe split-radix algorithm can only be applied when N is a multiple of 4, but since it breaks a DFT into smaller DFTs it can be combined with any other FFT algorithm as desired.\n\n","alt_names":["9eeeb1a9dddc6db18e41b5870e3c5c ...","M. Vetterli and H. J. Nussbaumer, Simple FFT and","Split Radix Fft Algorithm","Split radix","Split radix FFT algorithm","Split-radix FFT","Split-radix FFT algorithm","Split-radix FFT algorithm - Wikipedia :: The free encyclopedia","Split-radix FFT algorithm - Wikipedia, the free encyclopedia","Splitradix FFT algorithm","Who was Split-radix FFT algorithm","Wikipedia article Split-radix FFT","Wikipedia article Split-radix FFT algorithm","Wikipedia article on Split-radix FFT","Wikipedia article on Split-radix FFT algorithm","Wikipedia entry for Split-radix FFT algorithm","X k = U k + ω N k Z","http://en.wikipedia.org/wiki/Split-radix","http://en.wikipedia.org/wiki/Split-radix_FFT","http://en.wikipedia.org/wiki/Split-radix_FFT_algor ithm","http://en.wikipedia.org/wiki/Split-radix_FFT_algorithm","http://en.wikipedia.org/wiki/Split_radix","split radix","split-radix","split-radix FFT","split-radix FFT algorithm","split-radix FFT algorithm,","split-radix algorithm"],"name":"Split-radix FFT algorithm","categories":["FFT algorithms"],"tag_line":"The split-radix FFT is a fast Fourier transform (FFT) algorithm for computing the discrete Fourier transform (DFT), and was first described in an initially little-appreciated paper by R. Yavne (1968) and subsequently rediscovered simultaneously by various authors in 1984."}}
,{"_index":"throwtable","_type":"algorithm","_id":"butterfly-diagram","_score":0,"_source":{"description":"This article is about butterfly diagrams in FFT algorithms; for the sunspot diagrams of the same name, see Solar cycle.\n\nIn the context of fast Fourier transform algorithms, a butterfly is a portion of the computation that combines the results of smaller discrete Fourier transforms (DFTs) into a larger DFT, or vice versa (breaking a larger DFT up into subtransforms). The name \"butterfly\" comes from the shape of the data-flow diagram in the radix-2 case, as described below. The earliest occurrence in print of the term is thought to be in a 1969 MIT technical report. The same structure can also be found in the Viterbi algorithm, used for finding the most likely sequence of hidden states.\nMost commonly, the term \"butterfly\" appears in the context of the Cooley–Tukey FFT algorithm, which recursively breaks down a DFT of composite size n = rm into r smaller transforms of size m where r is the \"radix\" of the transform. These smaller DFTs are then combined via size-r butterflies, which themselves are DFTs of size r (performed m times on corresponding outputs of the sub-transforms) pre-multiplied by roots of unity (known as twiddle factors). (This is the \"decimation in time\" case; one can also perform the steps in reverse, known as \"decimation in frequency\", where the butterflies come first and are post-multiplied by twiddle factors. See also the Cooley–Tukey FFT article.)","alt_names":["- Butterfly diagram :","...mehr auf Wikipedia über Schmetterlingsgraph","Butterfly (FFT algorithm)","Butterfly Diagram","Butterfly diagram","Butterfly diagram - Wikipedia :: The free encyclopedia","Butterfly diagram - Wikipedia, the free encyclopedia","Butterfly diagram - Wikipedia, the free encyclopediaIn the","Butterfly diagrams","Butterfly_diagram","Cooley-Tukey butterfly operation","Ein Schmetterlingsgraph","FFT Butterflies","FFT Butterfly Algorithm","Papillon de la FFT","Radix-2 butterfly diagram","Schmetterlings-graph","Schmetterlingsgraph","Schmetterlingsgraphen","Wikipedia article Butterfly (FFT algorithm)","Wikipedia article Butterfly diagram","Wikipedia article on Butterfly diagram","Wikipedia entry for Butterfly diagram","Wikipedia-Artikel Butterfly-Graph","Wikipedia-Artikel Schmetterlingsgraph","Wikipedia-Butterfly diagram","Wikipedia-Seite zu 'Schmetterlingsgraph'","butterfly diagram","ca2f8fe6db344a152228962c12d6c ...","decimation butterflies","en:Butterfly_diagram","external image 200px-Butterfly-FFT.png","external image 380px-Fft_16_h760v600.png","http://de.wikipedia.org/wiki/Schmetterlingsgraph","http://en.wikipedia....tterfly_diagram","http://en.wikipedia.org/wiki/Butterfly_(FFT_algorithm)","http://en.wikipedia.org/wiki/Butterfly_diagram","http://en.wikipedia.org/wiki/butterfly_diagram","tterfly i","tterfly,","y http://en.wikipedia.org/wiki/Butterfly_diagram","yago-res:Butterfly diagram","ω = exp ( 2 π i n )","蝴蝶圖"],"name":"Butterfly diagram","categories":["Diagrams","FFT algorithms"],"tag_line":"This article is about butterfly diagrams in FFT algorithms; for the sunspot diagrams of the same name, see Solar cycle."}}
,{"_index":"throwtable","_type":"algorithm","_id":"false-radiosity","_score":0,"_source":{"description":"False Radiosity is a 3D computer graphics technique used to create texture mapping for objects that emulates patch interaction algorithms in radiosity rendering. Though practiced in some form since the late 90s, this term was coined only around 2002 by architect Andrew Hartness, then head of 3D and real-time design at Ateliers Jean Nouvel.\nDuring the period of nascent commercial enthusiasm for radiosity-enhanced imagery, but prior to the democratization of powerful computational hardware, architects and graphic artists experimented with time-saving 3D rendering techniques. By darkening areas of texture maps corresponding to corners, joints and recesses, and applying maps via self-illumination or diffuse mapping in a 3D program, a radiosity-like effect of patch interaction could be created with a standard scan-line renderer. Successful emulation of radiosity required a theoretical understanding and graphic application of patch view factors, path tracing and global illumination algorithms. Texture maps were usually produced with image editing software, such as Adobe Photoshop. The advantage of this method is decreased rendering time and easily modifiable overall lighting strategies.\nAnother common approach similar to false radiosity is the manual placement of standard omni-type lights with limited attenuation in places in the 3D scene where the artist would expect radiosity reflections to occur. This method uses many lights and can require an advanced light-grouping system, depending on what assigned materials/objects are illuminated, how many surfaces require false radiosity treatment, and to what extent it is anticipated that lighting strategies be set up for frequent changes.","alt_names":["- False radiosity :","False radiosity","False radiosity - Wikipedia, the free encyclopedia","False_radiosity","Wikipedia article False radiosity","Wikipedia article on False radiosity","Wikipedia entry for False radiosity","false radiosity","http://en.wikipedia.org/wiki/False_radiosity","yago-res:False radiosity"],"name":"False radiosity","categories":["3D computer graphics","All stub articles","Computer graphics algorithms","Graphics software stubs","Image processing","Rendering systems"],"tag_line":"False Radiosity is a 3D computer graphics technique used to create texture mapping for objects that emulates patch interaction algorithms in radiosity rendering."}}
,{"_index":"throwtable","_type":"algorithm","_id":"relevance-vector-machine","_score":0,"_source":{"description":"In mathematics, a relevance vector machine (RVM) is a machine learning technique that uses Bayesian inference to obtain parsimonious solutions for regression and probabilistic classification. The RVM has an identical functional form to the support vector machine, but provides probabilistic classification.\nIt is actually equivalent to a Gaussian process model with covariance function:\n\nwhere  is the kernel function (usually Gaussian),'s as the variances of the prior on the weight vector  ,and  are the input vectors of the training set.\nCompared to that of support vector machines (SVM), the Bayesian formulation of the RVM avoids the set of free parameters of the SVM (that usually require cross-validation-based post-optimizations). However RVMs use an expectation maximization (EM)-like learning method and are therefore at risk of local minima. This is unlike the standard sequential minimal optimization (SMO)-based algorithms employed by SVMs, which are guaranteed to find a global optimum (of the convex problem).\nThe relevance vector machine is patented in the United States by Microsoft.\n^ Tipping, Michael E. (2001). \"Sparse Bayesian Learning and the Relevance Vector Machine\". Journal of Machine Learning Research 1: 211–244. \n^ US 6633857, Michael E. Tipping, \"Relevance vector machine\"","alt_names":["MEGET kort wikipedia-side","Relevance Vector Machine","Relevance Vector Machine - Wikipedia","Relevance Vector Machines","Relevance vector machine","Relevance vector machine (RVM)","Relevance vector machine - Wikipedia, the free encyclopedia","Relevance vector machine Wikipedia the free encyclopedia","Relevance vector machine by Wikipedia","What is software in Relevance Vector Machine","Wikipedia article Relevance Vector Machine","Wikipedia entry for Relevance vector machine","en.wikipedia.org/wiki/Relevance_Vector_Machine","http://en.wikipedia.org/wiki/Relevance_V","http://en.wikipedia.org/wiki/Relevance_Vector_Machine","http://en.wikipedia.org/wiki/Relevance_vector_machine","yago-res:Relevance vector machine","англ. RVM"],"name":"Relevance vector machine","categories":["All articles with unsourced statements","Articles with unsourced statements from February 2010","Classification algorithms","Kernel methods for machine learning","Nonparametric Bayesian statistics"],"tag_line":"In mathematics, a relevance vector machine (RVM) is a machine learning technique that uses Bayesian inference to obtain parsimonious solutions for regression and probabilistic classification."}}
,{"_index":"throwtable","_type":"algorithm","_id":"twiddle-factor","_score":0,"_source":{"description":"A twiddle factor, in fast Fourier transform (FFT) algorithms, is any of the trigonometric constant coefficients that are multiplied by the data in the course of the algorithm. This term was apparently coined by Gentleman & Sande in 1966, and has since become widespread in thousands of papers of the FFT literature.\nMore specifically, \"twiddle factors\" originally referred to the root-of-unity complex multiplicative constants in the butterfly operations of the Cooley-Tukey FFT algorithm, used to recursively combine smaller discrete Fourier transforms. This remains the term's most common meaning, but it may also be used for any data-independent multiplicative constant in an FFT.\nThe Prime-factor FFT algorithm is one unusual case in which an FFT can be performed without twiddle factors, albeit only for restricted factorizations of the transform size.","alt_names":["'Twiddle'","Twiddle Factor","Twiddle factor","Twiddle factor - Wikipedia, the free encyclopedia","Twiddle factor – Wikipedia, the free encyclopedia","Wikipedia article Twiddle factor","Wikipedia article on Twiddle factor","Wikipedia entry for Twiddle factor","a twiddle factor","d twiddle factor","en.wikipedia.org/wiki/Twiddle_factor","http://en.wikipedia.org/wiki/Twiddle_fac","http://en.wikipedia.org/wiki/Twiddle_factor","twiddle factor","twiddle factors","yago-res:Twiddle factor"],"name":"Twiddle factor","categories":["FFT algorithms"],"tag_line":"A twiddle factor, in fast Fourier transform (FFT) algorithms, is any of the trigonometric constant coefficients that are multiplied by the data in the course of the algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"evolutionary-algorithm","_score":0,"_source":{"description":"In artificial intelligence, an evolutionary algorithm (EA) is a subset of evolutionary computation, a generic population-based metaheuristic optimization algorithm. An EA uses mechanisms inspired by biological evolution, such as reproduction, mutation, recombination, and selection. Candidate solutions to the optimization problem play the role of individuals in a population, and the fitness function determines the quality of the solutions (see also loss function). Evolution of the population then takes place after the repeated application of the above operators. Artificial evolution (AE) describes a process involving individual evolutionary algorithms; EAs are individual components that participate in an AE.\nEvolutionary algorithms often perform well approximating solutions to all types of problems because they ideally do not make any assumption about the underlying fitness landscape; this generality is shown by successes in fields as diverse as engineering, art, biology, economics, marketing, genetics, operations research, robotics, social sciences, physics, politics and chemistry.\nTechniques from evolutionary algorithms applied to the modeling of biological evolution are generally limited to explorations of microevolutionary processes and planning models based upon cellular processes. The computer simulations Tierra and Avida attempt to model macroevolutionary dynamics.\nIn most real applications of EAs, computational complexity is a prohibiting factor. In fact, this computational complexity is due to fitness function evaluation. Fitness approximation is one of the solutions to overcome this difficulty. However, seemingly simple EA can solve often complex problems; therefore, there may be no direct link between algorithm complexity and problem complexity.\nA possible limitation  of many evolutionary algorithms is their lack of a clear genotype-phenotype distinction. In nature, the fertilized egg cell undergoes a complex process known as embryogenesis to become a mature phenotype. This indirect encoding is believed to make the genetic search more robust (i.e. reduce the probability of fatal mutations), and also may improve the evolvability of the organism. Such indirect (aka generative or developmental) encodings also enable evolution to exploit the regularity in the environment. Recent work in the field of artificial embryogeny, or artificial developmental systems, seeks to address these concerns. And gene expression programming successfully explores a genotype-phenotype system, where the genotype consists of linear multigenic chromosomes of fixed length and the phenotype consists of multiple expression trees or computer programs of different sizes and shapes.","alt_names":["evolutionary optimization","эволюционных вычислений","evolutionäre Algorithmen","Evolutionary Algorithm","algoritmos evolutivos","artificial evolution","evolutionary algorithms","Evolutionary algorithms","Evolutionary algorithm","Evolutionary Algorithms","(evolutionary algorithms)","(no) http://en.wikipedia.org/wiki/Evolutionary_algorithm","- Artificial evolution :","- Evolutionary algorithm :","- Evolutionary algorithms :","-> Read the article about 'Evolutionary algorithm'",". Evolutionary methods","...mehr auf Wikipedia über Evolutionärer Algorithmus","...more on Wikipedia about Evolutionary algorithm",": Algorithme évolutionniste","Algorithme ?volutionniste - Wikip?dia","Algorithme évolutionnaire","Algorithme évolutionniste","Algorithme évolutionniste - Wikipédia","Algorithms that Evolve","Algoritmi Evolutivi","Algoritmo evolutivo","Algoritmo evolutivo - Wikipedia, a enciclopedia libre","Algoritmo evolutivo - Wikipedia, la enciclopedia libre","Algoritmo evolutivo – Wikipédia, a enciclopédia livre","Algoritmos Evolutivos","Algoritmos evolutivos.","Artificial Evolution","Artificial evolution","Comparación de algoritmos evolutivos","Descripción general de Algoritmos evolutivos.","EVOLUTIONARY ALGORITHM","Evolucionaria","Evolucioni algoritmi","Evolution algorithms","Evolution%C3%A4rer_Algorithmus bei der wikipedia","Evolutionaarinen algoritmi","Evolutionary Algorithm (Wikipedia)","Evolutionary Algorithm Wikipedia The Free Encyclopedia","Evolutionary Algorithm's","Evolutionary Algorithms Defined","Evolutionary Algorithms defined","Evolutionary Algorithms.","Evolutionary Algorythms","Evolutionary algorithm (Wikipedia)","Evolutionary algorithm - Simple English Wikipedia, the free ...","Evolutionary algorithm - Wikipedia :: The free encyclopedia","Evolutionary algorithm - Wikipedia, the free encyclopedia","Evolutionary algorithm - wikipedia, the free encyclopedia","Evolutionary algorithm Wikipedia the free encyclopedia","Evolutionary algorithm Wikipedia the free encyclopedia - result","Evolutionary algorithm by Wikipedia","Evolutionary algorithm in Wikipedia","Evolutionary algorithm techniques","Evolutionary algorithms; it is used under the","Evolutionary methods","Evolutionary methods,","Evolutionary_algorithm","Evolutionary_algorithm sur wikipedia","Evolutionstheoretischer Ansatz","EvolutionÃ¤rer Algorithmus â€“ Wikipedia","Evolutionäre Algorithmen","Evolutionäre Algorithmen.","Evolutionäre Verfahren","Evolutionäre/Genetische Algorithmen","Evolutionären Algorithmen","Evolutionären Algorithmus","Evolutionärer Algorithmus","Evolutionärer Algorithmus ? Wikipedia","Evolutionärer Algorithmus – Wikipedia","Evolutionärer Algorithmus — Wikipedia","Evolutionäreren Algorithmen","Evolutionære algoritmer","Evolution鋜en Algorithmen","Evolução artificial","Evoluční Algor","Evoution Algorithm","GA evolutivi","General description of evolutionary algorithms.","Genetic & Evolutionary Algorithms","Implementation of biological processes","It's called an evolutionary algorithm, read up.","Learn about Evolutionary algorithm>>>","Principales familles","Principes de bases","WIKI: Evolutionary algorithm","Wiki - Evolutionary programming","WikiPedia > Evolutionary algorithm (EA)","WikiPedia:Evolutionary_algorithms","Wikipedia : Evolutionary Algorithm","Wikipedia Article about Evolutionary Algorithms","Wikipedia article Algorithme évolutionniste","Wikipedia article Algoritmo evolutivo","Wikipedia article Artificial evolution","Wikipedia article Evolutionary algorithm","Wikipedia article Evolutionary algorithms","Wikipedia article Evolutionary methods","Wikipedia article Evolutionärer Algorithmus","Wikipedia article on Algoritmo evolutivo","Wikipedia article on Artificial evolution","Wikipedia article on Evolutionary algorithm","Wikipedia article Эволюционные алгоритмы","Wikipedia definition of Evolutionary Algorithms","Wikipedia entry for Evolutionary algorithm","Wikipedia entry on Evolutionary Algorithms","Wikipedia sur Algorithme évolutionnaire","Wikipedia-Artikel Evolutionärer Algorithmus","Wikipedia-Seite zu 'Evolutionärer Algorithmus'","Wikipedia: Evolutionary Algorithms","Wikipedia:Evolutionary_algorithm","Wikipediaで「進化的アルゴリズム」を調べる","Wikipédia artigo Evolução artificial","[COLOR=#0000ff]evolutionary algorithms[/COLOR]","algorithmes évolutionnaires","algorithmes évolutionnistes","algoritma evolusioner","algoritmi evolutivi.","algoritmo evolutivo","algoritmos (e programação) evolutiva","algoritmos de evolución","algoritmos evolutivos,","ar:خوارزمية تطورية","artificial evoluti","artigo da Wikipédia Algoritmo evolutivo","artículo de Wikipedia Algoritmo evolutivo","been quite successful in creating useful designs","bevezető az evolúciós algoritmusokhoz (Wikipedia)","các thuật toán tiến hóa","d&finition","d'algorithmes évolutionnaires","de.wikipedia.org/...Evolution%C3%A4rer_Algorithmus","de.wikipedia.org/wiki/Evolutionärer_Algorithmus","de:Evolutionärer Algorithmus","des algorithmes évolutionnaires.","echte KI","en.wikipedia.org/...Evolutionary_algorithm","en.wikipedia.org/wiki/Evolutionary_al...","en.wikipedia.org/wiki/Evolutionary_algorithm","es.wikipedia.org/wiki/Algoritmo_evolutivo","evolucijska algoritma","evolusi algoritma.","evolutiivinen suunnittelu","evolutinary algorithms","evolutinäre Algorithmen","evolution is WIDELY used in computer science","evolution is on computers","evolution of computer code","evolutionair algoritme","evolutionaire algoritmes","evolutionaire ontwerpmethodes","evolutionary aglorithms","evolutionary algorithm","evolutionary algorithm wiki","evolutionary algorithmic","evolutionary algorithms at Wikipedia","evolutionary algorithms t","evolutionary algorithms.","evolutionary algrorithm","evolutionary and genetic algorithims","evolutionary learning","evolutionary method","evolutionary or genetic algorithm","evolutionary principles","evolutionary schemes","evolutionary/genetic algorithms","evolutionaryalgorithms","evolutionär algoritm","evolutionäre Algorithmus","evolutionären Algorithmen","evolutionären Algorithmus","evolutionärer Algorithmus","evoluutioalgoritmit","evoluutiolaskennan","evolução artificial","evoluční algor","evolúciós algoritmusok","evrimsel bilgi işlem","f evolutionary algorithms","fa:الگوریتم های تکاملی","fr.wikipedia.org/wiki/Algorithme_évolutionniste","fr:Algorithme évolutionnaire","fr:Algorithme évolutionniste","genetic programming or evolutionary algorithms","gli algoritmi evolutivi (EA)","généralement employé","how our brains developed","http://de.wikipedia....rer_Algorithmus","http://de.wikipedia.org/wiki/Evol... lgorithmus","http://de.wikipedia.org/wiki/Evoluti...er_Algorithmus","http://de.wikipedia.org/wiki/Evolution% ... lgorithmus","http://de.wikipedia.org/wiki/Evolution%C3%A4rer_Algorithmus","http://de.wikipedia.org/wiki/Evolutionärer_Algorithmus","http://de.wikipedia.org/w…C3%A4rer_Algorithmus","http://en.Liarpedia.org/wiki/Evolutionary_algorithm","http://en.wikipedia....nary_algorithms","http://en.wikipedia....onary_algorithm","http://en.wikipedia.org/w.i/Evolutionary_algorithm","http://en.wikipedia.org/wi ki/Evolutionary_algorithm","http://en.wikipedia.org/wiki/Artificial_evolution","http://en.wikipedia.org/wiki/Evolut[…]y_algorithms","http://en.wikipedia.org/wiki/Evolutionary algorithm","http://en.wikipedia.org/wiki/Evolutionary_algorit...","http://en.wikipedia.org/wiki/Evolutionary_algorithm","http://en.wikipedia.org/wiki/Evolutionary_algorithm#External_links","http://en.wikipedia.org/wiki/Evolutionary_algorithms","http://en.wikipedia.org/wiki/Evolutionary_algorit…","http://en.wikipedia.org/wiki/Evolutionary_algori…","http://en.wikipedia.org/wi​ki/Evolutionary_algorithm","http://es.wikipedia.org/wiki/Algoritmo_evolutivo","http://fr.wikipedia.org/wiki/Algorit...9volutionniste","http://fr.wikipedia.org/wiki/Algorithme_%C3%A9volutionniste","http://ja.wikipedia.org/wiki/%​E9%80%B2","http://pt.wikipedia.org/wiki/Algoritmo_evolutivo","http://ru.wikipedia.org/wiki/Эволюционные_алгоритмы","ikipedia (englisch):","jogos da vida","just one subset of the computational applications of","l'algorithme évolutionniste","l'article de Wikipédia Algorithme évolutionniste","los algoritmos evolutivos.","n evolutionary algorithm","naturally-framed","on commence","reproducción, mutación, recombinación y selección","self-adaptative","simple:Evolutionary algorithm","stratégies évolutionnaires","symbio-organisms","teorías de la evolución","though people have theorized ways to do it","thuật toán tiến hóa.","técnicas adaptativas y evolutivas","uses evolutionary concepts","volutionary Algorithm","volutionary algorithm-","whole field of comp. science","wikipedia har en bra överblick","wikiに載ってた。。。（恥）","wikiに載ってた｡｡｡（恥）","wp:Evolutionary algorithm","Википедии статью Эволюционные алгоритмы","Еволюційний алгоритм","Еволюційні алгоритми","Курите букварь!","Никто, они - прямое следствие действующих во Вселенной физических","Эволюционные алгоритмы","эволюционные алгоритмы","эволюционные.","эволюционный алгоритм.","эволюционными алгоритмами","эволюционных алгоритма","эволюционных алгоритмов","الخوارزمية التطورية","الگوریتم های تکاملی","الگوریتم های تکاملی - ویکیپدیا","الگوریتمهای تکامل","الگوریتمهای تکاملی","الگوریتمِ تکاملی","خوارزمية تطورية","กลไก วิวัฒนาการ","กลไก วิวัฒนาการ.","ウィキペディアの記事 進化的アルゴリズム","进化算法","進化アルゴリズム","進化演算法（evolutionary algorithms）","進化的アルゴリズム","進化的アルゴリズム - Wikipedia","進化的アルゴリズム - ウィキ","進化的ｱﾙｺﾞﾘｽﾞﾑ-wikipedia","進化算法","진화 알고리즘과","진화 알고리즘을"],"name":"Evolutionary algorithm","categories":["All articles with specifically marked weasel-worded phrases","All articles with unsourced statements","Articles that may contain original research from May 2013","Articles with specifically marked weasel-worded phrases from May 2013","Articles with unsourced statements from May 2015","Articles with unsourced statements from September 2008","Cybernetics","Evolution","Evolutionary algorithms","Optimization algorithms and methods"],"tag_line":"In artificial intelligence, an evolutionary algorithm (EA) is a subset of evolutionary computation, a generic population-based metaheuristic optimization algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"learning-classifier-system","_score":0,"_source":{"description":"A learning classifier system, or LCS, is a machine learning system with close links to reinforcement learning and genetic algorithms. First described by John Holland, his LCS consisted of a population of binary rules on which a genetic algorithm altered and selected the best rules. Rule fitness was based on a reinforcement learning technique.","alt_names":["- Learning classifier system :","-> Read the article about 'Learning classifier system'","...more on Wikipedia about Learning classifier system","Holland classifier","Klasifikatorski sustavi sa sposobnošću učenja","LCS from Wikipedia","Learning Classifier System","Learning Classifier Systems","Learning Classifier systems","Learning classifier system","Learning classifier system - Wikipedia, the free encyclopedia","Learning classifier system by Wikipedia","Learning classifier systems","Learning_classifier_system","View Learning classifier system on Wikipedia","What is the overview of Learning classifier system","Wiki, Learning Classifier System","Wikipedia (Learning classifier system)","Wikipedia article ''Learning classifier system''","Wikipedia article Learning classifier system","Wikipedia article on Learning classifier system","Wikipedia entry for Learning classifier system","XCS classifier system","at lære klassificeringen systemet","des sysèmes à base de règles","en.wikipedia.org/wiki/Learning_classifier_system","http://en.wikipedia.org/wiki/Learning_cl","http://en.wikipedia.org/wiki/Learning_classif...","http://en.wikipedia.org/wiki/Learning_classifier_system","hệ thống phân loại học tập","learning classifier system","learning classifier systems","leren classifier systeem","sistem pembelajaran classifier","sistema clasificador de aprendizaje","sistema classificador de aprendizagem","sistema di classificazione di apprendimento","system nauczania klasyfikatora","système de classificateur d'apprentissage","Статья об LCS из Википедии","обучения классификатора системы","ส่วนขยายระบบการเรียนรู้","学习分类器系统","學習分類器系統","的学习分类","학습 분류 시스템"],"name":"Learning classifier system","categories":["All articles with unsourced statements","All stub articles","Articles with unsourced statements from February 2014","Articles with unsourced statements from July 2015","Evolutionary algorithms","Technology stubs"],"tag_line":"A learning classifier system, or LCS, is a machine learning system with close links to reinforcement learning and genetic algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"artificial-immune-system","_score":0,"_source":{"description":"In artificial intelligence, artificial immune systems (AIS) are a class of computationally intelligent systems inspired by the principles and processes of the vertebrate immune system. The algorithms typically exploit the immune system's characteristics of learning and memory to solve a problem.","alt_names":["- Artificial immune system :","-> Read the article about 'Artificial immune system'","...more on Wikipedia about Artificial immune system","Artefarita Imuna Sistemo","Artificial Immune System","Artificial Immune Systems","Artificial Immune Systems (AIS)","Artificial immune","Artificial immune system","Artificial immune system - Wikipedia :: The free encyclopedia","Artificial immune system - Wikipedia, the free encyclopedia","Artificial immune system - Wikipedia, the free encyclopedia ...","Artificial immune system Wikipedia the free encyclopedia","Artificial immune system Wikipedia, ...","Artificial immune system; it is used under the","Artificial immune systems","Artificial_immune_system","IQ there that is hidden","Keinoimmuunijärjestelmä","Keinoimmuunijärjestelmä – Wikipedia","Sistema Immune Artificial","Sistema Imune Artificial","Sistema Inmune Artificial","Sistema immunitario artificiale","Syst?me immunitaire artificiel - Wikip?dia","Système immunitaire artificiel","Système immunitaire artificiel - Wikipédia","The field of artificial immune systems was well","View Artificial immune system on Wikipedia","What is the history of Artificial immune system","What techniques does Artificial Immune System have","What techniques does Artificial Immune System have?","Wikipedia : 人工免疫システム","Wikipedia article Artificial Immune System","Wikipedia article Artificial immune system","Wikipedia article Artificial_immune_system","Wikipedia entry for Artificial immune system","Wikipediaで「人工免疫システム」を調べる","Wikipediaで「人工免疫系」を調べる","artificial immune system","artificial immune systems","en.wikipedia.org/wiki/Artificial_immune_system","fi.wikipedia.org/wiki/Keinoi...telm%C3%A4","http://en.wikipedia.org/wiki/Artificial_Immune_System","http://en.wikipedia.org/wiki/Artificial_immune_sys...","http://en.wikipedia.org/wiki/Artificial_immune_system","http://en.wikipedia.org/wiki/Artificial_immune_systems","http://fr.wikipedia.org/wiki/Syst%C3%A8me_immunitaire_artificiel","il sistema immunitario artificiale","ja:人工免疫システム","le système immunitaire artificiel","sistema immunitario artificiale","sistemas imunes artificiais","sistemas inmunes artificiales","umělý imunitní systém","umělých imunitních výpočetních systémů","人口免疫システム","人工免疫システム","人工免疫システム - Wikipedia","人工免疫系","人工免疫系-wikipedia","人工免疫系統","人工免疫ｼｽﾃﾑ-wikipedia"],"name":"Artificial immune system","categories":["Artificial immune systems","Evolutionary algorithms","Pages using citations with accessdate and no URL","Pages with citations lacking titles"],"tag_line":"In artificial intelligence, artificial immune systems (AIS) are a class of computationally intelligent systems inspired by the principles and processes of the vertebrate immune system."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cgal","_score":0,"_source":{"description":"The Computational Geometry Algorithms Library (CGAL) is a software library of computational geometry algorithms. While primarily written in C++, Scilab bindings and bindings generated with SWIG (supporting Python and Java for now) are also available.\nThe software is available under dual licensing scheme. When used for other open source software, it is available under open source licenses (LGPL or GPL depending on the component). In other cases commercial license may be purchased, under different options for academic/research and industrial customers.\n^ CGAL bindings, developed at GeometryFactory.\n^ CGAL Scilab bindings, developed at Scilab and INRIA by Edyta Przymus, Naceur Meskini and Sylvain Pion.\n^ CGAL license","alt_names":["- CGAL :","CGAL","CGAL - Wikipedia","CGAL - Wikipedia, the free encyclopedia","CGAL on wikipedia.org","CGAL |","CGAL-wikipedia","Cgal","Computational Geometry Algor...","Computational Geometry Algorithms Library","Computational Geometry Algorithms Library (CGAL)","Computational Geometry Algorithms Library - Wikipédia","What are Computational Geometry Algorithms Library's platforms?","Wikipedia article CGAL","Wikipedia article Computational Geometry Algorithms Library","Wikipedia article on CGAL","Wikipedia entry for CGAL","Wikipediaで「CGAL」を調べる","fr:Computational Geometry Algorithms Library","http://en.Liarpedia.org/wiki/Precancerous","http://en.wikipedia.org/wiki/CGAL","http://fr.wikipedia.org/wiki/Computational_Geometry_Algorithms_Library","http://ja.wikipedia.org/wiki/CGAL","ja:CGAL","l'article de Wikipédia CGAL","ヨーロッパとイスラエルの研究機関によって開発が進められており、また多くの使用実績がある"],"name":"CGAL","categories":["All articles containing potentially dated statements","Articles containing potentially dated statements from 2010","Articles containing potentially dated statements from 2013","C++ libraries","Free computer libraries","Geometric algorithms","Max Planck Institute for Informatics","Python libraries"],"tag_line":"The Computational Geometry Algorithms Library (CGAL) is a software library of computational geometry algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bregman-divergence","_score":0,"_source":{"description":"In mathematics, a Bregman divergence or Bregman distance is similar to a metric, but does not satisfy the triangle inequality nor symmetry. There are two ways in which Bregman divergences are important. Firstly, they generalize squared Euclidean distance to a class of distances that all share similar properties. Secondly, they bear a strong connection to exponential families of distributions; as has been shown by (Banerjee et al. 2005), there is a bijection between regular exponential families and regular Bregman divergences.\nBregman divergences are named after Lev M. Bregman, who introduced the concept in 1967. More recently researchers in geometric algorithms have shown that many important algorithms can be generalized from Euclidean metrics to distances defined by Bregman divergence (Banerjee et al. 2005; Nielsen and Nock 2006; Boissonnat et al. 2010).","alt_names":["- Bregman divergence :","43bdb1584cf97fa5b7b2ce31becaf ...","B F ( p &parallel; q )","Bregman Distance","Bregman Divergence","Bregman Divergences","Bregman distance","Bregman divergence","Bregman divergence - Wikipedia :: The free encyclopedia","Bregman divergence - Wikipedia, the free encyclopedia","Bregman divergence Wikipedia the free encyclopedia - result","Bregman divergence by Wikipedia","Bregman divergences","Bregman entropic pseudo-distance","Generalizing projective duality","Wikipedia article Bregman distance","Wikipedia article Bregman divergence","Wikipedia article on Bregman divergence","Wikipedia entry for Bregman divergence","Wikipedia:Bregman_divergence","bregman divergence","en.wikipedia.org/wiki/Bregman_distance","entropic regularization","generalized projection","http://en.wikipedia....gman_divergence","http://en.wikipedia.org/wiki/Bregman_di ... tributions","http://en.wikipedia.org/wiki/Bregman_div","http://en.wikipedia.org/wiki/Bregman_divergence"],"name":"Bregman divergence","categories":["Geometric algorithms","Statistical distance measures"],"tag_line":"In mathematics, a Bregman divergence or Bregman distance is similar to a metric, but does not satisfy the triangle inequality nor symmetry."}}
,{"_index":"throwtable","_type":"algorithm","_id":"forward–backward-algorithm","_score":0,"_source":{"description":"The forward–backward algorithm is an inference algorithm for hidden Markov models which computes the posterior marginals of all hidden state variables given a sequence of observations/emissions , i.e. it computes, for all hidden state variables , the distribution . This inference task is usually called smoothing. The algorithm makes use of the principle of dynamic programming to compute efficiently the values that are required to obtain the posterior marginal distributions in two passes. The first pass goes forward in time while the second goes backward in time; hence the name forward–backward algorithm.\nThe term forward–backward algorithm is also used to refer to any algorithm belonging to the general class of algorithms that operate on sequence models in a forward–backward manner. In this sense, the descriptions in the remainder of this article refer but to one specific instance of this class.\n\n","alt_names":[],"name":"Forward–backward algorithm","categories":["Dynamic programming","Error detection and correction","Machine learning algorithms","Markov models"],"tag_line":"The forward–backward algorithm is an inference algorithm for hidden Markov models which computes the posterior marginals of all hidden state variables given a sequence of observations/emissions , i.e."}}
,{"_index":"throwtable","_type":"algorithm","_id":"marching-cubes","_score":0,"_source":{"description":"Marching cubes is a computer graphics algorithm, published in the 1987 SIGGRAPH proceedings by Lorensen and Cline, for extracting a polygonal mesh of an isosurface from a three-dimensional discrete scalar field (sometimes called voxels). This paper is one of the most cited papers in the computer graphics field. The applications of this algorithm are mainly concerned with medical visualizations such as CT and MRI scan data images, and special effects or 3-D modelling with what is usually called metaballs or other metasurfaces. An analogous two-dimensional method is called the marching squares algorithm.","alt_names":["- Marching cubes :","...Wikipedia Marching cubes","...mehr auf Wikipedia über Marching Cubes","...more on Wikipedia about Marching cubes","3D Marching Cubes","Algorythme du Marching Cube","Cubes Marching","Lorensen和Cline","Marching Cube","Marching Cube Algorithmus","Marching Cube algorithm","Marching Cubes","Marching Cubes (Wikipedia)","Marching Cubes (wikipedia)","Marching Cubes - Wikipedia","Marching Cubes ? Wikipedia","Marching Cubes Algorithm","Marching Cubes Algorithmus","Marching Cubes algorithm","Marching Cubes algoritme","Marching Cubes â€“ Wikipedia","Marching Cubes – Wikipedia","Marching Cubes-Algorithmus","Marching Cubes-Algorithmus.","Marching Cubes算法","Marching cube","Marching cubes","Marching cubes - Wikipedia","Marching cubes - Wikipedia, ...","Marching cubes - Wikipedia, the free encyclopedia","Marching cubes - Wikipédia","Marching cubes algorithm","Marching cubes article","Marching cubes explained at Wikipedia","Marching cubes- , the free encyclopedia","Marching cubes; it is used under the","Marching kubussen","Marching terninger","Marching Сubes","Marching-Cubes","Marching-Cubes-Algorithmus","Marching_Cubes","Marching_cubes-wikipedia","Standard voxel triangulation","Wikipedia article Marching cubes","Wikipedia article Marching cubes algorithm","Wikipedia artikel Marching Cubes","Wikipedia artikel Marching cubes","Wikipedia entry for Marching cubes","Wikipedia-Artikel Marching Cube","Wikipedia-Artikel Marching Cubes","Wikipedia-Seite zu 'Marching Cubes'","algoritmo marching cubes","algoritmus Marching Cubes","band Category:","batu berbaris","de:Marching Cubes","en.wikipedia.org/wiki/Marching_cubes","en.wikipedia.org/​wiki/​Marching_cubes","fr:Marching cubes","http://de.wikipedia.org/wiki/Marching_Cu","http://de.wikipedia.org/wiki/Marching_Cubes","http://en.wikipedia..../Marching_cubes","http://en.wikipedia.org/wiki/Marchin...#Patent_issues","http://en.wikipedia.org/wiki/Marching...","http://en.wikipedia.org/wiki/Marching_cu","http://en.wikipedia.org/wiki/Marching_cubes","http://en.wikipedia.org/wiki/Marching_cubes#Patent_issues","http://en.wikipedia.org/wiki/Marching_cubes_algorithm","http://fr.wikipedia.org/wiki/Marching_cubes","http://it.wikipedia.org/wiki/Marching_cubes","http://ja.wikipedia.org/wiki/Marching_cubes","http://nl.wikipedia.org/wiki/Marching_Cubes","http://nl.wikipedia.org/wiki/Marching_cubes","http://pl.wikipedia.org/wiki/Marching_cubes","http://pl.wikipedia.org/wiki/Marhing_cubes","http://ru.wikipedia.org/wiki/Marching_cubes","http://uk.wikipedia.org/wiki/Marching_cubes","isosurface extraction algorithms","it:Marching cubes","ja:Marching cubes","khối diễu hành","kostki Marsz","l'article de Wikipédia Marching Cubes","l'article de Wikipédia Marching cubes","los cubos de Marcha","marcha Cubos","marcha cubos.","marching cube","marching cube algorithm","marching cubes","marching cubes algo","marching cubes algorithm","marching cubes patent","marching cubes-algorithm","marching-cubes","marcia cubi","nl:Marching Cubes","nl:Marching cubes","pl:Marching cubes","ru:Marching cubes","te voila bon pour un coup de WIKIPEDIA","the marching cubes","the marching cubes algorithm","uk:Marching cubes","walking-cubes","yago-res:Marching cubes","Идущие Кубы Алгоритм","Маршевые Кубы","Маршевые кубов","идут кубы","ก้อน marching.","“Marching Cubes”","マーチングキューブを","マーチングキューブアルゴリズム","工作步操多维数据","算法步操多维数据","行進のキューブ","행진 큐브","ﾏｰﾁﾝｸﾞｷｭｰﾌﾞｱﾙｺﾞﾘｽﾞﾑ"],"name":"Marching cubes","categories":["3D computer graphics","All articles with unsourced statements","Articles with unsourced statements from August 2015","Commons category template with no category set","Commons category without a link on Wikidata","Computer graphics algorithms","Mesh generation"],"tag_line":"Marching cubes is a computer graphics algorithm, published in the 1987 SIGGRAPH proceedings by Lorensen and Cline, for extracting a polygonal mesh of an isosurface from a three-dimensional discrete scalar field (sometimes called voxels)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"midpoint-circle-algorithm","_score":0,"_source":{"description":"In computer graphics, the midpoint circle algorithm is an algorithm used to determine the points needed for drawing a circle. Bresenham's circle algorithm is derived from the midpoint circle algorithm. The algorithm can be generalized to conic sections.\n\nThe algorithm is related to work by Pitteway and Van Aken.","alt_names":["a reasonably good article","(or this)","...Wikipedia Algorithme de tracé d'arc de cercle","1St Octant","Algorithme de Bresenham appliqué au cercle","Algorithme de trac? d'arc de cercle de","Algorithme de tracé d'arc de cercle de","Algorithme_de_tracé_d'arc_de_cercle_de_Bresenham","Bresehnam","Bresenham Circle","Bresenham circle","Bresenham circle.","Bresenham cirkel van algoritme","Bresenham kruhu algoritmus","Bresenham ring","Bresenham's Circle Algorithm","Bresenham's circle algorithm","Bresenham's cirkel algoritme","Bresenham-Kreis-Algorithmus","Bresenhamの円アルゴリズムを","Bresenham画的圆弧算法","Bresenham的圆的算法","Learn about Midpoint circle algorithm>>>","Midpoint Circle","Midpoint Circle Algorithm","Midpoint Circle Drawing Algorithm","Midpoint Ellipse Algorithm","Midpoint algoritmus kruhu","Midpoint circle algorith","Midpoint circle algorithm","Midpoint circle algorithm - Wikipedia :: The free encyclopedia","Midpoint circle algorithm - Wikipedia on Ask.com","Midpoint circle algorithm - Wikipedia, the free encyclopedia","Midpoint circle algorithm - Wikipedia, the free encyclopedia ...","Midpoint circle algorithm Wikipedia the free encyclopedia","Midpoint circle algorithm Wikipedia, ...","Midpoint circle algorithm.","Midpoint circle algorithm/Bresenham's circle algorithm","Midpoint circle algoritmus","Midpoint cirkel algoritme","Midpoint-Circle Algorithm","Midpoint-Circle-Algorithm","Midtpunkt cirkel algoritme","Mittelpunkt Kreis Algorithmus","Rastern von Kreisen","Rastern von Kreisen (de)","Rastern von Kreisen - Wikipedia","Rasterung von Kreisen","Rasterung von Kreisen – Wikipedia","Rasterung_von_Kreisen","Reading 1: Bresenham's circle","Simple Circle Drawing Algorithm","The Bresenham Circle","The midpoint circle algorithm","Tracé de cercle","Wikipedia article Algorithme de tracé d'arc de","Wikipedia article Midpoint circle algorithm","Wikipedia article about Midpoint circle algorithm","Wikipedia entry for Midpoint circle algorithm","Wikipedia-Artikel Rastern von Kreisen","Wikipedia-Artikel Rasterung von Kreisen","Wikipedia-Seite zu 'Rasterung von Kreisen'","Wikipedia: Midpoint Circle Algorithm","[Algorithme de Bresenham]","a Bresenham circle","algo de Bresenham","algorit-","algorithme de tracé d'arc de cercle","algorithme du point central","algorithms for this sort of thing","algoritmo circolo Punto medio","algoritmo del punto medio","algorytm Bresenham kręgu","algorytm koło półmetku","algorytmu midpoint","cerchio algoritmo di Bresenham","circle algorithm","circle-drawing","círculo algoritmo del punto medio","de:Rasterung von Kreisen","de:Rasterung_von_Kreisen","el círculo Bresenham algoritmo","en.wikipedia.org/...Midpoint_circle_algorithm","en.wikipedia.org/wiki/Midpoint_circle_algorithm","http://de.wikipedia.org/wiki/Rasterung_von_Kreisen","http://de.wikipedia.org/wiki/Rasterung_von_Kreisen#Methode_von_Horn","http://en.wikipedia....ircle_algorithm","http://en.wikipedia.org/...idpoint_circle_algorithm","http://en.wikipedia.org/wiki/Bresenham%27s_circle_algorithm","http://en.wikipedia.org/wiki/Bresenham' ... timization","http://en.wikipedia.org/wiki/Bresenham's_circle_algorithm","http://en.wikipedia.org/wiki/Midp..._algorithm","http://en.wikipedia.org/wiki/Midpoint circle algorithm","http://en.wikipedia.org/wiki/Midpoint_circle_...","http://en.wikipedia.org/wiki/Midpoint_circle_algorithm","http://en.wikipedia.org/wiki/Midpoint_circle_algorithm#Optimization","http://en.wikipedia.org/wiki/Midpoint_circle_algorithm#Optimization.","http://en.wikipedia.org/wiki/Midpoint_circle_algorithm.","http://en.wikipedia.org/wiki/Midpoint_circle_algorithm>","http://en.wikipedia.org/wiki/Midpoint_circle_algorithmを","http://en.wikipedia.org/wiki/Midpoint_ci…","http://en.wikipedia.org/wiki/​Midpoint_circle_algorithm","http://fr.wikipedia.org/wiki/Algorit...e_de_Bresenham","http://fr.wikipedia.org/wiki/Algorithme_de_trac%C3%A9_d","kręgu algorytm Bresenhama","mid-point algorithm","midpoint algorithm","midpoint circle algorithm","midpoint circle algorithm,","midpoint circle algoritme","not his","standard circle drawing routines","standard midpoint circle algorithm","w:Midpoint circle algorithm","wikipedia > bresenham's circle algorithm","wikipedia article on Bresenham's circle algorithm","x n + 1 2 = ( x n - 1 ) 2","Википедия, Википедия","круг алгоритм Bresenham's","круга алгоритм Bresenham's","среднесрочному круг алгоритма","मध्य सर्कल एल्गोरिथ्म","ここ（Wikipedia（英語））","ミッドポイント円アルゴリズムを","中點圓算法"],"name":"Midpoint circle algorithm","categories":["All Wikipedia articles needing clarification","Articles with example C code","Articles with example JavaScript code","Digital geometry","Geometric algorithms","Wikipedia articles needing clarification from February 2009"],"tag_line":"In computer graphics, the midpoint circle algorithm is an algorithm used to determine the points needed for drawing a circle."}}
,{"_index":"throwtable","_type":"algorithm","_id":"visibility-polygon","_score":0,"_source":{"description":"In computational geometry, the visibility polygon or visibility region for a point p in the plane among obstacles is the possibly unbounded polygonal region of all points of the plane visible from p. The visibility polygon can also be defined for visibility from a segment, or a polygon. Visibility polygons are useful in robotics, video games, and in determining positions to locate facilities, such as the best placement of security guards in an art gallery.\nIf the visibility polygon is bounded then it is a star-shaped polygon. A visibility polygon is bounded if all rays shooting from the point eventually terminate in some obstacle. This is the case, e.g., if the obstacles are the edges of a simple polygon and p is inside the polygon. In the latter case the visibility polygon may be found in linear time.\n\n^ Franco P. Preparata and Michael Ian Shamos (1985). Computational Geometry - An Introduction. Springer-Verlag. 1st edition: ISBN 0-387-96131-3; 2nd printing, corrected and expanded, 1988: ISBN 3-540-96131-3; Russian translation, 1989: ISBN 5-03-001041-6. \n^ El Gindy, Hossam; Avis, David (1981). \"A linear algorithm for computing the visibility polygon from a point\". Journal of Algorithms 2 (2): 186–197. doi:10.1016/0196-6774(81)90019-5. \n^ Lee, D. T. (May 1983). \"Visibility of a simple polygon\". Computer Vision, Graphics, and Image Processing 22 (2): 207–221. doi:10.1016/0734-189X(83)90065-8. \n^ Joe, Barry; Simpson, R. B. (1987). \"Corrections to Lee's visibility polygon algorithm\". BIT Numerical Mathematics 27 (4): 458–473. doi:10.1007/BF01937271.","alt_names":["- Visibility polygon :","Learn about Visibility polygon>>>","Visibility polygon","Visibility polygon - Wikipedia, the free encyclopedia","Visibility polygon from Wikipedia","Wikipedia article about Visibility polygon","Wikipedia entry for Visibility polygon","http://en.Liarpedia.org/wiki/Visibility_polygon","http://en.wikipedia.org/wiki/Visibility polygon","http://en.wikipedia.org/wiki/Visibility_polygon","visibility polygon"],"name":"Visibility polygon","categories":["Geometric algorithms","Polygons"],"tag_line":"In computational geometry, the visibility polygon or visibility region for a point p in the plane among obstacles is the possibly unbounded polygonal region of all points of the plane visible from p. The visibility polygon can also be defined for visibility from a segment, or a polygon."}}
,{"_index":"throwtable","_type":"algorithm","_id":"simulated-fluorescence-process-algorithm","_score":0,"_source":{"description":"The Simulated Fluorescence Process (SFP) is a computing algorithm used for scientific visualization of 3D data from, for example, fluorescence microscopes. By modeling a physical light/matter interaction process an image is computed showing the data as it would have appeared in reality when viewed under these conditions.","alt_names":["Simulated Fluorescence Process","Simulated fluorescence process algorithm","Simulated fluorescence process algorithm - Wikipedia, the free ...","Simulated fluorescence process algorithm - Wikipedia, the free ... ...","Simulated fluorescence process algorithm by Wikipedia","What is principle of Simulated fluorescence process algorithm","Wikipedia article Simulated fluorescence process algorithm","Wikipedia article Simulated_fluorescence_process_algorithm","Wikipedia article on Simulated fluorescence process algorithm","Wikipedia entry for Simulated fluorescence process algorithm","http://en.wikipedia.org/wiki/Simulated_f","http://en.wikipedia.org/wiki/Simulated_fluorescence_process_algorithm","simulated fluorescence process algorithm","yago-res:Simulated fluorescence process algorithm"],"name":"Simulated fluorescence process algorithm","categories":["All articles covered by WikiProject Wikify","All articles lacking in-text citations","All articles with too few wikilinks","All stub articles","Articles covered by WikiProject Wikify from March 2015","Articles lacking in-text citations from December 2010","Articles with too few wikilinks from March 2015","Computational science","Computer graphics algorithms","Fluorescence","Microscopes","Microscopy","Simulation software stubs","Visualization (graphic)"],"tag_line":"The Simulated Fluorescence Process (SFP) is a computing algorithm used for scientific visualization of 3D data from, for example, fluorescence microscopes."}}
,{"_index":"throwtable","_type":"algorithm","_id":"prune-and-search","_score":0,"_source":{"description":"Prune and search is a method of solving optimization problems suggested by Nimrod Megiddo in 1983. \nThe basic idea of the method is a recursive procedure in which at each step the input size is reduced (\"pruned\") by a constant factor 0 < p < 1. As such, it is a form of decrease and conquer algorithm, where at each step the decrease is by a constant factor. Let n be the input size, T(n) be the time complexity of the whole prune-and-search algorithm, S(n) is the time complexity of the pruning step, then T(n) obeys the following recurrence relation:\n\nwhich has the solution T(n) = O(S(n)), since summing a geometric series only multiplies by a constant factor, namely \nIn particular, Megiddo himself used this approach in his linear time algorithm for the linear programming problem when the dimension is fixed and for the minimal enclosing sphere problem for a set of points in space.\n\n","alt_names":["Prune and search","Prune and search - Wikipedia :: The free encyclopedia","Prune and search - Wikipedia, the free encyclopedia","Prune and search Wikipedia the free encyclopedia","http://en.Liarpedia.org/wiki/Prune_and_search","http://en.wikipedia.org/wiki/Prune_and_search","prune and search"],"name":"Prune and search","categories":["Geometric algorithms","Linear programming"],"tag_line":"Prune and search is a method of solving optimization problems suggested by Nimrod Megiddo in 1983."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sgi-algorithm","_score":0,"_source":{"description":"The SGI algorithm creates triangle strips from a set of triangles. It was published by K. Akeley, P. Haeberli, and D. Burns as a C program named \"tomesh.c\" for use with Silicon Graphics' IRIS GL API.\nThe algorithm operates on the set of triangles that have not yet been added to a triangle strip, starting with the entire set of input triangles. Triangles are greedily added to a strip until no triangle is available that can be appended to the strip; a new strip will be started in this case. When choosing a triangle for starting or continuing a triangle strip, the selection is based on a triangle's degree (i.e. the number of triangles adjacent to it), with smaller degrees being preferred.\nIf implemented using a priority queue to quickly identify triangles that can start a new strip, the algorithm runs in linear time.","alt_names":["SGI algorithm","SGI algorithm - Wikipedia, the free encyclopedia","Tomesh.c","http://en.wikipedia.org/wiki/SGI_algorithm"],"name":"SGI algorithm","categories":["Computer graphics algorithms"],"tag_line":"The SGI algorithm creates triangle strips from a set of triangles."}}
,{"_index":"throwtable","_type":"algorithm","_id":"beier–neely-morphing-algorithm","_score":0,"_source":{"description":"Image morphing is a technique to synthesize a fluid transformation from one image (source image) to another (destination image). Source image can be one or more than one images. There are two parts in the image morphing implementation. The first part is warping and the second part is cross-dissolving.\nThe algorithm of Beier and Neely is a method to compute a mapping of coordinates between 2 images from a set of lines; i.e., the warp is specified by a set of line pairs where the start-points and end-points are given for both images. The algorithm is widely used within morphing software.\nAlso noteworthy, this algorithm only discussed about the situation with at most 2 source images as there are other algorithms introducing multiple source images.","alt_names":[],"name":"Beier–Neely morphing algorithm","categories":["Algorithms and data structures stubs","All stub articles","Computer graphics algorithms","Computer science stubs"],"tag_line":"Image morphing is a technique to synthesize a fluid transformation from one image (source image) to another (destination image)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"recursive-xy-cut","_score":0,"_source":{"description":"The recursive X-Y cut is a top-down page segmentation technique that decomposes a document image recursively into a set of rectangular blocks. The algorithm works by projecting the document bitmap (i.e. summing up all the pixels in a line) to the sides of the document page. By this method, a white space density graph is produced, with peaks for vertical or horizontal whitespace lines. These peaks define the cuts of the document and are used top-down to segment the document into smaller pieces.\n\n","alt_names":["Recursive XY cut","Recursive XY-cut","Recursive XY-cut - Wikipedia, the free encyclopedia","Wikipedia entry for Recursive XY-cut","http://en.wikipedia.org/wiki/Recursive_XY-cut"],"name":"Recursive XY-cut","categories":["All orphaned articles","All stub articles","Computer graphics algorithms","Computer science stubs","Orphaned articles from February 2009"],"tag_line":"The recursive X-Y cut is a top-down page segmentation technique that decomposes a document image recursively into a set of rectangular blocks."}}
,{"_index":"throwtable","_type":"algorithm","_id":"möller–trumbore-intersection-algorithm","_score":0,"_source":{"description":"The Möller–Trumbore ray-triangle intersection algorithm, named after its inventors Tomas Möller and Ben Trumbore, is a fast method for calculating the intersection of a ray and a triangle in three dimensions without needing precomputation of the plane equation of the plane containing the triangle. Among other uses, it can be used in computer graphics to implement ray tracing computations involving triangle meshes.","alt_names":[],"name":"Möller–Trumbore intersection algorithm","categories":["All stub articles","Computer science stubs","Geometric algorithms","Geometry","Geometry stubs"],"tag_line":"The Möller–Trumbore ray-triangle intersection algorithm, named after its inventors Tomas Möller and Ben Trumbore, is a fast method for calculating the intersection of a ray and a triangle in three dimensions without needing precomputation of the plane equation of the plane containing the triangle."}}
,{"_index":"throwtable","_type":"algorithm","_id":"godfried-toussaint","_score":0,"_source":{"description":"Godfried T. Toussaint is a Professor of Computer Science and the Head of the Computer Science Program at New York University Abu Dhabi (NYUAD) in Abu Dhabi, United Arab Emirates. He does research on various aspects of computational geometry, discrete geometry, and their applications: pattern recognition (k-nearest neighbor algorithm, cluster analysis), motion planning, visualization (computer graphics), knot theory (stuck unknot problem), linkage (mechanical) reconfiguration, the art gallery problem, polygon triangulation, the largest empty circle problem, unimodality (unimodal function), and others. Other interests include meander (art), compass and straightedge constructions, instance-based learning, music information retrieval, and computational music theory.\nHe is a co-founder of the Annual ACM Symposium on Computational Geometry, and the Annual Canadian Conference on Computational Geometry.\nAlong with Selim Akl, he is an author and namesake of the efficient \"Akl–Toussaint algorithm\" for the construction of the convex hull of a planar point set. This algorithm exhibits a computational complexity with expected value linear in the size of the input. In 1980 he introduced the relative neighborhood graph (RNG) to the fields of pattern recognition and machine learning, and showed that it contained the minimum spanning tree, and was a subgraph of the Delaunay triangulation. Three other well known proximity graphs are the nearest neighbor graph, the Urquhart graph, and the Gabriel graph. The first is contained in the minimum spanning tree, and the Urquhart graph contains the RNG, and is contained in the Delaunay triangulation. Since all these graphs are nested together they are referred to as the Toussaint hierarchy.","alt_names":["Books and book chapters","G. T. Toussaint","Godfried T. Toussaint","Godfried Toussaint","Godfried Toussaint - Wikipedia","Godfried Toussaint - Wikipedia :: The free encyclopedia","Godfried Toussaint - Wikipedia, the free encyclopedia","Godfried Toussaint,","Godfried Toussaint; it is used under the","Godfried_Toussaint","Mathematical research ...","Mathematical research in music","Toussaint, G. T.","Toussaint, Godfried","Toussaint, Godfried T.","What is Godfried Toussaint","Wikipedia article Godfried Toussaint","en.wikipedia.org/wiki/G._T._Toussaint","en.wikipedia.org/wiki/Godfried_Toussaint","http://en.wikipedia.org/wiki/Godfried_To","http://en.wikipedia.org/wiki/Godfried_Toussaint","http://it.wikipedia.org/wiki/Godfried_Toussaint"],"name":"Godfried Toussaint","categories":["Canadian computer scientists","Living people","McGill University faculty","New York University Abu Dhabi faculty","Researchers in geometric algorithms","Wikipedia articles with ISNI identifiers","Wikipedia articles with VIAF identifiers","Wikipedia articles with possible conflicts of interest from August 2010"],"tag_line":"Godfried T. Toussaint is a Professor of Computer Science and the Head of the Computer Science Program at New York University Abu Dhabi (NYUAD) in Abu Dhabi, United Arab Emirates."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bootstrap-aggregating","_score":0,"_source":{"description":"Bootstrap aggregating, also called bagging, is a machine learning ensemble meta-algorithm designed to improve the stability and accuracy of machine learning algorithms used in statistical classification and regression. It also reduces variance and helps to avoid overfitting. Although it is usually applied to decision tree methods, it can be used with any type of method. Bagging is a special case of the model averaging approach.","alt_names":["Bagging","- Bootstrap aggregating :","-> Read more about Bootstrap aggregating","...more on Wikipedia about Bootstrap Aggregating","BAGGING","Bagging – ויקיפדיה","Bootsrap Aggregating","Bootstrap Aggregating","Bootstrap Aggregating - Wikipedia, the free encyclopedia","Bootstrap Aggregation","Bootstrap aggregating","Bootstrap aggregating (Bagging)","Bootstrap aggregating (bagging)","Bootstrap aggregating - Wikipedia, the free ...","Bootstrap aggregating - Wikipedia, the free encyclopedia","Bootstrap aggregating - Wikipedia, the free encyclopediaBagging is","Bootstrap aggregating Wikipedia the free encyclopedia","Bootstrap aggregating Wikipedia the free encyclopedia - result","Bootstrap aggregating by Wikipedia","Bootstrap aggregating; it is used under the","Bootstrap aggregation","Bootstrap_Aggregating","Bootstrap_aggregating","Example: Ozone data","What is the history of Bootstrap Aggregating","Wikipedia article Bootstrap Aggregating","Wikipedia article Bootstrap aggregating","Wikipedia article on Bootstrap Aggregating","Wikipedia article on Bootstrap aggregating","Wikipedia article on bagging","Wikipedia entry for Bootstrap aggregating","Wikipedia: Bootstrap Aggregating","Wikipedia:Bootstrap_Aggregating","[9] Bootstrap aggregating","bagging or boosting","bootstrap aggregating","bootstrapping/bagging","en.wikipedia.org/...Bootstrap_aggregating","en.wikipedia.org/wiki/Bootstrap_aggregating","en:Bootstrap aggregating","http://en.wikipedia.org/wiki/Bootstrap_Aggregating","http://en.wikipedia.org/wiki/Bootstrap_a","http://en.wikipedia.org/wiki/Bootstrap_aggregating","http://en.wikipedia.org/wiki/Bootstrap_ag…","te BAGGING"],"name":"Bootstrap aggregating","categories":["Computational statistics","Ensemble learning","Machine learning algorithms"],"tag_line":"Bootstrap aggregating, also called bagging, is a machine learning ensemble meta-algorithm designed to improve the stability and accuracy of machine learning algorithms used in statistical classification and regression."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fastica","_score":0,"_source":{"description":"FastICA is an efficient and popular algorithm for independent component analysis invented by Aapo Hyvärinen at Helsinki University of Technology. Like most ICA algorithms, FastICA seeks an orthogonal rotation of prewhitened data, through a fixed-point iteration scheme, that maximizes a measure of non-Gaussianity of the rotated components. Non-gaussianity serves as a proxy for statistical independence, which is a very strong condition and requires infinite data to verify. FastICA can also be alternatively derived as an approximative Newton iteration.","alt_names":["- FastICA :","-> Leggi tutto l'articolo su 'FastICA'","-> Read the article about 'FastICA'","...more on Wikipedia about FastICA","Fast ICA","FastICA","FastICA - Wikipedia","FastICA - Wikipedia, the free encyclopedia","FastICA Wikipedia the free encyclopedia","FastICA by Wikipedia","FastICA package","Wikipedia article Fast ICA","Wikipedia article FastICA","Wikipedia entry for FastICA","Wikipedia:FastICA","fastICA","http://en.wikipedia.org/wiki/FastICA","http://en.wikipedia.org/wiki/Fast_ICA","http://it.wikipedia.org/wiki/FastICA","it:FastICA","the FastICA algorithm"],"name":"FastICA","categories":["All articles needing additional references","Articles needing additional references from April 2013","Computational statistics","Machine learning algorithms","Multivariate statistics"],"tag_line":"FastICA is an efficient and popular algorithm for independent component analysis invented by Aapo Hyvärinen at Helsinki University of Technology."}}
,{"_index":"throwtable","_type":"algorithm","_id":"jit-bose","_score":0,"_source":{"description":"Prosenjit K. \"Jit\" Bose is a Canadian mathematician and computer scientist who works at Carleton University as a professor in the School of Computer Science and associate dean of research and graduate studies for the Faculty of Science. His research concerns graph algorithms and computational geometry, including work on geometric spanners and geographic routing in wireless ad hoc networks.\nBose did his undergraduate studies in mathematics at the University of Waterloo, graduating in 1990, and earned a master's degree from Waterloo in 1991. He earned his Ph.D. in computer science from McGill University in 1994 under the supervision of Godfried Toussaint. After postdoctoral studies at the University of British Columbia, he became an assistant professor at the Université du Québec à Trois-Rivières in 1995, and moved to Carleton in 1997.\n\n","alt_names":[],"name":"Jit Bose","categories":["20th-century mathematicians","21st-century mathematicians","Canadian computer scientists","Canadian mathematicians","Carleton University faculty","Graph drawing people","Living people","McGill University alumni","Researchers in geometric algorithms","University of Waterloo alumni","Université du Québec à Trois-Rivières faculty","Year of birth missing (living people)"],"tag_line":"Prosenjit K. \"Jit\" Bose is a Canadian mathematician and computer scientist who works at Carleton University as a professor in the School of Computer Science and associate dean of research and graduate studies for the Faculty of Science."}}
,{"_index":"throwtable","_type":"algorithm","_id":"diffusion-map","_score":0,"_source":{"description":"Diffusion maps is a dimensionality reduction or feature extraction algorithm introduced by R. R. Coifman and S. Lafon. It computes a family of embeddings of a data set into Euclidean space (often low-dimensional) whose coordinates can be computed from the eigenvectors and eigenvalues of a diffusion operator on the data. The Euclidean distance between points in the embedded space is equal to the \"diffusion distance\" between probability distributions centered at those points. Different from linear dimensionality reduction methods such as principal component analysis (PCA) and multi-dimensional scaling (MDS), diffusion maps is part of the family of nonlinear dimensionality reduction methods which focus on discovering the underlying manifold that the data has been sampled from. By integrating local similarities at different scales, diffusion maps gives a global description of the data-set. Compared with other methods, the diffusion maps algorithm is robust to noise perturbation and is computationally inexpensive.\n^ \n^ \n^ \n^","alt_names":[],"name":"Diffusion map","categories":["Machine learning algorithms","Pages containing cite templates with deprecated parameters"],"tag_line":"Diffusion maps is a dimensionality reduction or feature extraction algorithm introduced by R. R. Coifman and S. Lafon."}}
,{"_index":"throwtable","_type":"algorithm","_id":"coffman–graham-algorithm","_score":0,"_source":{"description":"In job shop scheduling and graph drawing, the Coffman–Graham algorithm is an algorithm, named after Edward G. Coffman, Jr. and Ronald Graham, for arranging the elements of a partially ordered set into a sequence of levels. The algorithm chooses an arrangement such that an element that comes after another in the order is assigned to a lower level, and such that each level has a number of elements that does not exceed a fixed width bound W. When W = 2, it uses the minimum possible number of distinct levels, and in general it uses at most 2 − 2/W times as many levels as necessary.","alt_names":[],"name":"Coffman–Graham algorithm","categories":["Graph drawing","Optimization algorithms and methods","Scheduling algorithms"],"tag_line":"In job shop scheduling and graph drawing, the Coffman–Graham algorithm is an algorithm, named after Edward G. Coffman, Jr. and Ronald Graham, for arranging the elements of a partially ordered set into a sequence of levels."}}
,{"_index":"throwtable","_type":"algorithm","_id":"john-hershberger","_score":0,"_source":{"description":"John E. Hershberger (born 1959) is an American computer scientist and software professional, a principal engineer at Mentor Graphics Corporation since 1993. He is known for his research in computational geometry and algorithm engineering.","alt_names":[],"name":"John Hershberger","categories":["1959 births","American computer scientists","BLP articles lacking sources from January 2013","CS1 errors: chapter ignored","California Institute of Technology alumni","Fellows of the Association for Computing Machinery","Living people","People from Tigard, Oregon","Researchers in geometric algorithms"],"tag_line":"John E. Hershberger (born 1959) is an American computer scientist and software professional, a principal engineer at Mentor Graphics Corporation since 1993."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cn2-algorithm","_score":0,"_source":{"description":"The CN2 induction algorithm is a learning algorithm for rule induction. It is designed to work even when the training data is imperfect. It is based on ideas from the AQ algorithm and the ID3 algorithm. As a consequence it creates a rule set like that created by AQ but is able to handle noisy data like ID3.","alt_names":["CN2","CN2 - Wikipedia, the free encyclopedia","CN2 algorithm","CN2 algorithm - Wikipedia, the free encyclopedia","CN2 algorithm by Wikipedia","CN2_algorithm","Wikipedia entry for CN2","en.wikipedia.org/wiki/CN2","http://en.wikipedia.org/wiki/CN2","http://en.wikipedia.org/wiki/CN2_algorithm"],"name":"CN2 algorithm","categories":["All articles needing additional references","All stub articles","Articles needing additional references from September 2012","Artificial intelligence stubs","Machine learning algorithms"],"tag_line":"The CN2 induction algorithm is a learning algorithm for rule induction."}}
,{"_index":"throwtable","_type":"algorithm","_id":"non-negative-matrix-factorization","_score":0,"_source":{"description":"Non-negative matrix factorization (NMF), also non-negative matrix approximation is a group of algorithms in multivariate analysis and linear algebra where a matrix V is factorized into (usually) two matrices W and H, with the property that all three matrices have no negative elements. This non-negativity makes the resulting matrices easier to inspect. Also, in applications such as processing of audio spectrograms non-negativity is inherent to the data being considered. Since the problem is not exactly solvable in general, it is commonly approximated numerically.\nNMF finds applications in such fields as computer vision, document clustering, chemometrics, audio signal processing and recommender systems.\n^ \n^ Tandon, Rashish; Suvrit Sra (2010). \"Sparse nonnegative matrix approximation: new formulations and algorithms\" (PDF). TR. \n^ Wang, Wenwu (2010). \"Instantaneous Versus Convolutive Non-Negative Matrix Factorization: Models, Algorithms and Applications to Audio Pattern Separation\". In Wang, Wenwu. Machine Audition: Principles, Algorithms and Systems. IGI Global. pp. 353–370. doi:10.4018/978-1-61520-919-4.ch015. \n^ Rainer Gemulla, Erik Nijkamp, Peter J Haas, Yannis Sismanis (2011). Large-scale matrix factorization with distributed stochastic gradient descent (PDF). Proc. ACM SIGKDD Int'l Conf. on Knowledge discovery and data mining. pp. 69–77. \n^ Yang Bao et al. (2014). TopicMF: Simultaneously Exploiting Ratings and Reviews for Recommendation. AAAI.","alt_names":["...more on Wikipedia about Non-negative matrix factorization","Approximate nonnegative matrix factorization","How to apply for Non-negative matrix decomposition","NMF","NMF(Non-negative matrix factorization)","NNMA","NNMF","Nnegative matrix factorizati","Non Negative Matrix Factorization","Non negative matrix factorization","Non negative matrix factorization Wikipedia the free encyclopedia","Non- negative matrix factorization - Wikipedia, the free ...","Non-Negative Matrix Factorization","Non-negative Matrix Decomposition (NMF)","Non-negative Matrix Factorization","Non-negative Matrix Factorization - Wikipedia, The Free Encyclopedia","Non-negative factorisation.","Non-negative matrix approximation","Non-negative matrix factorisation (NMF)","Non-negative matrix factoriz...","Non-negative matrix factorization","Non-negative matrix factorization (NMF)","Non-negative matrix factorization - Wikipedia","Non-negative matrix factorization - Wikipedia :: The free encyclopedia","Non-negative matrix factorization - Wikipedia, the free ...","Non-negative matrix factorization - Wikipedia, the free encyc","Non-negative matrix factorization - Wikipedia, the free encyclop","Non-negative matrix factorization - Wikipedia, the free encyclopedia","Non-negative matrix factorization by Wikipedia","Non-negative_matrix_factorization","Nonnegative Matrix Factorization","Nonnegative Matrix Factorization (NMF)","Nonnegative Matrix Factorization (NNMF)","Nonnegative matrices factoring decomposition","Nonnegative matrix factorization","Positive matrix factorization","Read More nonnegative matrix factorization wikipedia the free","Relation to other Techniques","Self modeling curve resolution","What are applications of Approximate nonnegative matrix factorization","What are the different types of Non-negative","What are the different types of Positive matrix","What is the current research of Positive matrix","Wikipedia (Non-negative matrix factorization)","Wikipedia article Approximate nonnegative matrix factorization","Wikipedia article NMF","Wikipedia article Non-negative matrix factorization","Wikipedia entry for Non-negative matrix factorization","Wikipedia:Non-negative matrix factorization","en.wikipedia.org/...-negative_matrix_factorization","en.wikipedia.org/wiki/Non-n...","en.wikipedia.org/wiki/Non-negative_matrix_factorization","factorisation en matrices non-négatives","fatoração de matrizes não-negativas.","http://en.wikipedia.org/wiki/ Non-negative_matrix_ factorization","http://en.wikipedia.org/wiki/Non-negativ","http://en.wikipedia.org/wiki/Non-negative_matrix_f actorization","http://en.wikipedia.org/wiki/Non-negative_matrix_factorization","http://en.wikipedia.org/wiki/Non-negative_matrix_factorization#Text_m","http://en.wikipedia.org/wiki/Non-negative_matrix_factorization#Text_mining","http://en.wikipedia.org/wiki/Non-negative_matrix_factorization...","http://en.wikipedia.org/wiki/Non-negativ…","không âm ma trận Phân tích nhân.","la factorización no matriz negativa.","la non-factorisation de matrice négative.","nicht-negative Matrix-Faktorisierung.","non-negatif faktorisasi matriks.","non-negative factors","non-negative matrix factorisation","non-negative matrix factorization","non-negative matrix factorization (NMF)","non-negativi di fattorizzazione della matrice.","positive matrix factorization","více o NMF","неотрицательных матричной факторизации.","ไม่ matrix factorization ลบ.","“Non-negative matrix factorization - Wikipedia, the free”, en","非負矩陣分解","非負矩陣因子分解","非负矩阵分解","非负矩阵因子分解","非负矩阵因式分解"],"name":"Non-negative matrix factorization","categories":["All articles with unsourced statements","Articles with unsourced statements from April 2015","Linear algebra","Machine learning algorithms","Matrix theory","Multivariate statistics","Pages with URL errors","Vague or ambiguous time from April 2011"],"tag_line":"Non-negative matrix factorization (NMF), also non-negative matrix approximation is a group of algorithms in multivariate analysis and linear algebra where a matrix V is factorized into (usually) two matrices W and H, with the property that all three matrices have no negative elements."}}
,{"_index":"throwtable","_type":"algorithm","_id":"buddy-memory-allocation","_score":0,"_source":{"description":"The buddy memory allocation technique is a memory allocation algorithm that divides memory into partitions to try to satisfy a memory request as suitably as possible. This system makes use of splitting memory into halves to try to give a best-fit. According to Donald Knuth, the buddy system was invented in 1963 by Harry Markowitz, who won the 1990 Nobel Memorial Prize in Economics, and was first described by Kenneth C. Knowlton (published 1965). Buddy memory allocation is relatively easy to implement. It supports limited but efficient splitting and coalescing of memory blocks.","alt_names":["-> Read more about Buddy memory allocation","...more on Wikipedia about Buddy memory allocation","Buddy Allocation","Buddy Memory Allocation","Buddy Memory Allocation System","Buddy Memory Allocator","Buddy Pages","Buddy Speicherzuweisung","Buddy allocation","Buddy allocator","Buddy block allocators","Buddy blocks","Buddy concepts","Buddy memory allocation","Buddy memory allocation - Wikipedia :: The free encyclopedia","Buddy memory allocation - Wikipedia, the free encyclopedia","Buddy memory allocation - Wikipedia, the free encyclopedia ...","Buddy memory allocation - Wikipedia, the free…","Buddy memory allocation Wikipedia the free encyclopedia","Buddy memory allocation from Wikipedia","Buddy memory system","Buddy systemet","Buddy система","Buddy-Allocator","Buddy-Speicherverwaltung","Buddy-Speicherverwaltung – Wikipedia","Buddy-Verfahren","Buddy_memory_allocation","Byddy allocation system","How it works for Buddy memory allocation","Implementation and consequences","Knuth 1973","Kumpel Allocator","Wikipedia (Buddy memory allocation)","Wikipedia article ''Buddy memory allocation''","Wikipedia article Buddy memory allocation","Wikipedia article Buddy_memory_allocation","Wikipedia describes the algorithm","Wikipedia entry for Buddy memory allocation","Wikipedia-Artikel Buddy-Verfahren","Wikipedia-Seite zu 'Buddy-Speicherverwaltung'","Wikipedia-Seite zu 'Buddy-Verfahren'","algoritmul de alocare buddy","allocator Buddy","allocatore Buddy","allocatore buddy","allocazione di memoria di amici","alocador Buddy","alocação de memória do camarada","alokasi memori buddy","article Buddy memory allocation","asignación de memoria de amigos","asignador de Buddy","binary buddy block allocator","buddy algorithm","buddy allocation","buddy allocation system","buddy allocator","buddy allocator algorithm","buddy heap","buddy memory allocation","buddy memory allocation algorithm","buddy storage system","buddy-systeem","buddy-systemet","cấp phát Buddy","cấp phát bộ nhớ buddy","de:Buddy-Speicherverwaltung","en.wikipedia.org/wiki/Buddy_memory_al...","en.wikipedia.org/wiki/Buddy_memory_allocation","en:Buddy memory allocation","en:Buddy_memory_allocation","http://de.wikipedia.org/wiki/Buddy-Speicherverwaltung","http://de.wikipedia.org/wiki/Buddy-Verfa","http://de.wikipedia.org/wiki/Buddy-Verfahren","http://en.wikipedia.org/wiki/Buddy memory allocation","http://en.wikipedia.org/wiki/Buddy_memor","http://en.wikipedia.org/wiki/Buddy_memory_all...","http://en.wikipedia.org/wiki/Buddy_memory_allocation","http://it.wikipedia.org/wiki/Buddy_memory_allocation","hệ thống buddy","kamaráda alokátor","kammerat fordelingsnøgle","l'allocateur Buddy","l'allocation de mémoire copain","localización de memoria amiga","méthode similaire","pengalokasi Buddy","podzielnik kumpel","pt:Buddy memory allocation","sistem buddy","sistema buddy","sistema de camarada","sistema de compañeros","system partnerski","système de jumelage","приятель выделения памяти","приятель распределитель","приятель системы","распределитель Бадди","จัดสรรหน่วยความจำ buddy","ระบบ เพื่อน","バディアロケータは","バディアロケータを","バディシステム","バディシステムを","バディメモリの割り当て","伙伴算法","伙伴系统","哥们分配器","夥伴系統","好友內存分配","好友内存分配","好友分配","버디 할당자","친구 메모리 할당","친구가 시스템을"],"name":"Buddy memory allocation","categories":["Memory management algorithms","Use dmy dates from August 2012"],"tag_line":"The buddy memory allocation technique is a memory allocation algorithm that divides memory into partitions to try to satisfy a memory request as suitably as possible."}}
,{"_index":"throwtable","_type":"algorithm","_id":"online-machine-learning","_score":0,"_source":{"description":"Online machine learning is used when data becomes available in a sequential order to determine a mapping from data set corresponding labels. The difference between online learning and batch learning (or \"offline\" learning) techniques, is that in online learning the mapping is updated after the arrival of every new data point in a scale fashion, whereas batch techniques are used when one has access to the entire training data set at once. Online learning could be used in the case of a process occurring in time, for example the value of a stock given its history and other external factors, in which case the mapping updates as time goes on and we get more and more samples.\nIdeally in online learning, the memory needed to store the function remains constant even with added data points, since the solution computed at one step is updated when a new data point becomes available, after which that data point can then be discarded. For many formulations, for example nonlinear kernel methods, true online learning is not possible, though a form of hybrid online learning with recursive algorithms can be used. In this case, the space requirements are no longer guaranteed to be constant since it requires storing all previous data points, but the solution may take less time to compute with the addition of a new data point, as compared to batch learning techniques.\nAs in all machine learning problems, the goal of the algorithm is to minimize some performance criteria using a loss function. For example, with stock market prediction the algorithm may attempt to minimize the mean squared error between the predicted and true value of a stock. Another popular performance criterion is to minimize the number of mistakes when dealing with classification problems. In addition to applications of a sequential nature, online learning algorithms are also relevant in applications with huge amounts of data such that traditional learning approaches that use the entire data set in aggregate are computationally infeasible.","alt_names":["- Online machine learning :","Online Machine Learning (Wikipedia Article)","Online learning algorithms","Online machine learning","Online machine learning - Wikipedia :: The free encyclopedia","Online machine learning - Wikipedia, the free encyclopedia","Online machine learning Wikipedia the free encyclopedia","Online machine learning by Wikipedia","Online machine learning; it is used under the","Wikipedia article Online machine learning","Wikipedia entry for Online machine learning","en.wikipedia.org/...Online_machine_learning","en.wikipedia.org/wiki/Online_machine_...","en.wikipedia.org/wiki/Online_machine_learning","http://en.wikipedia.org/wiki/Online_machine_learning","online learner","online machine learning","online machine learning wikipedia the free encyclopedia","online-learning approach"],"name":"Online machine learning","categories":["All articles covered by WikiProject Wikify","All articles needing additional references","All pages needing cleanup","Articles covered by WikiProject Wikify from March 2014","Articles needing additional references from November 2008","Articles with inconsistent citation formats","Articles with weasel words from November 2012","Machine learning algorithms","Wikipedia introduction cleanup from March 2014"],"tag_line":"Online machine learning is used when data becomes available in a sequential order to determine a mapping from data set corresponding labels."}}
,{"_index":"throwtable","_type":"algorithm","_id":"coppersmith–winograd-algorithm","_score":0,"_source":{"description":"In linear algebra, the Coppersmith–Winograd algorithm, named after Don Coppersmith and Shmuel Winograd, was the asymptotically fastest known algorithm for square matrix multiplication until 2010. It can multiply two  matrices in  time  (see Big O notation). This is an improvement over the naïve  time algorithm and the  time Strassen algorithm. Algorithms with better asymptotic running time than the Strassen algorithm are rarely used in practice, because the large constant factors in their running times make them impractical. It is possible to improve the exponent further; however, the exponent must be at least 2 (because an  matrix has  values, and all of them have to be read at least once to calculate the exact result).\nIn 2010, Andrew Stothers gave an improvement to the algorithm,  In 2011, Virginia Williams combined a mathematical short-cut from Stothers' paper with her own insights and automated optimization on computers, improving the bound to  In 2014, François Le Gall simplified the methods of Williams and obtained an improved bound of \nThe Coppersmith–Winograd algorithm is frequently used as a building block in other algorithms to prove theoretical time bounds. However, unlike the Strassen algorithm, it is not used in practice because it only provides an advantage for matrices so large that they cannot be processed by modern hardware.\nHenry Cohn, Robert Kleinberg, Balázs Szegedy and Chris Umans have re-derived the Coppersmith–Winograd algorithm using a group-theoretic construction. They also showed that either of two different conjectures would imply that the optimal exponent of matrix multiplication is 2, as has long been suspected. However, they were not able to formulate a specific solution leading to a better running-time than Coppersmith-Winograd at the time.","alt_names":[],"name":"Coppersmith–Winograd algorithm","categories":["Matrix multiplication algorithms","Matrix theory","Numerical linear algebra","Use dmy dates from July 2013"],"tag_line":"In linear algebra, the Coppersmith–Winograd algorithm, named after Don Coppersmith and Shmuel Winograd, was the asymptotically fastest known algorithm for square matrix multiplication until 2010."}}
,{"_index":"throwtable","_type":"algorithm","_id":"user:quantares/sandbox","_score":0,"_source":{"description":"Online machine learning is a method of learning in which data becomes available in a sequential order and at each step we use the new data to update our best predictor for future data. In contrast to online learning, batch learning techniques generate the best predictor by learning on the entire training data set at once. Online learning is a common technique used in areas of machine learning where it is computationally infeasible to train over the entire dataset, requiring the need of out-of-core algorithms. It is also used in situations where we want the learning algorithm to dynamically adopt to new patterns in the data, or when the data itself is generated as a function of time e.g. stock price prediction.\nTwo general modelling strategies exist for Online Learning models: Statistical Learning models and Adverserial models. In statistical learning models, we assume that the data samples are i.i.d (i.e they are not adopting with time), and instead our algorithm just has a limited access to the data. Examples of algorithms in this model include stochastic gradient descent, perceptron, etc. In adverserial models, we instead look at our learning problem as a game between two players (the learner vs the data generator), and we are trying to minimize our losses regardless of the move played by the other player. In this model, the opponent is allowed to dynamically adopt the data generated based on the output of the learning algorithm. Spam filtering falls in this category, as the adversary will dynamically generate new spam based on the current behviour of the spam detector. Examples of algorithms in this model include follow the leader, follow the regularised leader etc.\n\n","alt_names":[],"name":"User:Quantares/sandbox","categories":["Articles with inconsistent citation formats","Machine learning algorithms","Noindexed pages","Pages with reference errors"],"tag_line":"Online machine learning is a method of learning in which data becomes available in a sequential order and at each step we use the new data to update our best predictor for future data."}}
,{"_index":"throwtable","_type":"algorithm","_id":"randomized-weighted-majority-algorithm","_score":0,"_source":{"description":"The randomized weighted majority algorithm is an algorithm in machine learning theory. It improves the mistake bound of the weighted majority algorithm.\nImagine that every morning before the stock market opens, we get a prediction from each of our \"experts\" about whether the stock market will go up or down. Our goal is to somehow combine this set of predictions into a single prediction that we then use to make a buy or sell decision for the day. The RWMA gives us a way to do this combination such that our prediction record will be nearly as good as that of the single best expert in hindsight.","alt_names":["43e3233ed5852e61ea0ead87b ...","Randomized weighted majority algorithm","Randomized weighted majority algorithm - Wikipedia, the free","Randomized weighted majority algorithm - Wikipedia, the free ...","Randomized weighted majority algorithm by Wikipedia","http://en.wikipedia.org/wiki/Randomized_weighted_majority_algorithm"],"name":"Randomized weighted majority algorithm","categories":["Machine learning algorithms"],"tag_line":"The randomized weighted majority algorithm is an algorithm in machine learning theory."}}
,{"_index":"throwtable","_type":"algorithm","_id":"prefrontal-cortex-basal-ganglia-working-memory","_score":0,"_source":{"description":"Prefrontal cortex basal ganglia working memory (PBWM) is an algorithm that models working memory in the prefrontal cortex and the basal ganglia. It can be compared to long short-term memory (LSTM) in functionality, but is more biologically explainable.\nIt uses the primary value learned value model to train prefrontal cortex working-memory updating system, based on the biology of the prefrontal cortex and basal ganglia.\nIt is used as part of the Leabra framework and was implemented in Emergent.","alt_names":[],"name":"Prefrontal cortex basal ganglia working memory","categories":["All articles lacking reliable references","All articles needing additional references","All articles with unsourced statements","Articles lacking reliable references from April 2015","Articles needing additional references from September 2015","Articles with unsourced statements from September 2015","Machine learning algorithms","Neuroscience","Vague or ambiguous time from September 2015"],"tag_line":"Prefrontal cortex basal ganglia working memory (PBWM) is an algorithm that models working memory in the prefrontal cortex and the basal ganglia."}}
,{"_index":"throwtable","_type":"algorithm","_id":"hexq","_score":0,"_source":{"description":"HEXQ is a reinforcement learning algorithm created by Bernhard Hengst, which attempts to solve a Markov Decision Process by decomposing it hierarchically.\nBernhard Hengst (2002). \"Discovering Hierarchy in Reinforcement Learning with HEXQ\".","alt_names":["HEXQ","HEXQ - Wikipedia, the free encyclopedia","HEXQ by Wikipedia","Source Wikipedia.org Arcticle - HEXQ","Wikipedia article HEXQ","Wikipedia entry for HEXQ","http://en.wikipedia.org/wiki/HEXQ"],"name":"HEXQ","categories":["All orphaned articles","All stub articles","Computer science stubs","Machine learning algorithms","Orphaned articles from February 2009"],"tag_line":"HEXQ is a reinforcement learning algorithm created by Bernhard Hengst, which attempts to solve a Markov Decision Process by decomposing it hierarchically."}}
,{"_index":"throwtable","_type":"algorithm","_id":"wake-sleep-algorithm","_score":0,"_source":{"description":"The wake-sleep algorithm is an unsupervised learning algorithm for a stochastic multilayer neural network. The algorithm adjusts the parameters so as to produce a good density estimator. There are two learning phases, the “wake” phase and the sleep “sleep” phase, which are performed alternately. It was first designed as a model for brain functioning using Variational Bayesian Learning. After that, the algorithm was adapted to machine learning. It can be viewed as a way to train a Helmholtz Machine","alt_names":[],"name":"Wake-sleep algorithm","categories":["Machine learning algorithms"],"tag_line":"The wake-sleep algorithm is an unsupervised learning algorithm for a stochastic multilayer neural network."}}
,{"_index":"throwtable","_type":"algorithm","_id":"nagle's-algorithm","_score":0,"_source":{"description":"Nagle's algorithm, named after John Nagle, is a means of improving the efficiency of TCP/IP networks by reducing the number of packets that need to be sent over the network.\nNagle's document, Congestion Control in IP/TCP Internetworks (RFC 896) describes what he called the \"small packet problem\", where an application repeatedly emits data in small chunks, frequently only 1 byte in size. Since TCP packets have a 40 byte header (20 bytes for TCP, 20 bytes for IPv4), this results in a 41 byte packet for 1 byte of useful information, a huge overhead. This situation often occurs in Telnet sessions, where most keypresses generate a single byte of data that is transmitted immediately. Worse, over slow links, many such packets can be in transit at the same time, potentially leading to congestion collapse.\nNagle's algorithm works by combining a number of small outgoing messages, and sending them all at once. Specifically, as long as there is a sent packet for which the sender has received no acknowledgment, the sender should keep buffering its output until it has a full packet's worth of output, so that output can be sent all at once.","alt_names":["en.wikipedia.org/wiki/..._algorithm","Nagling","nagle","http://en.wikipedia.org/wiki/Nagle's_algorithm","Nagle's Algorithm","Nagle's algorithm","Nagle's Algorithm.","-> Read more about Nagle's algorithm","...Wikipedia Algoritmo di Nagle","...mehr auf Wikipedia über Nagle-Algorithmus","...more on Wikipedia about Nagle's algorithm","ACK de conecciÃ³n","ACK de conección","ACK延迟","Algorithme de Nagle","Algoritmo de Nagle","Algoritmo di Nagle","Algoritmo di Nagle - Wikipedia","Algoritmu' lu' Nagle","Algorythme de Nagle","Algorytm Nagle się","Algorytm Nagle'a","Algorytm Nagle'a â�“ Wikipedia, wolna encyklopedia","Algorytm Nagle'a Ă˘€“ Wikipedia, wolna encyklopedia","Meistens nicht","Nagel algorithm","Nagel's algorithm","Naggle","Naggle algorithm","Naggle's","Nagle Algoithmus","Nagle Algorithm","Nagle Algorithm 算法描述的是什么东西？","Nagle Algorithm.","Nagle Algorithmus","Nagle Algorithmus – Wikipedia","Nagle Algorythym...","Nagle algorithm","Nagle algorithm.","Nagle algoritme","Nagle algoritmoa","Nagle algoritmoa - Wikipedia, entziklopedia askea.","Nagle algoritmus","Nagle algorytm","Nagle delay","Nagle s algorithm Wikipedia the free encyclopedia","Nagle s algorithm Wikipedia the free encyclopedia - result","Nagle sur Wikipédia","Nagle एल्गोरिथ्म","Nagle है एल्गोरिथ्म","Nagle 算法","Nagle 알고리즘(영어)","Nagle's Algorithm (used to avoid Silly Window Syndrome","Nagle's Algorithm - Wikipedia, The Free Encyclopedia","Nagle's Algorithm on Wikipedia.","Nagle's Algorithm?","Nagle's Algorthm","Nagle's Alogrithm","Nagle's algorithm - Wikipedia :: The free encyclopedia","Nagle's algorithm - Wikipedia, the free ...","Nagle's algorithm - Wikipedia, the free encyclopedia","Nagle's algorithm - Wikipedia, the free encyclopedia »","Nagle's algorithm @ Wikipedia","Nagle's algorithm Wikipedia, the free ...","Nagle's algorithm is used to increase the efficiency","Nagle's algoritme","Nagle's buffering algorithm","Nagle's solution","Nagle's_algorithm","Nagle-Algorithmus","Nagle-Algorithmus - Wikipedia","Nagle-Algorithmus ? Wikipedia","Nagle-Algorithmus – Wikipedia","Nagle-Alogrithmus","Nagle-like","Nagle?s algorithm","Nagle`s algoritm","Nagled","Nagleing","Nagles","Nagles Alogorithm","Nagles Delay","Nagles algorithm","Nagleのアルゴリズム","Nagleのアルゴリズムは、","Nagleのアルゴリズムを参照","Nagleアルゴリズムを","Nagle的算法","Nagle算法","Naglův algoritmus","Pour ceux qui ont le courrage","See Wikipedia's definition.","TCP_NODELAY","TCP_NODELAYをの","TCP_NODELAY套","TCP_NODELAY의","Unless Wikipedia is horribly wrong or getting mangled","Wikiepdia Nagle's Algorithm","Wikipedia Algoritmo de Nagle","Wikipedia article Algorithme de Nagle","Wikipedia article Algorytm Nagle'a","Wikipedia article Nagle algorithm","Wikipedia article Nagle's algorithm","Wikipedia article on Algoritmo de Nagle","Wikipedia-Artikel Nagle-Algorithmus","Wikipedia-Seite zu 'Nagle-Algorithmus'","Wikipedia: Nagle's algorithm","Wikipedia:Algoritmo_di_Nagle","[13] Nagle's algorithm","[url=http://en.wikipedia.org/wiki/Nagle]","agle's algorithm","alGORytMOO NAgLe'A","algorithme Nagle","algorithme de Nagle","algoritmo Nagle","algoritmo de Nagle","algoritmo di Nagle","algoritmus Nagle","algorytm Nagle","algorytm Nagle'a","algorytmu Nagle'a","artículo de Wikipedia Algoritmo de Nagle","combine multiple application-level messages into a single","el algoritmo de Nagle","en.wikipedia.org/wiki/Nagle%27s_algorithm","en.wikipedia.org/wiki/Nagle's_algorithm","es:Algoritmo de Nagle","eu:Nagle algoritmoa","fr:Algorithme de Nagle","gle's algorithm [","he:האלגוריתם של נייגל","het algoritme van Nagle","http://de.wikipedia....gle-Algorithmus","http://de.wikipedia.org/wiki/Nagle-Algor","http://de.wikipedia.org/wiki/Nagle-Algorithmus","http://en.wikipedia....e%27s_algorithm","http://en.wikipedia.org/wiki/Nagel_algorithm","http://en.wikipedia.org/wiki/Nagle%27s_Algorithm","http://en.wikipedia.org/wiki/Nagle%27s_algori...","http://en.wikipedia.org/wiki/Nagle%27s_algorithm","http://en.wikipedia.org/wiki/Nagle%27s_algorithm#Interactions_with_real","http://en.wikipedia.org/wiki/Nagle's algorithm","http://en.wikipedia.org/wiki/Nagle's algorithm.","http://en.wikipedia.org/wiki/Nagle's...l-time_systems","http://en.wikipedia.org/wiki/Nagle's_Algorithm","http://en.wikipedia.org/wiki/Nagle_algorithm","http://en.wikipedia.org/wiki/Nagle_algor…","http://es.wikipedia.org/wiki/Algoritmo_de_Nagle","http://fr.wikipedia.org/wiki/Algorithme_de_Nagle","http://it.wikipedia.org/wiki/Algoritmo_di_Nagle","http://pl.wikipedia.org/wiki/Algorytm_Nagle%27a","http://pl.wikipedia.org/wiki/Algorytm_Nagle'a","l'algo de Nagle","l'algorithme Nagle","l'algorithme de Nagle","l'algoritmo Nagle","l'algoritmo di Nagle","le lien anglais est plus complet et explique","naggle","nagle algorithm","nagle's algorithm","nagle,","nagling","pl:Algorytm Nagle'a","reference 11:51 AM","se Nagle's Algoritme","see Nagle's Algorithm","this John Nagle","thttp://en.wikipedia.org/wiki/Nagle_algorithm","to algorytm Nagle","vedere Algoritmo di Nagle","ver algoritmo de Nagle","vgl. Nagle-Algorithmus","viz Nagle algoritmus","wiki article about Nagle's algorithm","zh:納格算法","zie Nagle's Algorithm","zobacz Algorytm Nagle się","Алгоритм Нагла","Алгоритм Нейгла","алгоритм Nagle","алгоритм Нагла","алгоритм Нейгла","алгоритм им. Джона Нагля, RFC896","алгоритму нагла","см. алгоритм Нэгла","האלגוריתם של נייגל","האלגוריתם של נייגל – ויקיפדיה","ויקיפדיה - 'האלגוריתם של נייגל'","एल्गोरिथ्म Nagle देखते हैं","बचने कर सकते","है देखना","हैं Nagle","“Nagle Algorithm”","のNagleアルゴリズムを","ネーグルのアルゴリズム","納格算法","见Nagle算法"],"name":"Nagle's algorithm","categories":["All articles needing additional references","Articles needing additional references from June 2014","Networking algorithms","Transmission Control Protocol"],"tag_line":"Nagle's algorithm, named after John Nagle, is a means of improving the efficiency of TCP/IP networks by reducing the number of packets that need to be sent over the network."}}
,{"_index":"throwtable","_type":"algorithm","_id":"token-bucket","_score":0,"_source":{"description":"The token bucket is an algorithm used in packet switched computer networks and telecommunications networks. It can be used to check that data transmissions, in the form of packets, conform to defined limits on bandwidth and burstiness (a measure of the unevenness or variations in the traffic flow). It can also be used as a scheduling algorithm to determine the timing of transmissions that will comply with the limits set for the bandwidth and burstiness: see network scheduler.","alt_names":["( en )Token bucket","(Wiki) トークンバケット","- Token bucket :","-Token","...Wikipedia HTB","A token bucket","HTB - Hierarchical Token Bucket","HTB to algorytm kolejkowania ruchu na routerze działającym","Hierarchical Token Bucket","Hierarchical Token Bucket ? Wikipedia, wolna encyklopedia","Hierarchical Token Bucket – Wikipedia, wolna encyklopedia","Hierarchical token bucket","Hierarchical_Token_Bucket","High level view","The token bucket algorithm","Token Bucket","Token Bucket (Алгоритм текущего ведра)","Token Bucket Algorithm","Token Bucket Algorithmus","Token Bucket Regulator","Token Bucket algorithm","Token Bucket algorithm *","Token Bucket protocol","Token Buckets","Token bucket","Token bucket - Wikipedia","Token bucket - Wikipedia, l'enciclopedia libera","Token bucket - Wikipedia, the free encyclopedia","Token bucket Wikipedia","Token bucket Wikipedia the free encyclopedia","Token bucket – Wikipedia, the free encyclopedia","Token bucket; it is used under the","Token buckets","Token kbelík","Token-Bucket-","Token-Bucket-Algorithmus","Token-Bucket-Algorithmus ? Wikipedia","Token-Bucket-Algorithmus Wikipedia","Token-Bucket-Algorithmus bei der wikipedia","Token-Bucket-Algorithmus – Wikipedia","Token-Bucket-Nutzung.","Token-Bucket-oder","Token-bucket Algorithmus","TokenBucket","Token_bucket","Traffic shaping algorithms (leaky bucket versus token bucket","Wikipedia article Hierarchical Token Bucket","Wikipedia article Token Bucket","Wikipedia article Token bucket","Wikipedia entry for Token bucket","Wikipedia-Artikel Token-Bucket-Algorithmus","Wikipediaで「トークンバケット」を調べる","Wikipédia artigo Token Bucket","balde de","bucket algorithm","colector de testigos","cubeta con ficha","cubeta con tokens","cubo de token de","de:Token-Bucket-Algorithmus","ember token","ember token.","en.wikipedia.org/...Token_bucket","en.wikipedia.org/wiki/Token_bucket","en:Hierarchical Token Bucket","en:Token bucket","htb","http://de.wikipedia.org/wiki/Token-Bucke","http://de.wikipedia.org/wiki/Token-Bucket-Algorithmus","http://de.wikipedia.org/wiki/Token_Bucket","http://en.wikipedia.org/wiki/Hierarchical_Token_Bucket","http://en.wikipedia.org/wiki/Hierarchical_Token_Bucket#Hierarchical_Token_Bucket","http://en.wikipedia.org/wiki/Hierarchical_Token_Bucket#Hierarchical_Token_Bucket.3D","http://en.wikipedia.org/wiki/Token_","http://en.wikipedia.org/wiki/Token_Bucket","http://en.wikipedia.org/wiki/Token_bucke","http://en.wikipedia.org/wiki/Token_bucket","http://en.wikipedia.org/wiki/Token_bucket#Hierarchical_token[..]","http://en.wikipedia.org/wiki/Token_bucket#Hierarchical_token_bucket","http://en.wikipedia.org/wiki/Token_bucket#Hierarchical_token_bucket,","http://en.wikipedia.org/wiki/Token_bucket#Traffic_shaping_algorithms_.28leaky_bucket_versus_token_bucket","http://en.wikipedia.org/wiki/Token_bucket.","http://en.wikipedia.org/wiki/Token_bucke…","http://it.wikipedia.org/wiki/Token_bucket","http://pl.wikipedia.org/wiki/HTB","http://pl.wikipedia.org/wiki/HTB »","http://pl.wikipedia.org/wiki/Hierarchical_Token_Bucket","http://pl.wikipedia.org/wiki/Hierarhical_Token_Bucket","http://pt.wikipedia.org/wiki/Token_Bucket","http://ru.wikipedia.org/wiki/Алгоритм_текущего_ведра","ja:トークンバケット","monedero virtual.","pl:Hierarchical Token Bucket","pt:Token Bucket","ru:Алгоритм текущего ведра","seau de jetons","seau de jetons,","seau de jetons.","secchio di token.","secchio token","tanda ember,","the Wikipedia article on token buckets","the token bucket algorithm","thùng token","thùng token.","token bucket","token bucket algorithm","token bucket,","token bucket.","token buckets","token kbelík","token spanden","token-bucket","token-bucket algorithm","token-bucketed","token-emmer","tokenbucketed","wikipedia /HTB »","wikipediaの記事:トークンバケット","xô","Алгоритм текущего ведра","Алгоритм текущего ведра — Википедия","алгоритм текущего ведра","знак ведро","знак ведро.","ถัง token","ถัง token.","トークンバケット","トークンバケット - Wikipedia","トークンバケットは、","バケットと","令牌","令牌桶","令牌桶算法","토큰 버킷","토큰을 양동이,","토큰을 양동이를","ﾄｰｸﾝﾊﾞｹｯﾄ-wikipedia"],"name":"Token bucket","categories":["All articles to be expanded","Articles to be expanded from June 2008","Network performance","Network scheduling algorithms"],"tag_line":"The token bucket is an algorithm used in packet switched computer networks and telecommunications networks."}}
,{"_index":"throwtable","_type":"algorithm","_id":"class-based-queueing","_score":0,"_source":{"description":"Class-based queuing (CBQ) is a queuing discipline for the network scheduler that allows traffic to share bandwidth equally, after being grouped by classes. The classes can be based upon a variety of parameters, such as priority, interface, or originating program.\nCBQ is a traffic management algorithm developed by the Network Research Group at Lawrence Berkeley National Laboratory as an alternative to traditional router-based technology. Now in the public domain as an open technology, CBQ is deployed by companies at the boundary of their WANs.\nCBQ divides user traffic into a hierarchy of classes based on any combination of IP addresses, protocols and application types. A company's accounting department, for example, may not need the same Internet access privileges as the engineering department. Because every company is organized differently and has different policies and business requirements, it is vital for traffic management technology to provide flexibility and granularity in classifying traffic flows.\nCBQ lets network managers classify traffic in a multilevel hierarchy. For instance, some companies may first identify the overall needs of each department or business group, and then define the requirements of each application or group of applications within each department. For performance and architectural reasons, traditional router-based queuing schemes are limited to a small number of classes and only allow one-dimensional classification.\nBecause it operates at the IP network layer, CBQ provides the same benefits across any Layer 2 technology and is equally effective with any IP protocol, such as Transmission Control Protocol (TCP) and User Datagram Protocol (UDP). It also operates with any client or server TCP/IP stack variation, since it takes advantage of standard TCP/IP flow control mechanisms to control end-to-end traffic.\nAn implementation is available under the GNU General Public License for the Linux kernel.","alt_names":[],"name":"Class-based queueing","categories":["All stub articles","Computer network stubs","Computer networking","Network scheduling algorithms"],"tag_line":"Class-based queuing (CBQ) is a queuing discipline for the network scheduler that allows traffic to share bandwidth equally, after being grouped by classes."}}
,{"_index":"throwtable","_type":"algorithm","_id":"random-early-detection","_score":0,"_source":{"description":"Random early detection (RED), also known as random early discard or random early drop is a queueing discipline for a network scheduler suited for congestion avoidance.\nIn the conventional tail drop algorithm, a router or other network component buffers as many packets as it can, and simply drops the ones it cannot buffer. If buffers are constantly full, the network is congested. Tail drop distributes buffer space unfairly among traffic flows. Tail drop can also lead to TCP global synchronization as all TCP connections \"hold back\" simultaneously, and then step forward simultaneously. Networks become under-utilized and flooded by turns. RED addresses these issues.","alt_names":["Random Early Detection","...more on Wikipedia about Random early detection","RED-Algorithmus","Random Early Detection (RED)","Random Early Detection - RED","Random Early Discard","Random Early Drop","Random early detection","Random early detection - Wikipedia ...","Random early detection - Wikipedia, the free encyclopedia","Random early detection Wikipedia the free encyclopedia","Random early detection from Wikipedia","Random early detection – Wikipedia","Random early detection – Wikipedia, wolna encyklopedia","Random early detection — Википедия","Random early detection: Other Variants","Random_Early_Detection","Random_early_detection","Rilevazione casuale anticipata","Wikipedia article Random Early Detection","Wikipedia article Random early detection","Wikipedia article Random early drop","Wikipedia entry for Random early detection","Wikipedia-Artikel Random early detection","Wikipedia-Artikel Random early drop","Wikipediaで「ランダム初期検知」を調べる","continue reading http://en.wikipedia.org/wiki/Random_early_detection","de:Random early detection","en.wikipedia.org/wiki/Random_early_de...","en.wikipedia.org/wiki/Random_early_detection","http://de.wikipedia.org/wiki/Random_earl","http://de.wikipedia.org/wiki/Random_early_detection","http://de.wikipedia.org/wiki/Random_early_drop","http://en.wikipedia.org/wiki/Random_earl","http://en.wikipedia.org/wiki/Random_early_detec...","http://en.wikipedia.org/wiki/Random_early_detection","http://en.wikipedia.org/wiki/Random_early_drop","http://pl.wikipedia.org/wiki/RED","http://pl.wikipedia.org/wiki/Random_early_detection","http://ru.wikipedia.org/wiki/Random_early_detection","ja:ランダム初期検知","random early detection","ru:Random early detection","uk:Random early detection","Произвольное Раннее Обнаружение","ランダム初期廃棄 - Wikipedia","ランダム初期検知","ランダム初期検知 - Wikipedia"],"name":"Random early detection","categories":["Network performance","Network scheduling algorithms"],"tag_line":"Random early detection (RED), also known as random early discard or random early drop is a queueing discipline for a network scheduler suited for congestion avoidance."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fair-queuing","_score":0,"_source":{"description":"Fair queuing is a family of scheduling algorithms used in some process and network schedulers. The concept implies a separate data packet queue (or job queue) for each traffic flow (or for each program process) as opposed to the traditional approach with one FIFO queue for all packet flows (or for all process jobs). The purpose is to achieve fairness when a limited resource is shared, for example to avoid that flows with large packets (or processes that generate small jobs) achieve more throughput (or CPU time) than other flows (or processes).\nFair queuing is implemented in some advanced packet switches and routers.","alt_names":["- Fair queueing :","- Fair queuing :","...mehr auf Wikipedia über Fair-Queuing","FAIR QUEUEING","Fair Queuing","Fair load balancing","Fair queueing","Fair queueing; it is used under the","Fair queuing","Fair queuing (ou quase isso)","Fair queuing - Wikipedia, the free encyclopedia","Fair scheduling","Fair-Queuing","Fair-Queuing – Wikipedia","Fair_queueing","Fair_queuing","Fair_queuing)","Wikipedia article Fair queueing","Wikipedia article Fair queuing","Wikipedia article Fair scheduling","Wikipedia article on Fair Queuing","Wikipedia article on Fair queuing","Wikipedia entry for Fair queuing","Wikipedia-Artikel Fair-Queuing","air queuing","en.wikipedia.org/wiki/Fair_queuing","fair queueing","fair queuing","fair queuing algorithms family","fair queuing.","http://de.wikipedia.org/wiki/Fair-Queuin","http://de.wikipedia.org/wiki/Fair-Queuing","http://en.wikipedia.org/wiki/Fair_Queuing","http://en.wikipedia.org/wiki/Fair_queueing","http://en.wikipedia.org/wiki/Fair_queuin","http://en.wikipedia.org/wiki/Fair_queuing"],"name":"Fair queuing","categories":["Network scheduling algorithms"],"tag_line":"Fair queuing is a family of scheduling algorithms used in some process and network schedulers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"weighted-fair-queueing","_score":0,"_source":{"description":"Weighted fair queueing (WFQ) is a data packet scheduling algorithm used by network schedulers. WFQ is both a packet based implementation of the generalized processor sharing policy (GPS), and a natural generalization of fair queuing (FQ): whereas FQ shares the link's capacity in equal subparts, WFQ allows to specify, for each flow, which fraction of the capacity will be given.\nWeighted fair queuing (WFQ) is also known as Packet-by-Packet GPS (PGPS or P-GPS) since it approximates generalized processor sharing \"to within one packet transmission time, regardless of the arrival patterns.\"\nIn WFQ, a scheduler handling N flows is configured with one weight  for each flow. Then, the flow of number i will achieve an average data rate of . A WFQ scheduler where all weights are equals is a FQ scheduler.\nLike all fair-queuing schedulers, each flow is protected from the others, and it can be proven that if a data flow is leaky bucket constrained, an end-to-end delay bound can be guaranteed.","alt_names":[],"name":"Weighted fair queueing","categories":["Network scheduling algorithms"],"tag_line":"Weighted fair queueing (WFQ) is a data packet scheduling algorithm used by network schedulers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"backpressure-routing","_score":0,"_source":{"description":"In queueing theory, a discipline within the mathematical theory of probability, the backpressure routing algorithm is a method for directing traffic around a queueing network that achieves maximum network throughput, which is established using concepts of Lyapunov drift. Backpressure routing considers the situation where each job can visit multiple service nodes in the network. It is an extension of max-weight scheduling where rather each job visits only a single service node.","alt_names":[],"name":"Backpressure routing","categories":["Networking algorithms","Queueing theory","Routing algorithms"],"tag_line":"In queueing theory, a discipline within the mathematical theory of probability, the backpressure routing algorithm is a method for directing traffic around a queueing network that achieves maximum network throughput, which is established using concepts of Lyapunov drift."}}
,{"_index":"throwtable","_type":"algorithm","_id":"expected-transmission-count","_score":0,"_source":{"description":"The ETX metric, or expected transmission count, is a measure of the quality of a path between two nodes in a wireless packet data network. It is used extensively in mesh networking algorithms.","alt_names":[],"name":"Expected transmission count","categories":["Routing algorithms","Wireless networking"],"tag_line":"The ETX metric, or expected transmission count, is a measure of the quality of a path between two nodes in a wireless packet data network."}}
,{"_index":"throwtable","_type":"algorithm","_id":"binary-gcd-algorithm","_score":0,"_source":{"description":"The binary GCD algorithm, also known as Stein's algorithm, is an algorithm that computes the greatest common divisor of two nonnegative integers. Stein's algorithm uses simpler arithmetic operations than the conventional Euclidean algorithm; it replaces division with arithmetic shifts, comparisons, and subtraction. Although the algorithm was first published by the Israeli physicist and programmer Josef Stein in 1967, it may have been known in 1st-century China.","alt_names":["-> Read the article about 'Binary GCD algorithm'","...mehr auf Wikipedia über Steinscher Algorithmus","...more on Wikipedia about Binary GCD algorithm","1)бинарный алгоритм","Binary GCD","Binary GCD (Stern's) Algorithm - C++ - From WikiPedia","Binary GCD Algorithm","Binary GCD algorithm","Binary GCD algorithm - Wikipedia :: The free encyclopedia","Binary GCD algorithm - Wikipedia, the free encyclopedia","Binary GCD algorithm - Wikipedia, the free encyclopedia ...","Binary GCD ·","Binary gcd","Binary gcd algorithm","Binary-Gcd","CMMDC binar","Port of code from wikipedia","Stein algorithm","Steinscher Algorithmus","Stein算法","The binary GCD algorithm","This GCD Loop (in C)","What is Binary GCD algorithm's implementation","What is Binary GCD algorithm's implementation?","Wikipedia article Binary GCD algorithm","Wikipedia article Binary gcd","Wikipedia entry for Binary GCD algorithm","Wikipedia-Artikel Steinscher Algorithmus","Wikipedia-Seite zu 'Steinscher Algorithmus'","Wikipedia::Binary GCD algorithm","a version for binary computers","binaire GCD","binaria GCD","binario GCD","binarnych GCD","binary GCD","binary GCD algorithm","binary algorithm","binary gcd","binary gcd algorithm","binary greatest common denominator algorithm","binary version","binární GCD","binäre GCD","binære GCD","c) Steinscher Algorithmus","d) Binary GCD algorithm","de:Steinscher Algorithmus","en.wikipedia.org/wiki/Binary_GCD_algorithm","en:binary GCD algorithm","http://de.wikipedia.org/wiki/Steinscher_","http://de.wikipedia.org/wiki/Steinscher_Algorithmus","http://en.wikipedia....y_GCD_algorithm","http://en.wikipedia.org/wiki/Binary_GCD_","http://en.wikipedia.org/wiki/Binary_GCD_algorithm","http://en.wikipedia.org/wiki/Binary_GCD_algorithm#Implementation_in_C","http://en.wikipedia.org/wiki/Binary_GCD_…","http://en.wikipedia.org/wiki/Binary_gcd","http://ru.wikipedia.org/wiki/Бинарны...нахождения_НОД","http://ru.wikipedia.org/wiki/Бинарный_ал...","ko:이진 최대공약수 알고리즘","l'algoritmo di Stein","om Wikipedia::Binary GCD algorithm","ru.wikipedia.org/wiki/Бинарный_алгоритм_...","ru:Бинарный алгоритм нахождения НОД","specialized algorithm for computers","steinsche Algorithmus","steinschen Algorithmus","the binary one","w:Бинарный алгоритм нахождения НОД","Бинарный алгоритм вычисления НОД","Бинарный алгоритм нахождения НОД","Википедия про НОД","Выглядит","бинарные НОД","бинарный алгоритм Евклида","двоичного нод","двоичный вариант","पर विचार","→ Статья «Бинарный алгоритм нахождения НОД»","バイナリGCDを","二进制GCD的","이진 최대공약수 알고리즘","이진 최대공약수 알고리즘 - 위키백과, 우리 ...","한국어위키백과-이진 최대공약수 알고리즘"],"name":"Binary GCD algorithm","categories":["All articles with unsourced statements","Articles with example C code","Articles with unsourced statements from March 2014","Number theoretic algorithms"],"tag_line":"The binary GCD algorithm, also known as Stein's algorithm, is an algorithm that computes the greatest common divisor of two nonnegative integers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pohlig–hellman-algorithm","_score":0,"_source":{"description":"In number theory, the Pohlig–Hellman algorithm sometimes credited as the Silver–Pohlig–Hellman algorithm is a special-purpose algorithm for computing discrete logarithms in a multiplicative group whose order is a smooth integer.\nThe algorithm was discovered by Roland Silver, but first published by Stephen Pohlig and Martin Hellman (independent of Silver).\nWe will explain the algorithm as it applies to the group Z*p consisting of all the elements of Zp which are coprime to p, and leave it to the advanced reader to extend the algorithm to other groups by using Lagrange's theorem.\nInput Integers p, g, e.\nOutput An Integer x, such that e ≡ gx (mod p) (if one exists).\n\nDetermine the prime factorization of the order of the group  :\n(All the pi are considered small since the group order is smooth.)\nFrom the Chinese remainder theorem it will be sufficient to determine the values of x modulo each prime power dividing the group order. Suppose for illustration that p1 divides this order but p12 does not. Then we need to determine x mod p1, that is, we need to know the ending coefficient b1 in the base-p1 expansion of x, i.e. in the expansion x = a1 p1 + b1. We can find the value of b1 by examining all the possible values between 0 and p1-1. (We may also use a faster algorithm such as baby-step giant-step when the order of the group is prime.) The key behind the examination is that:\n\n(using Euler's theorem). With everything else now known, we may try each value of b1 to see which makes the equation be true. If , then there is exactly one b1, and that b1 is the value of x modulo p1. (An exception arises if  since then the order of g is less than φ(p). The conclusion in this case depends on the value of  on the left: if this quantity is not 1, then no solution x exists; if instead this quantity is also equal to 1, there will be more than one solution for x less than φ(p), but since we are attempting to return only one solution x, we may use b1=0.)\nThe same operation is now performed for p2 through pn.\nA minor modification is needed where a prime number is repeated. Suppose we are seeing pi for the (k + 1)st time. Then we already know ci in the equation x = ai pik+1 + bi pik + ci, and we find either bi or ci the same way as before, depending on whether .\nWith all the bi known, we have enough simultaneous congruences to determine x using the Chinese remainder theorem.","alt_names":[],"name":"Pohlig–Hellman algorithm","categories":["Number theoretic algorithms"],"tag_line":"In number theory, the Pohlig–Hellman algorithm sometimes credited as the Silver–Pohlig–Hellman algorithm is a special-purpose algorithm for computing discrete logarithms in a multiplicative group whose order is a smooth integer."}}
,{"_index":"throwtable","_type":"algorithm","_id":"baby-step-giant-step","_score":0,"_source":{"description":"In group theory, a branch of mathematics, the baby-step giant-step is a meet-in-the-middle algorithm computing the discrete logarithm. The discrete log problem is of fundamental importance to the area of public key cryptography. Many of the most commonly used cryptography systems are based on the assumption that the discrete log is extremely difficult to compute; the more difficult it is, the more security it provides a data transfer. One way to increase the difficulty of the discrete log problem is to base the cryptosystem on a larger group.\n\n","alt_names":["- Baby-step giant-step :","-> Read more about Baby-step giant-step","-> Read the article about 'Baby-step giant-step","...mehr auf Wikipedia über Babystep-Giantstep-Algorithmus","...more on Wikipedia about Baby-step giant-step","2 The algorithm","Baby Step Giant Step","Baby Step Giant Step Wikipedia The Free Encyclopedia","Baby step giant step","Baby step giant step Wikipedia, the ...","Baby step, giant step","Baby-Step Giant-Step Algorithm for finding Discrete","Baby-step giant step","Baby-step giant-step","Baby-step giant-step - Wikipedia, the free encyclopedia","Baby-step giant-step – Wikipedia, the free encyclopedia","Baby-step-Giant-step-Algorithmus","Baby-step_giant-step","Baby-steps Giant-steps","Baby-steps giant-steps algoritme","Baby-steps giant-steps algoritme - Wikipedia","Babystep Giantstep Wikipedia The Free Encyclopedia","Babystep-Giantstep-Algorithmus","Babystep-Giantstep-Algorithmus – Wikipedia","Shanks' baby-step giant-step algorithm","What is theory of Baby-step giant-step","Wikipedia (Baby-step giant-step)","Wikipedia article Baby-step giant-step","Wikipedia article on Baby-step giant-step","Wikipedia artikel Baby-steps giant-steps algoritme","Wikipedia entry for Baby-step giant-step","Wikipedia sur Baby-step giant-step","Wikipedia-Artikel Babystep-Giantstep-Algorithmus","Wikipedia-Seite zu 'Babystep-Giantstep-Algorithmus'","baby step-giant step method","baby-step giant-step","baby-step giant-step - wikipedia, the free encyclopedia","baby-step giant-step algorithm","baby-step/giant-step method","baby-step_giant_step","baby-step，giant-step","de.wikipedia.org/wiki/Babystep-Giantstep-Algorithmus","e1ee7a297782f1b905a59820c9c2e3 ...","en.wikipedia.org/wiki/Baby-step_giant-step","en:Baby-step giant-step","http://de.wikipedia.org/wiki/Babystep-Gi","http://de.wikipedia.org/wiki/Babystep-Giantstep-Algorithmus","http://en.wikipedia.org/wiki/Baby-step_g","http://en.wikipedia.org/wiki/Baby-step_giant-step","http://en.wikipedia.org/wiki/Baby-step_g…","http://fr.wikipedia.org/wiki/Baby-step_giant-step","http://nl.wikipedia.org/wiki/Baby-steps_giant-step","http://nl.wikipedia.org/wiki/Baby-steps_giant-steps_algoritme","pedia. http://en.wikipedia.","yago-res:Baby-step giant-step","α x = β .","λ 2 and λ=max{λ 2, -λn"],"name":"Baby-step giant-step","categories":["Articles with example C code","Group theory","Number theoretic algorithms"],"tag_line":"In group theory, a branch of mathematics, the baby-step giant-step is a meet-in-the-middle algorithm computing the discrete logarithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"tonelli–shanks-algorithm","_score":0,"_source":{"description":"The Tonelli–Shanks algorithm (referred to by Shanks as the RESSOL algorithm) is used within modular arithmetic to solve a congruence of the form\n\nwhere n is a quadratic residue (mod p), and p is an odd prime.\nTonelli–Shanks cannot be used for composite moduli; finding square roots modulo composite numbers is a computational problem equivalent to integer factorization.\nAn equivalent, but slightly more redundant version of this algorithm was developed by Alberto Tonelli in 1891. The version discussed here was developed independently by Daniel Shanks in 1973, who explained:\n\n\"My tardiness in learning of these historical references was because I had lent Volume 1 of Dickson's History to a friend and it was never returned.\"","alt_names":[],"name":"Tonelli–Shanks algorithm","categories":["Articles containing proofs","Modular arithmetic","Number theoretic algorithms","Pages containing cite templates with deprecated parameters"],"tag_line":"The Tonelli–Shanks algorithm (referred to by Shanks as the RESSOL algorithm) is used within modular arithmetic to solve a congruence of the form\n\nwhere n is a quadratic residue (mod p), and p is an odd prime."}}
,{"_index":"throwtable","_type":"algorithm","_id":"interval-contractor","_score":0,"_source":{"description":"In mathematics, an interval contractor (or contractor for short)  associated to a set X is an operator C which associates to a box [x] in Rn another box C([x]) of Rn such that the two following properties are always satisfied\n (contractance property)\n (completeness property)\nA contractor associated to a constraint (such as an equation or an inequality) is a contractor associated to the set X of all x which satisfy the constraint. Contractors make it possible to improve the efficiency of branch-and-bound algorithms classically used in interval analysis.","alt_names":[],"name":"Interval contractor","categories":["Arithmetic","CS1 errors: invisible characters","Computer arithmetic","Mathematical optimization","Numerical analysis","Optimization algorithms and methods"],"tag_line":"In mathematics, an interval contractor (or contractor for short)  associated to a set X is an operator C which associates to a box [x] in Rn another box C([x]) of Rn such that the two following properties are always satisfied\n (contractance property)\n (completeness property)\nA contractor associated to a constraint (such as an equation or an inequality) is a contractor associated to the set X of all x which satisfy the constraint."}}
,{"_index":"throwtable","_type":"algorithm","_id":"optimization-mechanism","_score":0,"_source":{"description":"In network science started in, the optimization mechanism is a network growth algorithm, which randomly places new nodes in the system, and connects them to the existing nodes based on a cost-benefit analysis. Depending on the parameters used in the optimization mechanism, the algorithm can build three types of networks: a star network, a random network, and a scale-free network. Optimization mechanism is thought to be the underlying mechanism in several real networks, such as transportation networks, power grid, router networks, the network of highways, etc.","alt_names":[],"name":"Optimization mechanism","categories":["All articles needing additional references","All orphaned articles","Articles needing additional references from August 2014","Networks","Orphaned articles from August 2014","Routing algorithms"],"tag_line":"In network science started in, the optimization mechanism is a network growth algorithm, which randomly places new nodes in the system, and connects them to the existing nodes based on a cost-benefit analysis."}}
,{"_index":"throwtable","_type":"algorithm","_id":"mentor-routing-algorithm","_score":0,"_source":{"description":"The MENTOR routing algorithm is an algorithm for use in routing of mesh networks, specifically pertaining to their initial topology. It was developed in 1991 by Aaron Kershenbaum, Parviz Kermani, and George A. Grove and was published by the IEEE.","alt_names":["MENTOR (algorithm)","MENTOR routing algorithm","MENTOR routing algorithm - Wikipedia, the free encyclopedia","What is methodology of MENTOR routing algorithm","What is methodology of MENTOR routing algorithm?","Wikipedia entry for MENTOR routing algorithm","http://en.wikipedia.org/wiki/MENTOR_rout","http://en.wikipedia.org/wiki/MENTOR_routing_algorithm"],"name":"MENTOR routing algorithm","categories":["All orphaned articles","Orphaned articles from February 2009","Routing algorithms"],"tag_line":"The MENTOR routing algorithm is an algorithm for use in routing of mesh networks, specifically pertaining to their initial topology."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pocklington's-algorithm","_score":0,"_source":{"description":"Pocklington's algorithm is a technique for solving a congruence of the form\n\nwhere x and a are integers and a is a quadratic residue.\nThe algorithm is one of the first efficient methods to solve such a congruence. It was described by H.C. Pocklington in 1917.\n\n","alt_names":["Pocklington's algorithm","- Pocklington's algorithm :","Pocklington's","Pocklington's algorithm - Wikipedia, the free encyclopedia","What are some examples of Pocklington's algorithm","Wikipedia article Pocklington's algorithm","http://en.wikipedia.org/wiki/Pocklington %27s_algorithm","http://en.wikipedia.org/wiki/Pocklington%27s_algorithm","http://en.wikipedia.org/wiki/Pocklington's_algorithm"],"name":"Pocklington's algorithm","categories":["Modular arithmetic","Number theoretic algorithms"],"tag_line":"Pocklington's algorithm is a technique for solving a congruence of the form\n\nwhere x and a are integers and a is a quadratic residue."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dynamic-programming","_score":0,"_source":{"description":"In mathematics, management science, economics, computer science, and bioinformatics, dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions - ideally, using a memory-based data structure. The next time the same subproblem occurs, instead of recomputing its solution, one simply looks up the previously computed solution, thereby saving computation time at the expense of a (hopefully) modest expenditure in storage space. (Each of the subproblem solutions is indexed in some way, typically based on the values of its input parameters, so as to facilitate its lookup.) The act of storing solutions to subproblems is called \"memoization\".\nDynamic programming algorithms are used for optimization (for example, finding the shortest path between two points, or the fastest way to multiply many matrices). A dynamic programming algorithm will examine the previously solved subproblems and will combine their solutions to give the best solution for the given problem. The alternatives are many, such as using a greedy algorithm, which picks the locally optimal choice at each branch in the road. The locally optimal choice may be a poor choice for the overall solution. While a greedy algorithm does not guarantee an optimal solution, it is often faster to calculate. Fortunately, some greedy algorithms (such as minimum spanning trees) are proven to lead to the optimal solution.\nFor example, let's say that you have to get from point A to point B as fast as possible, in a given city, during rush hour. A dynamic programming algorithm will look at finding the shortest paths to points close to A, and use those solutions to eventually find the shortest path to B. On the other hand, a greedy algorithm will start you driving immediately and will pick the road that looks the fastest at every intersection. As you can imagine, this strategy might not lead to the fastest arrival time, since you might take some \"easy\" streets and then find yourself hopelessly stuck in a traffic jam.\nSometimes, applying memoization to a naive basic recursive solution already results in a dynamic programming solution with asymptotically optimal time complexity; however, the optimal solution to some problems requires more sophisticated dynamic programming algorithms. Some of these may be recursive as well but parametrized differently from the naive solution. Others can be more complicated and cannot be implemented as a recursive function with memoization. Examples of these are the two solutions to the Egg Dropping puzzle below.","alt_names":["dynamic algorithms","動的プログラミング","위키페디아 페이지","Dynamic Programming Algorithm","http://vi.wikipedia.org/wiki/Quy_ho%E1%BA","Dynamic programming","programming techniques","dynamic programming","動的計画法","Dynamic Programming","%D1%80%D0%BE%D0%B3%D1%80","'Dynamic programming'","'dynamic programming'","- Dynamic programming :","-> Read the article about 'Dynamic programming'","...Wikipedia Dynamisk programmering","...Wikipedia Programación dinámica (computación)","...Wikipedia Programação dinâmica","...Wikipedia Programmation dynamique","...Wikipedia Programowanie dynamiczne","...mehr auf Wikipedia über Dynamische Programmierung","...more on Wikipedia about Dynamic programming","1.1 피보나치 수열","108px-Fibonacci_dynamic_ ...","16. Dynamic programming","2 步骤","2 동적계획을 이용한 알고리즘","2.1 Checkerboard","2.1 Dynamic programming in mathematical optimization","2.1 Dãy Fibonacci","2.1 Fibonacci sequence","2.2 Bàn cờ","2.2 Checkerboard","2.2 Dynamic programming in computer programming","2.2 Sequence alignment","3 Algorithms that use dynamic programming","3 Các thuật toán sử dụng quy hoạch","3 Example: mathematical optimization","3 实例","3.1 Optimal consumption and saving","3.1 斐波那契数列(Fibonacci polynomial)","3.2 背包问题","4 Examples: Computer algorithms","4 使用动态规划的算法","4.1 Dijkstra's algorithm for the shortest path problem","4.2 Fibonacci sequence","4.3 A type of balanced 0-1 matrix","4.4 Checkerboard","4.5 Sequence alignment","4.6 Tower of Hanoi Puzzle","4.7 Egg dropping puzzle","5 Algorithms that use dynamic programming",">dynamic programming<","Algorithmen, die Programmierung verwenden dynamische","Algorithms that use dynamic programming","Algoritmer, der anvender dynamisk programmering","Algoritmes die dynamisch programmeren gebruik","Algoritmi che utilizzano la programmazione dinamica","Algoritmy, které používají dynamické programování","Algorytmy programowania dynamicznego, które korzystają","Alignment of histograms","Another Introduction","Checkerboard problem","DP(Dynamic Programming)","DYNAMIC PROGRAMMING","Definición de Programación dinámica más completo","Die dynamische Programmierung","Dinami?ko programiranje - ??????????","Dinamicno programiranje - Wikipedija, prosta enciklopedija","Dinamikus programozás","Dinaminis programavimas","Dinaminis programavimas – Vikipedija","Dinamičko programiranje","Dinamično programiranje","Dinamično programiranje - Wikipedija, prosta enciklopedija","Dinamično programiranje datoteka","Dinâmica de programação","Dynamic Prog. wiki","Dynamic Programing","Dynamic Programming # Sequence alignment","Dynamic Programming (DP)","Dynamic Programming (Wikipedia)","Dynamic Programming (wikipedia)","Dynamic Programming Wiki","Dynamic Programming Wikipedia","Dynamic Programming Wikipedia The F","Dynamic Programming(DP)","Dynamic Programming.","Dynamic Programming:","Dynamic Programming;","Dynamic disk on laptop","Dynamic na Programming","Dynamic na programming","Dynamic programing","Dynamic programming (DP)","Dynamic programming (EN)","Dynamic programming - Wikipedia","Dynamic programming - Wikipedia, the free","Dynamic programming - Wikipedia, the free enc...","Dynamic programming - Wikipedia, the free encyclopedia","Dynamic programming - Wikipedia, the free …","Dynamic programming - from Wikipedia, the free encyclopedia.","Dynamic programming Wikipedia the free encyclopedia","Dynamic programming Wikipedia the free encyclopedia - result","Dynamic programming Wikipedia, the ...","Dynamic programming algorithm","Dynamic programming wiki","Dynamic programming.","DynamicProgramming","Dynamic_programming","Dynamic_programming bei der wikipedia","Dynamické programovanie","Dynamické programování","Dynamické programování - Wikipedie","Dynamické programování - Wikipedie - Wikipedia","Dynamického programování","Dynamisch Programmeren","Dynamisch programmeren","Dynamische Programmierung","Dynamische Programmierung - Wikipedia","Dynamische Programmierung ? Wikipedia","Dynamische Programmierung Wikipedia","Dynamische Programmierung – Wikipedia","Dynamische programmering","Dynamische_Programmierung","Dynamische_Programmierung bei der wikipedia","Dynamischen Programmierung","Dynamischer Programmierung","Dynamisches Programmieren","Dynamisches_Programmieren bei der wikipedia","Dynamisk Programmering","Dynamisk programmering","Dynamisk programmering - Wikipedia","Dynamsicher Programmierung","Egg Dropping Puzzle","Egg dropping puzzle","Einführung in die dynamische Programmierung.","Example: mathematical ...","Example: mathematical optimization","Examples: Computer ...","Fibonacci number and DP","It's known as dynamic programming","La programación dinámica","La programmation dynamique","Learn about Dynamic programming>>>","Los algoritmos que utilizan la programación dinámica","More background on dynamic programming","Not necessarily. . .","Năng động, lập trình","PROGRAMACION DINAMICA II","Pemrograman Dinamis","Pemrograman dinamis","Programa cão","Programaci n din mica Wikipedia la enciclopedia libre","Programaci n din mica computaci n Wikipedia a","Programaci&#195;&#179;n din&#195;&","Programacinn Dinámica","Programació dinàmica - Viquipèdia","Programación Dinámica","Programación dinámica","Programación dinámica (computación)","Programación dinámica (computación) - Wikipedia, a ...","Programación dinámica (informática)","Programación dinámica - Wikipedia","Programación dinámica - Wikipedia, la enciclopedia libre","Programação Dinâmica","Programação Dinâmica (PD)","Programação Dinâmica na Wikipedia","Programação dinâmica","Programação dinâmica - Wikipédia, a enciclopédia livre","Programação dinâmica na wikpedia (english)","Programação dinâmica – Wikipédia, a enciclopédia livre","Programmation Dynamique","Programmation dynamique","Programmation dynamique - Wikip?dia","Programmation dynamique - Wikipédia","Programmation dynamique :","Programmazione Dinamica","Programmazione dinamica","Programmazione dinamica - Wikipedia","Programowanie dynamiczne","Programowanie dynamiczne ? Wikipedia, wolna encyklopedia","Programowanie dynamiczne – Wikipedia, wolna encyklopedia","Quy hoạch động","Quy hoạch động - Wikipedia tiếng Việt","Quy hoạch động – Wikipedia tiếng Việt","Read More About dynamic programming wikipedia the free","Read More dynamic programming wikipedia the free encyclopedia","Tham khảo chi tiết","The Wikipedia entry on Dynamic Programming","Via dynamic programming","Você sabe o que é programação dinâmica?","WIKIPÉDIE.","WP entry for dynamic programming","WP: Dynamische Programmierung","What is Dynamic Programming?","What is dynamic programming?","What is the history of Dynamic programming/Implementations","What is the overview of Dynamic programming/Implementations","Where it is not applicable","Wiki: Dynamic Programming","WikiPedia:動的計画法","Wikipedia - 'Dynamic Programming'","Wikipedia - 動的計画法","Wikipedia Artikel zu Dynamic Planning (aka Dynamic Programming","Wikipedia Dynamic programming","Wikipedia article Dynamic Programming","Wikipedia article Dynamic programming","Wikipedia article Dynamické programování","Wikipedia article Dynamische Programmierung","Wikipedia article Programación dinámica","Wikipedia article Programação dinâmica","Wikipedia article Programmation dynamique","Wikipedia article on Programación Dinámica","Wikipedia article on Programación dinámica (computación)","Wikipedia article on Programación dinámica (investigación operativa)","Wikipedia article on dynamic programming","Wikipedia article Динамическое программирование","Wikipedia article Динамічне програмування","Wikipedia article תכנון דינמי","Wikipedia article ഡൈനാമിക് പ്രോഗ്രാമിങ്","Wikipedia article 动态规划","Wikipedia dynamic programming article","Wikipedia entry for Dynamic programming","Wikipedia entry on dynamic programming","Wikipedia for Dynamic Programming","Wikipedia l'articolo Programmazione dinamica","Wikipedia link on dynamic programming","Wikipedia on Dynamic programming","Wikipedia on dynamic programming","Wikipedia über Dynamische Programmierung","Wikipedia-Artikel Dynamic programming","Wikipedia-Artikel Dynamische Programmierung","Wikipedia-Artikel Dynamische_Programmierung","Wikipedia-Artikel Dynamisches Programmieren","Wikipedia-Dynamic Programming","Wikipedia-Seite zu 'Dynamic programming'","Wikipedia-Seite zu 'Dynamische Programmierung'","Wikipedia: Dynamic programming","Wikipedia: Dynamische Programmierung","Wikipedia: dynamic programming","Wikipedia:Dynamic_programming","Wikipedia:dynamic programming","Wikipedii link","[Dynamic Programming]","a dynamic programming","a programação dinâmica","a type of balanced 0-1 matrix","algorithm that uses dynamic programming","algorithme de programmation dynamique,","algoritma pemrograman dinamis,","algoritmo de programación dinámica,","algoritmo de programação dinâmica,","algoritmo di programmazione dinamica,","artigo da Wikipédia Programação dinâmica","artículo de Wikipedia Programación Dinámica","artículo de Wikipedia Programación dinámica (computación)","artículo de Wikipedia Programación dinámica (informática)","artículo de Wikipedia Programación dinámica (investigación operativa)","ca:Programació dinàmica","chương trình năng động","chương trình năng động,","chương trình năng động?","cs:Dynamické programování","de programación dinámica","de programación dinámica?","de programação dinâmica","de programação dinâmica,","de programação dinâmica?","de programação,","de programmation dynamique","de programmation dynamique,","de.wikipedia.org/wik...ische_Programmierung","de.wikipedia.org/wiki/Dynamische_Programmierung","de:Dynamische Programmierung","der dynamischen Programmierung","di programmazione dinamica","di programmazione dinamica,","di programmazione dinamica:","dia.org/wiki/Reflection_(computer_programming","die dynamische Programmierung","die dynamische Programmierung,","die dynamische Programmierung:","dinamica di programmazione","dinamici di programmazione","dinamik programlama","dinamikus programozás","dinaminis programavimas","dinamiskā programmēšana","dinamiskās programmēšanas","dinamičko programiranje","dynaaminen ohjelmointi","dynamic program","dynamic programing","dynamic programmin","dynamic programming - Wikipedia, the free encyclopedia","dynamic programming - wikipedia, the free encyclopedia","dynamic programming >","dynamic programming a","dynamic programming algorithm","dynamic programming algorithms","dynamic programming in action.","dynamic programming method","dynamic programming page","dynamic programming problem","dynamic programming solution","dynamic programming technique","dynamic programming techniques","dynamic programming.","dynamic programming. G","dynamic programs","dynamic-programming","dynamic_programming","dynamickom programovaní","dynamické programovanie","dynamické programování","dynamického programovania","dynamického programování","dynamickém programování","dynamisch programmeren","dynamische Programmierung","dynamische Programmierung Technik.","dynamische Programmierung.","dynamische algoritmes","dynamische programmierung","dynamischen Programmierung","dynamischen Programmierung Algorithmus,","dynamischer Programmierung","dynamisk programmering","dünaamiline programmeerimine","een optimale probleem en optimale structuur","egg drop problem","egg dropping puzzle","en.wikipedia.org/...Dynamic_programming","en.wikipedia.org/wiki/Dynamic_programming","en.wikipedia.org/wiki/Dynamic_programming#Checkerboard","en:Dynamic programming","es.wikipedia.org/...n%C3%A1mica_(inform%C3","es:Programación dinámica","es:Programación dinámica (informática)","f3b8053210f2f7fe86a618ca4d286 ...","fa:برنامهریزی پویا","faster solution that's even more elegant","fr:Programmation dynamique","g dynamic programming,","giải thuật quy hoạch động","giới thiệu về chương trình năng động.","gl:Programación dinámica (computación)","he:תכנון דינמי","hi:डाइनैमिक प्रोग्रामिंग","http: // en. wikipedia. org/ wiki/ Dynamic_","http://cs.wikipedia.org/wiki/Dynamick%C3%A9_programov","http://cs.wikipedia.org/wiki/Dynamické_programování","http://de.wikipedia.org/wiki/Dynamic_programming","http://de.wikipedia.org/wiki/Dynamische_Programmieru...","http://de.wikipedia.org/wiki/Dynamische_Programmierung","http://de.wikipedia.org/wiki/Dynamisches_Programmieren","http://en.wikipedia....mic_programming","http://en.wikipedia.org/wiki/Dyn ... dynamic_programming","http://en.wikipedia.org/wiki/Dyna-","http://en.wikipedia.org/wiki/Dynami...rithms_that_use_dynamic_programming","http://en.wikipedia.org/wiki/Dynamic programming","http://en.wikipedia.org/wiki/Dynamic...g#Checkerboard","http://en.wikipedia.org/wiki/Dynamic...ic_programming","http://en.wikipedia.org/wiki/Dynamic_Programming","http://en.wikipedia.org/wiki/Dynamic_Programming Also, it","http://en.wikipedia.org/wiki/Dynamic_Pro…","http://en.wikipedia.org/wiki/Dynamic_programming","http://en.wikipedia.org/wiki/Dynamic_programming w","http://en.wikipedia.org/wiki/Dynamic_programming#Algorithms_that_use_dyna","http://en.wikipedia.org/wiki/Dynamic_programming#Algorithms_that_use_dynamic_programming","http://en.wikipedia.org/wiki/Dynamic_programming#Dynamic_pro...","http://en.wikipedia.org/wiki/Dynamic_programming#Dynamic_programming_in_computer_programming","http://en.wikipedia.org/wiki/Dynamic_programming#Egg_dropping_p","http://en.wikipedia.org/wiki/Dynamic_programming#Egg_dropping_puzzle","http://en.wikipedia.org/wiki/Dynamic_programming#Egg_dropping_puzzle)","http://en.wikipedia.org/wiki/Dynamic_programming#History","http://en.wikipedia.org/wiki/Dynamic_programming#cite_note-3","http://en.wikipedia.org/wiki/Dynamic_programming.","http://en.wikipedia.org/wiki/Dynamic_pro…","http://es.Wikipedia.org/wiki/Program..._(informática","http://es.wikipedia.org/wiki/Programaci ... .C3.A1mica","http://es.wikipedia.org/wiki/Programaci%C3%B3n_din","http://es.wikipedia.org/wiki/Programación_dinámica_(computac...","http://es.wikipedia.org/wiki/Programación_dinámica_(computación)","http://es.wikipedia.org/wi​ki/Programaci%C3","http://fr.wikipedia.org/wiki/Programmation_dynamique","http://gl.wikipedia.org/wiki/Programaci%C3%B3n_din","http://he.wikipedia.org/wiki/תכנון_דינמי","http://it.wikipedia.org/wiki/Programmazione_dinamica","http://ja.wikipedia.org/wiki/%e5%8b%95","http://ja.wikipedia.org/wiki/動的計画法","http://pl.wikipedia.org/wiki/Programowanie_dynamiczne","http://ru.wikipedia.org/wiki/Динамич...ограммирование","http://ru.wikipedia.org/wiki/Динамическое_...рограммирование","http://ru.wikipedia.org/wiki/Динамическое_программирование","http://ru.wikipedia.org/wiki/Динамическо…","http://sl.wikipedia.org/wiki/Dinamično_programiranje","http://sv.wikipedia.org/wiki/Dynamisk_programmering","http://vi.wikipedia.org/wiki/Quy_ho%...%91%E1","http://zh.wikipedia.org/wiki/动态规划","introducción a la programación dinámica.","introduction to dynamic programming","introduction à la programmation dynamique.","introduzione alla programmazione dinamica.","introdução à programação dinâmica.","it:Programmazione dinamica","ja:動的計画法","k × n","ko:동적 계획법","kỹ thuật lập trình năng động.","l'article de Wikipédia Programmation dynamique","la programación dinámica","la programación dinámica,","la programación dinámica.","la programación dinámica:","la programmation dynamique","la programmation dynamique.","la programmation dynamique:","la programmazione dinamic","la programmazione dinamica","lenguaje de programación dinámica","list of algorithms that use DP","lt:Dinaminis programavimas","lập trình năng động","lập trình năng động,","lập trình năng động.","lập trình năng động;","ml:ഡൈനാമിക് പ്രോഗ്രാമിങ്","năng động Lập trình","năng động chương trình:","năng động, lập trình,","năng động, lập trình.","optimal problem and optimal structure","optimale Problemlösung und optimale Struktur","optimale problem og optimal struktur","optymalnej struktury i problem optymalnego","origin of the term dynamic programming","other dynamic programming problems","pemrograman dinamis","pemrograman dinamis,","pemrograman dinamis.","pemrograman dinamis:","pengenalan pemrograman dinamis.","pl:Programowanie dynamiczne","principio de optimalidad","principio de optimalidad de Bellman","problema ottimale e la struttura ottimale","problema óptima y estructura óptima","program dinamik","program dinamis","programació dinàmica","programación dinámica","programación dinámica,","programación dinámica.","programare dinamica","programação dinâmica","programação dinâmica,","programação dinâmica.","programação dinâmica:","programimit dinamik","programmation dynamique","programmation dynamique,","programmation dynamique?","programmazione dinamic","programmazione dinamica","programmazione dinamica,","programmazione dinamica.","programmazione dinamica?","programowania dynamicznego","programowania dynamicznego.","programowanie dynamiczne","programowaniem dynamicznym","pt:Programação dinâmica","qui hoạch động","quy hoạch động","recursive economics","ru:Динамическое программирование","sh:Dinamičko programiranje","sl:Dinamično programiranje","solve this problem","sr:Динамичко програмирање","sv:Dynamisk programmering","technique de programmation dynamique.","technique of dynamic programming","tecnica di programmazione dinamica.","teknik pemrograman dinamis.","this is the general kind of approach","thuật toán lập trình năng động,","tily: 動的計画法 - Wikipedia","ttp://en.wikipedia.org/wiki/Dynamic_programming","técnica de programación dinámica.","técnica de programação dinâmica.","uk:Динамічне програмування","van dynamisch programmeren","vi:Quy hoạch động","w:Dynamic programming","wen:Dynamic programming","wikipedia:動的計画法","wikipediaの「動的計画法」","wp:Dynamic programming","ynamic programming","ynamic programming a","you are doing DP","zh:动态规划","řadě algoritmů","Δευτεροτομίτες-Βασεις_δεδομενάδες;","Δυναμικού Προγραμματισμού","δυναμικό προγραμματισμό","Алгоритмы, которые используют динамическое программирование","Википедии статью Динамическое программирование","Википедия о динимическом программировании","Динамик програмчлал","Динамическое програмирование (aka Оптимизация)","Динамическое програмирование(wiki)","Динамическое программировани...","Динамическое программирование","Динамическое программирование Беллмана","Динамическое программирование — метод решения задач с оптимальной подструктурой","Динамическое программирование?","Динамічне програмування","Динамічне програмування — Ві...","Классические задачи динамического программирования","алгоритм динамического программирования,","введения в динамическое программирование.","дин. прогр. на вики","динaмичecкoгo прoгрaммирoвaния","динамику.","динамическим программированием","динамическим программированием.","динамического программирования","динамического программирования,","динамического программирования.","динамического программирования:","динамическое программирование","динамическое программирование,","динамическом программировании","динамичното оптимиране","динамічного програмування","задачи оптимального и оптимальной структуры","про падение двух яиц","технику динамического программирования.","אלגוריתמים דינמיים","ויקיפדיה - 'תכנון דינמי'","תכנון דינמי","תכנון דינמי - Dynamic Programming ויקי","תכנון דינמי – ויקיפדיה","תכנות דינאמי","البرمجة الديناميكية","برنامه ریزی پویا","برنامه سازی پویا (Dynamic Programming)","برنامه نویسی پویا","برنامهریزی پویا","برنامهریزی پویا - ویکیپدیا","برنامهنویسی پویا","उपयोग में","एल्गोरिथम है कि प्रोग्रामिंग का उपयोग गतिशील","एल्गोरिदम कि गतिशील प्रोग्रामिंग का उपयोग","गतिशील प्रोग्रामिंग","लेकिन गतिशील","ডাইনামিক প্রোগ্রামিং","การ เขียน โปรแกรม แบบ ไดนามิก","การ เขียน โปรแกรม แบบ ไดนามิก,","การ เขียน โปรแกรม แบบ ไดนามิก.","การ เขียน โปรแกรม แบบ ไดนามิก:","การ เขียน โปรแกรม แบบ ไดนามิก?","การ แนะนำ การ เขียน โปรแกรม แบบ ไดนามิก.","การเขียนโปรแกรมแบบไดนามิก","ขั้น ตอน วิธี การ เขียน โปรแกรม แบบ ไดนามิก","เขียน โปรแกรม แบบ ไดนามิก.","เทคนิค การ เขียน โปรแกรม แบบ ไดนามิก.","โปรแกรม Dynamic","โปรแกรมแบบไดนามิก","“Dynamic programming - Wikipedia, the free encyclopedia”, en.wikipedia","“dynamic programming”","、動的プログラミング","「動的計画法」をWikipediaで調べる","の記事をそれ","プログラミング。","プログラミングと","プログラミングアルゴリズムを動的に使用する","プログラミングソリューション","プログラミング（","一些动态","使用动态规划的","动态的编程技术","动态的计画","动态编程","动态规划","动态规划- 维基百科，自由的百科全书","动态规划法","动态规划的介绍","动态规划算法","动态规划算法（Dynamic programming）","動態的編程技術","動態規划","動態規劃","動態規劃(Dynamic Programming，DP)","動態規劃(dynamic programming)","動態規劃介紹","動態規劃法(Dynamic Programming)","動態規劃算法","動的なプログラミング","動的なプログラミングが","動的なプログラミングテクニック","動的プログラミングの導入","動的プログラミングは","動的プログラミングアルゴリズムを","動的計画","動的計画法 - Wikipedia","動的計画法 -wikipedia","動的計画法 – Wikipedia","動的計画法 とは","動的計画法(DynamicProgramming)","動的計画法-wikipedia","動的計画法は、","動的計画法を","動的計画法（DP法）","和优化结构的优化问题","的动态","的动态规划","維基百科的文章“ 动态规划”","维基百科上关于动态规划的条目。","维基百科的文章“ 动态规划”","長いアルゴリズムのリスト","다이나믹 프로그래밍","동적 계획법","동적 계획법 - 위키백과, 우리 모두의 백과사전","동적 프로그래밍","동적 프로그래밍 기법을","동적 프로그래밍 소개를","동적 프로그래밍 알고리즘,에서","동적 프로그래밍의","동적 프로그래밍이","동적 프로그래밍이라고합니다.","동적 프로그래밍입니다","동적계획법","동적프로그래밍(dynamic programming)","위키 피 디아 문서 동적 계획법","위키 피 디아 문서 동적 프로그래밍","위키 피 디아 문서 동적계획법","특정 조건을 만족하는 행렬의 수","，采用"],"name":"Dynamic programming","categories":["Accuracy disputes from November 2015","All accuracy disputes","All articles needing additional references","All articles with unsourced statements","Articles needing additional references from April 2014","Articles needing additional references from May 2013","Articles with unsourced statements from May 2009","Dynamic programming","Equations","Mathematical optimization","Operations research","Optimal control","Optimization algorithms and methods","Systems engineering","Wikipedia articles with GND identifiers"],"tag_line":"In mathematics, management science, economics, computer science, and bioinformatics, dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions - ideally, using a memory-based data structure."}}
,{"_index":"throwtable","_type":"algorithm","_id":"gradient-descent","_score":0,"_source":{"description":"Gradient descent is a first-order optimization algorithm. To find a local minimum of a function using gradient descent, one takes steps proportional to the negative of the gradient (or of the approximate gradient) of the function at the current point. If instead one takes steps proportional to the positive of the gradient, one approaches a local maximum of that function; the procedure is then known as gradient ascent.\nGradient descent is also known as steepest descent, or the method of steepest descent. However, gradient descent should not be confused with the method of steepest descent for approximating integrals.","alt_names":["Gradientenabstiegsverfahren","steepest descent","gradient descent","- Gradient descent :","- Gradient method :","- Steepest descent :","-> Read more about Gradient descent","...mehr auf Wikipedia über Gradientenabstiegsverfahren","...more on Wikipedia about Gradient descent","1). Метод градиентного спуска.","2. Метод крутого восхождения (скорейшего спуска)","4 A computational example","A computational example","Algorithme du gradient","Algorithme du gradient - Wikipédia","Batch Gradient Descent","Descente de gradient","Die Methode des Gradientenabstiegs","Discesa del gradiente","Discesa del gradiente - Wikipedia","F ( 𝐱 )","Finding extrema","Gradient (steepest) Descent","Gradient (крутой) Спуск","Gradient Descend.","Gradient Descent","Gradient Descent - wikipedia def.","Gradient Descent optimization (wikipedia)","Gradient Descent.","Gradient descent","Gradient descent (steepest descent)","Gradient descent - Wikipedia - a.k.a. Steepest Descent Method","Gradient descent - Wikipedia, the free encyclopedi","Gradient descent - Wikipedia, the free encyclopedia","Gradient descent Wikipedia the free encyclopedia","Gradient descent from Wikipedia","Gradient descent method","Gradient descent.","Gradient method","Gradient method - Wikipedia, the free encyclopedia","Gradient method; it is used under the","Gradient_descent","Gradienten Verfahren bei Optimierungsproblem","Gradientenabstieg","Gradientenabstieg bei der wikipedia","Gradientenabstiegs","Gradientenabstiegsverfahren bei der wikipedia","Gradientenverfahren","Gradientenverfahren ? Wikipedia","Gradientenverfahren bei der wikipedia","Gradientenverfahren – Wikipedia","Gradientenverfahrens","Gradientinis nusileidimas","Gradientinį algoritmą","Method of Steepest Descent","Metoda gradientu prostego","Metoda gradientu prostego – Wikipedia, wolna encyklopedia","Optimierung auf das Verfahren","Solution of a linear system","Solution of a non-linear system","Steepest Descent (Gradient Descent)","Steepest_descent","Verfahren des steilsten Abstiegs","Verfahren des steilsten Abstiegs - Wikipedia","Verfahren des steilsten Abstiegs bei Wikipedia","Verfahren_des_steilsten_Abstiegs","What is the description of Gradient Descent","What is the description of Gradient method","Wikipedia : 最急降下法","Wikipedia article Algorithme du gradient","Wikipedia article Gradient descent","Wikipedia article Gradient method","Wikipedia article Steepest ascent","Wikipedia article Steepest descent","Wikipedia article on Gradient descent","Wikipedia article on Gradient method","Wikipedia article on Steepest descent","Wikipedia article Градиентный спуск","Wikipedia entry for Gradient descent","Wikipedia sur Descente de gradient","Wikipedia's Article on Gradient Descent","Wikipedia-Artikel Gradientenabstieg","Wikipedia-Artikel Gradientenabstiegsverfahren","Wikipedia-Artikel Gradientenverfahren","Wikipedia-Artikel Verfahren des steilsten Abstiegs","Wikipedia-Seite zu 'Gradientenverfahren'","Wikipedia-Seite zu 'Verfahren des steilsten Abstiegs'","Wikipedia: Gradient Descent","Wikipedia: Gradient descent","Wikipedia:Gradient descent","Wikipedia:Gradient_descent","Wikipediaで「最急降下法」を調べる","Wikipediaで「最速降下法」を調べる","[18] http://en.wikipedia.org/wiki/Gradient_descent","algorithme du gradient","de descente de gradient","de.wikipedia.org/wiki/Gradientenverfahren","de:Gradientenverfahren","del gradiente (più ripida) discesa","descenso de gradiente","descent step","descente de gradient","discesa del gradiente","el descenso de gradiente","en.wikipedia.org/...Gradient_descent","en.wikipedia.org/wiki/Gradient_descent","en:Gradient method","en:Gradient_descent","fr:Descente de gradient","fr:Descente_de_gradient","gradation method","gradient ascent","gradient ascent algorithm","gradient ascent/descent","gradient decent","gradient descen","gradient descent (GD)","gradient descent - Wikipedia, the free encyclopedia","gradient descent algorithm","gradient descent algorithm.","gradient descent approach","gradient descent learning","gradient descent method","gradient descent methods","gradient descent optimization","gradient descent wikipedia the free encyclopedia","gradient descent,","gradient descent.","gradient nedstigning","gradient-based","gradient-based methods","gradient-descent-like","gradiente de descenso","gradiente descendente","gradiente di discesa","gốc gradient","gốc gradient,","http://de.wikipedia.org/wiki/Gradientenabstieg","http://de.wikipedia.org/wiki/Gradientenv","http://de.wikipedia.org/wiki/Gradientenverfahren","http://de.wikipedia.org/wiki/Verfahren_des_steilsten_Abstiegs","http://en.wikipedia....teepest_descent","http://en.wikipedia.org/wiki/Gradient descent","http://en.wikipedia.org/wiki/Gradient_de","http://en.wikipedia.org/wiki/Gradient_descen","http://en.wikipedia.org/wiki/Gradient_descent","http://en.wikipedia.org/wiki/Gradient_descent.","http://en.wikipedia.org/wiki/Gradient_descent_method","http://en.wikipedia.org/wiki/Gradient_de…","http://en.wikipedia.org/wiki/Steepest_descent","http://fr.wikipedia.org/wiki/Algorithme_du_gradient","http://fr.wikipedia.org/wiki/Descente_de_gradient","http://pl.wikipedia.org/wiki/Metoda_gradientu_prostego","http://ru.wikipedia.org/wiki/Градиентный_спуск","http://ru.wikipedia.org/wiki/Метод_градиента","http://ru.wikipedia.org/wiki/Метод_наискорейшего_спуска","it:Discesa del gradiente","ja:最急降下法","keturunan gradien","korkeammalla matematiikalla.","lt:Gradientinis nusileidimas","math stuff","metodei de tip gradient","metodo spusta","minimization of an","ne, http://en.wikipedia.org/wiki/Gradient_descent.","pl:Metoda gradientu prostego","plus grande pente","přechodu (nejstrmější) Klesání","radient descent","ru.wikipedia.org/wiki/Метод_градиента","ru:Градиентный спуск","sklonu","steepest ascent","steepest descent algorithm","steepest descents","steepest-descent","stepsize rules","suavizado del paisaje","thttp://en.wikipedia.org/wiki/Gradient_descent","uk:Метод найшвидшого спуску","um das Optimierungsproblem","verloop dalen","w:Gradient descent","walk in the direction that seems to make","zejście gradientu","Градиентный спуск","Метод наискорейшего спуска","Метод найшвидшого спуску","градиентного спуска","градиентного спуска,","градиентный спуск","метод наискорейшего градиентного спуска","метод наискорейшего спуска","спуску,","ढाल वंश","โคตร ลาด","โคตรลาด","“Gradient descent - Wikipedia, the free encyclopedia”, en.wikipedia","∙ Algorithme du gradient - ...","「最急降下法」についてWikipediaで調査","「最急降下法」をWikipediaで調べる","勾配法","勾配系","勾配降下","最急降下法","最急降下法 - Wikipedia","最急降下法-wikipedia","最速降下法","最陡坡降法","梯度下降","梯度下降法","確率的最急降下法","기울기 하강","기울기 하강을"],"name":"Gradient descent","categories":["Articles with example Python code","First order methods","Gradient methods","Optimization algorithms and methods"],"tag_line":"Gradient descent is a first-order optimization algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"iterated-filtering","_score":0,"_source":{"description":"Iterated filtering algorithms are a tool for maximum likelihood inference on partially observed dynamical systems. Stochastic perturbations to the unknown parameters are used to explore the parameter space. Applying sequential Monte Carlo (the particle filter) to this extended model results in the selection of the parameter values that are more consistent with the data. Appropriately constructed procedures, iterating with successively diminished perturbations, converge to the maximum likelihood estimate. Iterated filtering methods have so far been used most extensively to study infectious disease transmission dynamics. Case studies include cholera, Ebola virus, influenza, malaria, HIV, pertussis, poliovirus and measles. Other areas which have been proposed to be suitable for these methods include ecological dynamics and finance.\nThe perturbations to the parameter space play several different roles. Firstly, they smooth out the likelihood surface, enabling the algorithm to overcome small-scale features of the likelihood during early stages of the global search. Secondly, Monte Carlo variation allows the search to escape from local minima. Thirdly, the iterated filtering update uses the perturbed parameter values to construct an approximation to the derivative of the log likelihood even though this quantity is not typically available in closed form. Fourthly, the parameter perturbations help to overcome numerical difficulties that can arise during sequential Monte Carlo.\n^ \n^ \n^ \n^ \n^ \n^ \n^ \n^ \n^ \n^ \n^ \n^ \n^ \n^ \n^ \n^ \n^ \n^ \n^ Ionides, E. L.. (2011). \"Discussion on \"Feature Matching in Time Series Modeling\" by Y. Xia and H. Tong.\". Statistical Science. doi:10.1214/11-STS345C. \n^ \n^ \n^","alt_names":["Iterated filtering","Iterated filtering - Wikipedia, the free encyclopedia","http://en.wikipedia.org/wiki/Iterated_filtering"],"name":"Iterated filtering","categories":["Dynamical systems","Monte Carlo methods","Nonlinear filters","Pages containing cite templates with deprecated parameters","Statistical algorithms"],"tag_line":"Iterated filtering algorithms are a tool for maximum likelihood inference on partially observed dynamical systems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"brent's-method","_score":0,"_source":{"description":"In numerical analysis, Brent's method is a complicated but popular root-finding algorithm combining the bisection method, the secant method and inverse quadratic interpolation. It has the reliability of bisection but it can be as quick as some of the less reliable methods. The algorithm tries to use the potentially fast-converging secant method or inverse quadratic interpolation if possible, but it falls back to the more robust bisection method if necessary. Brent's method is due to Richard Brent and builds on an earlier algorithm by Theodorus Dekker. Consequently, the method is also known as Brent-Dekker.","alt_names":["http://en.wikipedia.org/wiki/Brent's_method","Brent's method","- Brent method :","-> Read more about Brent's method","-Brent's method","...more on Wikipedia about Brent's method","1. Eintrag der Google Suche!!!","Brent method","Brent or Dekker)","Brent 或Dekker","Brent's Method","Brent's method - Wikipedia","Brent's method - Wikipedia, the free encyclopedia","Brent's method for root finding","Brent's method or Dekker's method","Brent's method.","Brent-Verfahren","Brent-Verfahren - Wikipedia","Brent-Verfahren ? Wikipedia","Brent-Verfahren – Wikipedia","Brents method","Brentの方法","Méthode de Brent","Méthode de Brent - Wikipédia","What is Brents method's example","Wikipedia article Brent method","Wikipedia article Brent's method","Wikipedia article Brents method","Wikipedia sur Méthode de Brent","Wikipedia-Artikel Brent-Verfahren","Wikipedia: Brent's method","brent s method","brent's method","de:Brent-Verfahren","en.wikipedia.org/wiki/Brent's_method","http://de.wikipedia.org/wiki/Brent-Verfa","http://en.wikipedia.org/wiki/Brent%27s_method","http://en.wikipedia.org/wiki/Brent's_met","http://en.wikipedia.org/wiki/Brent's_met…","http://en.wikipedia.org/wiki/Brent_method","http://en.wikipedia.org/wiki/Brent_metho…","http://en.wikipedia.org/wiki/Brents_method","http://en.wikipedia.org/wiki/Brents_meth​od","http://fr.wikipedia.org/wiki/M%C3%A9thode_de_Brent","ja:ブレント法","método de Brent","roots of an equation","s : = a + b 2","w:en:Brent's method","“Brent's method - Wikipedia, the free encyclopedia”, en.wikipedia","ブレント法","ブレント法 - Wikipedia","ブレント法（wikipedia）","ﾌﾞﾚﾝﾄ法-wikipedia"],"name":"Brent's method","categories":["Root-finding algorithms"],"tag_line":"In numerical analysis, Brent's method is a complicated but popular root-finding algorithm combining the bisection method, the secant method and inverse quadratic interpolation."}}
,{"_index":"throwtable","_type":"algorithm","_id":"pattern-search-(optimization)","_score":0,"_source":{"description":"Pattern search (PS) is a family of numerical optimization methods that do not require the gradient of the problem to be optimized. Hence PS can be used on functions that are not continuous or differentiable. Such optimization methods are also known as direct-search, derivative-free, or black-box methods.\nThe name, pattern search, was coined by Hooke and Jeeves. An early and simple PS variant is attributed to Fermi and Metropolis when they worked at the Los Alamos National Laboratory as described by Davidon  who summarized the algorithm as follows:\n\nThey varied one theoretical parameter at a time by steps of the same magnitude, and when no such increase or decrease in any one parameter further improved the fit to the experimental data, they halved the step size and repeated the process until the steps were deemed sufficiently small.","alt_names":["- Pattern search (optimization) :","Pattern Search","Pattern search (PS) is a family of numerical","Pattern search (optimization)","Pattern search (optimization) - Wikipedia, the free ...","Pattern search (optimization) - Wikipedia, the free encyclop...","Pattern search (optimization) - Wikipedia, the free encyclopedia","Pattern search optimization Wikipedia the free encyclopedia","Pattern search optimization Wikipedia the free encyclopedia - result","Wikipedia article Pattern search (optimization)","Wikipedia article on Pattern search (optimization)","http://en.wikipedia.org/wiki/Pattern_search_(optimization)","pattern search","pattern search,","pattern searching","yago-res:Pattern_search_(optimization)"],"name":"Pattern search (optimization)","categories":["Mathematical optimization","Optimization algorithms and methods"],"tag_line":"Pattern search (PS) is a family of numerical optimization methods that do not require the gradient of the problem to be optimized."}}
,{"_index":"throwtable","_type":"algorithm","_id":"jenkins–traub-algorithm","_score":0,"_source":{"description":"The Jenkins–Traub algorithm for polynomial zeros is a fast globally convergent iterative method published in 1970 by Michael A. Jenkins and Joseph F. Traub. They gave two variants, one for general polynomials with complex coefficients, commonly known as the \"CPOLY\" algorithm, and a more complicated variant for the special case of polynomials with real coefficients, commonly known as the \"RPOLY\" algorithm. The latter is \"practically a standard in black-box polynomial root-finders\".\nThis article describes the complex variant. Given a polynomial P,\n\nwith complex coefficients it computes approximations to the n zeros  of P(z), one at a time in roughly increasing order of magnitude. After each root is computed, its linear factor is removed from the polynomial. Using this deflation guarantees that each root is computed only once and that all roots are found.\nThe real variant follows the same pattern, but computes two roots at a time, either two real roots or a pair of conjugate complex roots. By avoiding complex arithmetic, the real variant can be faster (by a factor of 4) than the complex variant. The Jenkins–Traub algorithm has stimulated considerable research on theory and software for methods of this type.","alt_names":[],"name":"Jenkins–Traub algorithm","categories":["Numerical analysis","Root-finding algorithms"],"tag_line":"The Jenkins–Traub algorithm for polynomial zeros is a fast globally convergent iterative method published in 1970 by Michael A. Jenkins and Joseph F. Traub."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lu-reduction","_score":0,"_source":{"description":"LU reduction is an algorithm related to LU decomposition. This term is usually used in the context of super computing and highly parallel computing. In this context it is used as a benchmarking algorithm, i.e. to provide a comparative measurement of speed for different computers. LU reduction is a special parallelized version of an LU decomposition algorithm, an example can be found in (Guitart 2001). The parallelized version usually distributes the work for a matrix row to a single processor and synchronizes the result with the whole matrix (Escribano 2000).","alt_names":["LU Reduction","LU reduction","LU reduction - Wikipedia :: The free encyclopedia","LU reduction - Wikipedia, the free encyclopedia","LU_reduction","What are sources for LU Reduction","Wikipedia article LU Reduction","Wikipedia article LU reduction","Wikipedia article on LU Reduction","Wikipedia entry for LU reduction","http://en.wikipedia.org/wiki/LU_Reductio","http://en.wikipedia.org/wiki/LU_reduction"],"name":"LU reduction","categories":["Algorithms and data structures stubs","All stub articles","Applied mathematics stubs","Computer science stubs","Numerical linear algebra","Supercomputers"],"tag_line":"LU reduction is an algorithm related to LU decomposition."}}
,{"_index":"throwtable","_type":"algorithm","_id":"metropolis–hastings-algorithm","_score":0,"_source":{"description":"In statistics and in statistical physics, the Metropolis–Hastings algorithm is a Markov chain Monte Carlo (MCMC) method for obtaining a sequence of random samples from a probability distribution for which direct sampling is difficult. This sequence can be used to approximate the distribution (i.e., to generate a histogram), or to compute an integral (such as an expected value). Metropolis–Hastings and other MCMC algorithms are generally used for sampling from multi-dimensional distributions, especially when the number of dimensions is high. For single-dimensional distributions, other methods are usually available (e.g. adaptive rejection sampling) that can directly return independent samples from the distribution, and are free from the problem of auto-correlated samples that is inherent in MCMC methods.\n\n","alt_names":[],"name":"Metropolis–Hastings algorithm","categories":["Markov chain Monte Carlo","Monte Carlo methods","Statistical algorithms"],"tag_line":"In statistics and in statistical physics, the Metropolis–Hastings algorithm is a Markov chain Monte Carlo (MCMC) method for obtaining a sequence of random samples from a probability distribution for which direct sampling is difficult."}}
,{"_index":"throwtable","_type":"algorithm","_id":"minimax-approximation-algorithm","_score":0,"_source":{"description":"A minimax approximation algorithm (or L∞ approximation or uniform approximation) is a method to find an approximation of a mathematical function that minimizes maximum error.\nFor example, given a function  defined on the interval  and a degree bound , a minimax polynomial approximation algorithm will find a polynomial  of degree at most  to minimize","alt_names":["Learn about Minimax approximation algorithm>>>","Minimax approximation algorithm","Minimax approximation algorithm - Wikipedia :: The free encyclopedia","Minimax approximation algorithm - Wikipedia, the free ...","Minimax approximation algorithm - Wikipedia, the free encyclopedia","Wikipedia article on Minimax approximation algorithm","Wikipedia entry for Minimax approximation algorithm","http://en.wikipedia.org/wiki/Minimax_app","http://en.wikipedia.org/wiki/Minimax_approximation_algorithm","minimax approximation algorithms","minimax polynomial"],"name":"Minimax approximation algorithm","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Numerical analysis"],"tag_line":"A minimax approximation algorithm (or L∞ approximation or uniform approximation) is a method to find an approximation of a mathematical function that minimizes maximum error."}}
,{"_index":"throwtable","_type":"algorithm","_id":"bin-packing-problem","_score":0,"_source":{"description":"In the bin packing problem, objects of different volumes must be packed into a finite number of bins or containers each of volume V in a way that minimizes the number of bins used. In computational complexity theory, it is a combinatorial NP-hard problem.\nThere are many variations of this problem, such as 2D packing, linear packing, packing by weight, packing by cost, and so on. They have many applications, such as filling up containers, loading trucks with weight capacity constraints, creating file backups in media and technology mapping in Field-programmable gate array semiconductor chip design.\nThe bin packing problem can also be seen as a special case of the cutting stock problem. When the number of bins is restricted to 1 and each item is characterised by both a volume and a value, the problem of maximising the value of items that can fit in the bin is known as the knapsack problem.\nDespite the fact that the bin packing problem has an NP-hard computational complexity, optimal solutions to very large instances of the problem can be produced with sophisticated algorithms. In addition, many heuristics have been developed: for example, the first fit algorithm provides a fast but often non-optimal solution, involving placing each item into the first bin in which it will fit. It requires Θ(n log n) time, where n is the number of elements to be packed. The algorithm can be made much more effective by first sorting the list of elements into decreasing order (sometimes known as the first-fit decreasing algorithm), although this still does not guarantee an optimal solution, and for longer lists may increase the running time of the algorithm. It is known, however, that there always exists at least one ordering of items that allows first-fit to produce an optimal solution.\nA variant of bin packing that occurs in practice is when items can share space when packed into a bin. Specifically, a set of items could occupy less space when packed together than the sum of their individual sizes. This variant is known as VM packing since when virtual machines (VMs) are packed in a server, their total memory requirement could decrease due to pages shared by the VMs that need only be stored once. If items can share space in arbitrary ways, the bin packing problem is hard to even approximate. However, if the space sharing fits into a hierarchy, as is the case with memory sharing in virtual machines, the bin packing problem can be efficiently approximated.","alt_names":["Bin Packing","bin packing problem","% http://en.wikipedia.org/wiki/Bin 5Fpacking 5Fproblem","(Bin) Packing Problem","- Bin packing :","- Bin packing problem :",". http://de.wikipedia.org/wiki/Bin−Packing−Problem",". http://en.wikipedia.org/wiki/Bin_packing.",". http://en.wikipedia.org/wiki/Bin_packing_problem.","...mehr auf Wikipedia über Behälterproblem","...more on Wikipedia about Bin packing problem","...more on Wikipedia about First fit algorithm","/Bin_packing_problem/","15 - Bin packing problem - Wikipedia, the free encyclopedia","2D bin packing problem","2D packing problem","2d bin-packing problem","<http://en.wikipedia.org/wiki/Bin_packing","Algoritmo y Formula","Analysis of approximate algorithms","Analysis of heuristic algorithms","Aufteilungsproblem BP,","Beh?lterproblem ? Wikipedia","Behälter-","Behälterproblem","Behälterproblem – Wikipedia","Behälterproblems.","Bin Balení","Bin Balení problém","Bin Embalaje problema","Bin Packing -Wikipedia","Bin Packing Algorithms","Bin Packing Problem","Bin Packing Problem,","Bin Packing Problem.","Bin Packing problem","Bin Packing problem on Wikipedia","Bin Packing problemu","Bin Packing,","Bin Verpakking","Bin Verpakking Probleem","Bin Verpakking probleem","Bin balení problému","Bin embalagem,","Bin embalaje,","Bin imballaggio","Bin packing","Bin packing (wikipedia)","Bin packing problem","Bin packing problem (which is NP-complete)","Bin packing problem - Wikipedia, the free encyclopedia","Bin packing problem - Wikipedia, the free encyclopedia ...","Bin đóng gói","Bin-Packing","Bin-Packing - Wikipedia","Bin-Packing Problem","Bin-Packing-Problem","Bin-Packing-Problem - Wikipedia","Bin-iimpake,","Bin-packing","Cargo Load Planning Wiki","Figuring out the best order to pack files","First Fit Decreasing","First fit algorithm","First-fit algorithm","Fit First","Mochila binária","NP Hard problem","NP-uplne","Packaging algorithm","Packing Bin","Papelera de embalaje,","Probl?me de bin packing - Wikip?dia","Problem Bin Packing","Problème de bin packing","Problème de bin packing - W...","Problème de bin packing - Wikipédia","Sample algorithm","Tetris in three dimensions","Types of 2d Bin packing problems","Wikipedia (Bin packing problem)","Wikipedia - Bin Packing","Wikipedia article Bin packing","Wikipedia article Bin packing problem","Wikipedia article First fit algorithm","Wikipedia article on Bin packing","Wikipedia article ビンパッキング問題","Wikipedia entry for Bin packing problem","Wikipedia-Artikel Behälterproblem","Wikipedia-Artikel Bin-Packing","Wikipedia-Artikel Bin-Packing-Problem","Wikipedia-Artikel Bin-packing","Wikipedia-Seite zu 'Behälterproblem'","Wikipedia-Seite zu 'Bin-Packing-Problem'","Wikipedia-Seite zu Bin Packing (Behälterproblem)","Wikipedia: Bin packing problem","Wikipedia: Bin packing problem.","Wikipedia: Задача об упаковке в контейнеры","Wikipediaで「ビンパッキング問題」を調べる","a 1 , &ctdot; , a n","bin Verpackung","bin balení","bin balení problém","bin embalagem problema","bin emballage","bin emballage problème","bin imballaggio problema","bin masalah packing","bin packer","bin packing","bin packing algorithm","bin packing algorithms","bin packing probleem","bin packing problem - Wikipedia, the free encyclopedia","bin packing problems","bin pakning","bin pakning problem","bin pakning problemet","bin problema de embalaje","bin verpakking","bin vấn đề đóng gói","bin-packing","bin-packing algorithms","bin-packing heuristics","bin-packing problem","bin-packing problems","bin-packing-problems","bin_packing_problem","binpacking","binpacking Problem","binpacking probleem","binpacking problem","binpacking समस्या","binpacking,","binpacking問題","binpacking의","binに","de embalaje Bin,","de.wikipedia.org/wiki/Behälterproblem","de:Behälterproblem","details on the problem","diese einfachen Strategien","disse simple strategier","e http://en.wikipedia.org/wiki/Bin_packing_problem","embalaje Bin Problema","embalaje bin","embalaje del compartimiento","en.wikipedia.org/wiki/Bin_packing_pro...","en.wikipedia.org/wiki/Bin_packing_problem","en:bin packing problem","entry on bin-packing","estas estrategias simples","first-fit","first-fit algorithm","first-fit bin packing algorithm","fr:Problème de bin packing","gelistet ist die Rettung!","http://de.wikipedia.org/wiki/Beh%C3%A4lterproblem","http://de.wikipedia.org/wiki/Behälterproblem","http://de.wikipedia.org/wiki/Bin-Packing","http://de.wikipedia.org/wiki/Bin-Packing-Problem","http://en.wikipedia....iki/Bin_packing","http://en.wikipedia....packing_problem","http://en.wikipedia.org/wiki/Bin% 5Fpacking 5Fproblem","http://en.wikipedia.org/wiki/Bin% 5Fpacking% 5Fproblem","http://en.wikipedia.org/wiki/Bin%5Fpacking%5Fproblem","http://en.wikipedia.org/wiki/Bin_pac...roblem#_note","http://en.wikipedia.org/wiki/Bin_packing","http://en.wikipedia.org/wiki/Bin_packing.","http://en.wikipedia.org/wiki/Bin_packing_prob...","http://en.wikipedia.org/wiki/Bin_packing_problem","http://en.wikipedia.org/wiki/Bin_packing_problem#First-fit_algorithm","http://en.wikipedia.org/wiki/Bin_packing_problem,","http://en.wikipedia.org/wiki/Bin_packing_problem.","http://en.wikipedia.org/wiki/Bin_packing_problemを","http://en.wikipedia.org/wiki/Bin_packing…","http://en.wikipedia.org/wiki/Bin％5Fpacking 5Fproblem","http://en.wikipedia.org/wiki/Bin％5Fpacking％5Fproblem","http://en.wikipedia.org/wiki/Bin％5Fproblemを","http://en.wikipedia.org/wiki/B​in_packing_problem","http://en.wikipedia.org/wiki/First_fit_algorithm","http://en.wikipedia.org/wiki/First_fit_algorithm.","http://fr.wikipedia.org/wiki/Bin_packing_problem","http://fr.wikipedia.org/wiki/Probl%C...de_bin_packing","http://fr.wikipedia.org/wiki/Probl%C3%A8me_de_bin_packing","http://goo.gl/OBLuZ","http://ja.wikipedia.org/wiki/ビンパッキング問題","http://ru.wikipedia.org/wiki/Задача_о...контейнеры","http://ru.wikipedia.org/wiki/Задача_об_упаковке_в_контейнеры","imballaggio Bin Problema","imballaggio Bin,","imballaggio bin","ja:ビンパッキング問題","l'article de Wikipédia Bin packing problem","loading trucks","masalah pengepakan bin,","masalah pengepakan sampah","packing bin problema","pakattava esineitä lokeroihin","pakning problem","pakowania bin","pakowania problemu","pakowanie bin","papelera de embalaje","pengepakan Bin","pengepakan bin masalah.","problem binpacking","problem pakowania bin","problema bin embalaje","problema bin packing","problema bin packing,","problema bin packing.","problema binpacking","problema de embalaje bin","problema de embalaje bin,","problema de embalaje bin.","problema de embalaje del compartimiento","problema di bin packing","problema di bin packing.","problema di imballaggio","problema di imballaggio bin","problema di imballaggio bin,","problemu pakowania bin","problème d'emballage bin","problème de l'empaquetage,","problème de l'empaquetage.","problém bin balení","queste strategie semplici","ru:Задача об упаковке в контейнеры","tato jednoduchá strategie","the Bin Packing problem","the bin packing problem","these simple strategies","thùng bao bì vấn đề","tych prostych strategii","vấn đề bao bì thùng.","vấn đề đóng gói bin,","wikipedia alla riscossa!","wikipedia na ratunek!","đóng gói Bin,","Википедии статью Задача трехмерной упаковки в объем","Задача об упаковке в контейнеры","Задача_об_упаковке_в_контейнеры","Задачи об упаковке в контейнеры","Кроши мельче!","Упаковка в контейнеры","бен Проблема Упаковка","бен Упаковка","бен задачи упаковки","бен упаковке","двумерной упаковки объектов","задачей об упаковке в контейнеры","классическая NP-трудная задача об упаковке","проблема бен упаковке,","проблема бен упаковке.","проблема упаковки в контейнеры","упаковка проблемы бен","упаковке в контейнеры","упаковки в контейнеры","упаковки в контейнеры проблема","упаковки в контейнеры,","упаковки контейнера","बिन पैकिंग","बिन पैकिंग समस्या","वर्णन पैकिंग","समस्या पैकिंग बिन","ถัง บรรจุ","ถัง บรรจุ ปัญหา","ถังบรรจุปัญหา","บรรจุ ถัง","ปัญหา บรรจุ ถัง","ปัญหา บรรจุ ถัง.","“Bin Packing","、binpacking","、このページには、","これらの単純な戦略は","ビンのパッキン","ビンパッキング","ビンパッキング問題","ビンパッキング問題 - Wikipedia","ビンパッキング問題は","維基百科的文章“ 集装优化”","维基百科的文章“ 集装优化”","装箱","装箱问题","裝箱","裝箱問題","这些简单的策略","问题装箱","集装优化","빈 문제를 포장","빈 패킹","빈 패킹 문제","빈 패킹 문제의","쓰여왔다이 페이지에는","：http://en.wikipedia.org/wiki/Bin_packing_problem"],"name":"Bin packing problem","categories":["All articles needing additional references","Articles needing additional references from July 2015","CS1 errors: chapter ignored","Optimization algorithms and methods","Packing problems","Strongly NP-complete problems"],"tag_line":"In the bin packing problem, objects of different volumes must be packed into a finite number of bins or containers each of volume V in a way that minimizes the number of bins used."}}
,{"_index":"throwtable","_type":"algorithm","_id":"auction-algorithm","_score":0,"_source":{"description":"The term \"auction algorithm\"  applies to several variations of a combinatorial optimization algorithm which solves assignment problems, and network optimization problems with linear and convex/nonlinear cost. An auction algorithm has been used in a business setting to determine the best prices on a set of products offered to multiple buyers. It is an iterative procedure, so the name \"auction algorithm\" is related to a sales auction, where multiple bids are compared to determine the best offer, with the final sales going to the highest bidders.\nThe original form of the auction algorithm is an iterative method to find the optimal prices and an assignment that maximizes the net benefit in a bipartite graph, the maximum weight matching problem (MWM).  This algorithm was first proposed by Dimitri Bertsekas in 1979. Detailed analysis and extensions to more general network optimization problems (ε-relaxation in 1986, and network auction in 1992) are provided in his network optimization books Linear Network Optimization 1991, and Network Optimization: Continuous and Discrete Models 1998. The auction algorithm has excellent computational complexity, as given in these books, and is reputed to be among the fastest for solving single commodity network optimization problems. In addition, the original version of this algorithm is known to possess a distributed nature particularly suitable for distributed systems, since its basic computational primitives (bidding and auctioning) are localized rather than relying on queries of global information. However, the original version that is intrinsically distributable has a pseudo-polynomial time complexity, which means that the running time depends on the input data pattern. Later versions have improved the time complexity to the state-of-the-art level by using techniques such as ε-scaling (also discussed in the original 1979 paper) but at the sacrifice of undermining its distributed characteristics. In order to retain the distributed nature and also attain a polynomial time complexity, recently some researchers from the multi-agent community have been trying to improve the earlier version of the auction algorithm by switching to a different economic model, namely, from the selfish bidders' perspective to a merchant’s point of view, where the merchant of a market adjusts the article prices in order to quickly clear the inventory.\nThe ideas of the auction algorithm and ε-scaling  are also central in preflow-push algorithms for single commodity linear network flow problems. In fact the preflow-push algorithm for max-flow can be derived by applying the original 1979 auction algorithm to the max flow problem after reformulation as an assignment problem; see the 1998 Network Optimization book, by Bertsekas, Section 7.3.3. Moreover the preflow-push algorithm for the linear minimum cost flow problem is mathematically equivalent to the ε-relaxation method, which is obtained by applying the original auction algorithm after the problem is reformulated as an equivalent assignment problem.\nA later variation of the auction algorithm that solves shortest path problems was introduced by Bertsekas in 1991. It is a simple algorithm for finding shortest paths in a directed graph. In the single origin/single destination case, the auction algorithm maintains a single path starting at the origin, which is then extended or contracted by a single node at each iteration. Simultaneously, at most one dual variable will be adjusted at each iteration, in order to either improve or maintain the value of a dual function. In the case of multiple origins, the auction algorithm is well-suited for parallel computation. The algorithm is closely related to auction algorithms for other network flow problems. According to computational experiments, the auction algorithm is generally inferior to other state-of-the-art algorithms for the all destinations shortest path problem, but is very fast for problems with few destinations (substantially more than one and substantially less than the total number of nodes); see the article by Bertsekas, Pallottino, and Scutella, Polynomial Auction Algorithms for Shortest Paths.\nAuction algorithms for shortest hyperpath problems have been defined by De Leone and Pretolani in 1998. This is also a parallel auction algorithm for weighted bipartite matching, described by E. Jason Riedy in 2004.","alt_names":["- Auction algorithm :","Auction Algorithm (wikipedia)","Auction algorithm","Auction algorithm - Wikipedia :: The free encyclopedia","Auction algorithm - Wikipedia, the free encyclopedia","What are the comparisons of Auction algorithm","Wikipedia article Auction algorithm","Wikipedia entry for Auction algorithm","auction algorithm","auction algorithms","http://en.wikipedia.org/wiki/Auction_algorithm","yago-res:Auction algorithm"],"name":"Auction algorithm","categories":["Optimization algorithms and methods","Pages with duplicate reference names","Pages with reference errors"],"tag_line":"The term \"auction algorithm\"  applies to several variations of a combinatorial optimization algorithm which solves assignment problems, and network optimization problems with linear and convex/nonlinear cost."}}
,{"_index":"throwtable","_type":"algorithm","_id":"secant-method","_score":0,"_source":{"description":"In numerical analysis, the secant method is a root-finding algorithm that uses a succession of roots of secant lines to better approximate a root of a function f. The secant method can be thought of as a finite difference approximation of Newton's method. However, the method was developed independently of Newton's method, and predated the latter by over 3,000 years.","alt_names":["Derivation of the method","- Secant method :","-> Leggi l'articolo completo su Metodo delle secanti","...Wikipedia Metoda siecznych","...Wikipedia Metodo delle corde","...Wikipedia Méthode de la sécante","...mehr auf Wikipedia über Sekantenverfahren","...more on Wikipedia about Secant method","1 方法","2 方法的推导","3 收敛","6.وتری Secant",": http://en.wikipedia.org/wiki/Secant_method","H rm dszer - Wikip dia","Húrmódszer","Learn about Secant method>>>","M todo de la secante Wikipedia la enciclopedia","M?thode de la s?cante - Wikip?dia","M?todo de la secante - Wikipedia, la enciclopedia","Metoda sečen","Metoda siecznych ? Wikipedia, wolna encyklopedia","Metoda siecznych – Wikipedia, wolna encyklopedia","Metode sekan","Metodo delle corde","Metodo delle corde - Wikipedia","Metodo delle secanti","Metodo delle secanti - Wikipedia","Metodo delle secanti o delle corde","Mètode de la secant","Méthode de la sécante","Méthode de la sécante - Wikipédia","Método das secantes","Método de la secante","Método de la secante - Wikipedia, la enciclopedia libre","Secant Mehod(割线法)","Secant Method","Secant method","Secant method - Wikipedia :: The free encyclopedia","Secant method - Wikipedia, the free encyclopedia","Secant method - Wikipedia, the free encyclopedia http://en","Secant method Wikipedia the free encyclopedia","Secant method: Example code","Secant method; it is used under the","Secant search","Secant-methode","Secant_method","Secantmethod_jaredwf.png","Secant法","Sekantenverfahren","Sekantenverfahren - Wikipedia","Sekantenverfahren ? Wikipedia","Sekantmetoden","Sekantna metoda","Sekanttimenetelmä","Szel?módszer","Szelőmódszer","What are generalizations of Secant method","What are generalizations of Secant method?","Wiki -> Метод секущих","Wikipedia article Metoda siecznych","Wikipedia article Método das secantes","Wikipedia article Secant method","Wikipedia article Sekantmetoden","Wikipedia article Sekantna metoda","Wikipedia article on Secant method","Wikipedia entry for Secant method","Wikipedia sur Méthode de la sécante","Wikipedia-Artikel Sekantenverfahren","Wikipedia-Seite zu 'Sekantenverfahren'","Wikipedia:Secant method","artículo de Wikipedia Metodo de la secante","ca:Mètode de la secant","de:Sekantenverfahren","en.wikipedia.org/...Secant_method","es:Método de la secante","es:Método_de_la_secante","fi:Sekanttimenetelmä","fr:Méthode de la sécante","he secant metho","he:שיטת המיתר","http//de.wikipedia.org/wiki/Sekantenverfahren","http://de.wikipedia.org/wiki/Sekantenver","http://de.wikipedia.org/wiki/Sekantenverfahren","http://en.wikiped...ant_method","http://en.wikipedia.org/wiki/Secant_meth","http://en.wikipedia.org/wiki/Secant_method","http://en.wikipedia.org/wiki/Secant_method#Derivation_of_the_method","http://en.wikipedia.org/wiki/Secant_method#Example_code","http://en.wikipedia.org/wiki/Secant_method#The_method","http://en.wikipedia.org/wiki/Secant_meth…","http://en.wikipedia.org/wiki/secant_method","http://es.wikipedia.org/wiki/M%C3%A9todo_de_la_secante","http://fr. wikipedia.org/wiki /M%C3%A9thode_de_la_s","http://fr.wikipedia.org/wiki/M%C3%A9thode_de_la_s","http://it.wikipedia.org/wiki/Metodo_delle_corde","http://it.wikipedia.org/wiki/Metodo_delle_secanti","http://nl.wikipedia.org/wiki/Secant-meth","http://nl.wikipedia.org/wiki/Secant-methode","http://pl.wikipedia.org/wiki/Metoda_siecznych","http://pl.wikipedia.org/wiki/Metoda_siecznyh","http://ru.wikipedia.org/wiki/Метод_секущ...","http://ru.wikipedia.org/wiki/Метод_хорд","http://sl.wikipedia.org/wiki/Sekantna_metoda","http://sv.wikipedia.org/wiki/Sekantmetoden","http://zh.wikipedia.org/zh-tw/割线法","hu:Húrmódszer","hu:Szelőmódszer","id:Metode sekan","it:Metodo delle corde","metoda siecznych","metode sekan","metodo delle corde","metodo delle secanti","méthode de la sécante","método de la secante","newtonschen Iterationsvorschrift","nl:Secant-methode","order of convergence of the secant method for","pl.wikipedia.or...etoda_siecznych","pl:Metoda siecznych","pt:Método das secantes","ru:Метод секущих","secant method","secant method wiki","secant search","secant-methode","secant_method","secantmethode","sekantna metoda","sl:Sekantna metoda","sr:Метода сечице","sv:Sekantmetoden","wiki:Метод_хорд","x n + 1 = x n - x n - x","x secant","zh:割线法","éthode de la sécante,","Метод Хорд","Метод секущих","Метод хорд","Метода сечице","метод хорд","метода хорд (секущих)","ויקיפדיה - 'שיטת המיתר'","שיטת המיתר","שיטת המיתר – ויקיפדיה","割線法","割線法(Secant Method)","割線法- 維基百科,自由的百科全書","割线法","正割法(secant method)"],"name":"Secant method","categories":["Root-finding algorithms"],"tag_line":"In numerical analysis, the secant method is a root-finding algorithm that uses a succession of roots of secant lines to better approximate a root of a function f. The secant method can be thought of as a finite difference approximation of Newton's method."}}
,{"_index":"throwtable","_type":"algorithm","_id":"online-algorithm","_score":0,"_source":{"description":"In computer science, an online algorithm is one that can process its input piece-by-piece in a serial fashion, i.e., in the order that the input is fed to the algorithm, without having the entire input available from the start.\nIn contrast, an offline algorithm is given the whole problem data from the beginning and is required to output an answer which solves the problem at hand.\nAs an example, consider the sorting algorithms selection sort and insertion sort: Selection sort repeatedly selects the minimum element from the unsorted remainder and places it at the front, which requires access to the entire input; it is thus an offline algorithm. On the other hand, insertion sort considers one input element per iteration and produces a partial solution without considering future elements. Thus insertion sort is an online algorithm.\nNote that insertion sort produces the optimum result, i.e., a correctly sorted list. For many problems, online algorithms cannot match the performance of offline algorithms. If the ratio between the performance of an online algorithm and an optimal offline algorithm is bounded, the online algorithm is called competitive.\nNot every online algorithm has an offline counterpart.","alt_names":["on-line algorithm","- Offline algorithm :","- Online algorithm :","- Online algorithms :","-> Leggi tutto l'articolo su 'Algoritmo online'","-> Read the article about 'Online algorithm'","...mehr auf Wikipedia über Online-Algorithmus","1 Online algorithms","Algoritmo online","Algoritmo online - Wikipedia","Algorytm online","Algorytm online – Wikipedia, wolna encyklopedia","Learn more about online aglorithms","Offline algorithm","Offline algorithms","Online - Algorithmus","Online Algorithm","Online Algorithmen","Online Algorithms","Online Algorithms:","Online Algorithmus","Online algorithm","Online algorithm - Wikipedia :: The free encyclopedia","Online algorithm - Wikipedia, the free encyclopedia","Online algorithm Wikipedia the free encyclopedia","Online algorithm; it is used under the","Online algorithms","Online and offline algorithms","Online problem","Online,","Online-Algorithmen","Online-Algorithmus","Online-Algorithmus - Wikipedia","Online-Algorithmus bei Wikipedia","Online-Algorithmus bei der wikipedia","Online-Algorithmus in","Online-Algorithmus – Wikipedia","Online-Problem","Online-algoritme","Online_algorithm","Online_problem","Wikipedia article Algorytm online","Wikipedia article Offline algorithm","Wikipedia article Online algorithm","Wikipedia article Online algorithms","Wikipedia article Online problem","Wikipedia article on Online algorithm","Wikipedia article on Online algorithms","Wikipedia artikel Offline algoritme","Wikipedia artikel Offline-algoritme","Wikipedia artikel Online-algoritme","Wikipedia entry for Online algorithm","Wikipedia-Artikel Online-Algorithmus","Wikipedia-Seite zu 'Online-Algorithmus'","algoritmi on-line","algoritmos en línea","algoritmos online","algorytmem on-line","algorytmów online","de:Online-Algorithmus","en.wikipedia.org/wiki/Offline_algorithm","en.wikipedia.org/wiki/Online_algorithm","en:Online algorithm","gli algoritmi on-line","http://de.wikipedia.org/wiki/Online-Algo","http://de.wikipedia.org/wiki/Online-Algorithmus","http://en.wikipedia.org/wiki/Online_algo","http://en.wikipedia.org/wiki/Online_algorithm","http://en.wikipedia.org/wiki/Online_algorithms","http://en.wikipedia.org/wiki/Online_problem","http://it.wikipedia.org/wiki/Algoritmo_online","http://nl.wikipedia.org/wiki/Online-algo","http://nl.wikipedia.org/wiki/Online-algoritme","http://pl.wikipedia.org/wiki/Algorytm_online","it:Algoritmo online","ja:オンラインアルゴリズム","ko:온라인 알고리즘","los algoritmos en línea","nl:Online-algoritme","nline learning","offline algorithm","on-line algorithms","on-line algoritmus","on-line and off-line algorithms","online algorithm","online algorithms","online algoritmer","online algoritmes","online and offline algorithms","online problem","online problems","online sorting","online-algoritmeina","online-algoritmer","online-type algorithm","pl:Algorytm online","przyrostowo","онлайн алгоритмы","онлайн-алгоритма","ऑनलाइन एल्गोरिदम","「オンラインアルゴリズム」をWikipediaで調べる","ウィキペディアの記事 オンラインアルゴリズム","オンラインアルゴリズム","オンラインアルゴリズム - Wikipedia","在线算法","온라인 알고리즘","온라인, 오프라인 알고리즘","온라인알고리즘","위키 피 디아 문서 온라인 알고리즘","위키 피 디아 문서 온라인알고리즘"],"name":"Online algorithm","categories":["All articles needing additional references","Articles needing additional references from June 2013","Online algorithms"],"tag_line":"In computer science, an online algorithm is one that can process its input piece-by-piece in a serial fashion, i.e., in the order that the input is fed to the algorithm, without having the entire input available from the start."}}
,{"_index":"throwtable","_type":"algorithm","_id":"karmarkar's-algorithm","_score":0,"_source":{"description":"Karmarkar's algorithm is an algorithm introduced by Narendra Karmarkar in 1984 for solving linear programming problems. It was the first reasonably efficient algorithm that solves these problems in polynomial time. The ellipsoid method is also polynomial time but proved to be inefficient in practice.\nWhere  is the number of variables and  is the number of bits of input to the algorithm, Karmarkar's algorithm requires  operations on  digit numbers, as compared to  such operations for the ellipsoid algorithm. The runtime of Karmarkar's algorithm is thus\n\nusing FFT-based multiplication (see Big O notation).\nKarmarkar's algorithm falls within the class of interior point methods: the current guess for the solution does not follow the boundary of the feasible set as in the simplex method, but it moves through the interior of the feasible region, improving the approximation of the optimal solution by a definite fraction with every iteration, and converging to an optimal solution with rational data.\n\n","alt_names":["Karmarkar's algorithm","Karmarkar's interior-point algorithm","- Karmarkar's algorithm :","...Wikipedia Algoritmo di Karmarkar","1 The Algorithm","3 Patent controversy","Algorithme de Karmarkar","Algoritmi interior-point","Algoritmo de Kamarkar","Algoritmo di Karmarkar","Cultural note 2: A slightly older development: Karmaker's","Karmakar Algorithm?","Karmarkar Algorithm","Karmarkar Linear Programming Algorithm","Karmarkar S Algorithm Wikipedia The Free Encyclopedia","Karmarkar algorithm","Karmarkar s algorithm Wikipedia the free encyclopedia","Karmarkar%27s_algorithm","Karmarkar&#039;s algorithm - Wikipedia, the free encyclopedia","Karmarkar's Algorithm","Karmarkar's algorithm - Wikipedia :: The free encyclopedia","Karmarkar's algorithm - Wikipedia, the free encyclopedia","Karmarkar's algorithm patent controversy","Karmarkar's algorithm.","Learn about Karmarkar's algorithm>>>","Projective algorithm of Karmarkar","Projective method","Reiknirit Karmarkars","Skutki tej decyzji były raczej opłakane","What is Karmarkar algorithm's example","Wikipedia article Algorithme de Karmarkar","Wikipedia article Karmarkar's algorithm","Wikipedia article Projective method","Wikipedia article on Projective method","Wikipedia:Karmarkar's_algorithm","a new polynomial-time algorithm for linear programming","algoritmo di Karmarkar","en.wikipedia.org/wiki/Karmarkar's_algorithm","fr:Algorithme de Karmarkar","http://en.wikipedia.org/wiki/Karmarkar%27s_algorithm","http://en.wikipedia.org/wiki/Karmarkar%2…","http://en.wikipedia.org/wiki/Karmarkar's_algorithm","http://en.wikipedia.org/wiki/Karmarkar's_algorithm#Patent_controversy","http://en.wikipedia.org/wiki/Karmarkar's…","http://en.wikipedia.org/wiki/Karmarkar_algorithm","http://fr.wikipedia.org/wiki/Algorithme_de_Karmarkar","http://it.wikipedia.org/wiki/Algoritmo_di_Karmarkar","ja:カーマーカーのアルゴリズム","k &leftarrow; 0","projective algorithm","projective method","カーマーカーのアルゴリズム","カーマーカーのアルゴリズム - Wikipedia","カーマーカー法"],"name":"Karmarkar's algorithm","categories":["Articles with example pseudocode","Optimization algorithms and methods","Pages containing cite templates with deprecated parameters","Software patent law"],"tag_line":"Karmarkar's algorithm is an algorithm introduced by Narendra Karmarkar in 1984 for solving linear programming problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"metrical-task-system","_score":0,"_source":{"description":"Task systems are mathematical objects used to model the set of possible configuration of online algorithms. They were introduced by Borodin, Linial and Saks (1992) to model a variety of online problems. A task system determines a set of states and costs to change states. Task systems obtain as input a sequence of requests such that each request assigns processing times to the states. The objective of an online algorithm for task systems is to create a schedule that minimizes the overall cost incurred due to processing the tasks with respect to the states and due to the cost to change states.\nIf the cost function to change states is a metric, the task system is a metrical task system (MTS). This is the most common type of task systems. Metrical task systems generalize online problems such as paging, list accessing, and the k-server problem (in finite spaces).","alt_names":[],"name":"Metrical task system","categories":["Online algorithms"],"tag_line":"Task systems are mathematical objects used to model the set of possible configuration of online algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"raita-algorithm","_score":0,"_source":{"description":"In computer science, the Raita algorithm is a string searching algorithm which improves the performance of Boyer-Moore-Horspool algorithm. This algorithm preprocesses the string being searched for the pattern, which is similar to Boyer-Moore string search algorithm. The searching pattern of particular sub-string in a given string is different from Boyer-Moore-Horspool algorithm. This algorithm was published by Tim Raita in 1991.","alt_names":[],"name":"Raita Algorithm","categories":["All articles needing additional references","All articles to be merged","All articles with topics of unclear notability","All orphaned articles","Articles needing additional references from March 2015","Articles to be merged from March 2015","Articles with topics of unclear notability from March 2015","Orphaned articles from May 2013","String matching algorithms"],"tag_line":"In computer science, the Raita algorithm is a string searching algorithm which improves the performance of Boyer-Moore-Horspool algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"critical-path-method","_score":0,"_source":{"description":"The critical path method (CPM) is an algorithm for scheduling a set of project activities.","alt_names":["Kritischen Pfad","クリティカルパス","critical path method","chemin critique","critical path analysis","Critical Path Method","Critical Path Method (CPM)","Critical path method - Wikipedia, the free encyclopedia","(Kelley, James; Walker, Morgan. Critical-Path Planning and","(critical path analysis method)",", Methode des kritischen Pfades","- Critical Path Method :","- Critical path analysis :","- Critical path method :","...Wikipedia Método de la ruta crítica","...mehr auf Wikipedia über Methode des kritischen Pfades","Analisis jalur kritis","Analisis jalur kritis - Wikipedia bahasa Indonesia, ensiklopedia bebas","Analisis jalur kritis :: Wikipedia Bahasa Indonesia","Analisis jalur kritis Wikipedia bahasa Indonesia ensiklopedia bebas","Bide Kritikoaren Metodoa","Bide Kritikoaren Metodoa - Wikipedia, entziklopedia askea.","CPM (Critical Path Method)","CPM Netzplan","CPM o","CPM-Critical Path Method","Caminho Crítico","Caminho cr?tico ? Wikip?dia, a enciclop?dia","Caminho crítico","Caminho crítico - Wikipédia, a enciclopédia livre","Caminho crítico – Wikipédia, a enciclopédia livre","Chemin critique","Crashing critical path","Critial Path Management","Critical Path Analysis","Critical Path Analysis (CPA)","Critical Path Analysis (CPA):","Critical Path Analysis on Wikipedia","Critical Path Management","Critical Path Metho","Critical Path Method (CPM) -","Critical Path Method (CPM) Scheduling","Critical Path Method - Wikipedia, The Free Encyclopedia","Critical Path Method CPM","Critical Path Method Wiki","Critical Path Method en anglais","Critical Path Method in English","Critical Path Method of Scheduling","Critical Path Method or CPM.","Critical Path Method – Wikipedia, wolna encyklopedia","Critical Path Method, na wikipédia em inglês (mais","Critical Path Method; it is used under the","Critical Path Modeling","Critical Path Project Management","Critical Path and Dependencies","Critical Path method","Critical Path-Methode","Critical Paths","Critical path algoritm","Critical path analysis","Critical path analysis; it is used under the","Critical path method","Critical path method - Wikipedia :: The free encyclopedia","Critical path method - Wikipedia, the free encyclopedia ...","Critical path method - Wikipedia, the free encyclopedia ↪","Critical path method Wikipedia the free encyclopedia","Critical path method Wikipedia the free encyclopedia - result","Critical path method from Wikipedia","Critical path method; it is used under the","CriticalPath","Critical_Path_Method bei der wikipedia","Critical_path_analysis","Critical_path_method","DE.Wikipedia Methode des kritischen Pfades","Definición de Método de la ruta crítica más","EN.Wikipedia Critical path method","Fast tracking","Image:Pert chart colored.gif","Kriittinen polku","Kriittinen polku Wikipediassa","Kriittinen polku – Wikipedia","Kritick? cesta - Wikipedie","Kritická cesta","Kritická cesta - Wikipedie","Kritická cesta - Wikipedie - Wikipedia","Kritieke pad","Kritieke pad - Wikipedia","Kritieke pad methode","Learn about Critical path method>>>","M?todo de la ruta cr?tica - Wikipedia","Methode des kritischen Pfades","Methode des kritischen Pfades (CPM)","Methode des kritischen Pfades - Wikipedia","Methode des kritischen Pfades ? Wikipedia","Methode des kritischen Pfades – Wikipedia","Methode_des_kritischen_Pfades","Metoda Drumului Critic","Metódou kritickej cesty","Método de Ruta Crítica - Wikipedia","Método de la ruta crítica","Método de la ruta crítica - Wikipedia, la enciclopedia","Método del Camino Crítico","Netzplantechnik) vorliegen","Phương pháp Đường găng","Phương pháp Đường găng – Wikipedia","Phương pháp Đường găng – Wikipedia tiếng Việt","Program evaluation Review Technique","Ruta cr'tica","Ruta crítica","The critical path method defined and explained briefly","View Critical path method on Wikipedia","Wekipedia Japanより引用","What is the history of Critical Path Analysis","What is the history of Critical path method","Wiki - CPM: Critical Path Method","Wikipedia (Caminho crítico)","Wikipedia - Critcal Path","Wikipedia Método de la ruta crítica","Wikipedia article Analisis jalur kritis","Wikipedia article Caminho crítico","Wikipedia article Critical Path Analysis","Wikipedia article Critical Path Method","Wikipedia article Critical path analysis","Wikipedia article Critical path method","Wikipedia article Kritická cesta","Wikipedia article Kritieke pad","Wikipedia article Método de la ruta crítica","Wikipedia article on Método de la ruta crítica","Wikipedia article נתיב קריטי","Wikipedia article طريقة المسار الحرج","Wikipedia article การหาเส้นทางวิกฤต","Wikipedia article 크리티컬 패스 분석법","Wikipedia entry for Critical path method","Wikipedia over het kritieke pad","Wikipedia-Artikel Critical Path Method","Wikipedia-Artikel Methode des kritischen Pfades","Wikipedia-Seite zu 'Critical Path Method'","Wikipedia-Seite zu 'Methode des kritischen Pfades'","Wikipedia/Critical path method","Wikipedia: Critical Path Method","Wikipédia artigo Caminho crítico","Work Management: Critical Path Method","You'd also need a manufacturing industry that","[1.] http://en.wikipedia.org/wiki/Critical_path_method","[15] Critical Path Method","analisis jalur kritis","análise do caminho crítico","ar:طريقة المسار الحرج","artigo da Wikipédia Caminho crítico","artículo de Wikipedia Critical Path Method","artículo de Wikipedia Método de la ruta crítica","bg:Метод на критичния път","caminho crítico","caminho crítico do projeto","caminho crítico,","chemin critique,","computer supported scheduling","con đường quan trọng","critical path (CPM)","critical path analysi","critical path charts","critical path diagram","critical path metho","critical path method (CPM)","critical path method (CPM) analysis","critical path method wikipedia the free encyclopedia","critical path scheduling","critical path.","critical pathing,","critical-path analysis","cs:Kritická cesta","cálculo de la ruta crítica","de la ruta crítica","de:Methode des kritischen Pfades","drumurilor critice","en.wikipedia.org/...Critical_path_method","en.wikipedia.org/wiki/Critical_path_a...","en.wikipedia.org/wiki/Critical_path_m...","en.wikipedia.org/wiki/Critical_path_method","en:Critical Path Method","es.wikipedia.org/wiki/M%C3%A9todo_de_la_ruta_cr%C3","es.wikipedia.org/wiki/Método_de_la_ruta_crítica","es:Método de la ruta crítica","fi:Kriittinen polku","folga em seu caminho crítico","graficas de PERT/CPM.","he:נתיב קריטי","http://ar.wikipedia.org/wiki/طريقة_المسار_الحرج","http://cs.wikipedia.org...%A1_cesta","http://cs.wikipedia.org/wiki/Kritick%C3%A1_cesta","http://cs.wikipedia.org/wiki/Kritická_cesta","http://de.wikipedia.org/wiki/Methode...tischen_Pfades","http://de.wikipedia.org/wiki/Methode_de ... hen_Pfades","http://de.wikipedia.org/wiki/Methode_des","http://de.wikipedia.org/wiki/Methode_des_kritischen_Pfades","http://en.wikipedia.org/wiki/Critical_Path_Analysis","http://en.wikipedia.org/wiki/Critical_Path_Method","http://en.wikipedia.org/wiki/Critical_pa","http://en.wikipedia.org/wiki/Critical_path_analysis","http://en.wikipedia.org/wiki/Critical_path_me...","http://en.wikipedia.org/wiki/Critical_path_method","http://en.wikipedia.org/wiki/Critical_path_method#Basic_technique","http://en.wikipedia.org/wiki/Critical_path_method.","http://en.wikipedia.org/wiki/critical_path_method","http://en.wikipedia.​org/wiki/Critical_pa​th_method","http://es.wikipedia.org/wiki/Criti","http://es.wikipedia.org/wiki/Critical_Path_Method","http://es.wikipedia.org/wiki/Critical_Pa​th_Method","http://es.wikipedia.org/wiki/M%C3%A9todo_de_la_ruta_cr","http://eu.wikipedia.org/wiki/bide_kritikoaren_metodoa","http://fr.wikipedia.org/wiki/Chemin_critique","http://id.wikipedia.org/wiki/Analisis_jalur_kritis","http://id.wikipedia.org/wiki/analisis_jalur_kritis","http://ja.wikipedia.org/wiki/クリティカルパス法","http://nl.wikipedia.org/wiki/Kritieke_pad","http://nl.wikipedia.org/wiki/kritieke_pad","http://pl.wikipedia.org/wiki/Critical_Path_Method","http://pl.wikipedia.org/wiki/Metoda_%C5%9Bcie","http://pt.wikipedia.org/wiki/Caminho_cr%C3%AD","http://pt.wikipedia.org/wiki/Caminho_cr%C3%ADtico","http://ru.wikipedia.org/wiki/Метод_критического_пути","http://sv.wikipedia.org/wiki/Critical_Path_Method","http://sv.wikipedia.org/wiki/critical_path_method","http://tinyurl.com/m3c7fb","http://vi.wikipedia.org/wiki/Critical_Path_Method","ical path)","id:Analisis jalur kritis","itical path,","ja:クリティカルパス法","jalur kritis,","ko:크리티컬 패스 분석법","kriitilised teed","kritická cesta","kritiek pad","kritieke pad","kritische Pfad","kritischen Weg","kritischer Pfad","l Critical Pa","le chemin critique","le chemin critique du planning proposé","metoda kritične putanje","método de la ruta crítica","need to wait for other tasks","nl:Kritieke pad","percorso critico,","performing more activities in parallel","pl:Critical Path Method","pt:Caminho crítico","ritical Path","ritical path","ru:Метод критического пути","ruta critica","ruta crítica","ruta crítica,","rutas críticas","standard CPM","sv:Critical Path Method","tareas críticas","th:การหาเส้นทางวิกฤต","the Critical Path Method (CPM)","the critical path method","vi:Phương pháp Đường găng","zh:关键路径","|метод критического пути","Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù…Ø³Ø","étodo de la ruta crítica","Метод критического пути","Метод критического пути — Википедия","Метод на критичния път","Метод на критичния път — Уикипедия","Методът на критичния път","критический путь","критического пути","критическом пути","критическом пути,","метод критического пути","נתיב קריטי","נתיב קריטי – ויקיפדיה","المسار الحرج","طريقة المسار الحرج","طريقة المسار الحرج - ويكيبيديا، الموسوعة الحرة","مسیر بحرانی","การหาเส้นทางวิกฤต","การหาเส้นทางวิกฤต - วิกิพีเดีย","เส้นทาง ที่ สำคัญ","“Ruta crítica”","「クリティカルパス分析」をWikiで調べる","クリティカル パス分析","クリティカルパス分析","クリティカルパス法","クリティカルパス法 - Wikipedia","关键路径","关键路径方法","維基百科的文章“ 关键路径”","維基百科的文章“ 关键路径方法”","维基百科的文章“ 关键路径”","路径的关键","關鍵路徑","당신이","중요한 경로에있는,","크리티컬 패스 분석법"],"name":"Critical path method","categories":["All articles needing additional references","Articles needing additional references from May 2009","Business terms","Management","Network theory","Operations research","Production and manufacturing","Project management","Scheduling algorithms"],"tag_line":"The critical path method (CPM) is an algorithm for scheduling a set of project activities."}}
,{"_index":"throwtable","_type":"algorithm","_id":"interval-scheduling","_score":0,"_source":{"description":"Interval scheduling is a class of problems in computer science, particularly in the area of algorithm design. The problems consider a set of tasks. Each task is represented by an interval describing the time in which it needs to be executed. For instance, task A might run from 2:00 to 5:00, task B might run from 4:00 to 10:00 and task C might run from 9:00 to 11:00. A subset of intervals is compatible if no two intervals overlap. For example, the subset {A,C} is compatible, as is the subset {B}; but neither {A,B} nor {B,C} are compatible subsets, because the corresponding intervals within each subset overlap.\nThe interval scheduling maximization problem (ISMP) is to find a largest compatible set - a set of non-overlapping intervals of maximum size. The goal here is to execute as many tasks as possible.\nIn an upgraded version of the problem, the intervals are partitioned into groups. A subset of intervals is compatible if no two intervals overlap, and moreover, no two intervals belong to the same group (i.e. the subset contains at most a single representative interval of each group).\nThe group interval scheduling decision problem (GISDP) is to decide whether there exists a compatible set in which all groups are represented. The goal here is to execute a single representative task from each group. GISDPk is a restricted version of GISDP in which the number of intervals in each group is at most k.\nThe group interval scheduling maximization problem (GISMP) is to find a largest compatible set - a set of non-overlapping representatives of maximum size. The goal here is to execute a representative task from as many groups as possible. GISMPk is a restricted version of GISMP in which the number of intervals in each group is at most k. This problem is often called JISPk, where J stands for Job.\nGISMP is the most general problem; the other two problems can be seen as special cases of it:\nISMP is the special case in which each task belongs to its own group (i.e. it is equal to GISMP1).\nGISDP is the problem of deciding whether the maximum is exactly equal to the number of groups.","alt_names":["Interval Scheduling","Interval Scheduling Problem","Interval scheduling","Interval scheduling - Wikipedia, the free encyclopedia","Interval_scheduling","Wikipedia article Interval scheduling","Wikipedia entry for Interval scheduling","en.wikipedia.org/...Interval_scheduling","http://en.Liarpedia.org/wiki/Interval_scheduling","http://en.wikipedia.org/wiki/Interval_sc","http://en.wikipedia.org/wiki/Interval_scheduling","interval scheduling","maximum number of achievable tasks","weighted interval scheduling","间隔调度"],"name":"Interval scheduling","categories":["Scheduling algorithms"],"tag_line":"Interval scheduling is a class of problems in computer science, particularly in the area of algorithm design."}}
,{"_index":"throwtable","_type":"algorithm","_id":"quantum-phase-estimation-algorithm","_score":0,"_source":{"description":"In quantum computing, the quantum phase estimation algorithm is a quantum algorithm that finds many applications as a subroutine in other algorithms. The quantum phase estimation algorithm allows one to estimate the eigenphase of an eigenvector of a unitary gate, given access to a quantum state proportional to the eigenvector and a procedure to implement the unitary conditionally.","alt_names":["400px-Quantum_phase_estimation ...","Algorithme d'estimation de phase quantique","Quantum Phase estimation algorithm - Wikipedia, the free encyclopedia","Quantum phase estimation algorithm","Quantum phase estimation algorithm - Wikipedia :: The free encyclopedia","Quantum phase estimation algorithm - Wikipedia, the free encyclopedi","Quantum phase estimation algorithm - Wikipedia, the free encyclopedia","http://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm","phase estimation","quantum phase estimation algorithm"],"name":"Quantum phase estimation algorithm","categories":["All Wikipedia articles needing context","All articles needing expert attention","All pages needing cleanup","Articles needing expert attention from September 2010","Articles needing expert attention with no reason or talk parameter","Articles needing unspecified expert attention","Quantum algorithms","Wikipedia articles needing context from September 2010","Wikipedia introduction cleanup from September 2010"],"tag_line":"In quantum computing, the quantum phase estimation algorithm is a quantum algorithm that finds many applications as a subroutine in other algorithms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"atlantic-city-algorithm","_score":0,"_source":{"description":"An Atlantic City algorithm is a probabilistic polynomial-time algorithm that answers correctly at least 75% of the time (or, in some versions, some other value greater than 50%). The term \"Atlantic City\" was first introduced in 1982 by J. Finn in an unpublished manuscript entitled Comparison of probabilistic tests for primality.\nTwo other common classes of probabilistic algorithms are Monte Carlo algorithms and Las Vegas algorithms. Monte Carlo algorithms are always fast, but only probably correct. On the other hand, Las Vegas algorithms are always correct, but only probably fast. The Atlantic City algorithms which are bounded probabilistic polynomial time algorithms are probably correct and probably fast.\n\n","alt_names":[],"name":"Atlantic City algorithm","categories":["Cryptography","Randomized algorithms"],"tag_line":"An Atlantic City algorithm is a probabilistic polynomial-time algorithm that answers correctly at least 75% of the time (or, in some versions, some other value greater than 50%)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"entropy-compression","_score":0,"_source":{"description":"In mathematics and theoretical computer science, entropy compression is an information theoretic method for proving that a random process terminates, originally used by Robin Moser to prove an algorithmic version of the Lovász local lemma.","alt_names":[],"name":"Entropy compression","categories":["Analysis of algorithms","Probabilistic complexity theory","Randomized algorithms"],"tag_line":"In mathematics and theoretical computer science, entropy compression is an information theoretic method for proving that a random process terminates, originally used by Robin Moser to prove an algorithmic version of the Lovász local lemma."}}
,{"_index":"throwtable","_type":"algorithm","_id":"shortest-job-next","_score":0,"_source":{"description":"Shortest job next (SJN), also known as Shortest Job First (SJF) or Shortest Process Next (SPN), is a scheduling policy that selects the waiting process with the smallest execution time to execute next. SJN is a non-preemptive algorithm. Shortest remaining time is a preemptive variant of SJN.\nShortest job next is advantageous because of its simplicity and because it minimizes the average amount of time each process has to wait until its execution is complete. However, it has the potential for process starvation for processes which will require a long time to complete if short processes are continually added. Highest response ratio next is similar but provides a solution to this problem.\nAnother disadvantage of using shortest job next is that the total execution time of a job must be known before execution. While it is not possible to perfectly predict execution time, several methods can be used to estimate the execution time for a job, such as a weighted average of previous execution times.\nShortest job next can be effectively used with interactive processes which generally follow a pattern of alternating between waiting for a command and executing it. If the execution burst of a process is regarded as a separate \"job\", past behaviour can indicate which process to run next, based on an estimate of its running time.\nShortest job next is used in specialized environments where accurate estimates of running time are available. Estimating the running time of queued processes is sometimes done using a technique called aging.","alt_names":["...mehr auf Wikipedia über Shortest-Job-First","...more on Wikipedia about Shortest job next","1. SJF","KOZ - Wikipedia","Learn about Shortest job next>>>","Mais informações sobre SJF!","SJF (Shortest Job First)","SJF - Wikipédia, a enciclopédia livre","SJF 스케줄링","SRTF 스케줄링","Shortest Job (or Process) Next","Shortest Job First","Shortest Job First Process Scheduling","Shortest Job Next","Shortest Job Next (SJN)","Shortest Job Next – Wikipedia","Shortest Process First","Shortest job first","Shortest job first - Wikip?dia","Shortest job first - Wikipedia","Shortest job first - Wikipédia","Shortest job next","Shortest job next - Wikipedia, the free encyclopedia","Shortest job next; it is used under the","Shortest-Job-First","Shortest-Job-Next","Shortest-Job-Next in","Shortest-Job-Next – Wikipedia","Shortest-Process-Next","Wikipedia article Shortest Job Next","Wikipedia article Shortest job next","Wikipedia article on Shortest job next","Wikipedia l'articolo Shortest job first","Wikipedia-Artikel Shortest-Job-First","Wikipedia-Artikel Shortest-Job-Next","Wikipedia-Artikel Shortest-Process-Next","Wikipedia-Seite zu 'KOZ'","Wikipedia-Seite zu 'Shortest-Job-Next'","Wikipediaドイツ版 - KOZ","Wikipédia artigo SJF","[6] SJF","de.wikipedia.org/wiki/Shortest-Job-Next","de:Shortest-Job-First","de:Shortest-Job-Next","en.wikipedia.org/wiki/Shortest_job_next","en:Shortest job next","et:Shortest Job Next","fr:Shortest job first","http://de.wikipedia.org/wiki/Shortest-Jo","http://de.wikipedia.org/wiki/Shortest-Job-First","http://de.wikipedia.org/wiki/Shortest-Job-Next","http://de.wikipedia.org/wiki/Shortest-Pr","http://em.wikipedia.org/wiki/Shortestjobnext","http://en.wikipedia.org/wiki/Shortest_jo","http://en.wikipedia.org/wiki/Shortest_job_next","http://et.wikipedia.org/wiki/Shortest_Job_Next","http://et.wikipedia.org/wiki/Shortest_Job_Next_(SJN)","http://fr.wikipedia.org/wiki/Shortest_job_first","http://it.wikipedia.org/wiki/Shortest_job_first","http://pt.wikipedia.org/wiki/SJF","ko:최단 작업 우선 스케줄링","l'article de Wikipédia Shortest job first","pt:SJF","ru:Кратчайшая работа следующей","shortest job next","Кратчайшая работа следующей","위키 피 디아 문서 SJF 스케줄링","위키 피 디아 문서 SRTF 스케줄링","위키 피 디아 문서 최단 작업 우선 스케줄링","위키 피 디아 문서 최단 잔여 시간 우선","최단 작업 우선 스케줄링"],"name":"Shortest job next","categories":["Processor scheduling algorithms"],"tag_line":"Shortest job next (SJN), also known as Shortest Job First (SJF) or Shortest Process Next (SPN), is a scheduling policy that selects the waiting process with the smallest execution time to execute next."}}
,{"_index":"throwtable","_type":"algorithm","_id":"deadline-monotonic-scheduling","_score":0,"_source":{"description":"Deadline-monotonic priority assignment is a priority assignment policy used with fixed priority pre-emptive scheduling.\nWith deadline-monotonic priority assignment, tasks are assigned priorities according to their deadlines; the task with the shortest deadline being assigned the highest priority.\nThis priority assignment policy is optimal for a set of periodic or sporadic tasks which comply with the following restrictive system model:\nAll tasks have deadlines less than or equal to their minimum inter-arrival times (or periods).\nAll tasks have worst-case execution times (WCET) that are less than or equal to their deadlines.\nAll tasks are independent and so do not block each other's execution (for example by accessing mutually exclusive shared resources).\nNo task voluntarily suspends itself.\nThere is some point in time, referred to as a critical instant, where all of the tasks become ready to execute simultaneously.\nScheduling overheads (switching from one task to another) are zero.\nAll tasks have zero release jitter (the time from the task arriving to it becoming ready to execute).\nIf restriction 7 is lifted, then \"deadline minus jitter\" monotonic priority assignment is optimal.\nIf restriction 1. is lifted allowing deadlines greater than periods, then Audsley's optimal priority assignment algorithm may be used to find the optimal priority assignment.\nDeadline monotonic priority assignment is not optimal for fixed priority non-pre-emptive scheduling.\nA fixed priority assignment policy P is referred to as optimal if no task set exists which is schedulable using a different priority assignment policy which is not also schedulable using priority assignment policy P. Or in other words: Deadline-monotonic priority assignment (DMPA) policy is optimal if any process set, Q, that is schedulable by priority scheme, W, is also schedulable by DMPA","alt_names":["- Deadline-monotonic scheduling :","Deadline Monotonic <b>Scheduling</b> - Wikipedia","Deadline Monotonic Scheduling","Deadline Monotonic Scheduling - Wikipedia","Deadline Monotonic Scheduling in","Deadline Monotonic Scheduling – Wikipedia","Deadline Monotonic Scheduling 鈥�Wikipedia","Deadline monotonic scheduling","Deadline-monotonic scheduling","Deadline-monotonic scheduling - Wikipedia, the free encyclopedia","Deadline_Monotonic_Scheduling","Deadline_Monotonic_Scheduling bei der wikipedia","Wikipedia article ''Deadline-monotonic scheduling''","Wikipedia article Deadline-monotonic scheduling","Wikipedia entry for Deadline-monotonic scheduling","Wikipedia-Artikel Deadline Monotonic Scheduling","Wikipedia-Seite zu 'Deadline Monotonic Scheduling'","article Deadline-monotonic scheduling","deadline monotonic algorithm","deadline-monotonic scheduling","en:Deadline-monotonic scheduling","http://de.wikipedia.org/wiki/Deadline_Mo","http://en.wikipedia.org/wiki/Deadline-m ... scheduling","http://en.wikipedia.org/wiki/Deadline-mo","http://en.wikipedia.org/wiki/Deadline-monotonic_scheduling","yago-res:Deadline-monotonic scheduling"],"name":"Deadline-monotonic scheduling","categories":["All articles covered by WikiProject Wikify","All articles with too few wikilinks","All stub articles","Articles covered by WikiProject Wikify from December 2012","Articles with too few wikilinks from December 2012","Computer science stubs","Processor scheduling algorithms"],"tag_line":"Deadline-monotonic priority assignment is a priority assignment policy used with fixed priority pre-emptive scheduling."}}
,{"_index":"throwtable","_type":"algorithm","_id":"variation-(game-tree)","_score":0,"_source":{"description":"A Variation can refer to a specific sequence of successive moves in a turn-based game, often used to specify a hypothetical future state of a game that is being played. Although the term is most commonly used in the context of Chess analysis, it has been applied to other games. It also is a useful term used when describing computer tree-search algorithms (for example minimax) for playing games such as Go or Chess.\nA variation can be any number of steps as long as each step would be legal if it were to be played. It is often as far ahead as a human or computer can calculate; or however long is necessary to reach a particular position of interest. It may also lead to a terminal state in the game, in which case the term \"Winning Variation\" or \"Losing Variation\" is sometimes used.","alt_names":["Principal Variation","Principal Variation，并利用这个来排序下迭代里产生的走法。 游戏树中会有很多相同的节点。为免重覆计算节点，这游戏也使用了","Principal variation","Principle Variation","Variation (Game Tree)","Variation (game tree)","Variation (game tree) - Wikipedia, the free encyclopedia","Variation (game tree) - Wikipedia, the free encyclopedia ...","Variation (game tree); it is used under the","Variation game tree","Wikipedia article Variation (game tree)","Wikipedia article about Variation (game tree)","Wikipedia article on Principal variation","Wikipedia entry for Variation (game tree)","external image Principle_variation_16bit.PNG","http://en.wikipedia.org/wiki/Variation (game tree","http://en.wikipedia.org/wiki/Variation_(game_tree)","http://en.wikipedia.org/wiki/Variation_(game_tree)#Principal_variation","principal variation","ru.wikipedia.org/wiki/Вариант_(шахматная_композиция)","yago-res:Variation_(game_tree)","Вариант (шахматная композиция)","Вариант (шахматная композиция) — Википедия"],"name":"Variation (game tree)","categories":["Combinatorial game theory","Computer chess","Game artificial intelligence","Search algorithms","Trees (graph theory)"],"tag_line":"A Variation can refer to a specific sequence of successive moves in a turn-based game, often used to specify a hypothetical future state of a game that is being played."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fibonacci-search-technique","_score":0,"_source":{"description":"In computer science, the Fibonacci search technique is a method of searching a sorted array using a divide and conquer algorithm that narrows down possible locations with the aid of Fibonacci numbers. Compared to binary search, Fibonacci search examines locations whose addresses have lower dispersion. Therefore, when the elements being searched have non-uniform access memory storage (i.e., the time needed to access a storage location varies depending on the location previously accessed), the Fibonacci search has an advantage over binary search in slightly reducing the average time needed to access a storage location. The typical example of non-uniform access storage is that of a magnetic tape, where the time to access a particular element is proportional to its distance from the element currently under the tape's head. Note, however, that large arrays not fitting in CPU cache or even in RAM can also be considered as non-uniform access examples. Fibonacci search has a complexity of O(log(n)) (see Big O notation).\nFibonacci search was first devised by Jack Kiefer (1953) as a minimax search for the maximum (minimum) of a unimodal function in an interval.","alt_names":["- Fibonacci search technique :","Búsqueda de Fibonacci","Fibonacci Search","Fibonacci Search Algorithm","Fibonacci methods","Fibonacci search","Fibonacci search algorithm","Fibonacci search technique","Fibonacci search technique - Wikipedia :: The free encyclopedia","Fibonacci search technique - Wikipedia, the free encyclopedia","Fibonacci search technique Wikipedia the free encyclopedia","Fibonacci search.","Fibonacci_search_technique","The other kind of Fibonacci search","What is algorithm of Fibonacci search technique","What is algorithm of Fibonacci search?","Wikipedia article Fibonacci search","Wikipedia article Fibonacci search technique","Wikipedia article on Fibonacci search technique","Wikipedia entry for Fibonacci search technique","en.wikipedia.org/wiki/Fibonacci_search_technique","http://en.wikipedia.org/wiki/Fibonacci_s","http://en.wikipedia.org/wiki/Fibonacci_search","http://en.wikipedia.org/wiki/Fibonacci_search#Fibonacci_search","http://en.wikipedia.org/wiki/Fibonacci_search...","http://en.wikipedia.org/wiki/Fibonacci_search_technique","ibonacci search technique.","la búsqueda de Fibonacci","w:Fibonacci search technique"],"name":"Fibonacci search technique","categories":["All articles needing expert attention","All articles that are too technical","Articles needing expert attention from July 2013","Search algorithms","Wikipedia articles that are too technical from July 2013"],"tag_line":"In computer science, the Fibonacci search technique is a method of searching a sorted array using a divide and conquer algorithm that narrows down possible locations with the aid of Fibonacci numbers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"god's-algorithm","_score":0,"_source":{"description":"God's algorithm is a notion originating in discussions of ways to solve the Rubik's Cube puzzle, but which can also be applied to other combinatorial puzzles and mathematical games. It refers to any algorithm which produces a solution having the fewest possible number of moves, the idea being that an omniscient being would know an optimal step from any given configuration.","alt_names":["algoritmo de Dios","http://en.wikipedia.org/wiki/God's_algorithm","God's number","God's Number","God's algorithm","'God's Algorithm'","'God's algorithm'","(wiki/en) God's_algorithm","- God's algorithm :","1 Scope and definition","20 is the new God's number","Algorithme de Dieu","Algoritmo de Dios","Algoritmo de Dios.","Bóg algorytm","Bůh je algoritmus","El algoritmo de Dios","God Algorithm","God s algorithm Wikipedia the free encyclopedia","God%27s_algorithm","God's Algorithm","God's Algorithm (rofl Methode)","God's algorithm - Wikipedia","God's algorithm - Wikipedia :: The free encyclopedia","God's algorithm - Wikipedia, the free ...","God's algorithm - Wikipedia, the free encyclopedia","God's algorithm - Wikipedia, the free encyclopediaGod's algorithm","God's algorithm.","God's_algorithm","Gods algoritme","Gottes Algorithmus","Gottes Algorithmus Wikipedia","Gottes_Algorithmus","Gud's algoritme","L'algoritmo di Dio","Liczby Boga","Source Wikipedia.org Arcticle - God's algorithm","Tanrı'nın algoritması","Tanrının algoritması","View God's algorithm on Wikipedia","Wikipedia article God's algorithm","Wikipedia article about God's algorithm","Wikipedia article on God's number","Wikipedia-Seite zu 'Gottes Algorithmus'","Wikipedia: God's algorithm","Yaradan algoritması","algorisme de Déu","algorithme de Dieu","algoritmo de Deus","algoritmo divino","el algoritmo de Dios","el número de Dios","en.wikipedia.org/...God%27s_algorithm","en.wikipedia.org/...God's_algorithm","god's number","gods algorithm","http://de.wikipedia.org/wiki/Gottes_Algorithmus","http://en.wikipedia.org/wiki/God%27s_algorithm","http://en.wikipedia.org/wiki/God%27s_alg…","http://en.wikipedia.org/wiki/God%27s_number","nombre de Dieu","nombre...","tr:Tanrının algoritması","wikipedia - god's algorithm","Алгоритмом бога","Бог Алгоритм","לאלוהים יש אלגוריתם","“Algoritmo de Dios”","“God's Algorithm”","神のアルゴリズム","神の数字","神的算法"],"name":"God's algorithm","categories":["Logic puzzles","Mathematical games","Rubik's Cube","Search algorithms"],"tag_line":"God's algorithm is a notion originating in discussions of ways to solve the Rubik's Cube puzzle, but which can also be applied to other combinatorial puzzles and mathematical games."}}
,{"_index":"throwtable","_type":"algorithm","_id":"null-move-heuristic","_score":0,"_source":{"description":"In computer chess programs, the null-move heuristic is a heuristic technique used to enhance the speed of the alpha-beta pruning algorithm.\n\n","alt_names":["-> Read the article about 'Null-move heuristic'","...Wikipedia Heuristique à mouvement nul","...mehr auf Wikipedia über Null-Zug-Suche","...more on Wikipedia about Null-move heuristic","Diese Technik wird benötigt, um die Ermittlung der","Heuristique à mouvement nul","Null -move heuristic - Wikipedia, the free encyclopedia","Null bewegen Rebschnitt","Null di chuyển cắt tỉa","Null move heuristic","Null move heuristics","Null move pruning","Null pemangkasan bergerak","Null двигаться обрезки","Null ตัดย้าย","Null-Move Heuristik","Null-Zug-Suche","Null-Zug-Suche - Wikipedia","Null-Zug-Suche bei der wikipedia","Null-move","Null-move heuristic","Null-move heuristic - Wikipedia, the free encyclopedia","Null-move heuristic from Wikipedia","Nullmove","Nullmove bei der wikipedia","Nullmove-Prunning","Null値の移動剪定","Problems with the null-move heuristic","Speziell in Schachprogrammen hat sich das Nullmove Pruning","Verified null-move pruning","What is Null-move pruning's rationale","Wikipedia article Null-move heuristic","Wikipedia article Null-move_heuristic","Wikipedia article on Null-move heuristic","Wikipedia entry for Null-move heuristic","Wikipedia-Artikel Null-Zug-Suche","Wikipedia-Artikel Nullmove","Wikipedia-Seite zu 'Null-Zug-Suche'","de:Null-Zug-Suche","fr:Heuristique à mouvement nul","heuristique à mouvement nul","http://de.wikipedia.org/wiki/Null-Zug-Su","http://de.wikipedia.org/wiki/Null-Zug-Suche","http://de.wikipedia.org/wiki/Nullmove","http://en.wikipedia.org/wiki/Null-move_h","http://en.wikipedia.org/wiki/Null-move_heuristic","http://en.wikipedia.org/wiki/Null-move_heuristic#Problems_with_the_null","http://fr.wikipedia.org/wiki/Heuristiq [...] mouvement_nul","http://www.de.wikipedia.org/wiki/Null-Zug","ilipat pruning Null","la potatura mossa Null","la taille déplacer Null","mover la poda Null","null-move heuristic","null-move heuristics","nulo poda mover","ru:Эвристика нулевого хода","uk:Евристика нульового ходу","Евристика нульового ходу","Эвристика нулевого хода","евристика нульового ходу","空移动修剪","空移動修剪","널 이동 정리"],"name":"Null-move heuristic","categories":["Computer chess","Heuristics","Search algorithms"],"tag_line":"In computer chess programs, the null-move heuristic is a heuristic technique used to enhance the speed of the alpha-beta pruning algorithm.\n\n"}}
,{"_index":"throwtable","_type":"algorithm","_id":"difference-map-algorithm","_score":0,"_source":{"description":"The difference-map algorithm is a search algorithm for general constraint satisfaction problems. It is a meta-algorithm in the sense that it is built from more basic algorithms that perform projections onto constraint sets. From a mathematical perspective, the difference-map algorithm is a dynamical system based on a mapping of Euclidean space. Solutions are encoded as fixed points of the mapping.\nAlthough originally conceived as a general method for solving the phase problem, the difference-map algorithm has been used for the boolean satisfiability problem, protein structure prediction, Ramsey numbers, diophantine equations, and Sudoku, as well as sphere- and disk-packing problems. Since these applications include NP-complete problems, the scope of the difference map is that of an incomplete algorithm. Whereas incomplete algorithms can efficiently verify solutions (once a candidate is found), they cannot prove that a solution does not exist.\nThe difference-map algorithm is a generalization of two iterative methods: Fienup's Hybrid input output (HIO) algorithm for phase retrieval  and the Douglas-Rachford algorithm for convex optimization. Iterative methods, in general, have a long history in phase retrieval and convex optimization. The use of this style of algorithm for hard, non-convex problems is a more recent development.","alt_names":[],"name":"Difference-map algorithm","categories":["Constraint programming","Search algorithms"],"tag_line":"The difference-map algorithm is a search algorithm for general constraint satisfaction problems."}}
,{"_index":"throwtable","_type":"algorithm","_id":"backjumping","_score":0,"_source":{"description":"In backtracking algorithms, backjumping is a technique that reduces search space, therefore increasing efficiency. While backtracking always goes up one level in the search tree when all values for a variable have been tested, backjumping may go up more levels. In this article, a fixed order of evaluation of variables  is used, but the same considerations apply to a dynamic order of evaluation.\n\n","alt_names":["- Backjumping :","Backjumping","Backjumping - Expected number of visits","Backjumping - Wikipedia, the free encyclopedia","Backjumping Related Content:","Backjumping at internal nodes","Backjumping at leaf nodes","Backjumping from Wikipedia","Backjumping on wikipedia.org","Conflict-based backjumping","Conflict-based backjumping; it is used under the","Conflict-directed backjumping","Graph-based backjumping","Graph-based backjumping; it is used under the","Read More backjumping wikipedia the free encyclopedia","What is Conflict-based backjumping","Wikipedia (Backjumping)","Wikipedia article Backjumping","Wikipedia article Graph-based backjumping","Wikipedia article about Backjumping","Wikipedia article on Backjumping","Wikipedia article on Graph-based backjumping","Wikipedia entry for Backjumping","backjumping","backjumping technique","conflict-based backjumping","graph-based backjumping","http://en.wikipedia.org/wiki/Backjumping","http://en.wikipedia.org/wiki/Graph-based_backjumping","پسپرش (الگوریتم)"],"name":"Backjumping","categories":["Constraint programming","Search algorithms"],"tag_line":"In backtracking algorithms, backjumping is a technique that reduces search space, therefore increasing efficiency."}}
,{"_index":"throwtable","_type":"algorithm","_id":"rapidly-exploring-dense-trees","_score":0,"_source":{"description":"Rapidly exploring dense trees is a family of planning algorithms that includes the rapidly exploring random tree.","alt_names":[],"name":"Rapidly exploring dense trees","categories":["All articles covered by WikiProject Wikify","All articles with too few wikilinks","Articles covered by WikiProject Wikify from October 2013","Articles with too few wikilinks from October 2013","Search algorithms"],"tag_line":"Rapidly exploring dense trees is a family of planning algorithms that includes the rapidly exploring random tree."}}
,{"_index":"throwtable","_type":"algorithm","_id":"algorithms-for-calculating-variance","_score":0,"_source":{"description":"Algorithms for calculating variance play a major role in computational statistics. A key problem in the design of good algorithms for this problem is that formulas for the variance may involve sums of squares, which can lead to numerical instability as well as to arithmetic overflow when dealing with large values.","alt_names":["- Algorithms for calculating variance :","...more on Wikipedia about Algorithms for calculating variance","1 Naïve algorithm","10. Algorithms for calculating variance - Wikipedia, the free","2 Two-pass algorithm","2.1 Compensated variant","3 On-line algorithm","4 Weighted incremental algorithm","5 Parallel algorithm","7 Higher-order statistics","8 Covariance","Algorithm III","Algorithmen zur Berechnung Varianz","Algorithmes pour le calcul de la variance","Algorithms for Calculating Variance","Algorithms for calculating higher-order statistics","Algorithms for calculating mean and variance","Algorithms for calculating variance","Algorithms for calculating variance - Wikipedia ...","Algorithms for calculating variance - Wikipedia :: The free encyclopedia","Algorithms for calculating variance - Wikipedia, the free ...","Algorithms for calculating variance - Wikipedia, the free encyclope","Algorithms for calculating variance - Wikipedia, the free encyclopedia","Algorithms for calculating variance Wikipedia the free - result","Algorithms for calculating variance Wikipedia the free encyclopedia","Algorithms for calculating variance play a major role","Algorithms for calculating variance#Covariance","Algorithms for calculating variance; it is used under","Algorithms to calculate variance","Algorithms สำหรับการคำนวณความแปรปรวน","Algorithms_for_calculating_variance","Algoritma untuk menghitung varians","Algoritmos para el cálculo de la varianza","Algoritmos para o cálculo da variância","Các thuật toán để tính phương sai","Knuth's algorithm","Learn about Algorithms for calculating variance>>>","On-line algorithm","Online variance","Source Wikipedia.org Arcticle - Algorithms for calculating variance","This is a one-pass Welford algorithm that","Variance algorithm","WIKI * Variance Calculation Page: Algorithm II","WIKI Variance Calculation Page: Algorithm II","Weighted incremental algorithm","Welford algorithm","Welford's algorithm","What is Algorithms for calculating variance's example","What is Algorithms for calculating variance's example?","Wikipedia (Algorithms for calculating variance)","Wikipedia article Algorithms for calculating variance","Wikipedia article about Algorithms for calculating variance","Wikipedia entry for Algorithms for calculating variance","Wikipedia-Seite über die Berechnung Varianz in einem","Wikipedia: Algorithms for calculating variance","WikipediaVariance","algorithm I","algorithms for calculating variance","algoritmi per il calcolo della varianza","an algorithm like this","d5dbf91ec6c339293920a2d318ef ...","en.wikipedia.org/...ithms_for_calculating_variance","en.wikipedia.org/wiki/Algorithms_for_calculating_variance","en:Algorithms for calculating variance#Parallel algorithm","http://en.wikipedia.org/wiki/Algori...","http://en.wikipedia.org/wiki/Algori...lating_variance","http://en.wikipedia.org/wiki/Algorit...ating_variance","http://en.wikipedia.org/wiki/Algorit...eighted_increm","http://en.wikipedia.org/wiki/Algorit...line_algorithm","http://en.wikipedia.org/wiki/Algorith...culating_variance","http://en.wikipedia.org/wiki/Algorithms ... _algorithm","http://en.wikipedia.org/wiki/Algorithms ... g_variance","http://en.wikipedia.org/wiki/Algorithms for calculating","http://en.wikipedia.org/wiki/Algorithms%5Ffor%5Fcalculating","http://en.wikipedia.org/wiki/Algorithms_fo...lating_variance","http://en.wikipedia.org/wiki/Algorithms_for","http://en.wikipedia.org/wiki/Algorithms_for_c...","http://en.wikipedia.org/wiki/Algorithms_for_calcul ...","http://en.wikipedia.org/wiki/Algorithms_for_calculating_vari...","http://en.wikipedia.org/wiki/Algorithms_for_calculating_vari[..]","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Algorithm_II","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Algorithm_III","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Exam","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Higher-order_st","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Higher-order_statistics","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#III._On","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Na.C3","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#On-","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#On-line_algorithm","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Parallel_algorithm","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Two-pass_algorithm","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Va._Higher","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Weighted_increm","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Weighted_incremental_algorithm","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#cite_note-0","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#cite_note-1","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance)","http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance...","http://en.wikipedia.org/wiki/Algorithms_…","on-line algorithm for standard deviation","pagina di Wikipedia sul calcolo della varianza in","pairwise variance algorithm","parallel computation here","página de Wikipedia sobre el cálculo de la","ref0","set of algorithms","stable mean","stránky Wikipedie o výpočet rozptylu v jednom průchodu","taking S1 = the sum of x[k] and","there is more than one way","this Wikipedia article on variance calculations","this Wikipedia page (Algorithms for calculating variance)","variance s","variância on-line","wikipedia page on calculating variance in a single","wikipedia pagina over de berekening van variantie in","wikipedii na temat obliczania wariancji w jednym przebiegu","σ 2 = ∑ i = 1 n x i 2","Алгоритмы расчета дисперсии","страницу Википедии о расчете дисперсии за один проход","эту статью Википедии о расчеты дисперсии","、シングルパスで分散を計算するWikipediaのページ","アルゴリズムの分散を計算するための","分散のオンラインアルゴリズム (逐次更新計算)","单通Wikipedia页面上计算方差","方差算法计算","方差計算算法","알고리즘 편차를 계산"],"name":"Algorithms for calculating variance","categories":["Articles with example Python code","Articles with example pseudocode","Statistical algorithms","Statistical deviation and dispersion"],"tag_line":"Algorithms for calculating variance play a major role in computational statistics."}}
,{"_index":"throwtable","_type":"algorithm","_id":"focused-crawler","_score":0,"_source":{"description":"A focused crawler is a web crawler that collects Web pages that satisfy some specific property, by carefully prioritizing the crawl frontier and managing the hyperlink exploration process. Some predicates may be based on simple, deterministic and surface properties. For example, a crawler's mission may be to crawl pages from only the .jp domain. Other predicates may be softer or comparative, e.g., \"crawl pages with large PageRank\", or \"crawl pages about baseball\". An important page property pertains to topics, leading to topical crawlers. For example, a topical crawler may be deployed to collect pages about solar power, or swine flu, while minimizing resources spent fetching pages on other topics. Crawl frontier management may not be the only device used by focused crawlers; they may use a Web directory, an Web text index, backlinks, or any other Web artifact.\nA focused crawler must predict the probability that an unvisited page will be relevant before actually downloading the page. A possible predictor is the anchor text of links; this was the approach taken by Pinkerton  in a crawler developed in the early days of the Web. Topical crawling was first introduced by Filippo Menczer Chakrabarti et al. coined the term focused crawler and used a text classifier to prioritize the crawl frontier. Andrew McCallum and co-authors also used reinforcement learning to focus crawlers. Diligenti 'et al. traced the context graph leading up to relevant pages, and their text content, to train classifiers. A form of online reinforcement learning has been used along with features extracted from the DOM tree and text of linking pages, to continually train classifiers that guide the crawl. In a review of topical crawling algorithms, Menczer et al.  show that such simple strategies are very effective for short crawls, while more sophisticated techniques such as reinforcement learning and evolutionary adaptation can give the best performance over longer crawls.\nAnother type of focused crawlers is semantic focused crawler, which makes use of domain ontologies to represent topical maps and link Web pages with relevant ontological concepts for the selection and categorization purposes. In addition, ontologies can be automatically updated in the crawling process. Dong et al. introduced such an ontology-learning-based crawler using support vector machine to update the content of ontological concepts when crawling Web Pages.\nCrawlers are also focused on page properties other than topics. Cho et al. study a variety of crawl prioritization policies and their effects on the link popularity of fetched pages. Najork and Weiner show that breadth-first crawling, starting from popular seed pages, leads to collecting large-PageRank pages early in the crawl. Refinements involving detection of stale (poorly maintained) pages have been reported by Eiron et al.\nThe performance of a focused crawler depends on the richness of links in the specific topic being searched, and focused crawling usually relies on a general web search engine for providing starting points. Davison presented studies on Web links and text that explain why focused crawling succeeds on broad topics; similar studies were presented by Chakrabarti et al. Seed selection can be important for focused crawlers and significantly influence the crawling efficiency. A whitelist strategy is to start the focus crawl from a list of high quality seed URLs and limit the crawling scope to the domains of these URLs. These high quality seeds should be selected based on a list of URL candidates which are accumulated over a sufficient long period of general web crawling. The whitelist should be updated periodically after it is created.","alt_names":["A short description of focused crawling","Focused Crawler","Focused Web Crawling","Focused crawler","Focused crawler - Wikipedia, the free encyclopedia","Focused crawler - Wikipedia, the free encyclopediaA focused","Focused crawler Wikipedia the free encyclopedia","Focused oder auch Topical Crawler","Focused_crawler","Learn about Focused crawler>>>","Read More focused crawler wikipedia the free encyclopedia","View Focused crawler on Wikipedia","Wikipedia article Focused crawler","Wikipedia entry for Focused crawler","Wikipédia Focused crawler","focused crawler","focused crawler or topical crawler","focused crawler wikipedia the free encyclopedia","focused crawlers","focused crawling","http://en.wikipedia.org/wiki/Focused_cra","http://en.wikipedia.org/wiki/Focused_crawler","http://en.wikipedia.org/wiki/Focused_cra…","n12:Focused_crawler","voir wikipedia : topical crawlers"],"name":"Focused crawler","categories":["Internet search algorithms","Web crawlers","World Wide Web"],"tag_line":"A focused crawler is a web crawler that collects Web pages that satisfy some specific property, by carefully prioritizing the crawl frontier and managing the hyperlink exploration process."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ransac","_score":0,"_source":{"description":"Random sample consensus (RANSAC) is an iterative method to estimate parameters of a mathematical model from a set of observed data which contains outliers. It is a non-deterministic algorithm in the sense that it produces a reasonable result only with a certain probability, with this probability increasing as more iterations are allowed. The algorithm was first published by Fischler and Bolles at SRI International in 1981.They used RANSAC to solve the Location Determination Problem (LDP), where the goal is to determine the points in the space that project onto an image into a set of landmarks with known locations.\nA basic assumption is that the data consists of \"inliers\", i.e., data whose distribution can be explained by some set of model parameters, though may be subject to noise, and \"outliers\" which are data that do not fit the model. The outliers can come, e.g., from extreme values of the noise or from erroneous measurements or incorrect hypotheses about the interpretation of data. RANSAC also assumes that, given a (usually small) set of inliers, there exists a procedure which can estimate the parameters of a model that optimally explains or fits this data.","alt_names":["(External) RANSAC","(http://en.wikipedia.org/wiki/RANSAC).","- RANSAC :","-> Read more about RANSAC","-> Read the article about 'RANSAC'","Bài viết về RANSAC trên Wikipedia","Das geschieht in Erwartung, dass diese Menge frei","RANSAC","RANSAC (RANdom SAmple Consensus)","RANSAC (Wikipeida)","RANSAC - Wikipedia","RANSAC - Wikipedia, the free encyclopedia","RANSAC - Wikipédia","RANSAC - Wikip…","RANSAC Related Content:","RANSAC Wikipedia Page","RANSAC Wikipedia the free encyclopedia - result","RANSAC a","RANSAC algorithm","RANSAC bei Wikipedia","RANSAC i","RANSAC methods","RANSAC |","RANSAC 算法","RANSAC, Wikipedia","RANSAC-Algorithmus","RANSAC-Algorithmus - Wikipedia","RANSAC-Algorithmus ? Wikipedia","RANSAC-Algorithmus – Wikipedia","RANSAC; it is used under the","RANSAC算法","RANSAC을","RANdom SAmple Consensus","RANdom SAmple Consensus (RANSAC)","Random Sample Consensus","Random Sample Consensus (RANSAC)","Random sample consensus","Ransac","Ransac Wikipedia The Free Encyclopedia","The parameters","What are advantages and disadvantages of Random sample","What is RANSAC's example","What is the example of Random Sample Consensus","What is the overview of Random sample consensus","Wikipedia RANSAC article","Wikipedia article RANSAC","Wikipedia article Ransac","Wikipedia article on RANSAC","Wikipedia entry for RANSAC","Wikipedia has a good overview of the algorithm","Wikipedia-Artikel RANSAC-Algorithmus","Wikipedia-Seite zu 'RANSAC-Algorithmus'","ansac algorithm","de.wikipedia.org/wiki/RANSAC-Algorithmus","de:RANSAC-Algorithmus","en.wikipedia.org/RANSAC","en.wikipedia.org/wiki/RAN…","en:RANSAC","fr:RANSAC","http://de.wikipedia.org/wiki/RANSAC-Algo","http://de.wikipedia.org/wiki/RANSAC-Algorithmus","http://de.wikipedia.org/wiki/RANSAC-Algorithmus#Anwendungen","http://de.wikipedia.org/wiki/RANSAC−Algorithmus","http://en.wikipedia.org/wiki/ RANSAC","http://en.wikipedia.org/wiki/RANSA","http://en.wikipedia.org/wiki/RANSAC","http://en.wikipedia.org/wiki/RANSAC#The_algorithm","http://en.wikipedia.org/wiki/RANSAC, wh","http://en.wikipedia.org/wiki/RANSAC.","http://en.wikipedia.org/wiki/Ransac","http://fr.wikipedia.org/wiki/RANSAC","http://it.wikipedia.org/wiki/RANSAC","http://ru.wikipedia.org/wiki/RANSAC","it:RANSAC","k = log ( 1 - p ) log ( 1 - w n","random sample consensus","random sample consensus (RANSAC) algorithm","ransac","ru:RANSAC","ttp://en.wikipedia.org/wiki/Ransac)","yago-res:RANSAC","“RANSAC - Wikipedia, the free encyclopedia”, en.wikipedia.org","あてはめる","あてはめるを","的RANSAC","随机抽样一致性","隨機抽樣一致性","을 http://en.wikipedia.org/wiki/RANSAC"],"name":"RANSAC","categories":["All articles needing additional references","All articles with unsourced statements","Articles needing additional references from September 2014","Articles with example pseudocode","Articles with unsourced statements from September 2014","Geometry in computer vision","Robust statistics","SRI International","Statistical algorithms","Statistical outliers","Wikipedia articles needing clarification from April 2014","Wikipedia articles needing clarification from September 2014"],"tag_line":"Random sample consensus (RANSAC) is an iterative method to estimate parameters of a mathematical model from a set of observed data which contains outliers."}}
,{"_index":"throwtable","_type":"algorithm","_id":"buzen's-algorithm","_score":0,"_source":{"description":"In queueing theory, a discipline within the mathematical theory of probability, Buzen's algorithm (or convolution algorithm) is an algorithm for calculating the normalization constant G(N) in the Gordon–Newell theorem. This method was first proposed by Jeffrey P. Buzen in 1973. Computing G(N) is required to compute the stationary probability distribution of a closed queueing network.\nPerforming a naïve computation of the normalising constant requires enumeration of all states. For a system with N jobs and M states there are  states. Buzen's algorithm \"computes G(1), G(2), ..., G(N) using a total of NM multiplications and NM additions.\" This is a significant improvement and allows for computations to be performed with much larger networks.","alt_names":["Buzen's algorithm","Buzen s algorithm Wikipedia the free encyclopedia","Buzen's algorithm - Wikipedia, the free ...","Buzen's algorithm - Wikipedia, the free encyclopedia","Buzen's algorithm by Wikipedia","What is Buzen algorithm's implementation","Wikipedia article Buzen's algorithm","http://en.wikipedia.org/wiki/Buzen%27s_algorithm","Αλγόριθμος Buzen"],"name":"Buzen's algorithm","categories":["Queueing theory","Statistical algorithms","Stochastic processes"],"tag_line":"In queueing theory, a discipline within the mathematical theory of probability, Buzen's algorithm (or convolution algorithm) is an algorithm for calculating the normalization constant G(N) in the Gordon–Newell theorem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"quickselect","_score":0,"_source":{"description":"In computer science, quickselect is a selection algorithm to find the kth smallest element in an unordered list. It is related to the quicksort sorting algorithm. Like quicksort, it was developed by Tony Hoare, and thus is also known as Hoare's selection algorithm. Like quicksort, it is efficient in practice and has good average-case performance, but has poor worst-case performance. Quickselect and variants is the selection algorithm most often used in efficient real-world implementations.\nQuickselect uses the same overall approach as quicksort, choosing one element as a pivot and partitioning the data in two based on the pivot, accordingly as less than or greater than the pivot. However, instead of recursing into both sides, as in quicksort, quickselect only recurses into one side – the side with the element it is searching for. This reduces the average complexity from O(n log n) to O(n).\nAs with quicksort, quickselect is generally implemented as an in-place algorithm, and beyond selecting the k'th element, it also partially sorts the data. See selection algorithm for further discussion of the connection with sorting.","alt_names":[],"name":"Quickselect","categories":["All articles needing additional references","Articles needing additional references from August 2013","Selection algorithms"],"tag_line":"In computer science, quickselect is a selection algorithm to find the kth smallest element in an unordered list."}}
,{"_index":"throwtable","_type":"algorithm","_id":"nested-sampling-algorithm","_score":0,"_source":{"description":"The nested sampling algorithm is a computational approach to the problem of comparing models in Bayesian statistics, developed in 2004 by physicist John Skilling.","alt_names":["How to apply for Nested sampling algorithm","How to apply for Nested sampling algorithm?","Nested Sampling algorithm","Nested sampling","Nested sampling algorithm","Nested sampling algorithm - Wikipedia :: The free encyclopedia","Nested sampling algorithm - Wikipedia, the free encyclopedia","Nested sampling algorithm - Wikipedia, the free encyclopedia ...","Nested sampling algorithm - Wikipedia, the free encyclopedia http","P ( M 1 | D ) = P ( D | M 1","Read More nested sampling algorithm wikipedia the free","Source Wikipedia.org Arcticle - Nested sampling algorithm","What is Nested Sampling?","Wikipedia article Nested sampling","Wikipedia entry for Nested sampling algorithm","en.wikipedia.org/wiki/Nested_sampling_algorithm","http://en.wikipedia....pling_algorithm","http://en.wikipedia.org/wiki/Nested_samp","http://en.wikipedia.org/wiki/Nested_sampling","http://en.wikipedia.org/wiki/Nested_sampling_algorithm","nested sampling","yago-res:Nested sampling algorithm"],"name":"Nested sampling algorithm","categories":["All Wikipedia articles needing context","All pages needing cleanup","Bayesian statistics","Model selection","Statistical algorithms","Wikipedia articles needing context from October 2009","Wikipedia introduction cleanup from October 2009"],"tag_line":"The nested sampling algorithm is a computational approach to the problem of comparing models in Bayesian statistics, developed in 2004 by physicist John Skilling."}}
,{"_index":"throwtable","_type":"algorithm","_id":"elston–stewart-algorithm","_score":0,"_source":{"description":"The Elston–Stewart algorithm is an algorithm for computing the likelihood of observed genotype data given a pedigree. It is due to Robert Elston and John Stewart. It can handle relatively large pedigrees providing they are (almost) outbred. Its computation time is exponential in the number of markers. It is used in the analysis of genetic linkage.","alt_names":[],"name":"Elston–Stewart algorithm","categories":["All stub articles","Genetic epidemiology","Genetic linkage analysis","Genetics stubs","Statistical algorithms","Statistical genetics","Statistics stubs"],"tag_line":"The Elston–Stewart algorithm is an algorithm for computing the likelihood of observed genotype data given a pedigree."}}
,{"_index":"throwtable","_type":"algorithm","_id":"cyk-algorithm","_score":0,"_source":{"description":"In computer science, the Cocke–Younger–Kasami algorithm (alternatively called CYK, or CKY) is a parsing algorithm for context-free grammars, named after its inventors, John Cocke, Daniel Younger and Tadao Kasami. It employs bottom-up parsing and dynamic programming.\nThe standard version of CYK operates only on context-free grammars given in Chomsky normal form (CNF). However any context-free grammar may be transformed to a CNF grammar expressing the same language (Sipser 1997).\nThe importance of the CYK algorithm stems from its high efficiency in certain situations. Using Landau symbols, the worst case running time of CYK is , where n is the length of the parsed string and |G| is the size of the CNF grammar G. This makes it one of the most efficient parsing algorithms in terms of worst-case asymptotic complexity, although other algorithms exist with better average running time in many practical scenarios.","alt_names":["http://ja.wikipedia.org/wiki/CYK%E6%B3","CYK","- CKY algorithm :","- CYK algorithm :","...Wikipedia Algorytm CYK","...mehr auf Wikipedia über Cocke-Younger-Kasami-Algorithmus","...more on Wikipedia about CYK algorithm","1 Standard form","1.1 As pseudocode","1.2 As prose","1f5c74bf5e34cfac3e2545306570d ...","2.1 Generating a parse tree","2.2 Parsing non-CNF context-free grammars","2.3 Parsing weighted context-free grammars","2.4 Valiant's algorithm","2921f80a42ab5fd5b4338d3b6b4800 ...","443e66bef8823731dea8d7c798700 ...","Algorithme CYK","Algorithme de Cocke-Younger-Kasami","Algorithme de Cocke-Younger-Kasami - Wikip?dia","Algorithme de Cocke-Younger-Kasami - Wikipédia","Algoritmo CYK","Algoritmo CYK - Wikipedia, a enciclopedia libre","Algoritmo CYK - Wikipedia, la enciclopedia libre","Algoritmo CYK – Wikipédia, a enciclopédia livre","Algoritmus Cocke-Younger-Kasami","Algorytm CYK","Algorytm CYK – Wikipedia, wo...","Algorytm CYK – Wikipedia, wolna encyklopedia","CKY Algorithm","CKY algorithm","CKY algorithm; it is used under the","CKY algoritmoa","CKY法","CKY法-wikipedia","CYK - Wikipedia","CYK ???? - ????, ?? ??? ????","CYK Algorithm","CYK Parsing Algorithm","CYK algorithm","CYK algorithm - Wikipedia :: The free encyclopedia","CYK algorithm - Wikipedia, the free encyclopedia","CYK algorithm – Wikipedia, the free encyclopedia","CYK algorithm; it is used under the","CYK algoritması","CYK algoritmus","CYK bei der wikipedia","CYK on Wikipedia","CYK parser","CYK parsing","CYK parsing algorithm","CYK アルゴリズム","CYK 알고리즘","CYK-Algo in wikipedia","CYK-Algorithmus","CYK-Algorithmus - Wikipedia","CYK-algoritme","CYK-algoritme - Wikipedia","CYK-algoritmen","CYK-algoritmi","CYK_algorithm","CYKアルゴリズム","CYKアルゴリズム - Wikipedia","CYK法","CYK法 - Wikipedia","CYK法-wikipedia","CYK算法","CYK算法- 维基百科，自由的百科全书","Chomsky-algorithmus","Cocke Kasami Younger algorithm","Cocke-Kasami-Younger","Cocke-Kasami-Younger algorithm","Cocke-Younger'a-Kasami","Cocke-Younger-Kasami","Cocke-Younger-Kasami (CYK) algorithm","Cocke-Younger-Kasami (CYK) 알고리즘","Cocke-Younger-Kasami algorithm","Cocke-Younger-Kasami-Algorithmus","Cocke-Younger-Kasami-Algorithmus ? Wikipedia","Cocke-Younger-Kasami-Algorithmus Wikipedia","Cocke-Younger-Kasami-Algorithmus bei der wikipedia","Cocke-Younger-Kasami-Algorithmus – Wikipedia","Cocke-Younger-Kasami-Algorithmus –…","Cocke–Younger–Kasami (CYK) algorithm","Cocke–Younger–Kasami algorithm","Cyk Algorithm","Detailed description of the CYK algorithm.","Kuk-Janger-Kasami algoritam - Википедија","Lange & Leiß (2009)","Lee (2002)","Parsing weighted context-free grammars","Read More cyk algorithm wikipedia the free encyclopedia","Screenshot http://de.wikipedia.org/wiki/Cocke-Younger","Sipser 1997","The CYK Algorithm","Thuật toán CYK","Thuật toán CYK – Wikipedia tiếng Việt","Valiant (1975)","Valiant's algorithm","What are Cyk algorithm's extensions","Wikipedia : CYK法","Wikipedia article Algoritmo CYK","Wikipedia article Algoritmus Cocke-Younger-Kasami","Wikipedia article Algorytm CYK","Wikipedia article CKY algorithm","Wikipedia article CYK algorithm","Wikipedia article CYK-algoritme","Wikipedia article CYK-algoritmi","Wikipedia article Cocke-Kasami-Younger algorithm","Wikipedia article Cocke-Younger-Kasami algorithm","Wikipedia article on Algoritmo CYK","Wikipedia article on CYK algorithm","Wikipedia article on CYK algorithm.","Wikipedia artikel CYK-algoritme","Wikipedia entry for CYK algorithm","Wikipedia sur Algorithme CYK","Wikipedia-Artikel CYK","Wikipedia-Artikel CYK-Algorithmus","Wikipedia-Artikel Cocke-Younger-Kasami-Algorithmus","Wikipedia-Seite zu 'CYK-Algorithmus'","Wikipedia-Seite zu 'Cocke-Younger-Kasami-Algorithmus'","Wikipedia: CYK algorithm","Wikipediaで「CKY法」を調べる","Wikipediaで「CYK法」を調べる","Wikipédia artigo Algoritmo CYK","Wikipédia artigo CYK","af:CYK-algoritme","algorithm for context-free parsing","algorithme de CKY","algoritmo CYK","algorytmem Cooke'a-Youngera-Kasamiego","artículo de Wikipedia Algoritmo CYK","context-free grammar parsing algorithm","cs:Algoritmus Cocke-Younger-Kasami","cyk algorihtm","de.wikipedia.org/wiki/Cocke-Younger-Kasami-Algorithmus","de:Cocke-Younger-Kasami-Algorithmus","en.wikipedia.org/...CYK_algorithm","en.wikipedia.org/wiki/CYK_algorithm","en:CYK algorithm","es:Algoritmo CYK","fi:CYK-algoritmi","fr:Algorithme de Cocke-Younger-Kasami","gl:Algoritmo CYK","http://cs.wikipedia.org/wiki/Algoritmus_Cocke-Younger-Kasami","http://de.wikipedia.org/wiki/CYK-Algorithmus","http://de.wikipedia.org/wiki/Cocke-Y...mi","http://de.wikipedia.org/wiki/Cocke-Young","http://de.wikipedia.org/wiki/Cocke-Young...ami","http://de.wikipedia.org/wiki/Cocke-Younger-Kasami","http://en.wikipedia.org/wiki/CKY_algorithm","http://en.wikipedia.org/wiki/CYK_","http://en.wikipedia.org/wiki/CYK_al...","http://en.wikipedia.org/wiki/CYK_algorit","http://en.wikipedia.org/wiki/CYK_algorithm","http://en.wikipedia.org/wiki/CYK_algorit…","http://en.wikipedia.org/wiki/Cocke-Younger-Kasami_algorithm","http://es.wikipedia.org/wiki/Algoritmo_CYK","http://es.wikipedia.org/wiki/A…..oritmo_CYK","http://fr.wikipedia.org/wiki/Algorithme_de_Cocke-Younger-Kasami","http://ime.nu/ja.wikipedia.org/wiki/CKY","http://ja.wikipedia.org/wiki/CKY%E6%B3","http://ja.wikipedia.org/wiki/CKY法","http://ja.wikipedia.org/wiki/CYK%E3%82","http://nl.wikipedia.org/wiki/CYK-algoritme","http://pl.wikipedia.org/wiki/Algorytm_CYK","http://zh.wikipedia.org/wiki/CYK%E7%AE","ja:CYK法","ko:CYK 알고리즘","l'analyse CYK","l'article de Wikipédia CYK","nl:CYK-algoritme","no:CYK-algoritmen","pl:Algorytm CYK","pt:Algoritmo CYK","sr:Кук-Јангер-Касами алгоритам","vi:Thuật toán CYK","zh:CYK算法","Алгоритм Кока — Янгера — Касами","Википедия - CYK algorithm","алгоритъмът CYK","здесь в псевдокоде","ウィキペディアの記事 CYK法","維基百科的文章“ CYK算法”","维基百科的文章“ CYK算法”","위키 피 디아 문서 CYK 알고리즘"],"name":"CYK algorithm","categories":["Parsing algorithms"],"tag_line":"In computer science, the Cocke–Younger–Kasami algorithm (alternatively called CYK, or CKY) is a parsing algorithm for context-free grammars, named after its inventors, John Cocke, Daniel Younger and Tadao Kasami."}}
,{"_index":"throwtable","_type":"algorithm","_id":"iso-14651","_score":0,"_source":{"description":"ISO/IEC 14651:2007, Information technology -- International string ordering and comparison -- Method for comparing character strings and description of the common template tailorable ordering, is an ISO Standard specifying an algorithm that can be used when comparing two strings. This comparison can be used when collating a set of strings. The standard also specifies a datafile specifying the comparison order, the Common Tailorable Template, CTT. The comparison order is supposed to be tailored for different languages (hence the CTT is regarded as a template and not a default, though the empty tailoring, not changing any weighting, is appropriate in many cases), since different languages have incompatible ordering requirements. One such tailoring is European ordering rules (EOR), which in turn is supposed to be tailored for different European languages.\nThe Common Tailorable Template (CTT) datafile of this ISO Standard is aligned with the Default Unicode Collation Entity Table (DUCET) datafile of the Unicode Collation Algorithm (UCA) specified in Unicode Technical Standard #10.","alt_names":["- ISO 14651 :","14651","ISO 14651","ISO 14651 - Wikipedia, the free encyclopedia","ISO 14651 Wikipedia the free encyclopedia","ISO/IEC 14651","ISO_14651","Wikipedia article ISO 14651","Wikipedia article on ISO 14651","Wikipedia entry for ISO 14651","http://en.Liarpedia.org/wiki/ISO_14651","http://en.wikipedia.org/wiki/ISO_14651"],"name":"ISO 14651","categories":["All stub articles","Collation","Computing stubs","ISO standards","Standards and measurement stubs","String collation algorithms","Unicode algorithms"],"tag_line":"ISO/IEC 14651:2007, Information technology -- International string ordering and comparison -- Method for comparing character strings and description of the common template tailorable ordering, is an ISO Standard specifying an algorithm that can be used when comparing two strings."}}
,{"_index":"throwtable","_type":"algorithm","_id":"unicode-collation-algorithm","_score":0,"_source":{"description":"The Unicode collation algorithm (UCA) is an algorithm defined in Unicode Technical Report #10, which defines a customizable method to compare two strings. These comparisons can then be used to collate or sort text in any writing system and language that can be represented with Unicode.\nUnicode Technical Report #10 also specifies the Default Unicode Collation Element Table (DUCET). This datafile specifies the default collation ordering. The DUCET is customizable for different languages. Some such customisations can be found in Common Locale Data Repository (CLDR).\nAn important open source implementation of UCA is included with the International Components for Unicode, ICU. ICU also supports tailoring and the collation tailorings from CLDR are included in ICU. You can see the effects of tailoring and a large number of language specific tailorings in the on-line ICU Locale Explorer.","alt_names":["...more on Wikipedia about Unicode collation algorithm","Algorithmo de Collation Unicode","Algoritmo de intercalación Unicode","Algoritmo de intercalação Unicode","Algoritmo ng Pagkokolasyon sa Unicode","Algoritmom Klasifikacije u Unikodu","How are Unicode Collation Algorithm's tools","Unicode Collatie Algoritme","Unicode Collation Algorithm","Unicode Collation Algorithm (UCA)","Unicode Collation algorithm","Unicode collation algorithm","Unicode collation algorithm - Wikipedia :: The free encyclopedia","Unicode collation algorithm - Wikipedia, the free en...","Unicode collation algorithm - Wikipedia, the free encyclopedia","Unicode collation algorithm - Wikipedia, the free encyclopedia ...","Unicode collation algorithm Wikipedia the free encyclopedia","Unicode collation algorithm Wikipedia the free encyclopedia - result","Unicode collationalgorithm - Wikipedia, the free encyclopedia The Unicode","Unicode-based collation algorithm","Unicode_Collation_Algorithm","Unicode_collation_algorithm","Unicode参照アルゴリズム","Unicode校对法则","Unicodi collation algorithm","Wikipedia entry for Unicode collation algorithm","abecedního algoritmu řazení Unicode","default Unicode collation algorithm","en.wikipedia.org/wiki/Unicode_collation_algorithm","en:Unicode collation algorithm","http://en.wikipedia.org/wiki/Unicode Collation Algorithm","http://en.wikipedia.org/wiki/Unicode_Collatio...","http://en.wikipedia.org/wiki/Unicode_Collation_Algorithm","http://en.wikipedia.org/wiki/Unicode_col","http://en.wikipedia.org/wiki/Unicode_collatio...","http://en.wikipedia.org/wiki/Unicode_collation_algorithm","http://en.wikipedia.org/wiki/Unicode_collation_algorithm.","http://en.wikipedia.org/wiki/Unicode_collation_algorithmを","http://ja.wikipedia.org/wiki/Unicode%E5%8F","http://ja.wikipedia.org/wiki/Unicode%E7%85","l'algorithme de classement alphabétique Unicode","la algoritmo de unikoda alfabeta ordigo","unicodealgoritmen","w:Unicode Collation Algorithm","w:Unicode collation algorithm","wikipedia:Unicode collation algorithm","алгоритмом Уникод колације","алгоритмом сортировки Unicode","юникодным алгоритмом сортировки","∙ Unicode collation algorit..."],"name":"Unicode collation algorithm","categories":["Algorithms and data structures stubs","All stub articles","Collation","Computer science stubs","Standards and measurement stubs","String collation algorithms","Unicode algorithms"],"tag_line":"The Unicode collation algorithm (UCA) is an algorithm defined in Unicode Technical Report #10, which defines a customizable method to compare two strings."}}
,{"_index":"throwtable","_type":"algorithm","_id":"yamartino-method","_score":0,"_source":{"description":"The Yamartino method (introduced by Robert J. Yamartino in 1984) is an algorithm for calculating an approximation to the standard deviation σθ of wind direction θ during a single pass through the incoming data. The standard deviation of wind direction is a measure of lateral turbulence, and is used in a method for estimating the Pasquill stability category.\nThe simple method for calculating standard deviation requires two passes through the list of values. The first pass determines the average of those values; the second pass determines the sum of the squares of the differences between the values and the average. This double-pass method requires access to all values. A single-pass method can be used for normal data but is unsuitable for angular data such as wind direction where the 0°/360° (or +180°/-180°) discontinuity forces special consideration. For example, the directions 1°, 0°, and 359° (or -1°) should not average to the direction 120°!\nThe Yamartino method solves both problems. The United States Environmental Protection Agency (EPA) has chosen it as the preferred way to compute the standard deviation of wind direction. A further discussion of the Yamartino method, along with other methods of estimating the standard deviation of wind direction can be found in Farrugia & Micallef.\nIt should be mentioned that it is also possible to calculate the exact standard deviation in one pass. However, that method needs slightly more calculation effort.","alt_names":["9d1c67f070e2338921ff927064f7a5 ...","What is algorithm of Yamartino method","Wikipedia article Yamartino Method","Wikipedia article Yamartino method","Wikipedia article Yamartino_method","Wikipedia article on Yamartino method","Wikipedia entry for Yamartino method","Yamartino Method","Yamartino method","Yamartino method - Wikipedia, the free encyclopedia","Yamartino_method","caf371bba4f40ed1c83ed5ca40b ...","en.wikipedia.org/wiki/Yamartino_method","http://en.wikipedia.org/wiki/Yamartino Method","http://en.wikipedia.org/wiki/Yamartino_m","http://en.wikipedia.org/wiki/Yamartino_method","s a = n - 1 ∑ i = 1 n sin"],"name":"Yamartino method","categories":["Atmospheric dispersion modeling","Boundary layer meteorology","Directional statistics","Statistical algorithms"],"tag_line":"The Yamartino method (introduced by Robert J. Yamartino in 1984) is an algorithm for calculating an approximation to the standard deviation σθ of wind direction θ during a single pass through the incoming data."}}
,{"_index":"throwtable","_type":"algorithm","_id":"mobilegeddon","_score":0,"_source":{"description":"Mobilegeddon is a name given by webmasters and web-developers to the Google's algorithm update of April 21, 2015. The main effect of this update is give priority to web sites that display well on smartphones and other mobile devices. The change does not affect searches made from a desktop computer or a laptop.\nGoogle announced its intention to make the change in February 2015. The Economist found the timing \"awkward\" because they said \"It comes less than a week after the European Union accused the firm...\" of anti-competitive behaviors.\nThe protologism is a blend word of \"mobile\" and \"Armageddon\" because the change \"could cause massive disruption to page rankings.\" But, writing for Forbes, Robert Hof says that concerns about the change were \"overblown\" in part because \"Google is providing a test to see if sites look good on smartphones\".\nSearch engine results pages on smartphones now show URLs in \"breadcrumb\" format, as opposed to the previous explicit format.","alt_names":[],"name":"Mobilegeddon","categories":["All orphaned articles","Google","Orphaned articles from July 2015","Search algorithms","Search engine optimization"],"tag_line":"Mobilegeddon is a name given by webmasters and web-developers to the Google's algorithm update of April 21, 2015."}}
,{"_index":"throwtable","_type":"algorithm","_id":"uniform-binary-search","_score":0,"_source":{"description":"Uniform binary search is an optimization of the classic binary search algorithm invented by Donald Knuth and given in Knuth's The Art of Computer Programming. It uses a lookup table to update a single array index, rather than taking the midpoint of an upper and a lower bound on each iteration; therefore, it is optimized for architectures (such as Knuth's MIX) on which\na table lookup is generally faster than an addition and a shift, and\nmany searches will be performed on the same array, or on several arrays of the same length","alt_names":["Uniform binary search","Uniform binary search - Wikipedia, the free encyclopedia","Uniform binary search - Wikipedia, the free encyclopedia ...","Uniform binary search algorithm","Wikipedia article Uniform binary search","Wikipedia article Uniform binary search algorithm","Wikipedia entry for Uniform binary search","http://en.wikipedia.org/wiki/Uniform_bin","http://en.wikipedia.org/wiki/Uniform_binary_search","yago-res:Uniform binary search"],"name":"Uniform binary search","categories":["All orphaned articles","Articles with example C code","Orphaned articles from February 2009","Search algorithms"],"tag_line":"Uniform binary search is an optimization of the classic binary search algorithm invented by Donald Knuth and given in Knuth's The Art of Computer Programming."}}
,{"_index":"throwtable","_type":"algorithm","_id":"multi-key-quicksort","_score":0,"_source":{"description":"Multi-key quicksort, also known as three-way radix quicksort, is an algorithm for sorting strings. This hybrid of quicksort and radix sort was originally suggested by P. Shackleton, as reported in one of C.A.R. Hoare's seminal papers on quicksort; its modern incarnation was developed by Jon Bentley and Robert Sedgewick in the mid-1990s. The algorithm is designed to exploit the property that in many problems, strings tend to have shared prefixes.\nOne of the algorithm's uses is the construction of suffix arrays, for which it was one of the fastest algorithms as of 2004.","alt_names":[],"name":"Multi-key quicksort","categories":["Articles with example pseudocode","Comparison sorts","String sorting algorithms"],"tag_line":"Multi-key quicksort, also known as three-way radix quicksort, is an algorithm for sorting strings."}}
,{"_index":"throwtable","_type":"algorithm","_id":"proof-of-o(log*n)-time-complexity-of-union–find","_score":0,"_source":{"description":"In computer science, Union Find is an algorithm for doing certain operations on sets. This page is about proof of O(log*n) amortized time  of Union Find\nStatement: If m operations, either Union or Find, are applied to n elements, the total run time is O(m log*n), where log* is the iterated logarithm.","alt_names":[],"name":"Proof of O(log*n) time complexity of union–find","categories":["All articles lacking in-text citations","Articles lacking in-text citations from July 2012","Search algorithms"],"tag_line":"In computer science, Union Find is an algorithm for doing certain operations on sets."}}
,{"_index":"throwtable","_type":"algorithm","_id":"parsing-expression-grammar","_score":0,"_source":{"description":"In computer science, a parsing expression grammar, or PEG, is a type of analytic formal grammar, i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language. The formalism was introduced by Bryan Ford in 2004 and is closely related to the family of top-down parsing languages introduced in the early 1970s. Syntactically, PEGs also look similar to context-free grammars (CFGs), but they have a different interpretation: the choice operator selects the first match in PEG, while it is ambiguous in CFG. This is closer to how string recognition tends to be done in practice, e.g. by a recursive descent parser.\nUnlike CFGs, PEGs cannot be ambiguous; if a string parses, it has exactly one valid parse tree. It is conjectured that there exist context-free languages that cannot be parsed by a PEG, but this is not yet proven. PEGs are well-suited to parsing computer languages, but not natural languages where their performance is comparable to general CFG algorithms such as the Earley algorithm.","alt_names":["Bryan Ford","PEGs","Parsing Expression Grammars","&lbrace; a n b n : n ≥ 1 &rbrace","(parsing-expression grammar)","-> Read more about Parsing expression grammar","-> Read the article about 'Parsing expression grammar'","...more on Wikipedia about Packrat parser","...more on Wikipedia about Parsing expression grammar","Aigerim","Analizar expresiones gramaticales","Analizar gramática de expresiones","CLAVIJA","Implementing parsers from parsing expression grammars","Learn about Parsing expression grammar>>>","Les PEG","Memoizing Parsing Expression Grammar","PEG (Parsing Expression Grammers)","PEG (parsing expression grammar)","PEG - ویکیپدیا","PEG Parsers","PEG and left recursion","PEG example","PEG examples","PEG features","PEG formalism","PEG format","PEG grammars","PEG on Wikipedia","PEG packrat parser","PEG parsers","PEG(Parsing Expression Grammar)","PEG(解析表現文法)","PEG/Packrat","PEGs (parsing expression grammars.)","PEGs at Wikipedia (an alternative to CFGs)","PEGと呼ばれる形式文法","PEGを","Packrat Parser","Packrat parser","Packrat parser; it is used under the","Packrat parsers","Packrat parsing","Packrat-Parser","Packrat_Parser","Packrat_parser","Parse Expression Grammars","Parsen Ausdrucksgrammatik Seite auf Wikipedia","Parser Expression Grammar(s)","Parser Expression Grammars","Parser packrat","Parser packrat - Wikipédia","Parsing Ausdrucksgrammatik (PEG)","Parsing Ausdrucksgrammatik,","Parsing Expression","Parsing Expression Grammar","Parsing Expression Grammar (PEG)","Parsing Expression Grammar (PEG).","Parsing Expression Grammar - Wikipedia, The Free Encyclopedia","Parsing Expression Grammar Wikipedia page","Parsing Expression Grammars (PEG)","Parsing Expression Grammars (PEGs)","Parsing Expression Grammars or PEG","Parsing Expression Grammars, Wikipedia, the free encyclopedia","Parsing Expression Grammars.","Parsing Expression Grammatica (PEG).","Parsing Expression Grammatik (PEG).","Parsing Expression Grammer","Parsing Expressions","Parsing Expressions Grammars (PEGs)","Parsing Grammaires Expression","Parsing Grammars biểu","Parsing _expression_ Grammars","Parsing expressi grammar","Parsing expression grammar","Parsing expression grammar (PEG)","Parsing expression grammar - Wikipedia, the f","Parsing expression grammar - Wikipedia, the free ...","Parsing expression grammar - Wikipedia, the free encyclopedia","Parsing expression grammar - Wikipedia, the free encyclopedia ...","Parsing expression grammar - Wikipedia, the free encyclopedia...","Parsing expression grammar - Wikipedia, the free encyclopediaThe","Parsing expression grammar ...","Parsing expression grammar Wikipedia the free encyclopedia","Parsing expression grammar Wikipedia the free encyclopedia - result","Parsing expression grammar page on wikipedia","Parsing expression grammar – Wikipedia, the free encyclopedia","Parsing expression grammar, Wikipedia.en","Parsing expression grammar, the free encyclopedia","Parsing expression grammars","Parsing expression grammars (PEGS)","Parsing expression-grammar","Parsing grammaire d'expression","Parsing ngữ pháp biểu hiện","ParsingExpressionGrammar","Parsing_Expression_Grammar","Parsing_expression_grammar","Read More About parsing expression grammar - wikipedia the","Read More parsing expression grammar wikipedia the free","Tata bahasa Parsing Expression","Tolker udtryk grammatik side på Wikipedia","What are advantages of Parsing Expression Grammar","Wiki - Parsing Expression Grammars","Wikipedia : 解析表現文法","Wikipedia Entry for PEGs","Wikipedia PEG article","Wikipedia Parsing expression grammar","Wikipedia article Packrat parser","Wikipedia article Packrat parsing","Wikipedia article Parsing Expression Grammar","Wikipedia article Parsing expression grammar","Wikipedia article about PEG","Wikipedia article on Packrat parsing","Wikipedia article on Parsing expression grammar","Wikipedia entry for Parsing expression grammar","Wikipedia entry on PEG","Wikipedia page about PEGs","Wikipedia page on PEGs","Wikipedia(en)のParsing expression grammarの項目","Wikipedia-Artikel Packrat Parser","Wikipedia: Parsing Expression Grammar, Packrat Parsing","Wikipedia: Parsing expression grammer","Wikipedia::PEG(en)","Wikipediaで「解析表現文法」を調べる","Wikipediaの解析表現文法のページ","Wikipedia上的解析表达式语法页","[PEG]","[img]http://en.wikipedia.org/wiki/Parsing_expression_grammar","a gramática de análise de expressão,","a tu wyjaśnienie","about what","age old ideas","an array of arbitrary objects","analisi di espressione Grammatica (PEG)","analizowania wyrażeń Grammar (PEG)","análisis de gramáticas de expresión","análisis de la expresión gramatical (PEG)","article on PEGs","automated grammar parsing","de:Packrat Parser","ekspresi Parsing tata bahasa","en.wikipedia.org/...Parsing_expression_grammar","en.wikipedia.org/wiki/Parsing_express...","en.wikipedia.org/wiki/Parsing_expression_grammar","en.wikipedia.org/wiki/Parsing_expression_grammar#Examples","en:Packrat parser","en:Parsing expression grammar","expresión de análisis de página de gramática en","fa:PEG","grammatica espressione Parsing pagina su wikipedia","gramática de la expresión Parsing (PEG).","harmon's white papers","http://bit.ly/iSL05l","http://de.wikipedia.org/wiki/Packrat_Par","http://de.wikipedia.org/wiki/Packrat_Parser","http://en.Liarpedia.org/wiki/Parsing_expression_grammar","http://en.wikipedia.org/wiki/P...g_expression_grammar","http://en.wikipedia.org/wiki/Packrat_parser","http://en.wikipedia.org/wiki/Parsing_Expressi...","http://en.wikipedia.org/wiki/Parsing_Expression_Grammar","http://en.wikipedia.org/wiki/Parsing_exp","http://en.wikipedia.org/wiki/Parsing_expressi...","http://en.wikipedia.org/wiki/Parsing_expression_gr...","http://en.wikipedia.org/wiki/Parsing_expression_grammar","http://en.wikipedia.org/wiki/Parsing_expression_grammar#Definition","http://en.wikipedia.org/wiki/Parsing_expression_grammar#Disadvantages","http://en.wikipedia.org/wiki/Parsing_expression_grammar#Examples","http://en.wikipedia.org/wiki/Parsing_expression_grammar#Implementing_parsers_from_parsing_expression_grammars","http://en.wikipedia.org/wiki/Parsing_expression_grammar#Indirect_Left_Recursion","http://en.wikipedia.org/wiki/Parsing_expression_grammar.","http://fr.wikipedia.org/wiki/Parser_packrat","http://ja.wikipedia.org/wiki/解析表現文法","il parsing di grammatica espressione","il parsing di grammatiche Expression","ja:解析表現文法","l'analisi di grammatiche di espressione","la gramática de la expresión","packrat parser","packrat parsers","packrat parsing","packrat parsing algorithm","packrat/PEG","parse expression grammar","parser expression grammar","parser expression-грамматик","parseren expressie grammatica pagina op wikipedia","parseren van Expression Grammar (PEG)","parsing expression grammar","parsing expression grammar (PEG)","parsing expression grammar - Wikipedia, the free encyclopedia","parsing expression grammar wikipedia the free encyclopedia","parsing expression grammar#Implementing parsers from parsing expression","parsing expression grammar-wikipedia,the free encyclopedia","parsing expression grammars","parsing expression grammars (PEGs)","parsing expression grammars (PEGs).","parsing expressions","procés gramatical","při analýze projevu gramatika (PEG)","ru:Грамматика, разбирающая выражение","se analýzy výrazů gramatika (PEG)","starting expression of a parsing expression grammar","the Wikipedia entry on PEGs","traditional packrat parser approach","ttp://en.wikipedia.org/wiki/Parsing_expression_grammar","ttp://en.wikipedia.org/wiki/Parsing_expression_grammar)","výraz analýze gramatiky stránku na Wikipedii","wikipedia:PEG","wikipedia:Parsing expression grammar","wikipedia:解析表現文法","wypowiedzi Parsowanie strony gramatyki na Wikipedii","Вот на википедии внизу список из реализаций","Грамматика, разбирающая выражение","Колышки","РВ-грамматики","выражение грамматики разбора страницу в Википедии","грамматики, разбирающие выражение","давно придумано и написано","похоже что речь об этом","синтаксический анализ выражений Грамматика (PEG).","синтаксический анализ выражений Грамматика (ПЭГ)","синтаксический анализ выражений Грамматики","синтаксический анализ выражений грамматику","การ แยก Expression Grammars","การ แยก แสดง ไวยากรณ์ (ตรึง).","การ แยก ไวยากรณ์ การ แสดงออก","ตอก","、PEG","、たとえば","的的","表現の文法解析","表达语法解析","表達語法解析","解析表現文法","解析表現文法 - Wikipedia","解析表現文法 PEG","解析表現文法 – Wikipedia","解析表現文法#.E6.AC.A0.E7.82.B9","解析表現文法-wikipedia","解析表現文法（PEG） 。","解析表現文法（ペッグ）","解析表达式语法","解析表达式语法（聚乙二醇）。","解析表達式語法","解析表達式語法（聚乙二醇）。","구문 표현 문법 (PEG)","이 링크를","표현 문법 구문","표현 문법 구문입니다."],"name":"Parsing expression grammar","categories":["All accuracy disputes","Articles with disputed statements from July 2014","Formal languages","Parsing algorithms","Wikipedia external links cleanup from September 2011","Wikipedia spam cleanup from September 2011"],"tag_line":"In computer science, a parsing expression grammar, or PEG, is a type of analytic formal grammar, i.e."}}
,{"_index":"throwtable","_type":"algorithm","_id":"all-nearest-smaller-values","_score":0,"_source":{"description":"In computer science, the all nearest smaller values problem is the following task: for each position in a sequence of numbers, search among the previous positions for the last position that contains a smaller value. This problem can be solved efficiently both by parallel and non-parallel algorithms: Berkman, Schieber & Vishkin (1993), who first identified the procedure as a useful subroutine for other parallel programs, developed efficient algorithms to solve it in the Parallel Random Access Machine model; it may also be solved in linear time on a non-parallel computer using a stack-based algorithm. Later researchers have studied algorithms to solve it in other models of parallel computation.","alt_names":["- All nearest smaller values :","All nearest smaller values","All nearest smaller values - Wikipedia, the free encyclopedia","What is All nearest smaller values's example","Wikipedia article All nearest smaller values","Wikipedia entry for All nearest smaller values","all nearest smaller","all nearest smaller values","en.wikipedia.org/wiki/All_nearest_smaller_values","en:all nearest smaller values","http://en.wikipedia.org/wiki/All_nearest_smaller_values"],"name":"All nearest smaller values","categories":["Parallel computing","Search algorithms"],"tag_line":"In computer science, the all nearest smaller values problem is the following task: for each position in a sequence of numbers, search among the previous positions for the last position that contains a smaller value."}}
,{"_index":"throwtable","_type":"algorithm","_id":"starvation-(computer-science)","_score":0,"_source":{"description":"In computer science, starvation is a problem encountered in concurrent computing where a process is perpetually denied necessary resources to process its work. Starvation may be caused by errors in a scheduling or mutual exclusion algorithm, but can also be caused by resource leaks, and can be intentionally caused via a denial-of-service attack such as a fork bomb.\nThe impossibility of starvation in a concurrent algorithm is called starvation-freedom, lockout-freedom or finite bypass, is an instance of liveness, and is one of the two requirements for any mutual exclusion algorithm (the other being correctness). The name \"finite bypass\" means that any process (concurrent part) of the algorithm is bypassed at most a finite number times before being allowed access to the shared resource.","alt_names":[],"name":"Starvation (computer science)","categories":["All articles needing additional references","All stub articles","Articles needing additional references from January 2011","Computer science stubs","Concurrency (computer science)","Processor scheduling algorithms"],"tag_line":"In computer science, starvation is a problem encountered in concurrent computing where a process is perpetually denied necessary resources to process its work."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fscan","_score":0,"_source":{"description":"FScan is a disk scheduling algorithm to determine the motion of the disk's arm and head in servicing read and write requests. It uses two subqueues. During the scan, all of the requests are in the first queue and all new requests are put into the second queue. Thus, service of new requests is deferred until all of the old requests have been processed. When the scan ends, the arm is taken to the first queue entries and is started all over again.","alt_names":["- FSCAN :","FSCAN","FSCAN - Wikipedia, the free encyclopedia","FSCAN Wikipedia, the free encyclopedia","FSCAN: Analysis","FSCAN; it is used under the","Fscan","What does FSCAN stand for","Wikipedia article FSCAN","Wikipedia article on FSCAN","Wikipedia entry for FSCAN","fscan - Wikipedia, the free encyclopedia","http://en.wikipedia.org/wiki/FSCAN","yago-res:FSCAN"],"name":"FSCAN","categories":["All articles lacking sources","Articles lacking sources from December 2009","Disk scheduling algorithms"],"tag_line":"FScan is a disk scheduling algorithm to determine the motion of the disk's arm and head in servicing read and write requests."}}
,{"_index":"throwtable","_type":"algorithm","_id":"beam-stack-search","_score":0,"_source":{"description":"Beam Stack Search is a search algorithm that combines chronological backtracking (that is, depth-first search) with beam search and is similar to Depth-First Beam Search. Both search algorithms are anytime algorithms that find good but likely sub-optimal solutions quickly, like beam search, then backtrack and continue to find improved solutions until convergence to an optimal solution.\n\n","alt_names":["- Beam stack search :","Beam Stack Search","Beam stack","Beam stack search","Beam stack search - Wikipedia :: The free encyclopedia","Beam stack search - Wikipedia, the free encyclopedia","Beam stack search - Wikipedia, the free encyclopedia ...","Beam stack search; it is used under the","What are alternatives to Beam stack search","Wikipedia (Beam stack search)","Wikipedia article Beam stack search","Wikipedia entry for Beam stack search","beam stack search","beam-stack search","http://en.wikipedia.org/wiki/Beam_stack_","http://en.wikipedia.org/wiki/Beam_stack_search","yago-res:Beam stack search"],"name":"Beam stack search","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Search algorithms"],"tag_line":"Beam Stack Search is a search algorithm that combines chronological backtracking (that is, depth-first search) with beam search and is similar to Depth-First Beam Search."}}
,{"_index":"throwtable","_type":"algorithm","_id":"atropos-scheduler","_score":0,"_source":{"description":"In computer science, Atropos is a real-time scheduling algorithm developed at Cambridge University. It combines the earliest deadline first algorithm with a best effort scheduler to make use of slack time, while exercising strict admission control.","alt_names":["...more on Wikipedia about Atropos scheduler","Atropos scheduler","Atropos scheduler - Wikipedia, the free encyclopedia","Atropos scheduler; it is used under the","Wikipedia (Atropos scheduler)","Wikipedia article Atropos scheduler","Wikipedia article on Atropos scheduler","Wikipedia entry for Atropos scheduler","http://en.Liarpedia.org/wiki/Atropos_scheduler","http://en.wikipedia.org/wiki/Atropos_sch","http://en.wikipedia.org/wiki/Atropos_scheduler","yago-res:Atropos scheduler"],"name":"Atropos scheduler","categories":["All articles lacking sources","All stub articles","Articles lacking sources from December 2009","Computer science stubs","Real-time computing","Scheduling algorithms"],"tag_line":"In computer science, Atropos is a real-time scheduling algorithm developed at Cambridge University."}}
,{"_index":"throwtable","_type":"algorithm","_id":"selection-algorithm","_score":0,"_source":{"description":"In computer science, a selection algorithm is an algorithm for finding the kth smallest number in a list or array; such a number is called the kth order statistic. This includes the cases of finding the minimum, maximum, and median elements. There are O(n) (worst-case linear time) selection algorithms, and sublinear performance is possible for structured data; in the extreme, O(1) for an array of sorted data. Selection is a subproblem of more complex problems like the nearest neighbor and shortest path problems. Many selection algorithms are derived by generalizing a sorting algorithm, and conversely some sorting algorithms can be derived as repeated application of selection.\nThe simplest case of a selection algorithm is finding the minimum (or maximum) element by iterating through the list, keeping track of the running minimum – the minimum so far – (or maximum) and can be seen as related to the selection sort. Conversely, the hardest case of a selection algorithm is finding the median, and this necessarily takes n/2 storage. In fact, a specialized median-selection algorithm can be used to build a general selection algorithm, as in median of medians. The best-known selection algorithm is quickselect, which is related to quicksort; like quicksort, it has (asymptotically) optimal average performance, but poor worst-case performance, though it can be modified to give optimal worst-case performance as well.","alt_names":["linear time algorithm","selection problem","median of medians","selection algorithm","quickselect","# Partición http://en.wikipedia.org/wiki/Selection_algorithm-based_general_selection_algorithm","&Oscr; ( n log n )","* Partition Based Selection Algorithm","- Median search :","-> Read the article about 'Selection algorithm'","Algorithmus auswählen","Algorithmus zur Auswahl","Algoritma Seleksi","Algoritma seleksi","Algoritma seleksi - Wikipedia bahasa Indonesia, ensiklopedia bebas","Algoritmus výběru","Algorytm Hoare a","Algorytm Hoare'a","Auswahl Algorithmen","Auswahl-Algorithmen","Auswahl-Algorithmus","BFPRT","BFPRT partitioning algorithm","BFPRT-Алгоритм","BFPRT-Алгоритм — Википедия","Finding the median","Hoare's quickselect","Hoare's selection algorithm","Introselect","La mediana del algoritmo de medianas.","Learn about Selection algorithm>>>","Linear general selection algorithm - Median of Medians algorithm","Linear minimum ...","Lower bounds for Selection","Median Sort","Median der Mediane Algorithmus.","Median of Medians","Median of Medians Algorithm","Median of Medians algorithm","Median of Medians selection algorithm","Median of medians","Median of medians algorithm","Median of medians algorithm.","Median search","Median_search","Mediana algorytm mediany.","Medianen af medianerne algoritme.","Medians of Medians algorithm","Medián mediánů algoritmu.","Nonlinear general ...","Nonlinear general selection algorithm","O (N) частичное рода","O (n) delvis sortere","O (n) een gedeeltelijke sorteren","O (n) ordinamento parziale","O (n) tipo parcial","O (n), częściowe sortowania","O(N+KlogN)","O(n) partial sort","O（N）的部分，","Partition-based general selection algorithm","Partition-based_general_selection_algorithm","Quick Select","Quick Selection Algorithm","Quick select","Quick-select","QuickSelect","QuickSelect o la mediana de las medianas-","QuickSelect oder Median-of-Mediane","QuickSelectem","Quickselect","Rivest-Tarjan-Selection algorithm","Seleccione el algoritmo","Select Algorithm","Select algorithm","Select algoritme","Selecteer Algorithm","Selectie algoritmes","Selectie-algoritme","Selection Algorithm","Selection Algorithms","Selection Sort technique","Selection algorithm","Selection algorithm - Wikipedia :: The free encyclopedia","Selection algorithm - Wikipedia, the free encyclopedia","Selection algorithm Wikipedia the free encyclopedia","Selection algorithm on wikipedia","Selection algorithm on wikipedia.","Selection algorithm.","Selection algorithm:","Selection algorithms","Selection and median algorithms","Selection by sorting","Selection problem","Selection_algorithm","Selection_algorithm - Selecting k smallest or largest elements","Selekcja (informatyka)","Selezionare Algorithm","Szybkiego","The Selection Problem","The algorithm of Blum, Floyd, Pratt, Rivest, and","There are O(n) algorithms for finding a","Tournament Algorithm","Tournament Tree","Tournament tree","Trounament Trees","Udvælgelse algoritmer","Vyberte algoritmus","Vælg Algoritme","Výběr algoritmu","Výběr algoritmů","Wikipedia article Algorytm Hoare'a","Wikipedia article Algorytm magicznych piątek","Wikipedia article Quickselect","Wikipedia article Selection algorithm","Wikipedia article Selection problem","Wikipedia article on Quickselect","Wikipedia article on Selection algorithm","Wikipedia entry for Selection algorithm","Wikipedia l'articolo Quickselect","Wikipedia link on selection problem","Wikipedia | Selection algorithm | Linear minimum/maximum algorithms","Wikipedia: Selection Algorithm","Wikipedia:Quickselect","Wikipediaで「選択アルゴリズム」を調べる","Wybierz Algorithm","a linear time k-th largest selection algorithm","a variety of selection algorithms","algorithme de sélection","algorithmes de sélection","algoritma seleksi","algoritme kiezen","algoritmi di selezione","algoritmo Seleccione","algoritmo Selezionare","algoritmo de selección","algoritmo de selección de","algoritmo de seleção","algoritmo di selezione","algoritmos de selección","algoritmos de seleção","algoritmul de gasire a medianei","algoritmus pro výběr","algoritmus výběru","algorytm Wybierz","algorytm selekcji","algorytm wyboru","algorytmu selekcji","algorytmy wyboru","can be solved in O(n) time","corretta selezione perno","dell'algoritmo Selezione","der Select-Algorithmus","does indeed require n - 1 comparisons","efficiently selecting the k smallest elements","el algoritmo de Selección","en.wikipedia.org/...Selection_algorithm","en.wikipedia.org/wiki/Selection_algorith..._or_largest_elements","en.wikipedia.org/wiki/Selection_algorithm","finding the median","general selection algorithm","gli algoritmi di selezione","http://en.wikipedia....hm#Lower_bounds","http://en.wikipedia.org/Selection_algorithm","http://en.wikipedia.org/wiki/Median_sear","http://en.wikipedia.org/wiki/Median_search","http://en.wikipedia.org/wiki/Quickselect","http://en.wikipedia.org/wiki/S....._algorithm","http://en.wikipedia.org/wiki/Selec [...] _algorithm","http://en.wikipedia.org/wiki/Select...thm#Introselect","http://en.wikipedia.org/wiki/Selecti...es t_elements","http://en.wikipedia.org/wiki/Selecti...hm#Introselect","http://en.wikipedia.org/wiki/Selecti...on_algor ithm","http://en.wikipedia.org/wiki/Selecti...rgest_elements","http://en.wikipedia.org/wiki/Selecti...s_algorithm.22","http://en.wikipedia.org/wiki/Selecti...tion_algorithm","http://en.wikipedia.org/wiki/Selection 5Falgorithm% #% lineal","http://en.wikipedia.org/wiki/Selection% 5Falgorithm","http://en.wikipedia.org/wiki/Selection% 5Falgorithm # Linear","http://en.wikipedia.org/wiki/Selection% 5Falgorithm # Lineární","http://en.wikipedia.org/wiki/Selection% 5Falgorithm # lineare","http://en.wikipedia.org/wiki/Selection% 5Falgorithm # Линейные","http://en.wikipedia.org/wiki/Selection%5Falgorithm","http://en.wikipedia.org/wiki/Selection%5Falgorithm#Linear","http://en.wikipedia.org/wiki/Selection_ ... _algorithm","http://en.wikipedia.org/wiki/Selection_ ... t_elements","http://en.wikipedia.org/wiki/Selection_a","http://en.wikipedia.org/wiki/Selection_algori...","http://en.wikipedia.org/wiki/Selection_algorithm","http://en.wikipedia.org/wiki/Selection_algorithm # La partizione","http://en.wikipedia.org/wiki/Selection_algorithm # Partition-based_general_selection_algorithm","http://en.wikipedia.org/wiki/Selection_algorithm # Partycja-based_general_selection_algorithm","http://en.wikipedia.org/wiki/Selection_algorithm # Selecting_k_smallest_or_largest_elements","http://en.wikipedia.org/wiki/Selection_algorithm # oddíl, based_general_selection_algorithm","http://en.wikipedia.org/wiki/Selection_algorithm # секциям based_general_selection_algorithm","http://en.wikipedia.org/wiki/Selection_algorithm f","http://en.wikipedia.org/wiki/Selection_algorithm#Introselect","http://en.wikipedia.org/wiki/Selection_algorithm#Language_su...","http://en.wikipedia.org/wiki/Selection_algorithm#Language_support","http://en.wikipedia.org/wiki/Selection_algorithm#Linear_gene...","http://en.wikipedia.org/wiki/Selection_algorithm#Linear_general_selec","http://en.wikipedia.org/wiki/Selection_algorithm#Linear_general_selec...","http://en.wikipedia.org/wiki/Selection_algorithm#Linear_general_selection_algori\\ thm_","http://en.wikipedia.org/wiki/Selection_algorithm#Linear_general_selection_algorithm","http://en.wikipedia.org/wiki/Selection_algorithm#Linear_general_selection_algorithm_-_","http://en.wikipedia.org/wiki/Selection_algorithm#Linear_general_selection_algorithm_-_Median_of_Medians_algorithm","http://en.wikipedia.org/wiki/Selection_algorithm#Online_selection_algorithm","http://en.wikipedia.org/wiki/Selection_algorithm#Optimised_sorting_algorithms","http://en.wikipedia.org/wiki/Selection_algorithm#Partition-","http://en.wikipedia.org/wiki/Selection_algorithm#Partition-based_general_selecti","http://en.wikipedia.org/wiki/Selection_algorithm#Partition-based_general_selection_algorithm","http://en.wikipedia.org/wiki/Selection_algorithm#Partition_based_general _selection_algorithm","http://en.wikipedia.org/wiki/Selection_algorithm#Proof_of_O.2","http://en.wikipedia.org/wiki/Selection_algorithm#Selecting_k...","http://en.wikipedia.org/wiki/Selection_algorithm#Selecting_k_smallest_or_largest_elements","http://en.wikipedia.org/wiki/Selection_algorithm#Selection_by_sorting","http://en.wikipedia.org/wiki/Selection_algorithm#Tournament_Alg","http://en.wikipedia.org/wiki/Selection_algorithm#Using_data_structures_to_..","http://en.wikipedia.org/wiki/Selection_algorithm#Using_data_structures_to_select_in_sublinear_time","http://en.wikipedia.org/wiki/Selection_algorithm.","http://en.wikipedia.org/wiki/Selection_algorithmを","http://en.wikipedia.org/wiki/Selection_algorithm을","http://en.wikipedia.org/wiki/Selection_algorithm＃のSelecting_k_smallest_or_largest_elements","http://en.wikipedia.org/wiki/Selection_a…","http://en.wikipedia.org/wiki/Selection_problem#Partition_based_general_selection_algorithm","http://en.wikipedia.org/wiki/Selection％5Falgorithm","http://en.wikipedia.org/wiki/Selection％5Falgorithmは","http://en.wikipedia.org/wiki/Selection％の5Falgorithm","http://id.wikipedia.org/wiki/Algoritma_seleksi","http://it.wikipedia.org/wiki/Quickselect","http://ja.wikipedia.org/wiki/選択アルゴリズム","http://pl.wikipedia.org/wiki/Algorytm_Hoare%27a","http://pl.wikipedia.org/wiki/Algorytm_Hoare'a","http://pl.wikipedia.org/wiki/Algorytm_magicznych_pi%C4%85tek","http://pl.wikipedia.org/wiki/Algorytm_magicznych_piątek","http://pl.wikipedia.org/wiki/Algorytm_magicznyh_pi%C4%85tek","http://pl.wikipedia.org/wiki/Selekcja_(informatyka)","ingenious algorithm","introspective select","juiste pivot selectie","korrekte Drehpunkt Auswahl","kth largest number","l'algoritmo di selezione","linear median selection algorithm","linear time algorithm for finding the median of","linear time selection algorithm","linear-time selection algorithm","link <---","los algoritmos de selección","lower the runtime","may be found in linear time","median finding algorithm","median of a list in O(n)","median of median","median of medians algorithm","median selection algorithm","median-finding","median-of-medians","median-of-medians algorithm","median-of-three","menu 'a discesa","ordentlig pivot valg","partition based selection","partition-based general selection algorithm","partition-based selection algorithm","proper pivot selection","página de la wikipedia sobre este algoritmo","quick select","quickselect algorithm","quickselect eller median-of-medianer","quickselect lub średnio-of-median","quickselect nebo střední-Z-mediánů","quickselect or median-of-medians","quickselectまたは中央値-の-中央値の","rank selection algorithm","section on min/max k values in a","selección de pivotes adecuado","select algorithm (wikipedia)","selectie algoritme","selectie algoritmen","selectie-algoritme","selecting first k","selecting k smallest or largest elements","selecting the best","selection algorith","selection algorithms","selection algorithms.","selection-algorithm","selezione di algoritmi","sort and select","správného výběru pivot","stelling van Knuth","takes linear time","the Median of Medians algorithm","the Select algorithm","the median-of-medians","thinking about the logic","this Wikipedia article on selection algorithms","thuật toán lựa chọn","top-k selection algorithm","tournament algorithm","udvalg algoritme","udvælgelse algoritme","umfjöllun um slíka lausn á vefnum","valg algoritmer","variations on the quicksort","volba algoritmu","výběr algoritmů","wikipedia on select","właściwego doboru obrotu","Алгоритм выбора","Википедии статью BFPRT-Алгоритм","Выберите алгоритм","Выбор алгоритма","Выбор алгоритмов","алгоритм выбора","википедиевскую статью","выбор алгоритма","выбор алгоритмов","выбора алгоритма","выбора алгоритмов","правильный выбор стержень","דווקא יש חמישיות","उचित धुरी चयन","चयन एल्गोरिथ्म","चयन एल्गोरिदम","विभाजन के based_general_selection_algorithm # http://en.wikipedia.org/wiki","हे (एन) आंशिक तरह","हैं एक चयन","ขั้นตอนวิธีการเลือก","“median of medians”","、問題","のアルゴリズムや","アルゴリズムを選択し","アルゴリズム値","一个选择","中央値アルゴリズムの中央値。","少し面倒","快速选择","的选择算法","选择算法","选择适当","適切なピボット選択を","選択アルゴリズム","選択アルゴリズム - Wikipedia","選択アルゴリズム -wikipedia","選択アルゴリズムの一種","選択アルゴリズムは、","選択アルゴリズムを","選択ｱﾙｺﾞﾘｽﾞﾑ-wikipedia","選擇算法","선택 알고리즘","＃パーティションbased_general_selection_algorithm http://en.wikipedia.org/wiki/Selection_algorithm"],"name":"Selection algorithm","categories":["All articles with unsourced statements","Articles with unsourced statements from April 2014","Selection algorithms"],"tag_line":"In computer science, a selection algorithm is an algorithm for finding the kth smallest number in a list or array; such a number is called the kth order statistic."}}
,{"_index":"throwtable","_type":"algorithm","_id":"knuth's-algorithm-x","_score":0,"_source":{"description":"\"Algorithm X\" is the name Donald Knuth used in his paper \"Dancing Links\" to refer to \"the most obvious trial-and-error approach\" for finding all solutions to the exact cover problem. Technically, Algorithm X is a recursive, nondeterministic, depth-first, backtracking algorithm. While Algorithm X is generally useful as a succinct explanation of how the exact cover problem may be solved, Knuth's intent in presenting it was merely to demonstrate the utility of the dancing links technique via an efficient implementation he called DLX.\nThe exact cover problem is represented in Algorithm X using a matrix A consisting of 0s and 1s. The goal is to select a subset of the rows so that the digit 1 appears in each column exactly once.\nAlgorithm X functions as follows:\n\nThe nondeterministic choice of r means that the algorithm essentially clones itself into independent subalgorithms; each subalgorithm inherits the current matrix A, but reduces it with respect to a different row r. If column c is entirely zero, there are no subalgorithms and the process terminates unsuccessfully.\nThe subalgorithms form a search tree in a natural way, with the original problem at the root and with level k containing each subalgorithm that corresponds to k chosen rows. Backtracking is the process of traversing the tree in preorder, depth first.\nAny systematic rule for choosing column c in this procedure will find all solutions, but some rules work much better than others. To reduce the number of iterations, Knuth suggests that the column choosing algorithm select a column with the lowest number of 1s in it.","alt_names":["Knuth's Algorithm X","Knuth's Algorithm X - Wikipedia, the free encyclopedia","-Algorithmus X","...more on Wikipedia about Knuth's Algorithm X","Algorisme X","Algorithm X","Algorithm X @ Wikipedia","Algorithm X method","Algorithm_X wikipedia","Algorithme X","Algorithme de Knuth X - Wikipedia, l'encyclopédie libre","Algorithmus X","Algoritimo X","Algoritma X","Algoritme X","Algoritmo X","Algoritmo de Knuth X - Wikipédia, a enciclopédia livre","Algoritmus X","Algorytm X","Alogrithm X","Knuth Algorytm X - Wikipedia, wolna encyklopedia","Knuth algoritmi X - Wikipedia, vapaa tietosanakirja","Knuth s Algorithm X - Wikipedia, the free encyclopedia","Knuth&#39;s Algorithm X - Wikipedia, the free","Knuth's Algorithm X - Wikipedia","Knuth's Algorithm X - Wikipedia :: The free encyclopedia","Knuth's Algoritme X - Wikipedia, den frie encyklopedi","Knuth's algoritm X - Wikipedia, den fria encyklopedin","Knuth's algoritms X - Vikipēdija, brīvā enciklopēdija","Knuth的算法X -维基百科，自由的百科全书","Learn about Knuth's Algorithm X>>>","Thuật toán X","What is Knuth's Algorithm X's example","Wikipedia article Knuth's Algorithm X","Wikipedia article Knuth's algorithm X","Wikipedia article Knuths Algorithm x","X Algoritam","X Algoritem","X Algorithm","X Algorithme","X Algoritma","X Algoritme","X Algoritmi","X Algoritmo","X Algoritmul","X algoritm","X algoritmas","X algoritme","X algoritmi","X algoritmus","X Αλγόριθμος","X Алгоритм","X алгоритъм","X-Algorithmus","Xのアルゴリズム","X算法","algorithm X","algorithm x","algorithme X","algoritmus X","en.wikipedia.org/Algorithm_X","en.wikipedia.org/wiki/Knuth%27s_Algorithm_X","http://en.wikipedia.org/wiki/Algorithm_X","http://en.wikipedia.org/wiki/Knuth%27s_Algorithm_X","http://en.wikipedia.org/wiki/Knuth's_Alg...","http://en.wikipedia.org/wiki/Knuth's_Algorithm_X","Алгоритм X","Кс Алгоритам","алгоритм Х","اکس الگوریتم","س خوارزمية","アルゴリズムのX","算法X","알고리즘 X가"],"name":"Knuth's Algorithm X","categories":["Donald Knuth","Search algorithms"],"tag_line":"\"Algorithm X\" is the name Donald Knuth used in his paper \"Dancing Links\" to refer to \"the most obvious trial-and-error approach\" for finding all solutions to the exact cover problem."}}
,{"_index":"throwtable","_type":"algorithm","_id":"burstsort","_score":0,"_source":{"description":"Burstsort and its variants are cache-efficient algorithms for sorting strings and are faster than radix sort for large data sets of common strings, first published in 2003.\nBurstsort algorithms use a trie to store prefixes of strings, with growable arrays of pointers as end nodes containing sorted, unique, suffixes (referred to as buckets). Some variants copy the string tails into the buckets. As the buckets grow beyond a predetermined threshold, the buckets are \"burst\", giving the sort its name. A more recent variant uses a bucket index with smaller sub-buckets to reduce memory usage. Most implementations delegate to multikey quicksort, an extension of three-way radix quicksort, to sort the contents of the buckets. By dividing the input into buckets with common prefixes, the sorting can be done in a cache-efficient manner.\nBurstsort was introduced as a sort that is similar to MSD Radix Sort, but is faster due to being aware of caching and related radixes being stored closer to each other due to specifics of trie structure. It exploits specifics of strings that are usually encountered in real world. And even though asymptotically it is the same as radix sort, with time complexity of O(wn) (w - word length and n - number of strings to be sorted), but due to more optimal memory distribution it tends to be twice as fast on big data sets of strings.","alt_names":["- Burstsort :","BrustSort","Burst-Art","Burstsort","Burstsort - Wikipedia, The Free Encyclopedia","Burstsort - Wikipedia, the free encyclopedia","Burstsort – Wikipédia, a enciclopédia livre","Burstsort.","Wikipedia (Burstsort)","Wikipedia article Burstsort","Wikipedia article about Burstsort","Wikipedia article on Burstsort","Wikipedia entry for Burstsort","Wikipedia: Burstsort","burst sort","burstsort","especie estallido","espécie de ruptura","http://en.wikipedia.org/wiki/Burstsort","loại burst","semacam meledak","sort strings faster than quicksort or radix sort","sorta scoppio","sorte irruption","yago-res:Burstsort","взрыв рода","การออกมาจัดเรียง","の並べ替えは、大文字と","突发排序","突發排序","버스트 정렬이","：Burstsort。"],"name":"Burstsort","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","String sorting algorithms"],"tag_line":"Burstsort and its variants are cache-efficient algorithms for sorting strings and are faster than radix sort for large data sets of common strings, first published in 2003."}}
,{"_index":"throwtable","_type":"algorithm","_id":"median-of-medians","_score":0,"_source":{"description":"In computer science, the median of medians algorithm is a selection algorithm based on the quickselect algorithm, and is optimal, having worst-case linear time complexity for selecting the kth largest element. The algorithm finds an approximate median in linear time – this is the key step – which is then used as a pivot in quickselect. In other words, it uses an (asymptotically) optimal approximate median-selection algorithm to build an (asymptotically) optimal general selection algorithm.\nThe approximate median-selection algorithm can also be used as a pivot strategy in quicksort, yielding an optimal algorithm, with worst-case complexity O(n log n). Although this approach optimizes quite well, it is typically outperformed in practice by instead choosing random pivots, which has average linear time for selection and average log-linear time for sorting, and avoids the overhead of computing the pivot. Median of medians is used in the hybrid introselect algorithm as a fallback, to ensure worst-case linear performance: introselect starts with quickselect, to obtain good average performance, and then falls back to median of medians if progress is too slow.\nThe algorithm was published in Blum et al. (Tarjan), and thus is sometimes called BFPRT after the last names of the authors. In the original paper the algorithm was referred to as PICK, referring to quickselect as \"FIND\".","alt_names":[],"name":"Median of medians","categories":["Selection algorithms"],"tag_line":"In computer science, the median of medians algorithm is a selection algorithm based on the quickselect algorithm, and is optimal, having worst-case linear time complexity for selecting the kth largest element."}}
,{"_index":"throwtable","_type":"algorithm","_id":"mtd-f","_score":0,"_source":{"description":"MTD(f), is a minimax search algorithm, developed in 1994 by Aske Plaat, Jonathan Schaeffer, Wim Pijls, and Arie de Bruin. Experiments with tournament-quality chess, checkers, and Othello programs show it to be the most efficient minimax algorithm. The name MTD(f) is an abbreviation for MTD(n,f) (Memory-enhanced Test Driver with node n and value f). It is an alternative to the alpha-beta pruning algorithm.","alt_names":["...more on Wikipedia about MTD-f","Learn about MTD-f>>>","MTD f","MTD(f)","MTD(f) from Wikipedia","MTD-f","MTD-f - Wikipedia","MTD-f - Wikipedia, the free encyclopedia","MTD-f |","MTD-f-wikipedia","MTDf Wikipedia the free encyclopedia","View MTD(f) on Wikipedia","What is performance of MTD-f","Wikipedia article MTD(f)","Wikipedia article MTD-f","Wikipedia article on MTD(f)","Wikipedia article on MTD-f","Wikipedia entry for MTD-f","Wikipediaで「MTD-f」を調べる","Zero Window Searches","http://en.wikipedia.org/wiki/MTD%28f%29","http://en.wikipedia.org/wiki/MTD-f","http://ja.wikipedia.org/wiki/MTD-f","http://ja.wikipedia.org/wiki/MTD-f#Null_Window_Search","http://ja.wikipedia.org/wiki/MTD-fの","ja:MTD-f","ウィキペディアの記事 MTD-f"],"name":"MTD-f","categories":["Articles with example pseudocode","Search algorithms"],"tag_line":"MTD(f), is a minimax search algorithm, developed in 1994 by Aske Plaat, Jonathan Schaeffer, Wim Pijls, and Arie de Bruin."}}
,{"_index":"throwtable","_type":"algorithm","_id":"floyd–rivest-algorithm","_score":0,"_source":{"description":"In computer science, the Floyd-Rivest algorithm is a selection algorithm developed by Robert W. Floyd and Ronald L. Rivest that has an optimal expected number of comparisons within lower-order terms. It is functionally equivalent to quickselect, but runs faster in practice on average.  It has an expected running time of O(n) and an expected number of comparisons of n + min(k, n - k) + O(n1/2).\nThe algorithm was originally presented in a Stanford University technical report containing two papers, where it was referred to as SELECT and paired with PICK, or median of medians.  It was subsequently published in Communications of the ACM, Volume 18: Issue 3.","alt_names":[],"name":"Floyd–Rivest algorithm","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Selection algorithms"],"tag_line":"In computer science, the Floyd-Rivest algorithm is a selection algorithm developed by Robert W. Floyd and Ronald L. Rivest that has an optimal expected number of comparisons within lower-order terms."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fast-folding-algorithm","_score":0,"_source":{"description":"In signal processing, the fast folding algorithm (Staelin, 1969) is an efficient algorithm for the detection of approximately-periodic events within time series data. It computes superpositions of the signal modulo various window sizes simultaneously.\nThe FFA is best known for its use in the detection of pulsars, as popularised by SETI@home and Astropulse.","alt_names":[],"name":"Fast folding algorithm","categories":["Algorithms and data structures stubs","All stub articles","Computer science stubs","Signal processing"],"tag_line":"In signal processing, the fast folding algorithm (Staelin, 1969) is an efficient algorithm for the detection of approximately-periodic events within time series data."}}
,{"_index":"throwtable","_type":"algorithm","_id":"twisting-properties","_score":0,"_source":{"description":"Starting with a sample  observed from a random variable X having a given distribution law with a non-set parameter, a parametric inference problem consists of computing suitable values – call them estimates – of this parameter precisely on the basis of the sample. An estimate is suitable if replacing it with the unknown parameter does not cause major damage in next computations. In algorithmic inference, suitability of an estimate reads in terms of compatibility with the observed sample.\nIn turn, parameter compatibility is a probability measure that we derive from the probability distribution of the random variable to which the parameter refers. In this way we identify a random parameter Θ compatible with an observed sample. Given a sampling mechanism , the rationale of this operation lies in using the Z seed distribution law to determine both the X distribution law for the given θ, and the Θ distribution law given an X sample. Hence, we may derive the latter distribution directly from the former if we are able to relate domains of the sample space to subsets of Θ support. In more abstract terms, we speak about twisting properties of samples with properties of parameters and identify the former with statistics that are suitable for this exchange, so denoting a well behavior w.r.t. the unknown parameters. The operational goal is to write the analytic expression of the cumulative distribution function , in light of the observed value s of a statistic S, as a function of the S distribution law when the X parameter is exactly θ.","alt_names":["85be10f123b351298c2b3477 ...","Joint probability density function of parameters K of","Twisting properties","Twisting properties - Wikipedia, the free encyclopedia","Wikipedia article Twisting properties","Wikipedia entry for Twisting properties","en.wikipedia.org/wiki/Twisting_properties","http://en.wikipedia.org/wiki/Twisting_properties","twisting argument","yago-res:Twisting properties"],"name":"Twisting properties","categories":["Algorithmic inference","All Wikipedia articles needing context","All articles lacking in-text citations","All pages needing cleanup","Articles lacking in-text citations from September 2009","Computational statistics","Wikipedia articles needing context from January 2009","Wikipedia introduction cleanup from January 2009"],"tag_line":"Starting with a sample  observed from a random variable X having a given distribution law with a non-set parameter, a parametric inference problem consists of computing suitable values – call them estimates – of this parameter precisely on the basis of the sample."}}
,{"_index":"throwtable","_type":"algorithm","_id":"wagner–fischer-algorithm","_score":0,"_source":{"description":"In computer science, the Wagner–Fischer algorithm is a dynamic programming algorithm that computes the edit distance between two strings of characters.","alt_names":[],"name":"Wagner–Fischer algorithm","categories":["Algorithms on strings","String similarity measures"],"tag_line":"In computer science, the Wagner–Fischer algorithm is a dynamic programming algorithm that computes the edit distance between two strings of characters."}}
,{"_index":"throwtable","_type":"algorithm","_id":"inside–outside-algorithm","_score":0,"_source":{"description":"In computer science, the inside–outside algorithm is a way of re-estimating production probabilities in a probabilistic context-free grammar. It was introduced James K. Baker in 1979 as a generalization of the forward–backward algorithm for parameter estimation on hidden Markov models to stochastic context-free grammars. It is used to compute expectations, for example as part of the expectation–maximization algorithm (an unsupervised learning algorithm).\n\n","alt_names":[],"name":"Inside–outside algorithm","categories":["Algorithms and data structures stubs","All Wikipedia articles needing context","All pages needing cleanup","All stub articles","Computer science stubs","Parsing algorithms","Wikipedia articles needing context from June 2012","Wikipedia introduction cleanup from June 2012"],"tag_line":"In computer science, the inside–outside algorithm is a way of re-estimating production probabilities in a probabilistic context-free grammar."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lalr-parser","_score":0,"_source":{"description":"In computer science, an LALR parser or Look-Ahead LR parser is a simplified version of a canonical LR parser, to parse (separate and analyze) a text according to a set of production rules specified by a formal grammar for a computer language. (\"LR\" means left-to-right, rightmost derivation.)\nThe LALR parser was invented by Frank DeRemer in his 1969 PhD dissertation, Practical Translators for LR(k) languages, in his treatment of the practical difficulties at that time of implementing LR(1) parsers. He showed that the LALR parser has more language recognition power than the LR(0) parser, while requiring the same number of states as the LR(0) parser for a language that can be recognized by both parsers. This makes the LALR parser a memory-efficient alternative to the LR(1) parser for languages that are not LR(0). It was also proved that there exist LR(1) languages that are not LALR. Despite this weakness, the power of the LALR parser is enough for many mainstream computer languages, including Java, though the reference grammars for many languages fail to be LALR due to being ambiguous.\nThe original dissertation gave no algorithm for constructing such a parser given some formal grammar. The first algorithms for LALR parser generation were published in 1973. In 1982, DeRemer and Tom Pennello published an algorithm that generated highly memory-efficient LALR parsers. LALR parsers can be automatically generated from some grammar by an LALR parser generator such as Yacc or GNU Bison. The automatically generated code may be augmented by hand-written code to augment the power of the resulting parser.","alt_names":["push down automaton","LALR-Parser","LALR(1)","- LALR :","- LALR parser :","-> Read the article about 'LALR parser'","...mehr auf Wikipedia über LALR-Parser","...more on Wikipedia about LALR parser","2 Generating LALR Parsers","A Wikipedia site.","Analyse LALR - Wikipédia","Backtracking LALR(1)","Backtracking LALR(k)","Generating LALR Parsers","LALR","LALR (1)","LALR (Look Aside Left to Right)","LALR (Look-ahead LR) parser","LALR - Wikipedia","LALR - Википедија","LALR / LR","LALR Parser","LALR Parsing","LALR category","LALR on Wikipedia","LALR on Wikipedia.","LALR parser","LALR parser (Wikipedia)","LALR parser - Wikipedia, the free encyclopedia","LALR parser - Wikipedia, the free encyclopediaAn LALR","LALR parser - Wikipedia, the free …","LALR parser Wikipedia Entry","LALR parser generators","LALR parser method","LALR parser – Wikipedia, the free encyclopedia","LALR parser; it is used under the","LALR parsers","LALR парсера","LALR 法","LALR(1) grammar","LALR(1) parser","LALR(1)-Parser","LALR(1)-Parsing","LALR(k)","LALR-Parser ? Wikipedia","LALR-Parser in","LALR-Parser – Wikipedia","LALR1","LALR; it is used under the","LALR_parser","LALR法","LALR法 - Wikipedia","LALR法-wikipedia","LALR法とは？ (Wikipediaへのリンク)","LALR（1）の","LARL(1) parser generator","Lalr Parser","Learn about LALR parser>>>","Look-Ahead LR","Look-ahead LR parser","Wikipadia - LALR法","Wikipedia : LALR法","Wikipedia article LALR","Wikipedia article LALR parser","Wikipedia article LALR parsers","Wikipedia article Look-ahead LR parser","Wikipedia article on LALR","Wikipedia article on LALR parser","Wikipedia article on LALR parsers","Wikipedia entry for LALR parser","Wikipedia l'articolo LALR","Wikipedia-Artikel LALR-Parser","Wikipedia-Seite zu 'LALR-Parser'","Wikipediaで「LALR法」を調べる","Właściwości klas gramatyk LALR(k) i LR(k","analisador LALR","analizador LALR","analyseur LALR","ar:المحلل اللغوي LALR","certain kinds of parsers","cú pháp LALR","de:LALR-Parser","en.wikipedia.org/LALR_parser","en.wikipedia.org/wiki/LALR_parser","en.wikipedia.org/wiki/LALR_parsers","en.wikipedia.org/wiki/Look-ahead_LR_parser","en:LALR parser","fr:Analyse LALR","http://de.wikipedia.org/wiki/LALR-Parser","http://en.wikipedia....iki/LALR_parser","http://en.wikipedia.org/wiki/LALR","http://en.wikipedia.org/wiki/LALR% 5Fparser","http://en.wikipedia.org/wiki/LALR%5Fparser","http://en.wikipedia.org/wiki/LALR_parser","http://en.wikipedia.org/wiki/LALR_parser.","http://en.wikipedia.org/wiki/LALR_parsers","http://en.wikipedia.org/wiki/LALRparser","http://fr.wikipedia.org/wiki/Analyse_LALR","http://it.wikipedia.org/wiki/LALR","http://ja.wikipedia.org/wiki/LALR%E6%B3","http://ko.wikipedia.org/wiki/LALR","http://pl.wikipedia.org/wiki/LALR","http://ru.wikipedia.org/wiki/LALR(1)","it:LALR","ja:LALR法","ko:LALR","lalr","lalr (1)","lalr parser wikipedia the free encyclopedia","look ahead parser","look-ahead LR parsers","lookahead LR parser","macchina a stati LALR","parser LALR","pl:LALR","r. http://en.wikipedia.org/wiki/LALR_parser.","right-recursive","ru:LALR(1)","sr:LALR","tabular LALR","的LALR（1）","좋은 LALR 파서를"],"name":"LALR parser","categories":["All articles with unsourced statements","Articles with unsourced statements from December 2012","Parsing algorithms","Use dmy dates from July 2012"],"tag_line":"In computer science, an LALR parser or Look-Ahead LR parser is a simplified version of a canonical LR parser, to parse (separate and analyze) a text according to a set of production rules specified by a formal grammar for a computer language."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lr-parser","_score":0,"_source":{"description":"In computer science, LR parsers are a type of bottom-up parsers that efficiently handle deterministic context-free languages in guaranteed linear time. The LALR parsers and the SLR parsers are common variants of LR parsers. LR parsers are often mechanically generated from a formal grammar for the language by a parser generator tool. They are very widely used for the processing of computer languages, more than other kinds of generated parsers.\nThe name LR is an acronym. The L means that the parser reads input text in one direction without backing up; that direction is typically Left to right within each line, and top to bottom across the lines of the full input file. (This is true for most parsers.) The R means that the parser produces a reversed Rightmost derivation; it does a bottom-up parse, not a top-down LL parse or ad-hoc parse. The name LR is often followed by a numeric qualifier, as in LR(1) or sometimes LR(k). To avoid backtracking or guessing, the LR parser is allowed to peek ahead at k lookahead input symbols before deciding how to parse earlier symbols. Typically k is 1 and is not mentioned. The name LR is often preceded by other qualifiers, as in SLR and LALR.\nLR parsers are deterministic; they produce a single correct parse without guesswork or backtracking, in linear time. This is ideal for computer languages. But LR parsers are not suited for human languages which need more flexible but slower methods. Other parser methods (CYK algorithm, Earley parser, and GLR parser) that backtrack or yield multiple parses may take O(n2), O(n3) or even exponential time when they guess badly.\nThe above properties of L, R, and k are actually shared by all shift-reduce parsers, including precedence parsers. But by convention, the LR name stands for the form of parsing invented by Donald Knuth, and excludes the earlier, less powerful precedence methods (for example Operator-precedence parser). LR parsers can handle a larger range of languages and grammars than precedence parsers or top-down LL parsing. This is because the LR parser waits until it has seen an entire instance of some grammar pattern before committing to what it has found. An LL parser has to decide or guess what it is seeing much sooner, when it has only seen the leftmost input symbol of that pattern. LR is also better at error reporting. It detects syntax errors as early in the input stream as possible.","alt_names":["LR(k)","LR(0) parser","- LR grammar :","- LR parser :","- LR(0) parser :","-> Read the article about 'LR parser'","...mehr auf Wikipedia über LR-Parser","...more on Wikipedia about LR parser","//en.wikipedia.org/wiki/LR_parser(p","1 Architecture of LR Parsers","1 Architecture of LR parsers","1 LR 剖析器的结构","1.1 General case","1.1 The Action and Goto Table","1.1 剖析算法","1.2 Concrete example","1.2 The Parsing Algorithm","1.2 范例","1.2.1 Action and goto tables","1.2.1 动作表与状态转移表","1.2.2 Parsing procedure","1.2.2 剖析过程","1.2.3 Walkthrough","1.2.3 范例说明","1.3 An Example","2 Constructing LR(0) parsing tables","2 建构LR(0) 剖析表","2.1 Items","2.1 LR(0) 项目（Items）","2.2 Item sets","2.2 项目集合","2.3 Closure of item sets","2.3 Extension of Item Set by expansion of","2.3 项目集合的封闭集","2.4 Closure of item sets","2.4 The augmented grammar","2.4 扩充文法","2.5 Augmented grammar","2.5 Finding the reachable item sets and the","2.5 寻找可到达的集合与之间的转移","2.6 Constructing the action and goto table","2.6 建构动作表与状态转移表","2.6.1 A note about LR(0) versus","2.6.1 关于LR(0) 与SLR、LALR","2.7 Conflicts in the constructed tables","2.7 表格中的冲突","3 LR(0) 的例子","3 Table construction","3.1 Finding the reachable item sets and the","3.2 Constructing the action and goto tables","3.2.1 A note about LR(0) versus","3.3 Conflicts in the constructed tables","Analisador sintático LR","Analisador sintático LR – Wikipédia, a enciclopédia livre","Analizador sint?ctico LR - Wikipedia, la enciclopedia libre","Analizador sintáctico LR","Analizador sintáctico LR - Wikipedia, la enciclopedia libre","Analyse LR","Analyse LR - Wikip?dia","Analyse LR - Wikipédia","Another Wikipedia site.","Architecture of LR parsers","Conceptually, an LR Parser is","Constructing LR(0) parsing tables","Definición de Analizador sintáctico LR más completo","Figure 1 Architecture of a table based bottom","How to construct an LR parse table.","LALR(1), LR(0), SLR(1), and LR","LALR-parser","LR Grammars","LR Parser","LR Parser – Wikipedia","LR Parsers","LR Parsing","LR Wiki","LR category","LR gramar","LR grammar","LR grammar; it is used under the","LR grammars","LR parser","LR parser (Wikipedia)","LR parser - Wikipedia, the free encyclopedia","LR parser Wikipedia the free encyclopedia","LR parser Wikipedia the free encyclopedia - result","LR parser from Wikipedia","LR parser – Wikipedia, the free encyclopedia","LR parser; it is used under the","LR parsers","LR parseru","LR parsing","LR parsing algorithm","LR грамматики","LR 分析器","LR 剖析器- Wikipedia","LR 法","LR(0)","LR(0) Parser","LR(0) item","LR(0) parser; it is used under the","LR(0) parsers","LR(1) algorithm","LR(1) grammars","LR(???)","LR(X)","LR(k) Sprachen","LR(k) parseable","LR(k) parser","LR(k) parsers","LR(k)-Parsing","LR(k)-parseable","LR(n)","LR-","LR-Parser","LR-Parser ? Wikipedia","LR-Parser – Wikipedia","LR-parsers","LR-анализатор","LR-анализаторы","LR1","LR_grammar","LR_parser","LR_parser en la Wikipedia","LRの","LR剖析器","LR剖析器- 维基百科，自由的百科全书","LR法","LR法 - Wikipedia","LR法 - Wikipedia »","LR法-wikipedia","LR法とは？ (Wikipediaへのリンク)","LR的","LR解析","Left to right parser","Lr Parser","Parser LR","Parser LR - Wikipedia","Parser LR – Wikipedia, wolna encyklopedia","Table construction","Wikiepedia article on LR parsers.","Wikipedia - LR法","Wikipedia article Analisador sintático LR","Wikipedia article Analizador sintáctico LR","Wikipedia article LALR-parser","Wikipedia article LR parser","Wikipedia article LR parsing","Wikipedia article LR(0) parser","Wikipedia article on Analizador sintáctico LR","Wikipedia article on LR grammar","Wikipedia article on LR parser","Wikipedia article on LR(0) parser","Wikipedia article on Parser LR","Wikipedia crash course in parsing","Wikipedia entry for LR parser","Wikipedia entry on LR parsers","Wikipedia on LR parsers","Wikipedia's LR Parsing","Wikipedia's discussion of LR parsing","Wikipedia-Artikel LR Parser","Wikipedia-Artikel LR-Parser","Wikipedia-Seite zu 'LR-Parser'","Wikipedia: LR parser","Wikipediaで「LR法」を調べる","Wikipédia artigo Analisador sintático LR","analyse LR","analyses LR","artículo de Wikipedia LR parser","at http://en.wikipedia.org/wiki/LR_parser.","da:LALR-parser","de:LR-Parser","en.wikipedia.org/LR_parser","en.wikipedia.org/wiki/LR%280%29_parser","en.wikipedia.org/wiki/LR(0)_parser","en.wikipedia.org/wiki/LR_parser","en:LR_parser","es:Analizador sintáctico LR","es:LR parser","fr:Analyse LR","general informations about LR parser","grammaire LR(1)","http://ar.wikipedia.org/wiki/LR_Parser","http://bit.ly/hmrHfA","http://de.wikipedia.org/wiki/LR-Parser","http://en.wikipedia.org/wiki/LR% 5Fparser","http://en.wikipedia.org/wiki/LR%5Fparser","http://en.wikipedia.org/wiki/LR(0)_parser","http://en.wikipedia.org/wiki/LR_par...le_Construction","http://en.wikipedia.org/wiki/LR_pars...e_Construction","http://en.wikipedia.org/wiki/LR_parser","http://en.wikipedia.org/wiki/LR_parser#Table_Construction","http://en.wikipedia.org/wiki/LR_parser#The_Parsing_Algorithm","http://es.wikipedia.org/wiki/Analizador_sint%C3%A1ctico_LR","http://fr.wikipedia.org/wiki/Analyse_LR","http://fr.wikipedia.org/wiki/Analyse_LR.","http://it.wikipedia.org/wiki/Parser_LR","http://ja.wikipedia.org/wiki/LR%E6%B3","http://pl.wikipedia.org/wiki/Parser_LR","http://ru.wikipedia.org/wiki/LR-%D0%B0","http://zh.wikipedia.org/wiki/LR%E5%89","http://zh.wikipedia.org/wiki/LR_%E5%88","it:Parser LR","ja:LR法","lr(k)","parser LR","parsers that make use of such automata","parsing LR","pl:Parser LR","pt:Analisador sintático LR","real parser","ru.wikipedia.org/wiki/LR-анализатор","ru:LR parser","ru:LR-анализатор","s http://en.wikipedia.org/wiki/LR_parser","shit/reduce conflicts","wiki:LR parser","wikipedia: LR_parser","zh:LR 剖析器","zh:LR剖析器","Википедии статью LR parser","Википедии статью LR-анализатор","лево-рекурсивная (ЛР)","ウィキペディアの記事 LR法","維基百科的文章“ LR 分析器”","維基百科的文章“ LR 剖析器”","维基百科的文章“ LR 分析器”","维基百科的文章“ LR 剖析器”"],"name":"LR parser","categories":["All articles with unsourced statements","Articles with unsourced statements from June 2012","Parsing algorithms"],"tag_line":"In computer science, LR parsers are a type of bottom-up parsers that efficiently handle deterministic context-free languages in guaranteed linear time."}}
,{"_index":"throwtable","_type":"algorithm","_id":"perceptual-hashing","_score":0,"_source":{"description":"Perceptual hashing is the use of an algorithm that produces a snippet or fingerprint of various forms of multimedia. Perceptual hash functions are analogous if features are similar, whereas cryptographic rely on the avalanche effect of a small change in input value creating a drastic change in output value. Perceptual hash functions are widely used to protect against copyright infringement and digital forensics because of the ability to have a correlation between hashes so you can compare and map source data. For example, Wikipedia could maintain a database of text hashes of popular online books or articles for which the authors hold copyrights to, anytime a Wikipedia user uploads an online book or article that has a copyright, the hashes will be almost exactly the same and could be flagged as plagiarism. This same flagging system can be used for any multimedia or text file.","alt_names":[],"name":"Perceptual hashing","categories":["Algorithms and data structures stubs","All articles covered by WikiProject Wikify","All articles with too few wikilinks","All stub articles","Articles covered by WikiProject Wikify from November 2014","Articles with too few wikilinks from November 2014","Computer science stubs","Hashing"],"tag_line":"Perceptual hashing is the use of an algorithm that produces a snippet or fingerprint of various forms of multimedia."}}
,{"_index":"throwtable","_type":"algorithm","_id":"uuhash","_score":0,"_source":{"description":"UUHash is a hash algorithm employed by clients on the FastTrack network. It is employed for its ability to hash very large files in a very short period of time, even on older computers. However, this is achieved by only hashing a fraction of the file. This weakness makes it trivial to create a hash collision, allowing large sections to be completely altered without altering the checksum.\nThis method is used by Kazaa. The weakness of UUHash is exploited by anti-p2p agencies to corrupt downloads.","alt_names":["...mehr auf Wikipedia über UUHash","How it works for UUHash","Sig2Dat","UUHash","UUHash - Wikipedia, the free encyclopedia","UUHash Related Content:","UUhash","Wikipedia article ''UUHash''","Wikipedia article UUHash","Wikipedia entry for UUHash","Wikipedia-Artikel UUHash","http://de.wikipedia.org/wiki/UUHash","http://en.wikipedia.org/wiki/UUHash","read up on UUhash","sig2dat","uuhash","wikipedia article on UUHash","yago-res:UUHash"],"name":"UUHash","categories":["Search algorithms"],"tag_line":"UUHash is a hash algorithm employed by clients on the FastTrack network."}}
,{"_index":"throwtable","_type":"algorithm","_id":"lander–green-algorithm","_score":0,"_source":{"description":"The Lander–Green algorithm is an algorithm, due to Eric Lander and Philip Green for computing the likelihood of observed genotype data given a pedigree. It is appropriate for relatively small pedigrees and a large number of markers. It is used in the analysis of genetic linkage.","alt_names":[],"name":"Lander–Green algorithm","categories":["All stub articles","Genetic epidemiology","Genetic linkage analysis","Genetics stubs","Statistical algorithms","Statistical genetics","Statistics stubs"],"tag_line":"The Lander–Green algorithm is an algorithm, due to Eric Lander and Philip Green for computing the likelihood of observed genotype data given a pedigree."}}
,{"_index":"throwtable","_type":"algorithm","_id":"intelligent-water-drops-algorithm","_score":0,"_source":{"description":"Intelligent Water Drops algorithm, or the IWD algorithm, is a swarm-based nature-inspired optimization algorithm. This algorithm contains a few essential elements of natural water drops and actions and reactions that occur between river's bed and the water drops that flow within. The IWD algorithm may fall into the category of Swarm intelligence and Metaheuristic. Intrinsically, the IWD algorithm can be used for Combinatorial optimization. However, it may be adapted for continuous optimization too. The IWD was first introduced for the traveling salesman problem in 2007. Since then, multitude of researchers have focused on improving the algorithm for different problems.","alt_names":[],"name":"Intelligent Water Drops algorithm","categories":["Artificial intelligence","Collective intelligence","Optimization algorithms and methods","Pages with duplicate reference names","Pages with reference errors"],"tag_line":"Intelligent Water Drops algorithm, or the IWD algorithm, is a swarm-based nature-inspired optimization algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"generalized-iterative-scaling","_score":0,"_source":{"description":"In statistics, generalized iterative scaling (GIS) and improved iterative scaling (IIS) are two early algorithms used to fit log-linear models, notably multinomial logistic regression (MaxEnt) classifiers and extensions of it such as MaxEnt Markov models and conditional random fields. These algorithms have been largely surpassed by gradient-based methods such as L-BFGS and coordinate descent algorithms.","alt_names":[],"name":"Generalized iterative scaling","categories":["All stub articles","CS1 errors: missing author or editor","Log-linear models","Optimization algorithms and methods","Statistics stubs"],"tag_line":"In statistics, generalized iterative scaling (GIS) and improved iterative scaling (IIS) are two early algorithms used to fit log-linear models, notably multinomial logistic regression (MaxEnt) classifiers and extensions of it such as MaxEnt Markov models and conditional random fields."}}
,{"_index":"throwtable","_type":"algorithm","_id":"adversary-model","_score":0,"_source":{"description":"In computer science, an online algorithm measures its competitiveness against different adversary models. For deterministic algorithms, the adversary is the same as the adaptive offline adversary. For randomized online algorithms competitiveness can depend upon the adversary model used.","alt_names":[],"name":"Adversary model","categories":["Algorithms and data structures stubs","All stub articles","Analysis of algorithms","Computer science stubs","Online algorithms"],"tag_line":"In computer science, an online algorithm measures its competitiveness against different adversary models."}}
,{"_index":"throwtable","_type":"algorithm","_id":"backtracking","_score":0,"_source":{"description":"Backtracking is a general algorithm for finding all (or some) solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds candidates to the solutions, and abandons each partial candidate c (\"backtracks\") as soon as it determines that c cannot possibly be completed to a valid solution.\nThe classic textbook example of the use of backtracking is the eight queens puzzle, that asks for all arrangements of eight chess queens on a standard chessboard so that no queen attacks any other. In the common backtracking approach, the partial candidates are arrangements of k queens in the first k rows of the board, all in different rows and columns. Any partial solution that contains two mutually attacking queens can be abandoned.\nBacktracking can be applied only for problems which admit the concept of a \"partial candidate solution\" and a relatively quick test of whether it can possibly be completed to a valid solution. It is useless, for example, for locating a given value in an unordered table. When it is applicable, however, backtracking is often much faster than brute force enumeration of all complete candidates, since it can eliminate a large number of candidates with a single test.\nBacktracking is an important tool for solving constraint satisfaction problems, such as crosswords, verbal arithmetic, Sudoku, and many other puzzles. It is often the most convenient (if not the most efficient) technique for parsing, for the knapsack problem and other combinatorial optimization problems. It is also the basis of the so-called logic programming languages such as Icon, Planner and Prolog.\nBacktracking depends on user-given \"black box procedures\" that define the problem to be solved, the nature of the partial candidates, and how they are extended into complete candidates. It is therefore a metaheuristic rather than a specific algorithm – although, unlike many other meta-heuristics, it is guaranteed to find all solutions to a finite problem in a bounded amount of time.\nThe term \"backtrack\" was coined by American mathematician D. H. Lehmer in the 1950s. The pioneer string-processing language SNOBOL (1962) may have been the first to provide a built-in general backtracking facility.","alt_names":["marcha atrás","backtrack","backtracking algorithm","バックトラック","backtracked","backtracking","Backtracking","backtracks","(Backtrackin","- Backtracking :","-> Read more about Backtracking","...Wikipedia Backtracking","...Wikipedia Retour sur trace","...Wikipedia Vuelta Atrás","...mehr auf Wikipedia über Backtracking","...more on Wikipedia about Backtracking","3: Lexikon: Backtracking","Back in the search","BackTracking","Backtraces","Backtrack Programming","Backtracker","Backtracking (deutsche Wikipedia)","Backtracking (englische Wikipedia)","Backtracking - Wikipedia","Backtracking - Wikipedia, the free encyclopedia","Backtracking - Wikipedie","Backtracking ? Wikipedia","Backtracking Algorithm","Backtracking Algorithm.","Backtracking I","Backtracking Related Content:","Backtracking Search","Backtracking Search Algorithm","Backtracking Suche","Backtracking Wikipedia","Backtracking Wikipedia page","Backtracking Wikipedia the free encyclopedia","Backtracking Wikipedia the free encyclopedia - result","Backtracking Zoeken","Backtracking algorithm","Backtracking algorithm.","Backtracking algoritme","Backtracking at Wikipedia.","Backtracking from Wikipedia","Backtracking method","Backtracking na Wikipedia","Backtracking on Wikipedia","Backtracking pseudocode","Backtracking search","Backtracking sem backjumping","Backtracking wikipedia","Backtracking â€“ Wikipedia","Backtracking алгоритма.","Backtracking – Algorithmus","Backtracking – Wikipedia","Backtracking – Wikipédia, a enciclopédia livre","Backtracking-Algorithmus","Backtracking-Methode","Backtracking-Problem","Backtracking.","Backtracking; it is used under the","Backtrackings","Backtrackről","Backtraking documentation (from wikipedia)","Denselben Weg zurückverfolgen","Learn about Backtracking>>>","Lösungsstrategie Rekursion: Backtracking","Mal das hier lesen","Marcha atrás","Mehr zu Backtracking","Pesquisar backtracking na Wikipedia Portugal","Quay lui (khoa học máy tính) – Wikipedia tiếng","Read More backtracking wikipedia the free encyclopedia","Recursive BackTracking","Recursive Backtracking","Reference: Backtrack search","Retour sur trace","Retour sur trace - Wikipedia","Retour sur trace - Wikipédia","Screenshot http://de.wikipedia.org/wiki/Backtracking","Search for Backtracking on Wikipedia!","Search info on Backtracking at Wikipedia","Tùy ý","Vuelta Atr s Wikipedia la enciclopedia libre","Vuelta Atr s Wikipedia la enciclopedia libre - result","Vuelta Atr?s - Wikipedia, la enciclopedia libre","Vuelta Atras","Vuelta Atrás","Vuelta Atrás - Wikipedia","Vuelta Atrás - Wikipedia, la enciclopedia libre","Vuelta Atr谩s","Vuelta atrás","Web de wikipedia España","Wiki de Verdad","Wikimedia Foundation, Inc. (2009, February 12 th 2009","Wikipedia (Backtracking)","Wikipedia - Backtracking","Wikipedia : Backtracking","Wikipedia Vuelta Atrás","Wikipedia article Backtracking","Wikipedia article Backtracking search","Wikipedia article Vuelta Atrás","Wikipedia article about Backtracking","Wikipedia article on Backtracking","Wikipedia article on Vuelta Atrás","Wikipedia article on Vuelta atrás","Wikipedia article Пошук з вертанням","Wikipedia artikel Backtracking","Wikipedia entry for Backtracking","Wikipedia l'articolo Backtracking","Wikipedia-Artikel Backtrace","Wikipedia-Artikel Backtracking","Wikipedia-Seite zu 'Backtrace'","Wikipedia-Seite zu 'Backtracking'","Wikipedia: Backtracking","Wikipedia: Backtraking","Wikipediaで「バックトラック」を調べる","Wikipédia artigo Backtracking","Zacofanie","acktracking.","algoritma Backtracking.","algoritma backtrack","algoritmo Backtracking.","algoritmo backtracking","algoritmo de backtracking","algoritmo de backtracking.","algoritmo di backtracking","algoritmo di backtracking.","algoritmu Ústupek","algorytmu Backtracking","article Backtracking","artigo da Wikipédia Backtracking","artículo de Wikipedia Backtracking","artículo de Wikipedia Vuelta Atrás","artículo de Wikipedia Vuelta atrás","back tracking","backtrack algorithms","backtrack-free","backtrack.","backtrackable","backtrackar","backtracking Search","backtracking algorithm.","backtracking algorithms","backtracking algoritme","backtracking in Wikipedia suchen","backtracking search","backtracking search in Wikipedia","backtracking thing","backtracking wikipedia the free encyclopedia","backtracking,","backtracking-algorithmus","backtracking.","backtrackingu","backtraking","bektrekom","clever refinement","cs.wikipedia.org/wiki/Backtracking","cs:Backtracking","dar marcha atrás","de traçage","de.wikipedia.org/ wiki/Backtracking","de.wikipedia.org/wiki/Backtracking","de.wikipedia.org/wiki/Backtracking#Springerproblem","de:Backtracking","en.wikipedia.org/...Backtracking","en.wikipedia.org/wiki/Backtracking","en.wikipedia.org/wiki/Backtracking....","es.wikipedia.org/...Vuelta_Atr%C3%A1s","es.wikipedia.org/wiki/Vuelta_Atr%C3%A1s","es:Vuelta Atrás","es:Vuelta_Atrás","fa:عقبگرد (الگوریتم)","fa:پسگرد (الگوریتم)","fr:Retour sur trace","gå tilbage","he:גישוש נסוג","http://cs.wikipedia.org/wiki/Backtracking","http://de.wikipedia.org/wiki/Ba cktracking","http://de.wikipedia.org/wiki/Backtra...Sudoku-Problem","http://de.wikipedia.org/wiki/Backtrace","http://de.wikipedia.org/wiki/Backtrackin","http://de.wikipedia.org/wiki/Backtracking","http://de.wikipedia.org/wiki/Backtracking#L.C3","http://de.wikipedia.org/wiki/Backtracking?","http://en.wikipedia....ki/Backtracking","http://en.wikipedia.o\\ rg/wiki/Backtracking#cite_note","http://en.wikipedia.org/wiki/Backtracking","http://en.wikipedia.org/wiki/Backtracking#Pseudocode).","http://en.wikipedia.org/wiki/Backtracking#cite_note-0","http://en.wikipedia.org/wiki/Backtracking#cite_note-1","http://en.wikipedia.org/wiki/Backtracking#cite_note-2","http://en.wikipedia.org/wiki/Backtracking.","http://en.wikipedia.org/wiki/Backtracking\\","http://en.wikipedia.org/wiki/Backtracking_search","http://en.wikipedia.org/wiki/Backtrackin…","http://en.wikipedia.org/wiki/en:Backtracking","http://es.wikipedia.org/wiki/Backtracking","http://es.wikipedia.org/wiki/Backtrackin…","http://es.wikipedia.org/wiki/Vuelta_Atr%C3%A1s","http://es.wikipedia.org/wiki/Vuelta_Atr%…","http://es.wikipedia.org/wiki/Vuelta_Atrás","http://es.wikipedia.org/wiki/Vuelta_Atrás.","http://es.wikipedia.org/wiki/Vuelta_Atrá…","http://fr.wikipedia....ki/Backtracking","http://fr.wikipedia.org/wiki/Retour_sur_trace","http://it.wikipedia....ki/Backtracking","http://it.wikipedia.org/wiki/Backtracking","http://it.wikipedia.org/wiki/Backtrackin…","http://nl.wikipedia.org/wiki/Backtracking","http://pl.wikipedia.org/wiki/Algorytm_z_nawrotami","http://pl.wikipedia.org/wiki/Backtracking","http://pt.wikipedia.org/wiki/Backtracking","http://ru.wikipedia.org/wiki/Поиск_с_возвратом","http://vi.wikipedia.org/wiki/Quay_lu...A1y_t%C3","is backtrack","it:Backtracking","ja:バックトラッキング","kesako ici","ko:백트래킹","ko:퇴각검색","l'algorithme de retour arrière.","la estrategia de backtracking","logical backtracking","look into Backtracking","look into Backtracking.","man kann damit auch das Rucksackproblem lösen","metodei backtracking","mundur","nl:Backtracking","pl:Algorytm z nawrotami","pl:Backtracking","prohledávání s návratem","pt:Backtracking","quay lui","recursive backtracking","retour sur trace","ro:Backtracking","ru:Поиск с возвратом","start with some investigation","terugkrabbelen","thuật toán Backtracking.","tilbageskridt","todos os subconjuntos de um conjunto S","tp://de.wikipedia.org/wiki/Backtracking","tùy ý","uk:Пошук з вертанням","ustupování","vi:Quay lui (khoa học máy tính)","visszalép","vollständige Backtracking-Suche","wycofywania","wycofywania się","zh:回溯法","« backtracking »","Ústupek","ústupku","Поиск с возвратом","Пошук з вертанням","алгоритма отката","бэктрекингом","бэктрэкинг","возвратом","отслеживанию","отступает","перебор с возвратом","поиска с возвратом","גישוש נסוג","גישוש נסוג – ויקיפדיה","صفحة الWikipedia","पीछे हट","हट","ขั้น ตอน วิธี Backtracking.","“Backtracking - Wikipedia, the free encyclopedia”, en.wikipedia.org","“backtracking”","「バックトラック」についてWikipediaで調査","「バックトラック」をWikipediaで調べる","「バックトラック」をWikiで調べる","バックトラッキング","バックトラッキング - Wikipedia","バックトラッキング(Wikipedia)","バックトラック backtrack","バックトラックは","バックトラックは、","バックトラックを","バックトラックアルゴリズム","バックトラック探索","倒退","回溯","回溯搜索","回溯法","回溯法- 维基百科，自由的百科全书","回溯算法","回溯追蹤演算法","當回溯從缺點时","的回溯","維基百科的文章“ 回溯法”","维基百科的文章“ 回溯法”","되돌아 오는것","되돌아 오는것 알고리즘을","되돌아 오는것은","백트래킹","백트래킹 탐색","백트랙킹","위키 피 디아 문서 되추적 기법","위키 피 디아 문서 백트래킹","퇴각검색","，回溯","ﾊﾞｯｸﾄﾗｯｷﾝｸﾞ-wikipedia","ﾊﾞｯｸﾄﾗｯｸ-wikipedia"],"name":"Backtracking","categories":["All articles with unsourced statements","Articles with unsourced statements from January 2011","Operations research","Pages with URL errors","Pattern matching","Search algorithms"],"tag_line":"Backtracking is a general algorithm for finding all (or some) solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds candidates to the solutions, and abandons each partial candidate c (\"backtracks\") as soon as it determines that c cannot possibly be completed to a valid solution."}}
,{"_index":"throwtable","_type":"algorithm","_id":"phonetic-algorithm","_score":0,"_source":{"description":"A phonetic algorithm is an algorithm for indexing of words by their pronunciation. Most phonetic algorithms were developed for use with the English language; consequently, applying the rules to words in other languages might not give a meaningful result.\nThey are necessarily complex algorithms with many rules and exceptions, because English spelling and pronunciation is complicated by historical changes in pronunciation and words borrowed from many languages.\nAmong the best-known phonetic algorithms are:\nSoundex, which was developed to encode surnames for use in censuses. Soundex codes are four-character strings composed of a single letter followed by three numbers.\nDaitch–Mokotoff Soundex, which is a refinement of Soundex designed to better match surnames of Slavic and Germanic origin. Daitch–Mokotoff Soundex codes are strings composed of six numeric digits.\nKölner Phonetik: This is similar to Soundex, but more suitable for German words.\nMetaphone, Double Metaphone, and Metaphone 3 which are suitable for use with most English words, not just names. Metaphone algorithms are the basis for many popular spell checkers.\nNew York State Identification and Intelligence System (NYSIIS), which maps similar phonemes to the same letter. The result is a string that can be pronounced by the reader without decoding.\nMatch Rating Approach developed by Western Airlines in 1977 - this algorithm has an encoding and range comparison technique.\nCaverphone, created to assist in data matching between late 19th century and early 20th century electoral rolls, optimized for accents present in parts of New Zealand.","alt_names":["phonetic algorithms","phonetic algorithm","-> Read the article about 'Phonetic algorithm'","/a> Erstellt: 31.01.2008 15:10:50 Geändert","?Kölner Phonetic?","Algorithme phonétique","Algorithme phonétique - Wikipédia","Algorithmes phonétiques","Algoritma fonetik","Klner Phonetik ? Wikipedia","Koelner Phonetik","Kí¶lner Phonetik","Kölner Phonetic (Kölner Verfahren)","Kölner Phonetik","Kölner Phonetik ? Wikipedia","Kölner Phonetik – Wikipedia, die freie Enzyklopädie","Kölner Verfahren","Kölner_Phonetik","Köwner Phonetik","Phoentic Matching (Wikipedia)","Phoic algorithm Wikipedia the free encyclopedia.","Phonetic Algorithm","Phonetic Algorithms","Phonetic algorithm","Phonetic algorithm - Wikipedia :: The free encyclopedia","Phonetic algorithm - Wikipedia, the free encyclopedia","Phonetic algorithm - Wikipedia, the free encyclopedia - Mozilla","Phonetic algorithm -...","Phonetic algorithms","Phonetic_algorithm","Wikipedia (de): Kölner Phonetik ? Buchstabencodes","Wikipedia (de): Kölner Phonetik – Buchstabencodes","Wikipedia article Phonetic algorithm","Wikipedia article on Phonetic algorithm","Wikipedia article ขั้นตอนวิธีเชิงสัทลักษณ์","Wikipedia entry for Phonetic algorithm","Wikipedia sur Algorithme phonétique","Wikipedia-Artikel Kölner Phonetik","Wikipedia-Artikel Kölner Verfahren","Wikipedia-Seite zu 'Kölner Phonetik'","algorithme phonétique","algorithmes phonétiques","algoritm fonetik","algoritma fonetik","algoritmo de fonética","algoritmo di fonetica","algoritmo fonetico","algoritmo fonético","d'autres algorithmes phonétiques","de.wikipedia.org/...K%C3%B6lner_Phonetik","en.wikipedia.org/wiki/Phonetic_algorithm","find more info on those here","he:אלגוריתם פונטי","http://de.wikipedia.org/wiki/K%C3%B6lner_Phon","http://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik","http://de.wikipedia.org/wiki/K%C3%B6lner_Verfahren","http://de.wikipedia.org/wiki/Kölner_...k#Buchstabencodes","http://de.wikipedia.org/wiki/Kölner_Phonetik","http://de.wikipedia.org/wiki/Kölner_Phonetik>","http://de.wikipedia.org/wiki/Kölner_Verfahren","http://en.wikipedia.org/wiki/Phonetic algorithm","http://en.wikipedia.org/wiki/Phonetic_algorit...","http://en.wikipedia.org/wiki/Phonetic_algorithm","http://fr.wikipedia.org/wiki/Algorithme_phon%C3%A9tique","kölner Phonetik","kölner phonetik","other phonetic algorithms on wikipedia","phonetic algorithm,","phonetischen Algorithmus","phonetischer Algorithmen","phonetischer Algorithmus","th:ขั้นตอนวิธีเชิงสัทลักษณ์","thuật toán ngữ âm","ttp://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik","yago-res:Phonetic algorithm","фонетический алгоритм","фонетическое алгоритм","фонетической Алгоритм","אלגוריתם פונטי","אלגוריתם פונטי – ויקיפדיה","ויקיפדיה - 'אלגוריתם פונטי'","กลไก การ ออกเสียง","ขั้น ตอน วิธี การ ออกเสียง","ขั้นตอนวิธีเชิงสัทลักษณ์","วิธีการออกเสียง","“Kölner Phonetic”","アルゴリズムを、","アルゴリズムを名前","拼音算法","維基百科的文章“ 语音算法”","维基百科的文章“ 语音算法”","語音算法","语音算法","音声アルゴリズムの","음성 알고리즘","음성 알고리즘과"],"name":"Phonetic algorithm","categories":["Algorithms and data structures stubs","All articles needing additional references","All stub articles","Articles needing additional references from August 2009","Computer science stubs","Phonetic algorithms","Phonetics stubs","Phonology"],"tag_line":"A phonetic algorithm is an algorithm for indexing of words by their pronunciation."}}
,{"_index":"throwtable","_type":"algorithm","_id":"adaptive-projected-subgradient-method","_score":0,"_source":{"description":"The adaptive projected subgradient method (APSM) is an algorithm, the goal of which is to minimize iteratively a sequence of cost functions.\nThis algorithmic \"tool\" is general and has been used in several tasks, such as online/adaptive parameter estimation, online classification,  and adaptive distributed learning. The algorithm can be used in both linear and non-linear scenarios (using kernels).\n^ Yamada, I.; Ogura, N. (2003). \"Adaptive projected subgradient method and its applications to set theoretic adaptive filtering\". The Thirty-seventh Asilomar Conference on Signals, Systems & Computers, 2003. p. 600. doi:10.1109/ACSSC.2003.1291982. ISBN 0-7803-8104-1. \n^ Yamada, I.; Ogura, N. (2005). \"Adaptive Projected Subgradient Method for Asymptotic Minimization of Sequence of Nonnegative Convex Functions\". Numerical Functional Analysis and Optimization 25 (7–8): 593. doi:10.1081/NFA-200045806. \n^ Slavakis, Konstantinos; Yamada, Isao (5 August 2011). \"The adaptive projected subgradient method constrained by families of quasi-nonexpansive mappings and its application to online learning\". Ithaca, New York: Cornell University.\n^ Slavakis, Konstantinos, Sergios Theodoridis, and Isao Yamada. \"Online kernel-based classification using adaptive projection algorithms.\" Signal Processing, IEEE Transactions on 56.7 (2008): 2781-2796.\n^ OĞUZ, ÖZKAN. PERFORMANCE OF A NON-LINEAR ADAPTIVE BEAMFORMER ALGORITHM FOR SIGNAL-OF-INTEREST EXTRACTION. Diss. MIDDLE EAST TECHNICAL UNIVERSITY, 2015.\n^ Chouvardas, Symeon, Konstantinos Slavakis, and Sergios Theodoridis. \"Adaptive robust distributed learning in diffusion sensor networks.\" Signal Processing, IEEE Transactions on 59.10 (2011): 4692-4707.\n^ Slavakis, K.; Bouboulis, P.; Theodoridis, S. (2012-02-01). \"Adaptive Multiregression in Reproducing Kernel Hilbert Spaces: The Multiaccess MIMO Channel Case\". IEEE Transactions on Neural Networks and Learning Systems 23 (2): 260–276. doi:10.1109/TNNLS.2011.2178321. ISSN 2162-237X. \n^ Bouboulis, P.; Slavakis, K.; Theodoridis, S. (2012-03-01). \"Adaptive Learning in Complex Reproducing Kernel Hilbert Spaces Employing Wirtinger's Subgradients\". IEEE Transactions on Neural Networks and Learning Systems 23 (3): 425–438. doi:10.1109/TNNLS.2011.2179810. ISSN 2162-237X. \n^ Theodoridis, Sergios (2013). Academic Press Library in Signal Processing. CHAPTER 17 Online Learning in Reproducing Kernel Hilbert Spaces- Konstantinos Slavakis, Pantelis Bouboulis and Sergios Theodoridis: ACADEMIC PRESS. ISBN 978-0-12-397226-2. \n^ \"Source code for Kernel APSM\".","alt_names":[],"name":"Adaptive projected subgradient method","categories":["Algorithms and data structures stubs","All orphaned articles","All stub articles","Applied mathematics stubs","Computer science stubs","Estimation theory","Gradient methods","Machine learning","Orphaned articles from June 2013","Statistics stubs"],"tag_line":"The adaptive projected subgradient method (APSM) is an algorithm, the goal of which is to minimize iteratively a sequence of cost functions."}}
,{"_index":"throwtable","_type":"algorithm","_id":"very-large-scale-neighborhood-search","_score":0,"_source":{"description":"In mathematical optimization, Neighborhood Search is a technique that tries to find good or near-optimal solutions to a mathematical optimisation problem by repeatedly trying to improve the current solution by looking for a better solution which is in the neighbourhood of the current solution. In that sense, the neighborhood of the current solution includes a possibly large number of solutions which are near to the current solution. Obviously, there is a degree of looseness in that definition in that the neighborhood might include just those solutions that require a single change from the current solution, or it might include the larger set of solutions that differ in two or more values from the current solution. A very large-scale neighborhood search is a local search algorithm which makes use of a neighborhood definition, which is large and possibly exponentially sized.\nThe resulting algorithms are often far superior to algorithms using small neighborhoods because the local improvements are larger. If the neighbourhood searched is limited to just one or a very small number of changes from the current solution, then it is often very difficult to escape from local minima and additional meta-heuristic techniques may need to be used such as Simulated Annealing or Tabu search to allow the search process to escape from a local minimum. In large neighborhood search techniques, the possible changes from one solution to its neighbor may allow tens or hundreds of values to change, and this means that the size of the neighborhood may itself be sufficient to allow the search process to avoid or escape local minima. As a result, it is often unnecessary to introduce additional meta-heuristic techniques.","alt_names":["Recherche locale à grand voisinage","Very Large-Scale Neighborhood Search","Very large-scale neighborhood search","Very large-scale neighborhood search - Wikipedia, the free","Wikipedia article Very large-scale neighborhood search","Wikipedia article on Very large-scale neighborhood search","http://en.wikipedia.org/wiki/Very_large-scale_neighborhood_search","very large-scale neighborhood search"],"name":"Very large-scale neighborhood search","categories":["All Wikipedia articles needing context","All articles covered by WikiProject Wikify","All articles with too few wikilinks","All pages needing cleanup","Articles covered by WikiProject Wikify from October 2012","Articles with too few wikilinks from October 2012","Optimization algorithms and methods","Wikipedia articles needing context from February 2009","Wikipedia introduction cleanup from February 2009"],"tag_line":"In mathematical optimization, Neighborhood Search is a technique that tries to find good or near-optimal solutions to a mathematical optimisation problem by repeatedly trying to improve the current solution by looking for a better solution which is in the neighbourhood of the current solution."}}
,{"_index":"throwtable","_type":"algorithm","_id":"aho–corasick-algorithm","_score":0,"_source":{"description":"In computer science, the Aho–Corasick algorithm is a string searching algorithm invented by Alfred V. Aho and Margaret J. Corasick. It is a kind of dictionary-matching algorithm that locates elements of a finite set of strings (the \"dictionary\") within an input text. It matches all patterns simultaneously. The complexity of the algorithm is linear in the length of the patterns plus the length of the searched text plus the number of output matches. Note that because all matches are found, there can be a quadratic number of matches if every substring matches (e.g. dictionary = a, aa, aaa, aaaa and input string is aaaa).\nInformally, the algorithm constructs a finite state machine that resembles a trie with additional links between the various internal nodes. These extra internal links allow fast transitions between failed pattern matches (e.g. a search for cat in a trie that does not contain cat, but contains cart, and thus would fail at the node prefixed by ca), to other branches of the trie that share a common prefix (e.g., in the previous case, a branch for attribute might be the best lateral transition). This allows the automaton to transition between pattern matches without the need for backtracking.\nWhen the pattern dictionary is known in advance (e.g. a computer virus database), the construction of the automaton can be performed once off-line and the compiled automaton stored for later use. In this case, its run time is linear in the length of the input plus the number of matched entries.\nThe Aho–Corasick string matching algorithm formed the basis of the original Unix command fgrep.\n\n","alt_names":[],"name":"Aho–Corasick algorithm","categories":["All articles lacking in-text citations","Articles lacking in-text citations from February 2013","String matching algorithms"],"tag_line":"In computer science, the Aho–Corasick algorithm is a string searching algorithm invented by Alfred V. Aho and Margaret J. Corasick."}}
,{"_index":"throwtable","_type":"algorithm","_id":"match-rating-approach","_score":0,"_source":{"description":"The match rating approach (MRA) is a phonetic algorithm developed by Western Airlines in 1977 for the indexation and comparison of homophonous names.\nThe algorithm itself has a simple set of encoding rules but a more lengthy set of comparison rules. The main mechanism being the similarity comparison which calculates the number of unmatched characters by comparing the strings from left to right and then from right to left and removing identical characters. This value is subtracted from 6 and then compared to a minimum threshold. The minimum threshold is defined by table A and is dependent upon the length of the strings.\nThe encoded name is known (perhaps incorrectly) as a personal numeric identifier (PNI). The PNI codex can never contain more than 6 alpha only characters.\nMatch rating approach performs well with names containing the letter \"y\" unlike the original flavour of the NYSIIS algorithm. For example, the surnames \"Smith\" and \"Smyth\" are successfully matched.\nMRA does not perform well with encoded names that differ in length by more than 2.","alt_names":[],"name":"Match rating approach","categories":["All Wikipedia articles needing context","All pages needing cleanup","Phonetic algorithms","Wikipedia articles needing context from October 2009","Wikipedia introduction cleanup from October 2009"],"tag_line":"The match rating approach (MRA) is a phonetic algorithm developed by Western Airlines in 1977 for the indexation and comparison of homophonous names."}}
,{"_index":"throwtable","_type":"algorithm","_id":"caverphone","_score":0,"_source":{"description":"The Caverphone phonetic matching algorithm was created by David Hood in the Caversham Project at the University of Otago in New Zealand in 2002, revised in 2004. It was created to assist in data matching between late 19th century and early 20th century electoral rolls, where the name only needed to be in a \"commonly recognisable form\". The algorithm was intended to apply to those names that could not easily be matched between electoral rolls, after the exact matches were removed from the pool of potential matches. The algorithm is optimised for accents present in the study area (southern part of the city of Dunedin, New Zealand).","alt_names":["Caverphe","Caverphone","Caverphone - Wikipedia, the free encyclopedia","Caverphone - Wikipedia,...","Wikipedia - Caverphone","Wikipedia article Caverphone","Wikipedia entry for Caverphone","caverphone","http://en.wikipedia.org/wiki/Caverphone","yago-res:Caverphone"],"name":"Caverphone","categories":["All Wikipedia articles needing context","All articles with topics of unclear notability","All pages needing cleanup","Articles with topics of unclear notability from September 2008","Phonetic algorithms","Wikipedia articles needing context from October 2009","Wikipedia introduction cleanup from October 2009"],"tag_line":"The Caverphone phonetic matching algorithm was created by David Hood in the Caversham Project at the University of Otago in New Zealand in 2002, revised in 2004."}}
,{"_index":"throwtable","_type":"algorithm","_id":"limited-memory-bfgs","_score":0,"_source":{"description":"Limited-memory BFGS (L-BFGS or LM-BFGS) is an optimization algorithm in the family of quasi-Newton methods that approximates the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm using a limited amount of computer memory. It is a popular algorithm for parameter estimation in machine learning.\nLike the original BFGS, L-BFGS uses an estimation to the inverse Hessian matrix to steer its search through variable space, but where BFGS stores a dense n×n approximation to the inverse Hessian (n being the number of variables in the problem), L-BFGS stores only a few vectors that represent the approximation implicitly. Due to its resulting linear memory requirement, the L-BFGS method is particularly well suited for optimization problems with a large number of variables. Instead of the inverse Hessian Hk, L-BFGS maintains a history of the past m updates of the position x and gradient ∇f(x), where generally the history size m can be small (often m<10). These updates are used to implicitly do operations requiring the Hk-vector product.","alt_names":[],"name":"Limited-memory BFGS","categories":["Optimization algorithms and methods"],"tag_line":"Limited-memory BFGS (L-BFGS or LM-BFGS) is an optimization algorithm in the family of quasi-Newton methods that approximates the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm using a limited amount of computer memory."}}
,{"_index":"throwtable","_type":"algorithm","_id":"grover's-algorithm","_score":0,"_source":{"description":"Grover's algorithm is a quantum algorithm that finds with high probability the unique input to a black box function that produces a particular output value, using just O(N1/2) evaluations of the function, where N is the size of the function's domain.\nThe analogous problem in classical computation cannot be solved in fewer than O(N) evaluations (because, in the worst case, the Nth member of the domain might be the correct member). At roughly the same time that Grover published his algorithm, Bennett, Bernstein, Brassard, and Vazirani published a proof that no quantum solution to the problem can evaluate the function fewer than O(N1/2) times, so Grover's algorithm is asymptotically optimal.\nUnlike other quantum algorithms, which may provide exponential speedup over their classical counterparts, Grover's algorithm provides only a quadratic speedup. However, even quadratic speedup is considerable when N is large. Grover's algorithm could brute force a 128-bit symmetric cryptographic key in roughly 264 iterations, or a 256-bit key in roughly 2128 iterations. As a result, it is sometimes suggested that symmetric key lengths be doubled to protect against future quantum attacks.\nLike many quantum algorithms, Grover's algorithm is probabilistic in the sense that it gives the correct answer with a probability of less than 1. Though there is technically no upper bound on the number of repetitions that might be needed before the correct answer is obtained, the expected number of repetitions is a constant factor that does not grow with N.\nGrover's original paper described the algorithm as a database search algorithm, and this description is still common. The database in this analogy is a table of all of the function's outputs, indexed by the corresponding input.","alt_names":["Гровера","Grover-Algorithmus","&langle; ω | s &rangle; = &langle; s | ω &rangle","- Grover's algorithm :","-> Read the article about 'Grover's algorithm'","...more on Wikipedia about Grover's algorithm","13420954dfe20fdf5c5ba4fc0e33b ...","7dd1865929e83006e75ab811d3f3aa ...","826acbc8a05add87f17d9a2787c27 ...","9eaa37d52e1a6de675842d2ee88a52 ...","Algorithm steps","Algorithme de Grover","Algorithme de Grover - Wikipédia","Algoritmo de Grover","Algoritmo de Grover - Wikipedia, la enciclopedia libre","Bell proof of quantum superiority for database seach","Der folgende Ablauf des Algorithmus bezieht sich auf","Grover Algorithmus","Grover Algorithmus – Wikipedia","Grover algorithm","Grover database search algorithm","Grover je algoritmus","Grover s algorithm - Wikipedia, the free encyclopedia","Grover s algorithm Wikipedia the free encyclopedia","Grover search algorithm","Grover%27s_algorithm","Grover's Algorithm","Grover's Algorithmus","Grover's Quantum Algorithm for NP Search","Grover's algorithm","Grover's algorithm - Wikipedia :: The free encyclopedia","Grover's algorithm - Wikipedia, the free ...","Grover's algorithm - Wikipedia, the free encyclopedia","Grover's algorithm,","Grover's algorithm.","Grover's algorithm?","Grover's algorithms","Grover's algoritme","Grover's kwantumzoekalgoritme","Grover's quantum search algorithm","Grover's search","Grover's search algorithm","Grover's search algorithm better than classical computers.","Grover's searching algorithms","Grover's_algorithm","Grover-Algorithmus Wikipedia","Grover-Algorithmus â€“ Wikipedia","Grover-Algorithmus – Wikipedia","Grover-algorithm","Grover-algoritmus","Grover`s algorithm","Groverio algoritmas","Groverio algoritme","Groverit","Groverovog","Grovers","Grovers algorithm","Grovers algorithm Wikipedia the free encyclopedia","Grovers algoritm","Grovers zoekalgoritme","Learn about Grover's algorithm>>>","Lov Grover's Quantum Search Algorithm","OR function","QC search algorithm","Screenshot http://de.wikipedia.org/wiki/Grover-Algorithmus","Search an unsorted database with N entries in","Suchen in unsortierten Listen","The first iteration","What are applications of Grover algorithm","What are applications of Quadratic speedup theorem","Wikipedia Algoritmo de Grover","Wikipedia article ''Grover's algorithm''","Wikipedia article Algorithme de Grover","Wikipedia article Algorytm Grovera","Wikipedia article Grover algorithm","Wikipedia article Grover's algorithm","Wikipedia article Grover-algoritmus","Wikipedia article Grovers algorithm","Wikipedia article on Algoritmo de Grover","Wikipedia article on Grover's algorithm","Wikipedia-Artikel Grover-Algorithmus","Wikipedia-Seite zu 'Grover-Algorithmus'","[Grover, 1996]","a quadratic speedup for brute force search","abrindo apenas 1000 gavetas em média","algorithm for searching an unsorted database with N","algorithm ของการ sort เพื่อใช้ใน quantum computer เท่านั้น","algorithme de Grover","algoritmo de Grover","algoritmo de Grover.","algoritmo de búsqueda cúantica de Grover","algoritmo di Grover","algorytm Grovera","algorítmo de Grover","artículo de Wikipedia Algoritmo de Grover","can do this","database lookups","en.wikipedia.org/wiki/Grover%27s_algorithm","en.wikipedia.org/wiki/Grover's_algorithm","es.wikipedia.org/wiki/Algoritmo_de_Grover","fr.wikipedia.org/wiki/Algorithme_de_Grover","fr:Algorithme_de_Grover","grover s algorithm wikipedia the free encyclopedia","http://de.wikipedia.org/wiki/Grover-Algo","http://de.wikipedia.org/wiki/Grover-Algorithmus","http://de.wikipedia.org/wiki/Grover-Algo…","http://en.wikipedia.org/wiki/Grover %27s_algorithm","http://en.wikipedia.org/wiki/Grover%27s_algor...","http://en.wikipedia.org/wiki/Grover%27s_algorithm","http://en.wikipedia.org/wiki/Grover%27s_algorithm#Optimality","http://en.wikipedia.org/wiki/Grover%27s_algorithm...","http://en.wikipedia.org/wiki/Grover's algorithm","http://en.wikipedia.org/wiki/Grover's_algorithm","http://en.wikipedia.org/wiki/Grover_algorithm","http://en.wikipedia.org/wiki/Grovers_algorithm","http://es.wikipedia.org/wiki/Algoritmo_de_Grover","http://es.wikipedia.org/wiki/Algoritmo_de_Grover#N.C3","http://goo.gl/QbXe","http://pl.wikipedia.org/wiki/Algorytm_Grovera","http://ru.wikipedia.org/wiki/Алгоритм_Гровера","http://tinyurl.com/kpj6c2","http://www.wikipedia.org/wiki/Grover's_algorithm","hľadanie ihly v kope sena","kwantowym algorytmem Grovera","l'algorithme de Grover","l'algoritmo di Grover","quadratic speed boost","quantum database search algorithm","quantum search","quantum search algorithms","search 316 (the square root of 100000) keys","searching databases","searching through unsorted databases","secara ilmiah memang telah terbukti","sqrt(N)","zoekalgoritme van Grover","Алгоритм Гровера","Квантовый Алгоритм Гровера","алгоритм Гровера","квантов алгоритъм за търсене в несортиран масив","אלגוריתם גרובר","אלגוריתם גרובר – ויקיפדיה","ויקיפדיה - 'אלגוריתם גרובר'","グローバーのアルゴリズム","グローバーのアルゴリズム - Wikipedia","ｸﾞﾛｰﾊﾞｰのｱﾙｺﾞﾘｽﾞﾑ-wikipedia"],"name":"Grover's algorithm","categories":["Quantum algorithms","Search algorithms"],"tag_line":"Grover's algorithm is a quantum algorithm that finds with high probability the unique input to a black box function that produces a particular output value, using just O(N1/2) evaluations of the function, where N is the size of the function's domain."}}
,{"_index":"throwtable","_type":"algorithm","_id":"ziggurat-algorithm","_score":0,"_source":{"description":"The ziggurat algorithm is an algorithm for pseudo-random number sampling. Belonging to the class of rejection sampling algorithms, it relies on an underlying source of uniformly-distributed random numbers, typically from a pseudo-random number generator, as well as precomputed tables. The algorithm is used to generate values from a monotone decreasing probability distribution. It can also be applied to symmetric unimodal distributions, such as the normal distribution, by choosing a value from one half of the distribution and then randomly choosing which half the value is considered to have been drawn from. It was developed by George Marsaglia and others in the 1960s.\nA typical value produced by the algorithm only requires the generation of one random floating-point value and one random table index, followed by one table lookup, one multiply operation and one comparison. Sometimes (2.5% of the time, in the case of a normal or exponential distribution when using typical table sizes) more computations are required. Nevertheless, the algorithm is computationally much faster than the two most commonly used methods of generating normally distributed random numbers, the Marsaglia polar method and the Box–Muller transform, which require at least one logarithm and one square root calculation for each pair of generated values. However, since the ziggurat algorithm is more complex to implement it is best used when large quantities of random numbers are required.\nThe term ziggurat algorithm dates from Marsaglia's paper with Wai Wan Tsang in 2000; it is so named because it is conceptually based on covering the probability distribution with rectangular segments stacked in decreasing order of size, resulting in a figure that resembles a ziggurat.","alt_names":["- Ziggurat algorithm :","Algorithme de Ziggurat","L'algorithme ziggourat","L'algoritmo di Ziggurat","Marsaglia & Tsang Ziggurat algorithm","Méthode Ziggourat","Random (numbers)","Wikipedia article Ziggurat algorithm","Wikipedia article on Ziggurat algorithm","Wikipedia entry for Ziggurat algorithm","Wikipedia, Ziggurat algorithm","Wikipedia: Ziggurat algorithm","Ziggura","Ziggurat Algorithmus","Ziggurat algorithm","Ziggurat algorithm - Wikipedia :: The free encyclopedia","Ziggurat algorithm - Wikipedia, the free encycl...","Ziggurat algorithm - Wikipedia, the free encyclopedia","Ziggurat algorithm 이 2000년에 논문","Ziggurat algorithm.","Ziggurat algorithm; it is used under the","Ziggurat algoritma","Ziggurat algoritme","Ziggurat-Algorihtmus","Ziggurat-Algorithmus","Ziggurat_algorithm","Ziggurat法","Ziggurat的算法","Zigorat Algorithm","Zikkurat Algorithmus","algoritmo Ziggurat","algoritmo de Zigurat","algoritmo ziggurat","en.wikipedia.org/wiki/Ziggurat_algorithm","from the precomputed lookup tables it uses to","http://en.wikipedia.org/wiki/Ziggurat_al","http://en.wikipedia.org/wiki/Ziggurat_algorithm","http://en.wikipedia.org/wiki/Ziggurat_algorithm fo","http://fr.wikipedia.org/wiki/M%C3%A9thode_Ziggourat","method for generating a guassian random","thuật toán Ziggurat","ziggurat algorithm","Алгоритм Зиккурат","אלגוריתם Zigguart","שיטת זיגורט","שיטת זיגורט – ויקיפדיה","ขั้น ตอน วิธี Ziggurat","ジッグラトのアルゴリズム","通灵塔算法","지구 라트 알고리즘은"],"name":"Ziggurat algorithm","categories":["All articles with unsourced statements","Articles with unsourced statements from September 2011","Non-uniform random numbers","Pages using citations with format and no URL","Pseudorandom number generators","Statistical algorithms"],"tag_line":"The ziggurat algorithm is an algorithm for pseudo-random number sampling."}}
,{"_index":"throwtable","_type":"algorithm","_id":"quantum-algorithm","_score":0,"_source":{"description":"In quantum computing, a quantum algorithm is an algorithm which runs on a realistic model of quantum computation, the most commonly used model being the quantum circuit model of computation. A classical (or non-quantum) algorithm is a finite sequence of instructions, or a step-by-step procedure for solving a problem, where each step or instruction can be performed on a classical computer. Similarly, a quantum algorithm is a step-by-step procedure, where each of the steps can be performed on a quantum computer. Although all classical algorithms can also be performed on a quantum computer, the term quantum algorithm is usually used for those algorithms which seem inherently quantum, or use some essential feature of quantum computation such as quantum superposition or quantum entanglement.\nProblems which are undecidable using classical computers remain undecidable using quantum computers. What makes quantum algorithms interesting is that they might be able to solve some problems faster than classical algorithms.\nThe most well known algorithms are Shor's algorithm for factoring, and Grover's algorithm for searching an unstructured database or an unordered list. Shor's algorithms runs exponentially faster than the best known classical algorithm for factoring, the general number field sieve. Grover's algorithm runs quadratically faster than the best possible classical algorithm for the same task.\n\n","alt_names":["Quantum Algorithms","quantum algorithm","Quantum algorithms","quantum algorithms","- Quantum algorithm :","- Quantum algorithms :","-> Read the article about 'Quantum algorithm'","...Wikipedia Algoritmo quantistico","...Wikipedia Algorytm kwantowy","...more on Wikipedia about Quantum algorithm","99aa27ae1467ee7a44f37db24837b1 ...","Algoritmo cuántico","Algoritmo cuántico - Wikipedia, la enciclopedia libre","Algoritmo quantistico","Algorytm kwantowy","Algorytm kwantowy – Wikipedia, wolna encyklopedia","Kvanttialgoritmi","Quantum Algorithm","Quantum algorithm","Quantum algorithm - Wikipedia :: The free encyclopedia","Quantum algorithm - Wikipedia, the free encyclopedia","Quantum_algorithm","What is the overview of Quantum algorithm","Wikipedia article Algorytm kwantowy","Wikipedia article on Quantum algorithm","Wikipedia article on Quantum algorithms","Wikipedia entry for Quantum algorithm","algoritmi quantistici","algorytm kwantowy","algorytmu kwantowego","algorytmy kwantowe","and its relatives","en.wikipedia.org/wiki/Quantum_algorithm","es:Algoritmo cuántico","fi:Kvanttialgoritmi","http://en.wikipedia.org/wiki/Quantum_algorithm","http://en.wikipedia.org/wiki/Quantum_algorithm#Algorithms_based_on_the_quantum_Fourie","http://en.wikipedia.org/wiki/Quantum_algorithm#Algorithms_based_on_the_quantum_Fourier_transform","http://en.wikipedia.org/wiki/Quantum_algorithm#Quantum_Simulation","http://en.wikipedia.org/wiki/Quantum_algorithms","http://es.wikipedia.org/wiki/Algoritmo_cu%C3%A1ntico","http://it.wikipedia.org/wiki/Algoritmo_quantistico","http://pl.wikipedia.org/wiki/Algorytm_kwantowy","http://ru.wikipedia.org/wiki/Квантовый_алгоритм","it:Algoritmo quantistico","kwantowy algorytm","non-classical processing","pl:Algorytm kwantowy","quantum walk algorithms","ru:Квантовый алгоритм","simulation of quantum many-body systems","ta:குவாண்டம் படிமுறைத்தீர்வு","uantum algorithm","uantum algorithms us","very few have been successful","Κβαντικοί Αλγόριθμοι","Квантовый алгоритм","Квантовый алгоритм Википедия","квантовые алгоритмы","квантовый алгоритм","квантовых алгоритмов","الخوارزميات الكمومية"],"name":"Quantum algorithm","categories":["All articles with unsourced statements","Articles with unsourced statements from December 2014","Quantum algorithms","Quantum computing","Quantum information science","Theoretical computer science","Use dmy dates from September 2011"],"tag_line":"In quantum computing, a quantum algorithm is an algorithm which runs on a realistic model of quantum computation, the most commonly used model being the quantum circuit model of computation."}}
,{"_index":"throwtable","_type":"algorithm","_id":"quantum-fourier-transform","_score":0,"_source":{"description":"In quantum computing, the quantum Fourier transform is a linear transformation on quantum bits, and is the quantum analogue of the discrete Fourier transform. The quantum Fourier transform is a part of many quantum algorithms, notably Shor's algorithm for factoring and computing the discrete logarithm, the quantum phase estimation algorithm for estimating the eigenvalues of a unitary operator, and algorithms for the hidden subgroup problem.\nThe quantum Fourier transform can be performed efficiently on a quantum computer, with a particular decomposition into a product of simpler unitary matrices. Using a simple decomposition, the discrete Fourier transform on  amplitudes can be implemented as a quantum circuit consisting of only  Hadamard gates and controlled phase shift gates, where  is the number of qubits. This can be compared with the classical discrete Fourier transform, which takes  gates (where  is the number of bits), which is exponentially more than . However, the quantum Fourier transform acts on a quantum state, whereas the classical Fourier transform acts on a vector, so not every task that uses the classical Fourier transform can take advantage of this exponential speedup.\nThe best quantum Fourier transform algorithms known today require only  gates to achieve an efficient approximation.","alt_names":["&langle; ψ | &phiv; &rangle; = ∑ k &Element; &Zopf; / ( N","-> Read more about Quantum Fourier transform","...more on Wikipedia about Quantum Fourier transform","550px-Quantum_Fourier_ ...","600px-Quantum_Fourier_ ...","Kwantowa transformata Fouriera – Wikipedia, wolna encyklopedia","QFT??","Quanten-Fouriertransformation","Quanten-Fouriertransformation ? Wikipedia","Quanten-Fouriertransformation bei der wikipedia","Quanten-Fouriertransformation – Wikipedia","Quantenfouriertransformation (Wiki)","Quantum Fourier Transform","Quantum Fourier Transform on N Quibits","Quantum Fourier Transforms","Quantum Fourier transform","Quantum Fourier transform - Wikipedia, the free encyclopedia","Quantum Fourier transform - Wikipedia, the free encyclopedia ...","Quantum fourier transforms","Source Wikipedia.org Arcticle - Quantum Fourier transform","The 3 qubit quantum Fourier transform is the","What is Quantum fourier transforms's example?","What is the example of Quantum Fourier Transform","Wikipedia article Quantum Fourier transform","Wikipedia article on Quantum Fourier transform","Wikipedia-Artikel Quanten-Fouriertransformation","c4ac5ec4ad968bcaa24de93821a543 ...","edit Properties","en:quantum Fourier transform","http://de.wikipedia.org/wiki/Quanten-Fou","http://de.wikipedia.org/wiki/Quanten-Fouriertransformation","http://en.wikipedia.org/wiki/Quantum_Fou","http://en.wikipedia.org/wiki/Quantum_Fourier_transform","http://pl.wikipedia.org/wiki/Kwantowa_transformata_Fouriera","ide utama","idea principal","idea principale","idéia principal","kwantowej transformaty Fouriera","kwantową transformatę Fouriera","l'idée principale","never mind how","quantum Fourier transform","quantum fourier transform","quantum fourier transformatie","quanutm fourier transform","transformación Fourier cuántica","ý tưởng chính của","Основной идеей","התמרת פורייה קוונטית","התמרת פורייה קוונטית – ויקיפדיה","แนวคิด หลัก","主要なアイデア","主要思想","量子傅立葉變換- 维基百科，自由的百科全书","量子傅立葉轉換","量子傅立葉轉換- 维基百科，自由的百科","量子傅立葉轉換- 维基百科，自由的百科全书","量子快速傅立叶变换","주요 아이디어의"],"name":"Quantum Fourier transform","categories":["Quantum algorithms","Transforms"],"tag_line":"In quantum computing, the quantum Fourier transform is a linear transformation on quantum bits, and is the quantum analogue of the discrete Fourier transform."}}
,{"_index":"throwtable","_type":"algorithm","_id":"simon's-problem","_score":0,"_source":{"description":"In computational complexity theory and quantum computing, Simon's problem is a computational problem in the model of decision tree complexity or query complexity, conceived by Daniel Simon in 1994. Simon exhibited a quantum algorithm, usually called Simon's algorithm, that solves the problem exponentially faster than any (deterministic or probabilistic) classical algorithm.\nSimon's algorithm uses  queries to the black box, whereas the best classical probabilistic algorithm necessarily needs at least  queries. It is also known that Simon's algorithm is optimal in the sense that any quantum algorithm to solve this problem requires  queries. This problem yields an oracle separation between BPP and BQP, unlike the separation provided by the Deutsch-Jozsa algorithm, which separates P and EQP.\nAlthough the problem itself is of little practical value it is interesting because it provides an exponential speedup over any classical algorithm. Moreover, it was also the inspiration for Shor's algorithm. Both problems are special cases of the abelian hidden subgroup problem, which is now known to have efficient quantum algorithms.\n\n","alt_names":[],"name":"Simon's problem","categories":["All articles with unsourced statements","Articles with unsourced statements from May 2012","Quantum algorithms"],"tag_line":"In computational complexity theory and quantum computing, Simon's problem is a computational problem in the model of decision tree complexity or query complexity, conceived by Daniel Simon in 1994."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fino","_score":0,"_source":{"description":"In computer science, FINO (Sometimes seen as \"FISH\", for First In, Still Here) is a humorous scheduling algorithm. It is an acronym for \"First In Never Out\" as opposed to traditional \"first in first out\" (FIFO) and \"last in first out\" (LIFO) algorithms.\nFINO works by withholding all scheduled tasks permanently. No matter how many tasks are scheduled at any time, no task ever actually takes place. This makes FINO extremely simple to implement, but useless in practice. A stateful FINO queue can be used to implement a memory leak.\nA mention of FINO appears in the Signetics 25120 write-only memory joke datasheet.","alt_names":["- FINO :","...Wikipedia FINO","...more on Wikipedia about FINO","Definición de First in, never out más completo","FINO","FINO - Wikipedia, the free encyclopedia","FINO on Wikipedia","FINO; it is used under the","First In, Never Out","First in, never out","Wikipedia article FINO","Wikipedia article First in, never out","Wikipedia article on FINO","article FINO","artículo de Wikipedia FINO","es:FINO","http://en.wikipedia.org/wiki/FINO","http://es.wikipedia.org/wiki/FINO","http://es.wikipedia.org/wiki/First_in,_never_out","yago-res:FINO"],"name":"FINO","categories":["All stub articles","Computer humor","Computer science stubs","Scheduling algorithms"],"tag_line":"In computer science, FINO (Sometimes seen as \"FISH\", for First In, Still Here) is a humorous scheduling algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"featherstone's-algorithm","_score":0,"_source":{"description":"Featherstone's algorithm is a technique used for computing the effects of forces applied to a structure of joints and links (an \"open kinematic chain\") such as a skeleton used in ragdoll physics.\nThe Featherstone's algorithm uses a reduced coordinate representation. This is in contrast to the more popular Lagrange multiplier method, which uses maximal coordinates. Brian Mirtich's PhD Thesis has a very clear and detailed description of the algorithm. Baraff's paper \"Linear-time dynamics using Lagrange multipliers\" has a discussion and comparison of both algorithms.","alt_names":["Featherstone's algorithm","Source Wikipedia.org Arcticle - Featherstone's algorithm","Wikipedia article Featherstone's algorithm","featherstone algorithm","http://en.Liarpedia.org/wiki/Featherstone%27s_algorithm","http://en.wikipedia.org/wiki/Featherstone%27s_algorithm"],"name":"Featherstone's algorithm","categories":["Algorithms and data structures stubs","All stub articles","Computational physics","Computer physics engines","Computer science stubs","Mechanics"],"tag_line":"Featherstone's algorithm is a technique used for computing the effects of forces applied to a structure of joints and links (an \"open kinematic chain\") such as a skeleton used in ragdoll physics."}}
,{"_index":"throwtable","_type":"algorithm","_id":"i/o-scheduling","_score":0,"_source":{"description":"Input/output (I/O) scheduling is the method that computer operating systems use to decide in which order the block I/O operations will be submitted to storage volumes. I/O scheduling is sometimes called disk scheduling.\nI/O scheduling usually has to work with hard disk drives that have long access times for requests placed far away from the current position of the disk head (this operation is called a seek). To minimize the effect this has on system performance, most I/O schedulers implement a variant of the elevator algorithm that reorders the incoming randomly ordered requests so the associated data would be accessed with minimal arm/head movement.\nI/O schedulers can have many purposes depending on the goals; common purposes include the following:\nTo minimize time wasted by hard disk seeks\nTo prioritize a certain processes' I/O requests\nTo give a share of the disk bandwidth to each running process\nTo guarantee that certain requests will be issued before a particular deadline\nCommon scheduling disciplines include the following:\nRandom scheduling (RSS)\nFirst In, First Out (FIFO), also known as First Come First Served (FCFS)\nLast In, First Out (LIFO)\nShortest seek first, also known as Shortest Seek / Service Time First (SSTF)\nElevator algorithm, also known as SCAN (including its variants, C-SCAN, LOOK, and C-LOOK)\nN-Step-SCAN SCAN of N records at a time\nFSCAN, N-Step-SCAN where N equals queue size at start of the SCAN cycle\nCompletely Fair Queuing (CFQ) on Linux\nAnticipatory scheduling\nNoop scheduler\nDeadline scheduler\nmClock scheduler","alt_names":["看看Wiki","I/O scheduling","- I/O scheduling :","Disk scheduling","Festplatten-Scheduler","Festplatten-Scheduler – Wikipedia","I O scheduling","I O scheduling - Wikipedia, the free encyclopedia","I/O Scheduler","I/O Scheduling","I/O Sheduler","I/O scheduler","I/O schedulers","I/O scheduling - Wikipedia, the free encyclopedia","I/O scheduling - Wikipedia, the free encyclopedia ...","I/O scheduling: Common disk scheduling disciplines","I/O scheduling; it is used under the","I/O-Scheduler","IO Scheduling","IO schedulers","Learn about I/O scheduling>>>","Ordonnancement d'E/S","Ordonnancement d'E/S - Wikipédia","Ordonnanceur de tâches E/S","Planificaciones por software:","Planificación de E/S","What is implementation of I/O Scheduling","Wikipedia article I/O Scheduling","Wikipedia article I/O scheduler","Wikipedia article I/O scheduling","Wikipedia article on Disk scheduling","Wikipedia article on I/O scheduling","Wikipedia article on Planificación de E/S","Wikipedia entry for I/O scheduling","Wikipedia-Artikel Festplatten-Scheduler","Wikipedia-Seite zu 'Festplatten-Scheduler'","[8] I/O scheduling","[LOOK HERE]","artículo de Wikipedia Planificacion de E/S","artículo de Wikipedia Planificación de E/S","de.wikipedia.org/wiki/Festplatten-Scheduler","http://de.wikipedia.org/wiki/Festplatten-Scheduler","http://en.wikipedia.org/wiki/Disk_scheduling","http://en.wikipedia.org/wiki/I/O_Scheduling","http://en.wikipedia.org/wiki/I/O_schedul","http://en.wikipedia.org/wiki/I/O_scheduler","http://en.wikipedia.org/wiki/I/O_scheduling","http://es.wikipedia.org/wiki/Planificaci%C3%B3n_de_E","http://fr.wikipedia.org/wiki/Ordonnancement_d%27E/S","input or output operation","mechanizmach I/O schedulingu","ordonnanceurs des entrées/sorties","und Schreibaufträgen an Festplatten und andere","Планировщик ввода-вывода (I/O scheduler)","планировщика ввода-вывода","排产","디스크 스케줄링","위키 피 디아 문서 디스크 스케줄링"],"name":"I/O scheduling","categories":["All articles needing additional references","Articles needing additional references from February 2013","Disk scheduling algorithms"],"tag_line":"Input/output (I/O) scheduling is the method that computer operating systems use to decide in which order the block I/O operations will be submitted to storage volumes."}}
,{"_index":"throwtable","_type":"algorithm","_id":"anticipatory-scheduling","_score":0,"_source":{"description":"Anticipatory scheduling is an algorithm for scheduling hard disk input/output (I/O scheduling). It seeks to increase the efficiency of disk utilization by \"anticipating\" future synchronous read operations.\n\"Deceptive idleness\" is a situation where a process appears to be finished reading from the disk when it is actually processing data in preparation of the next read operation. This will cause a normal work-conserving I/O scheduler to switch to servicing I/O from an unrelated process. This situation is detrimental to the throughput of synchronous reads, as it degenerates into a seeking workload. Anticipatory scheduling overcomes deceptive idleness by pausing for a short time (a few milliseconds) after a read operation in anticipation of another close-by read requests.\nAnticipatory scheduling yields significant improvements in disk utilization for some workloads. In some situations the Apache web server may achieve up to 71% more throughput from using anticipatory scheduling.\nThe Linux anticipatory scheduler may reduce performance on disks using Tagged Command Queuing (TCQ), high performance disks, and hardware RAID arrays. An anticipatory scheduler (AS) was the default Linux kernel scheduler between 2.6.0 and 2.6.18, by which time it was replaced by the CFQ scheduler.\nAs of kernel version 2.6.33, the Anticipatory scheduler (AS) has been removed from the Linux kernel. The reason being that while useful, the scheduler's effects could be achieved through tuned use of other schedulers (mostly CFQ, which can also be configured to idle with the slice_idle tunable). Since the anticipatory scheduler added maintenance overhead while not improving the workload coverage of the Linux kernel, it was deemed redundant.","alt_names":["- Anticipatory scheduling :","Anticipatory I/O atau AS","Anticipatory IO Scheduler (AS)","Anticipatory Scheduler","Anticipatory Scheduling","Anticipatory scheduler","Anticipatory scheduling","Anticipatory scheduling - Wi...","Anticipatory scheduling - Wikipedia, the free encyclopedia","Anticipatory scheduling - Wikipédia","Anticipatory scheduling Wikipedia the free encyclopedia - result","Read More anticipatory scheduling wikipedia the free encyclopedia","Wikipedia article Anticipatory scheduling","Wikipedia entry for Anticipatory scheduling","anticipatory scheduler","http://en.wikipedia.org/wiki/Anticipatory_s","http://en.wikipedia.org/wiki/Anticipatory_sch...","http://en.wikipedia.org/wiki/Anticipatory_scheduli ng","http://en.wikipedia.org/wiki/Anticipatory_scheduling","http://fr.wikipedia.org/wiki/Anticipatory_scheduling","wikipedia page for Anticipatory scheduling","yago-res:Anticipatory scheduling"],"name":"Anticipatory scheduling","categories":["All stub articles","Disk scheduling algorithms","Linux kernel features","Linux stubs","Operating system kernels"],"tag_line":"Anticipatory scheduling is an algorithm for scheduling hard disk input/output (I/O scheduling)."}}
,{"_index":"throwtable","_type":"algorithm","_id":"modified-due-date-scheduling-heuristic","_score":0,"_source":{"description":"The modified due-date scheduling heuristic is used in scheduling tasks to resources (for example, to answer the question \"What order should we make sandwiches in, so as to please our customers?\").\nIt assumes that the objective of the scheduling process is to minimise the total amount of time spent on tasks after their due dates. This strategy is most relevant when completing all tasks carries a certainty that at least some of them will be completed late.\nThe modified due date forms the basis of an algorithm that attempts first to complete tasks early or on time, and second to complete tasks as soon as possible when the requested due date is unattainable: Given a list of tasks, with a range of due dates (dj), and a range of times it takes to complete the tasks (pj), then at any moment (t) you should do the task that has the smallest modified due date. The modified due date itself is the highest of either the due date, or the completion date if you started the task now:\nmddj = max( dj, t+pj ).\nThus, if the due date of the PB and J is 5 minutes from now, but its time to complete is 6 minutes, the modified due date of the PB and J is 6 minutes from now. Imagine a second customer is requesting that a Reuben be prepared in 7 minutes from now, but the Reuben takes 5 minutes to complete: in this case, the MDD of the Reuben is 7 minutes; the PB and J has a smaller MDD, and thus you should make the PB and J first, while the second customer waits patiently for the Reuben to be started. In this case, the PB and J is 1 minute late, and the Reuben is 4 minutes late. Both sandwiches are made late, but the total lateness is only 5 minutes. If you had made the Reuben first, the second customer may have gotten the sandwich early, but the first customer would have received their sandwich 6 minutes late.","alt_names":[],"name":"Modified due-date scheduling heuristic","categories":["All Wikipedia articles needing context","All articles lacking sources","All pages needing cleanup","All stub articles","Articles lacking sources from October 2007","Computer science stubs","Scheduling algorithms","Wikipedia articles needing context from October 2009","Wikipedia introduction cleanup from October 2009"],"tag_line":"The modified due-date scheduling heuristic is used in scheduling tasks to resources (for example, to answer the question \"What order should we make sandwiches in, so as to please our customers?\")."}}
,{"_index":"throwtable","_type":"algorithm","_id":"least-slack-time-scheduling","_score":0,"_source":{"description":"Least slack time (LST) scheduling is a scheduling algorithm. It assigns priority based on the slack time of a process. Slack time is the amount of time left after a job if the job was started now. This algorithm is also known as least laxity first. Its most common use is in embedded systems, especially those with multiple processors. It imposes the simple constraint that each process on each available processor possesses the same run time, and that individual processes do not have an affinity to a certain processor. This is what lends it a suitability to embedded systems.","alt_names":["...mehr auf Wikipedia über Least Laxity First","...more on Wikipedia about Least slack time scheduling","2. Least slack time scheduling - Wikipedia, the free","Algoritmo LLF (ou LST - Least slack time) - Wikipedia","Der Prozess-Scheduler wählt in diesem Verfahren diejenigen","LSTスケジューリング","Least Laxity First","Least Laxity First in","Least Laxity First – Wikipedia","Least Slack Time - Wikipedia","Least Slack Time First","Least Slack Timeとは？ (Wikipediaへのリンク)","Least Slacktime First","Least slack time scheduling","Least slack time scheduling - Wikipedia, the free encyclopedia","Least_Laxity_First","Least_Laxity_First bei der wikipedia","Least_Slack_Time","Least_slack_time_scheduling","Less time programming game - Wikipedia, the free encyclopedia","Wikipedia (Least slack time scheduling)","Wikipedia article Least slack time scheduling","Wikipedia article on Least slack time scheduling","Wikipedia-Artikel LLF","Wikipedia-Artikel Least Laxity First","Wikipediaで「Least Slack Time」を調べる","en.wikipedia.org/wiki/Least_slack_time_scheduling","en:Least slack time scheduling","http://de.wikipedia.org/wiki/Least_Laxit","http://de.wikipedia.org/wiki/Least_Laxity_First","http://en.wikipedia....time_scheduling","http://en.wikipedia.org/wiki/Least_slack","http://en.wikipedia.org/wiki/Least_slack_time_scheduling","http://ja.wikipedia.org/wiki/Least_Slack_Time","ja.wikipedia.org/wiki/Least_Slack_Time","least slack time scheduling","slack time based prioritization","ウィキペディアの記事 Least Slack Time"],"name":"Least slack time scheduling","categories":["All articles lacking sources","Articles lacking sources from December 2009","Scheduling algorithms"],"tag_line":"Least slack time (LST) scheduling is a scheduling algorithm."}}
,{"_index":"throwtable","_type":"algorithm","_id":"sequence-step-algorithm","_score":0,"_source":{"description":"A sequence step algorithm (SQS-AL) is an algorithm implemented in a discrete event simulation system to maximize resource utilization. This is achieved by running through two main nested loops: A sequence step loop and a replication loop. For each sequence step, each replication loop is a simulation run that collects crew idle time for activities in that sequence step. The collected crew idle times are, then, used to determine resource arrival dates for user-specified confidence levels. The process of collecting the crew idle times and determining crew arrival times for activities on a considered sequence step is repeated from the first to the last sequence step.","alt_names":["Sequence step algorithm","Sequence step algorithm - Wikipedia, the free encyclopedia","Sequence step algorithm - Wikipedia, the free encyclopedia ...","Wikipedia entry for Sequence step algorithm","en.wikipedia.org/wiki/Sequence_step_a...","http://en.wikipedia.org/wiki/Sequence_step_algorithm","yago-res:Sequence step algorithm"],"name":"Sequence step algorithm","categories":["Algorithms and data structures stubs","All articles covered by WikiProject Wikify","All articles needing expert attention","All articles with too few wikilinks","All orphaned articles","All stub articles","Articles covered by WikiProject Wikify from March 2013","Articles needing expert attention from October 2009","Articles needing expert attention with no reason or talk parameter","Articles needing unspecified expert attention","Articles with too few wikilinks from March 2013","Computer science stubs","Network theory","Orphaned articles from February 2009","Project management","Scheduling algorithms"],"tag_line":"A sequence step algorithm (SQS-AL) is an algorithm implemented in a discrete event simulation system to maximize resource utilization."}}
,{"_index":"throwtable","_type":"algorithm","_id":"n-step-scan","_score":0,"_source":{"description":"N-Step-SCAN (also referred to as N-Step LOOK) is a disk scheduling algorithm to determine the motion of the disk's arm and head in servicing read and write requests. It segments the request queue into subqueues of length N. Breaking the queue into segments of N requests makes service guarantees possible. Subsequent requests entering the request queue won't get pushed into N sized subqueues which are already full by the elevator algorithm. As such, starvation is eliminated and guarantees of service within N requests is possible.\nAnother way to look at N-step SCAN is this: A buffer for N requests is kept. All the requests in this buffer are serviced in any particular sweep. All the incoming requests in this period are not added to this buffer but are kept up in a separate buffer. When these top N requests are serviced, the IO scheduler chooses the next N requests and this process continues. This allows for better throughput and avoids starvation.","alt_names":["- N-Step-SCAN :","N Step SCAN","N-Step-SCAN","N-Step-SCAN - Wikipedia, the free encyclopedia","N-Step-SCAN: Analysis","N-Step-SCAN; it is used under the","What is analysis of N-Step-SCAN","Wikipedia article N-Step-SCAN","Wikipedia article on N-Step-SCAN","Wikipedia entry for N-Step-SCAN","http://en.wikipedia.org/wiki/N-Step-SCAN","yago-res:N-Step-SCAN"],"name":"N-Step-SCAN","categories":["All articles needing additional references","Articles needing additional references from February 2008","Disk scheduling algorithms"],"tag_line":"N-Step-SCAN (also referred to as N-Step LOOK) is a disk scheduling algorithm to determine the motion of the disk's arm and head in servicing read and write requests."}}
,{"_index":"throwtable","_type":"algorithm","_id":"multilevel-queue","_score":0,"_source":{"description":"Multi-level queueing, used at least since the late 1950s/early 1960s, is a queue with a predefined number of levels. Unlike the multilevel feedback queue, items get assigned to a particular level at insert (using some predefined algorithm), and thus cannot be moved to another level. Items get removed from the queue by removing all items from a level, and then moving to the next. If an item is added to a level above, the \"fetching\" restarts from there. Each level of the queue is free to use its own scheduling, thus adding greater flexibility than merely having multiple levels in a queue.","alt_names":["Multilevel Queue","Multilevel queue","Multilevel queue - Wikipedia, the free encyclopedia","Multilevel queue Wikipedia the free encyclopedia","Wikipedia article Multilevel queue","Wikipedia entry for Multilevel queue","http://en.wikipedia.org/wiki/Multilevel_queue","yago-res:Multilevel queue","다단계 큐 스케줄링","다단계 피드백 큐 스케줄링","위키 피 디아 문서 다단계 큐 스케줄링","위키 피 디아 문서 다단계 피드백 큐 스케줄링","위키 피 디아 문서 다단계 피드팩 큐"],"name":"Multilevel queue","categories":["All articles needing additional references","All stub articles","Articles needing additional references from September 2014","Computer science stubs","Scheduling algorithms"],"tag_line":"Multi-level queueing, used at least since the late 1950s/early 1960s, is a queue with a predefined number of levels."}}
,{"_index":"throwtable","_type":"algorithm","_id":"heterogeneous-earliest-finish-time","_score":0,"_source":{"description":"Heterogeneous Earliest Finish Time (or HEFT) is a heuristic to schedule a set of dependent tasks onto a network of heterogeneous workers taking communication time into account. For inputs HEFT takes a set of tasks, represented as a directed acyclic graph, a set of workers, the times to execute each task on each worker, and the times to communicate the results from each job to each of its children between each pair of workers. It descends from list scheduling algorithms.","alt_names":[],"name":"Heterogeneous Earliest Finish Time","categories":["Pages containing cite templates with deprecated parameters","Scheduling algorithms"],"tag_line":"Heterogeneous Earliest Finish Time (or HEFT) is a heuristic to schedule a set of dependent tasks onto a network of heterogeneous workers taking communication time into account."}}
,{"_index":"throwtable","_type":"algorithm","_id":"graphical-path-method","_score":0,"_source":{"description":"The Graphical Path Method (GPM) is a mathematically based algorithm used in project management for planning, scheduling and resource control. GPM represents logical relationships of dated objects – such as activities, milestones, and benchmarks – in a time-scaled network diagram.\n\n","alt_names":["Graphical path method","Graphical path method - Wikipedia, the free encyclopedia","http://en.wikipedia.org/wiki/Graphical_path_method"],"name":"Graphical path method","categories":["Critical Path Scheduling","Project management","Scheduling algorithms"],"tag_line":"The Graphical Path Method (GPM) is a mathematically based algorithm used in project management for planning, scheduling and resource control."}}
,{"_index":"throwtable","_type":"algorithm","_id":"earliest-deadline-first-scheduling","_score":0,"_source":{"description":"Earliest deadline first (EDF) or least time to go is a dynamic scheduling algorithm used in real-time operating systems to place processes in a priority queue. Whenever a scheduling event occurs (task finishes, new task released, etc.) the queue will be searched for the process closest to its deadline. This process is the next to be scheduled for execution.\nEDF is an optimal scheduling algorithm on preemptive uniprocessors, in the following sense: if a collection of independent jobs, each characterized by an arrival time, an execution requirement and a deadline, can be scheduled (by any algorithm) in a way that ensures all the jobs complete by their deadline, the EDF will schedule this collection of jobs so they all complete by their deadline.\nWith scheduling periodic processes that have deadlines equal to their periods, EDF has a utilization bound of 100%. Thus, the schedulability test for EDF is:\n\nwhere the  are the worst-case computation-times of the  processes and the  are their respective inter-arrival periods (assumed to be equal to the relative deadlines).\nThat is, EDF can guarantee that all deadlines are met provided that the total CPU utilization is not more than 100%. Compared to fixed priority scheduling techniques like rate-monotonic scheduling, EDF can guarantee all the deadlines in the system at higher loading.\nHowever, when the system is overloaded, the set of processes that will miss deadlines is largely unpredictable (it will be a function of the exact deadlines and time at which the overload occurs.) This is a considerable disadvantage to a real time systems designer. The algorithm is also difficult to implement in hardware and there is a tricky issue of representing deadlines in different ranges (deadlines can't be more precise than the granularity of the clock used for the scheduling). If a modular arithmetic is used to calculate future deadlines relative to now, the field storing a future relative deadline must accommodate at least the value of the ((\"duration\" {of the longest expected time to completion} * 2) + \"now\"). Therefore EDF is not commonly found in industrial real-time computer systems.\nInstead, most real-time computer systems use fixed priority scheduling (usually rate-monotonic scheduling). With fixed priorities, it is easy to predict that overload conditions will cause the low-priority processes to miss deadlines, while the highest-priority process will still meet its deadline.\nThere is a significant body of research dealing with EDF scheduling in real-time computing; it is possible to calculate worst case response times of processes in EDF, to deal with other types of processes than periodic processes and to use servers to regulate overloads.","alt_names":["...Wikipedia Earliest deadline first scheduling","...mehr auf Wikipedia über Earliest Deadline First","...more on Wikipedia about Earliest deadline first scheduling","Algoritmo EDF - Wikipedia (en)","Deadline interchange","EDF (Earliest Deadline First)","EDF (antes de primeiro mandato)","EDF (antes primer plazo)","EDF (avant le premier mandat)","EDF (earliest deadline first)","EDF (früheste Termin zuerst)","EDF (nejbližší termín první)","EDF (prima primo termine)","EDF (voor de eerste term)","EDF (vor dem ersten Semester)","EDF (vroegste deadline eerst)","EDF (vóór de eerste termijn)","EDF (до первого члена)","EDF (ранние сроки первого)","EDF is an optimal scheduling algorithm on preemptive","EDF 스케줄링","EDFS","EDFスケジューリング","EDF（第一項の前）","Earliest Deadline First","Earliest Deadline First (EDF)","Earliest Deadline First - Wikipedia","Earliest Deadline First Scheduling","Earliest Deadline First – Wikipedia","Earliest Deadline Firstとは？ (Wikipediaへのリンク)","Earliest deadline first","Earliest deadline first sche...","Earliest deadline first scheduling","Earliest deadline first scheduling - Wikipedia","Earliest deadline first scheduling - Wikipedia, the ...","Earliest deadline first scheduling - Wikipedia, the free ...","Earliest deadline first scheduling - Wikipedia, the free encyclopedia","Earliest deadline first scheduling - Wikipédia","Earliest deadline first scheduling -…","Earliest deadline first scheduling ...","Earliest deadline first scheduling Wikipedia the free encyclopedia","Earliest dealine first scheduling","Earliest-deadline-first scheduler","Earliest_Deadline_First","Earliest_Deadline_First bei der wikipedia","Earliest_Deadline_First-wikipedia","Earlist Deadline First scheduling","Early_Deadline_First","Eearliest Deadline First","Heavy traffic ...","Kernels implementing ...","Learn about Earliest deadline first scheduling>>>","Read More earliest deadline first scheduling wikipédia","Scheduler EDF (Earliest Deadline First Scheduling)","Source Wikipedia.org Arcticle - Earliest deadline first scheduling","That is, EDF can guarantee that all deadlines","The AQuoSA project constitutes a modification to the","Wikipedia (Earliest deadline first scheduling)","Wikipedia article ''Earliest deadline first scheduling''","Wikipedia article Earliest deadline first scheduling","Wikipedia article Earliest dealine first scheduling","Wikipedia article about Earliest deadline first scheduling","Wikipedia article on Earliest deadline first scheduling","Wikipedia entry for Earliest deadline first scheduling","Wikipedia page on EDF algorithm","Wikipedia-Artikel Earliest Deadline First","Wikipedia-Seite zu 'Earliest Deadline First'","cs:Earliest deadline first","de:Earliest Deadline First","deadline first scheduling","deadline interchange","earliest deadline first","earliest deadline first (EDF) scheduler","earliest deadline first algorithm","earliest deadline first scheduling","en.wikipedia.org/...iest_deadline_first_scheduling","en.wikipedia.org/wiki/Earliest_deadli...","en.wikipedia.org/wiki/Earliest_deadline_first_scheduling","en:Earliest deadline first scheduling","fr:Earliest deadline first scheduling","http://cs.wikipedia.org/wiki/Earliest_deadline_first","http://de.wikipedia.org/wiki/Earliest_De","http://de.wikipedia.org/wiki/Earliest_Deadline_First","http://en.wikipedia.org/wiki/Earliest_d ... scheduling","http://en.wikipedia.org/wiki/Earliest_de","http://en.wikipedia.org/wiki/Earliest_deadlin...","http://en.wikipedia.org/wiki/Earliest_deadline_first_scheduling","http://fr.wikipedia.org/wiki/Earliest_deadline_first_scheduling","http://ja.wikipedia.org/wiki/Earliest_Deadline_Fir ...","http://ja.wikipedia.org/wiki/Earliest_Deadline_First","http://ja.wikipedia.org/wiki/Earliest_Deadline_Firstのthumbnail","http://ko.wikipedia.org/wiki/%25EC%25B5%259C","http://nl.wikipedia.org/wiki/Earliest_deadline_fir","ja:Earliest Deadline First","ko:최단 마감 우선 스케줄링","nl:Earliest deadline first scheduling","sv:Earliest deadline first","ウィキペディアの記事 Earliest Deadline First","ウィキペディアの記事 Early Deadline First","法国电力公司（前第一项）","위키 피 디아 문서 EDF 스케줄링","위키 피 디아 문서 최단 마감 우선 스케줄링","최단 마감 우선 스케줄링"],"name":"Earliest deadline first scheduling","categories":["All Wikipedia articles needing clarification","Processor scheduling algorithms","Real-time computing","Wikipedia articles needing clarification from June 2013"],"tag_line":"Earliest deadline first (EDF) or least time to go is a dynamic scheduling algorithm used in real-time operating systems to place processes in a priority queue."}}
,{"_index":"throwtable","_type":"algorithm","_id":"incremental-heuristic-search","_score":0,"_source":{"description":"Incremental heuristic search algorithms combine both incremental and heuristic search to speed up searches of sequences of similar search problems, which is important in domains that are only incompletely known or change dynamically. Incremental search has been studied at least since the late 1960s. Incremental search algorithms reuse information from previous searches to speed up the current search and solve search problems potentially much faster than solving them repeatedly from scratch. Similarly, heuristic search has been studied at least since the late 1960s. Heuristic search algorithms, often based on A*, use heuristic knowledge in the form of approximations of the goal distances to focus the search and solve search problems potentially much faster than uninformed search algorithms. The resulting search problems, sometimes called dynamic path planning problems, are graph search problems where paths have to be found repeatedly because the topology of the graph, its edge costs, the start vertex or the goal vertices change over time.\nSo far, three main classes of incremental heuristic search algorithms have been developed:\nThe first class restarts A* at the point where its current search deviates from the previous one (example: Fringe Saving A*).\nThe second class updates the h-values from the previous search during the current search to make them more informed (example: Generalized Adaptive A*).\nThe third class updates the g-values from the previous search during the current search to correct them when necessary, which can be interpreted as transforming the A* search tree from the previous search into the A* search tree for the current search (examples: Lifelong Planning A*, D*, D* Lite).\nAll three classes of incremental heuristic search algorithms are different from other replanning algorithms, such as planning by analogy, in that their plan quality does not deteriorate with the number of replanning episodes.","alt_names":["- Incremental heuristic search :","Incremental heuristic search","Incremental heuristic search - Wikipedia :: The free encyclopedia","Incremental heuristic search - Wikipedia, the free encyclopedia","Incremental heuristic search - Wikipedia, the free encyclopedia ...","Lifelong Planning A*","What are applications of Incremental heuristic search","Wikipedia article Incremental heuristic search","Wikipedia entry for Incremental heuristic search","http://en.wikipedia.org/wiki/Incremental_heuristic_search","incremental heuristic search","incremental heuristic searches","incremental search algorithms","ncremental heuristic search","yago-res:Incremental heuristic search"],"name":"Incremental heuristic search","categories":["Artificial intelligence","Robot control","Search algorithms"],"tag_line":"Incremental heuristic search algorithms combine both incremental and heuristic search to speed up searches of sequences of similar search problems, which is important in domains that are only incompletely known or change dynamically."}}
,{"_index":"throwtable","_type":"algorithm","_id":"dichotomic-search","_score":0,"_source":{"description":"In computer science, a dichotomic search is a search algorithm that operates by selecting between two distinct alternatives (dichotomies) at each step. It is a specific type of divide and conquer algorithm. A well-known example is binary search.\nAbstractly, a dichotomic search can be viewed as following edges of an implicit binary tree structure until it reaches a leaf (a goal or final state). This creates a theoretical tradeoff between the number of possible states and the running time: given k comparisons, the algorithm can only reach O(2k) possible states and/or possible goals.\nSome dichotomic searches only have results at the leaves of the tree, such as the Huffman tree used in Huffman compression, or the implicit classification tree used in Twenty Questions. Other dichotomic searches also have results in at least some internal nodes of the tree, such as a dichotomic search table for Morse code. There is thus some looseness in the definition. Though there may indeed be only two paths from any node, there are thus three possibilities at each step: choose one onwards path or the other, or stop at this node.\n\nDichotomic searches are often used in repair manuals, sometimes graphically illustrated with a flowchart similar to a fault tree.","alt_names":["- Dichotomic search :","Busca dicotômica","Busca dicotômica - Wikipédia, a enciclopédia livre","Dichotomic Search","Dichotomic search","Dichotomic search - Wikipedia, the free encyclopedia","Dichotomic search from Wikipedia","Wikipedia (Busca dicotômica)","Wikipedia article Busca dicotômica","Wikipedia article Dichotomic search","Wikipedia entry for Dichotomic search","a dichotomi","a dichotomic","busca dicotómica","busca dicotômica","búsquedas dicotómicas","dichomotic search","dichotmic search","dichotomic search","http://en.wikipedia.org/wiki/Dichotomic_","http://en.wikipedia.org/wiki/Dichotomic_searc...","http://en.wikipedia.org/wiki/Dichotomic_search","http://en.wikipedia.org/wiki/Dichotomic_search.","http://pt.wikipedia.org/wiki/Busca_dicot%C3%B4mica","pt:Busca dicotômica","yago-res:Dichotomic search","дихотомический поиск","“Dichotomic search - Wikipedia, the free encyclopedia”, en.wikipedia"],"name":"Dichotomic search","categories":["All articles lacking in-text citations","All stub articles","Articles lacking in-text citations from December 2014","Computer science stubs","Search algorithms"],"tag_line":"In computer science, a dichotomic search is a search algorithm that operates by selecting between two distinct alternatives (dichotomies) at each step."}}
,{"_index":"throwtable","_type":"algorithm","_id":"graphplan","_score":0,"_source":{"description":"Graphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995. Graphplan takes as input a planning problem expressed in STRIPS and produces, if one is possible, a sequence of operations for reaching a goal state.\nThe name graphplan is due to the use of a novel planning graph, to reduce the amount of search needed to find the solution from straightforward exploration of the state space graph.\nIn the state space graph:\nthe nodes are possible states,\nand the edges indicate reachability through a certain action.\nOn the contrary, in Graphplan's planning graph:\nthe nodes are actions and atomic facts, arranged into alternate levels,\nand the edges are of two kinds:\nfrom an atomic fact to the actions for which it is a condition,\nfrom an action to the atomic facts it makes true or false.\n\nthe first level contains true atomic facts identifying the initial state.\nLists of incompatible facts that cannot be true at the same time and incompatible actions that cannot be executed together are also maintained.\nThe algorithm then iteratively extends the planning graph, proving that there are no solutions of length l-1 before looking for plans of length l by backward chaining: supposing the goals are true, Graphplan looks for the actions and previous states from which the goals can be reached, pruning as many of them as possible thanks to incompatibility information.\nA closely related approach to planning is the Planning as Satisfiability (Satplan). Both reduce the automated planning problem to search for plans of different fixed horizon lengths.","alt_names":["- Graphplan :","...more on Wikipedia about Graphplan","GraphPlan","Graphplan","Graphplan - Wikipedia, the free encyclopedia","Graphplan Wikipedia the free encyclopedia","Graphplan algorithm","Source Wikipedia.org Arcticle - Graphplan","Wikipedia article ''Graphplan''","Wikipedia article Graphplan","Wikipedia article Graphplan algorithm","Wikipedia entry for Graphplan","article Graphplan","graphplan","http://en.wikipedia.org/wiki/Graphplan","yago-res:Graphplan"],"name":"Graphplan","categories":["Automated planning and scheduling","Search algorithms"],"tag_line":"Graphplan is an algorithm for automated planning developed by Avrim Blum and Merrick Furst in 1995."}}
,{"_index":"throwtable","_type":"algorithm","_id":"shortest-remaining-time","_score":0,"_source":{"description":"Shortest remaining time, also known as shortest remaining time first (SRTF), is a scheduling method that is a preemptive version of shortest job next scheduling. In this scheduling algorithm, the process with the smallest amount of time remaining until completion is selected to execute. Since the currently executing process is the one with the shortest amount of time remaining by definition, and since that time should only reduce as execution progresses, processes will always run until they complete or a new process is added that requires a smaller amount of time.\nShortest remaining time is advantageous because short processes are handled very quickly. The system also requires very little overhead since it only makes a decision when a process completes or a new process is added, and when a new process is added the algorithm only needs to compare the currently executing process with the new process, ignoring all other processes currently waiting to execute.\nLike shortest job first, it has the potential for process starvation; long processes may be held off indefinitely if short processes are continually added. This threat can be minimal when process times follow a heavy-tailed distribution.\nLike shortest job next scheduling, shortest remaining time scheduling is rarely used outside of specialized environments because it requires accurate estimations of the runtime of all processes that are waiting to execute.","alt_names":["...more on Wikipedia about Shortest remaining time","2. Shortest remaining time next(SRTN)","SRT (Shortest Remaining Time)","Short Remaining Time","Shortest Remaining Time","Shortest Remaining Time First","Shortest Remaining Time Next","Shortest Remaining time","Shortest Remaining time - Wikipedia, the free encyclopedia","Shortest remaining time","Shortest remaining time - Wikipedia, the free ...","Shortest remaining time - Wikipedia, the free encyclopedia","Shortest time remaining","Wikipedia article Shortest remaining time","Wikipedia entry for Shortest remaining time","en.wikipedia.org/wiki/Shortest_remain...","en:Shortest remaining time","et:Shortest Remaining Time Next","http://en.wikipedia.org/wiki/Shortest_re","http://en.wikipedia.org/wiki/Shortest_remaining_time","http://en.wikipedia.org/wiki/Shortest_re…","http://et.wikipedia.org/wiki/SRTN","http://et.wikipedia.org/wiki/Shortest_Remaining_Time_Next","http://et.wikipedia.org/wiki/Shortest_Remaining_Time_Next_(SRTN)","shortest remaining time","shortest remaining time scheduleru procesů","shortest-remaining-time scheduling"],"name":"Shortest remaining time","categories":["Processor scheduling algorithms"],"tag_line":"Shortest remaining time, also known as shortest remaining time first (SRTF), is a scheduling method that is a preemptive version of shortest job next scheduling."}}
,{"_index":"throwtable","_type":"algorithm","_id":"foreground-background","_score":0,"_source":{"description":"Foreground-background is a scheduling algorithm that is used to control execution of multiple processes on a single processor. It is based on two waiting lists, the first one is called foreground because this is the one in which all processes initially enter, and the second one is called background because all processes, after using all of their execution time in foreground, are moved to background.\nWhen a process becomes ready it begins its execution in foreground immediately, forcing the processor to give up execution of current process in the background and execute newly created process for a predefined period. This period is usually 2 or more quanta. If the process is not finished after its execution in the foreground it is moved to background waiting list where it will be executed only when the foreground list is empty. After being moved to background, process is then run longer than before, usually 4 quanta. The time of execution is increased because the process obviously needs more than 2 quanta to finish (this is the reason it was moved to background). This gives the process the opportunity to finish within this newly designated time. If the process does not finish after this, it is then preempted and moved to the end of the background list.\nThe advantage of the foreground-background algorithm is that it gives process the opportunity to execute immediately after its creation, but scheduling in the background list is pure round-robin scheduling.","alt_names":["Foreground Background","Foreground background","Foreground background Wikipedia the free encyclopedia","Foreground background Wikipedia, the ...","Foreground-background","Foreground-background - Wikipedia, the free encyclopedia","Foreground-background - Wikipedia, the free encyclopedia ... of current","Foreground-background - Wikipedia, the free encyclopedia Foreground-background","Foreground-background; it is used under the","Foreground/Background","Foregroundbackground Wikipedia the free encyclopedia","Wikipedia article Foreground Background","Wikipedia article Foreground-background","Wikipedia article on Foreground-background","Wikipedia entry for Foreground-background","foreground-background","foreground/background","http://en.wikipedia.org/wiki/Foreground-","http://en.wikipedia.org/wiki/Foreground-background","yago-res:Foreground-background","“Foreground-background - Wikipedia, the free encyclopedia”, en.wikipedia"],"name":"Foreground-background","categories":["All articles lacking sources","Articles lacking sources from February 2007","Processor scheduling algorithms"],"tag_line":"Foreground-background is a scheduling algorithm that is used to control execution of multiple processes on a single processor."}}
,{"_index":"throwtable","_type":"algorithm","_id":"jump-search","_score":0,"_source":{"description":"In computer science, a jump search or block search refers to a search algorithm for ordered lists. It works by first checking all items Lkm, where  and m is the block size, until an item is found that is larger than the search key. To find the exact position of the search key in the list a linear search is performed on the sublist L[(k-1)m, km].\nThe optimal value of m is √n, where n is the length of the list L. Because both steps of the algorithm look at, at most, √n items the algorithm runs in O(√n) time. This is better than a linear search, but worse than a binary search. The advantage over the latter is that a jump search only needs to jump backwards once, while a binary can jump backwards up to log n times. This can be important if a jumping backwards takes significantly more time than jumping forward.\nThe algorithm can be modified by performing multiple levels of jump search on the sublists, before finally performing the linear search. For an k-level jump search the optimum block size ml for the lth level (counting from 1) is n(k-l)/k. The modified algorithm will perform k backward jumps and runs in O(kn1/(k+1)) time.","alt_names":["Block search","Jump Search","Jump search","Jump search - Wikipedia, the free encyclopedia","What is implementation of Jump search","Wikipedia article Block search","Wikipedia article Jump search","Wikipedia entry for Jump search","block search","http://en.wikipedia.org/wiki/Jump_search","jump search"],"name":"Jump search","categories":["Search algorithms"],"tag_line":"In computer science, a jump search or block search refers to a search algorithm for ordered lists."}}
,{"_index":"throwtable","_type":"algorithm","_id":"proportional-share-scheduling","_score":0,"_source":{"description":"Proportional Share Scheduling is a type of scheduling which preallocates certain amount of CPU time to each of the processes. In a proportional share algorithm every job has a weight, and jobs receive a share of the available resources proportional to the weight of every job.","alt_names":[],"name":"Proportional share scheduling","categories":["All articles needing additional references","All stub articles","Articles needing additional references from December 2009","Computer science stubs","Processor scheduling algorithms"],"tag_line":"Proportional Share Scheduling is a type of scheduling which preallocates certain amount of CPU time to each of the processes."}}
,{"_index":"throwtable","_type":"algorithm","_id":"linear-search","_score":0,"_source":{"description":"In computer science, linear search or sequential search is a method for finding a particular value in a list that checks each element in sequence until the desired element is found or the list is exhausted. The list need not be ordered.\nLinear search is the simplest search algorithm; it is a special case of brute-force search. Its worst case cost is proportional to the number of elements in the list. Its expected cost is also proportional to the number of elements if all elements are searched equally. If the list has more than a few elements and is searched often, then more complicated search methods such as binary search or hashing may be appropriate. Those methods have faster search times but require additional resources to attain that speed.","alt_names":["линейный поиск","Linear Search","linear search","- Sequential search :","-> Read the article about 'Linear search'","...Wikipedia Busca linear","...Wikipedia Przeszukiwanie liniowe","...Wikipedia Ricerca sequenziale","...Wikipedia Ricerca sequenziale con sentinella","...mehr auf Wikipedia über Lineare Suche","...more on Wikipedia about Linear search","1.1 Non-uniform probabilities","3.1 Forward iteration","3.2 Recursive version","3.3 Searching in reverse order","3.4 Using a sentinel","3.5 Linear search on an ordered list","Busca linear","Busca linear - Wikipédia, a enciclopédia livre","Busca linear – Wikipédia, a enciclopédia livre","Der Suchaufwand wächst linear mit der Anzahl der","Encyclopedia: Linear search","How to apply for Linear search?","Lineair zoeken","Lineair zoeken - Wikipedia","Lineair zoeken Wikipedia","Linear Search - Simple English Wikipedia, The Free Encyclopedia","Linear Search algorithm","Linear Search.","Linear Searching","Linear ricerca","Linear search","Linear search - Simple English Wikipedia, the free encyclopedia","Linear search - Wikipedia, the free encyclopedia","Linear search may perform better","Linear search:","Linear search; it is used under the","Linear searching","Linear wyszukiwania","Linear_search","Lineare Suche","Lineare Suche ? Wikipedia","Lineare Suche Wikipedia","Lineare Suche – Wikipedia","Lineare_Suche","Lineáris keresés","Lineárne vyhľadávanie","Lineární vyhledávání","Lineární vyhledávání - Wikipedie","Lineær søgning","Lineærsøk","Liniowe przeszukiwanie","Pencarian Linear","Pencarian Linear - Wikipedia Bahasa Indonesia, Ensiklopedia Bebas","Pencarian linear","Pencarian linear - Wikipedia bahasa Indonesia, ensiklopedia bebas","Peräkkäishaku","Peräkkäishaku (Wikipedia)","Peräkkäishaku – Wikipedia","Pesquisa sequencial","Przeszukiwanie liniowe – Wikipedia, wolna encyklopedia","Przeszukiwanie_liniowe","Recherche séquentielle","Ricerca sequenziale","Ricerca sequenziale - Wikipedia","Ricerca sequenziale con sentinella","Sequential (Linear) Search","Sequential Scan","Sequential Search","Sequential or linear search","Sequential search","Sequential search - Wikipedia, the free encyclopedia","Sequentielle Suche - Wikipedia","Sequenzielle Suche - Wikipedia","Tm kim tun t ting Vit","Tìm kiếm tuyến tính - Wikipedia tiếng Việt","Wikipedia (Busca linear)","Wikipedia (Linear search)","Wikipedia article Busca linear","Wikipedia article Linear search","Wikipedia article Linear_search","Wikipedia article Lineær søgning","Wikipedia article Línuleg leit","Wikipedia article Pencarian linear","Wikipedia article Przeszukiwanie liniowe","Wikipedia article Sequential search","Wikipedia article Линейный поиск","Wikipedia entry for Linear search","Wikipedia-Artikel Lineare Suche","Wikipedia-Artikel Sequentielle Suche","Wikipedia-Artikel Sequenzielle Suche","Wikipedia-Seite zu 'Lineare Suche'","Wikipedia.ja:線型探索","Wikipediaで「線型探索」を調べる","a name based on a given number","a sequential search","artigo da Wikipédia Busca linear","búsqueda lineal","código em Pascal","en.wikipedia.org/...Linear_search","fi:Peräkkäishaku","http://de.wikipedia.org/wiki/Lineare_Suc","http://de.wikipedia.org/wiki/Lineare_Suche","http://de.wikipedia.org/wiki/Sequentiell…","http://en.Liarpedia.org/wiki/Linear_search","http://en.wikipedia.org/wiki/Linear_sear","http://en.wikipedia.org/wiki/Linear_search","http://en.wikipedia.org/wiki/Linear_sear…","http://en.wikipedia.org/wiki/Sequential_search","http://it.wikipedia.org/wiki/Ricerca_sequenziale","http://nl.wikipedia.org/wiki/Lineair_zoeken","http://pl.wikipedia....kiwanie_liniowe","http://pl.wikipedia.org/wiki/Przeszukiwanie_liniowe","http://pl.wikipedia.org/wiki/Pżeszukiwanie_liniowe","http://pt.wikipedia....ki/Busca_linear","http://pt.wikipedia.org/wiki/Busca_linear","is:Línuleg leit","la búsqueda lineal","lineair search","lineair zoeken","lineal buscando","linear seach","linear searc","linear table searches","lineare Suche","linearen Suche","lineární vyhledávání","lineær Søg","lineær søgning","lineære søgning","liniowy wyszukiwania","n , k = 0 n + 1 k + 1 , 1","pencarian linear","peräkkäishaku","pt.wikipedia.org/wiki/Busca_linear","ricerca lineare","ricerca sequenziale","ru:Линейный поиск","scansione lineare","searching through every item","sequential search","sequential search algorithm","sequentially searching","sequentieel zoekproces","simple:Linear search","tìm kiếm tuyến tính","uk:Лінійний пошук","usca linear","vi:Tìm kiếm tuyến tính","vi:Tìm kiếm tuần tự","vyhrabávat","wyszukiwanie liniowe","zh:线性搜索","Википедии статью Линейный поиск","Линейный поиск","Лінійний пошук","лінейны пошук Алгарытм","лінійний пошук","रैखिक खोज","“Linear search - Wikipedia, the free encyclopedia”, en.wikipedia","リニアサーチを","循序搜尋法(linear search)","的线性搜索","線型探索","線型探索 - Wikipedia","線型探索 – Wikipedia","線型探索-wikipedia","線形探索","線形探索・線型探索（せんけいたんさく）","线性搜索","顺序查找","순차검색","순차탐색"],"name":"Linear search","categories":["All articles needing additional references","Articles needing additional references from November 2010","Articles with example Java code","Articles with example pseudocode","Search algorithms"],"tag_line":"In computer science, linear search or sequential search is a method for finding a particular value in a list that checks each element in sequence until the desired element is found or the list is exhausted."}}
,{"_index":"throwtable","_type":"algorithm","_id":"late-move-reductions","_score":0,"_source":{"description":"Late Move Reductions (LMR) is a non-game specific enhancement to the alpha-beta algorithm and its variants which attempts to examine a game search tree more efficiently. It uses the assumption that good game-specific move ordering causes a program to search the most likely moves early. If a cut-off is going to happen in a search, the first few moves are the ones most likely to cause them. In games like chess, most programs search winning captures and \"killers\" first. LMR will reduce the search depth for moves searched later at a given node. This allows the program to search deeper along the critical lines, and play better.\nMost chess programs will search the first several moves at a node to full depth. Often, they do not reduce moves considered to be very tactical, such as captures or promotions. If the score of the move at a reduced depth is smaller than the alpha, the move is assumed to be bad. However, if the score is larger than alpha, the reduced tells us nothing so we will have to do a full search (fail-low).\nThis search reduction can lead to a different search space than the pure alpha-beta method which can give different results. Care must be taken to select the reduction criteria or the search will miss some deep threats.","alt_names":["Late Move Reductions","Late Move Reductions - Wikipedia, the free encyclopedia","Late Move Reductions from Wikipedia","Wikipedia article Late Move Reductions","Wikipedia article about Late Move Reductions","Wikipedia article on Late Move Reductions","Wikipedia entry for Late Move Reductions","http://en.wikipedia.org/wiki/Late Move Reductions","http://en.wikipedia.org/wiki/Late_Move_R","http://en.wikipedia.org/wiki/Late_Move_Reductions","yago-res:Late Move Reductions"],"name":"Late Move Reductions","categories":["All articles lacking in-text citations","Articles lacking in-text citations from March 2014","Computer chess","Search algorithms"],"tag_line":"Late Move Reductions (LMR) is a non-game specific enhancement to the alpha-beta algorithm and its variants which attempts to examine a game search tree more efficiently."}}
,{"_index":"throwtable","_type":"algorithm","_id":"american-flag-sort","_score":0,"_source":{"description":"An American flag sort is an efficient, in-place variant of radix sort that distributes items into hundreds of buckets. Non-comparative sorting algorithms such as radix sort and American flag sort are typically used to sort large objects such as strings, for which comparison is not a unit-time operation. American flag sort iterates through the bits of the objects, considering several bits of each object at a time. For each set of bits, American flag sort makes two passes through the array of objects: first to count the number of objects that will fall in each bin, and second to place each object in its bucket. This works especially well when sorting a byte at a time, using 256 buckets. With some optimizations, it is twice as fast as quicksort for large sets of strings.\nThe name comes by analogy with the Dutch national flag problem in the last step: efficiently partition the array into many \"stripes\".","alt_names":["American Flag Sort","American flag sort","American flag sort - Wikipedia, the free encyclopedia","American flag sort; it is used under the","Wikipedia article American flag sort","Wikipedia article on American flag sort","Wikipedia entry for American flag sort","Wikipedia/American Flag Sort","http://en.wikipedia.org/wiki/American_fl","http://en.wikipedia.org/wiki/American_flag_sort"],"name":"American flag sort","categories":["String sorting algorithms"],"tag_line":"An American flag sort is an efficient, in-place variant of radix sort that distributes items into hundreds of buckets."}}
,{"_index":"throwtable","_type":"algorithm","_id":"fnn-algorithm","_score":0,"_source":{"description":"The false nearest neighbor algorithm is an algorithm for estimating the embedding dimension. The concept was proposed by Kennel et al. The main idea is to examine how the number of neighbors of a point along a signal trajectory change with increasing embedding dimension. In too low an embedding dimension, many of the neighbors will be false, but in an appropriate embedding dimension or higher, the neighbors are real. With increasing dimension, the false neighbors will no longer be neighbors. Therefore, by examining how the number of neighbors change as a function of dimension, an appropriate embedding can be determined.","alt_names":["...more on Wikipedia about FNN algorithm","FNN algorithm","FNN algorithm - Wikipedia, the free encyclopedia","FNN algorithm; it is used under the","False nearest neighbor algorithm","False nearest neighbors","What is FNN algorithm","Wikipedia article FNN algorithm","Wikipedia article False nearest neighbors","Wikipedia entry for FNN algorithm","false nearest neighbors","http://en.wikipedia.org/wiki/FNN_algorit","http://en.wikipedia.org/wiki/FNN_algorithm","yago-res:FNN algorithm"],"name":"FNN algorithm","categories":["Algorithms and data structures stubs","All Wikipedia articles needing context","All pages needing cleanup","All stub articles","Computer science stubs","Dynamical systems","Nonlinear time series analysis","Statistical algorithms","Wikipedia articles needing context from October 2009","Wikipedia introduction cleanup from October 2009"],"tag_line":"The false nearest neighbor algorithm is an algorithm for estimating the embedding dimension."}}
,{"_index":"throwtable","_type":"algorithm","_id":"look-ahead-(backtracking)","_score":0,"_source":{"description":"In backtracking algorithms, look ahead is the generic term for a subprocedure that attempts to foresee the effects of choosing a branching variable to evaluate or one of its values. The two main aims of look-ahead are to choose a variable to evaluate next and the order of values to assign to it.","alt_names":["Forward Checking","Learn about Look-ahead (backtracking)>>>","Look ahead (backtracking) Wikipedia, ...","Look ahead backtracking","Look ahead backtracking Wikipedia the free encyclopedia","Look ahead backtracking Wikipedia the free encyclopedia - result","Look-ahead (backtracking)","Look-ahead (backtracking) - Wikipedia :: The free encyclopedia","Look-ahead (backtracking) - Wikipedia, the free encyclopedia","Look-ahead (backtracking) - Wikipedia, the free encyclopedia ...","Look-ahead (backtracking); it is used under the","Look-ahead backtracking - Wikipedia, the free encyclopedia","LookAhead","Lookahead backtracking Wikipedia the free encyclopedia","The results of look ahead is used to","Wikipedia (Look-ahead (backtracking))","Wikipedia article Look-ahead (backtracking)","Wikipedia entry for Look-ahead (backtracking)","en.wikipedia.org/wiki/Look-ahead_(bac...","en.wikipedia.org/wiki/Look-ahead_(backtracking)","forward checking","http://en.wikipedia.org/wiki/Forward_che","http://en.wikipedia.org/wiki/Look-ahead_%28backtracking","http://en.wikipedia.org/wiki/Look-ahead_(backtracking","http://en.wikipedia.org/wiki/Look-ahead_…","look-ahead (backtracking) - Wikipedia, the free encyclopedia"],"name":"Look-ahead (backtracking)","categories":["Constraint programming","Search algorithms"],"tag_line":"In backtracking algorithms, look ahead is the generic term for a subprocedure that attempts to foresee the effects of choosing a branching variable to evaluate or one of its values."}}
,{"_index":"throwtable","_type":"algorithm","_id":"introselect","_score":0,"_source":{"description":"In computer science, introselect (short for \"introspective selection\") is a selection algorithm that is a hybrid of quickselect and median of medians which has fast average performance and optimal worst-case performance. Introselect is related to the introsort sorting algorithm: these are analogous refinements of the basic quickselect and quicksort algorithms, in that they both start with the quick algorithm, which has good average performance and low overhead, but fall back to an optimal worst-case algorithm (with higher overhead) if the quick algorithm does not progress rapidly enough. Both algorithms were introduced by David Musser in (Musser 1997), with the purpose of providing generic algorithms for the C++ Standard Library which had both fast average performance and optimal worst-case performance, thus allowing the performance requirements to be tightened.","alt_names":[],"name":"Introselect","categories":["Pages with DOIs inactive since 2015","Selection algorithms"],"tag_line":"In computer science, introselect (short for \"introspective selection\") is a selection algorithm that is a hybrid of quickselect and median of medians which has fast average performance and optimal worst-case performance."}}
,{"_index":"throwtable","_type":"algorithm","_id":"string-kernel","_score":0,"_source":{"description":"In machine learning and data mining, a string kernel is a kernel function that operates on strings, i.e. finite sequences of symbols that need not be of the same length. String kernels can be intuitively understood as functions measuring the similarity of pairs of strings: the more similar two strings a and b are, the higher the value of a string kernel K(a, b) will be.\nUsing string kernels with kernelized learning algorithms such as support vector machines allow such algorithms to work with strings, without having to translate these to fixed-length, real-valued feature vectors. String kernels are used in domains where sequence data are to be clustered or classified, e.g. in text mining and gene analysis.","alt_names":["- String Kernel :","- String kernel :","String Kernel","String kernel","String kernel - Wikipedia, the free encyclopedia","String kernel by Wikipedia","Wikipedia article String Kernel","Wikipedia article String kernel","http://en.wikipedia.org/wiki/String_kernel"],"name":"String kernel","categories":["Algorithms on strings","Kernel methods for machine learning","Natural language processing","String similarity measures"],"tag_line":"In machine learning and data mining, a string kernel is a kernel function that operates on strings, i.e."}}
,{"_index":"throwtable","_type":"algorithm","_id":"glr-parser","_score":0,"_source":{"description":"A GLR parser (GLR standing for \"generalized LR\", where L stands for \"left-to-right\" and R stands for \"rightmost (derivation)\") is an extension of an LR parser algorithm to handle nondeterministic and ambiguous grammars. The theoretical foundation was provided in a 1974 paper by Bernard Lang (along with other general Context-Free parsers such as GLL). It describes a systematic way to produce such algorithms, and provides uniform results regarding correctness proofs, complexity with respect to grammar classes, and optimization techniques. The first actual implementation of GLR was described in a 1984 paper by Masaru Tomita, it has also been referred to as a \"parallel parser\". Tomita presented five stages in his original work, though in practice it is the second stage that is recognized as the GLR parser.\nThough the algorithm has evolved since its original forms, the principles have remained intact. As shown by an earlier publication, Lang was primarily interested in more easily used and more flexible parsers for extensible programming languages. Tomita's goal was to parse natural language text thoroughly and efficiently. Standard LR parsers cannot accommodate the nondeterministic and ambiguous nature of natural language, and the GLR algorithm can.\n^ \n^ \n^","alt_names":["- GLR parser :","Analisador sintático GLR","Filter Generator GLR","Filter-Generator GLR","GLR (Generalized LR)","GLR Parsing","GLR Parsing.","GLR filtro generatore","GLR filtro gerador","GLR générateur de filtre","GLR ontleder generator","GLR parser","GLR parser - Wikipedia, the free encyclopedia","GLR parser - Wikipedia, the free encyclopedia Briefly, the","GLR parser Wikipedia the free encyclopedia","GLR parser generator","GLR parser – Wikipedia, the free encyclopedia","GLR parser; it is used under the","GLR parsers","GLR parsing","GLR-Parser-Generator","GLR-парсер","GLR_parser","GLRパーザ","GLR分析器生成器","GLR法","GLR法 - Wikipedia","GLR法-wikipedia","Generalized LR","Generalized LR parsing","Generalized Left-to-Right parser","Learn about GLR parser>>>","RGL générateur de filtre","Tomita's algorithm","Tomita-Parser","Tomita-Parser - Wikipedia","Tomita-Parser – Wikipedia","What are advantages of GLR parser","What is algorithm of Generalized LR parser","Wikipedia article Analisador sintático GLR","Wikipedia article GLR parser","Wikipedia article Glr parser","Wikipedia article on GLR parser","Wikipedia entry for GLR parser","Wikipedia-Artikel Tomita-Parser","Wikipedia-Seite zu 'Tomita-Parser'","Wikipedia: GLR parser","Wikipediaで「GLR法」を調べる","WikipediaのGLRの説明","continue reading http://en.wikipedia.org/wiki/GLR_parser","de:Tomita-Parser","en.wikipedia.org/GLR_parser","en.wikipedia.org/wiki/GLR_parser","en.wikipedia.org/wiki/GLR_parser as general background","filter generator GLR","generador de filtros GLR","general parsing method","generalized LR","generalized LR parsers","generalized LR parsing","generatore GLR filtro","generatore di parser GLR","generic LR","http://de.wikipedia.org/wiki/Tomita-Pars","http://de.wikipedia.org/wiki/Tomita-Parser","http://en.wikipedia.org/wiki/GLR%5Fparser","http://en.wikipedia.org/wiki/GLR_parser","http://ja.wikipedia.org/wiki/GLR%E6%B3","http://ja.wikipedia.org/wiki/GLR法","http://pl.wikipedia.org/wiki/Parser_GLR","http://pt.wikipedia.org/wiki/Analisador_sint%C3%A1tico_GLR","http://ru.wikipedia.org/wiki/GLR-%D0%BF","nondeterministic / many-worlds parser","yago-res:GLR parser","фильтр РВО генератора","ウィキペディアの記事 GLR法","フィルタジェネレータGLRを","过滤器生成的GLR"],"name":"GLR parser","categories":["All articles covered by WikiProject Wikify","All articles lacking in-text citations","All articles with unsourced statements","All pages needing cleanup","Articles covered by WikiProject Wikify from February 2015","Articles lacking in-text citations from May 2011","Articles with unsourced statements from May 2011","Parsing algorithms","Wikipedia introduction cleanup from February 2015"],"tag_line":"A GLR parser (GLR standing for \"generalized LR\", where L stands for \"left-to-right\" and R stands for \"rightmost (derivation)\") is an extension of an LR parser algorithm to handle nondeterministic and ambiguous grammars."}}
,{"_index":"throwtable","_type":"algorithm","_id":"operator-precedence-parser","_score":0,"_source":{"description":"In computer science, an operator precedence parser is a bottom-up parser that interprets an operator-precedence grammar. For example, most calculators use operator precedence parsers to convert from the human-readable infix notation relying on order of operations to a format that is optimized for evaluation such as Reverse Polish notation (RPN).\nEdsger Dijkstra's shunting yard algorithm is commonly used to implement operator precedence parsers. Other algorithms include the precedence climbing method and the top down operator precedence method.","alt_names":["- Operator-precedence parser :","-> Read more about Operator-precedence parser","-> Read the article about 'Operator-precedence parser'","-Operator přednost parser","-parser precedenza Operator","...more on Wikipedia about Operator-precedence parser","Alternatives to Dijkstra's Algorithm","Metoda pierwszeństwa operatorów","Operator Precedence Parser","Operator Precedence Parsing","Operator precedence parser","Operator precedence parsing","Operator-Precedence Parsing","Operator-Vorrang-Parser","Operator-parser voorrang","Operator-precedence","Operator-precedence parser","Operator-precedence parser - WIKIPEDIA","Operator-precedence parser - Wikipedia, the free ...","Operator-precedence parser - Wikipedia, the free encyclopedia","Operator-precedence parser - Wikipedia, the free encyclopedia ...","Operator-precedence parser – Wikipedia, the free encyclopedia","Operator-precedence parser: Alternatives to Dijkstra's Algorithm","Operator-precedence parser; it is used under the","Operator-precedence parsers","Operator-precedence_parser","Operators Predence","Operators precedence","Parsing infix equations","Parsing-Regeln","Relationship to other parsers","Wikipedia - Operator-precedence parser","Wikipedia article Operator-precedence parser","Wikipedia entry for Operator-precedence parsers","Wikipedia on operator-precedece parsers","Wikipedia: Operator-precedence parser","analizowania przepisów","analýzu pravidla","diutamakan operator","en.wikipedia.org/wiki/Operator-precedence_parser","gruesome hacks","http://en.wikipedia.org/wiki/Operator-precede...","http://en.wikipedia.org/wiki/Operator-precedence_parser","http://en.wikipedia.org/wiki/Operator-precedence_parser#Alternatives_to_Dijkstra","http://en.wikipedia.org/wiki/Operator-precedence_parser#Exam","http://en.wikipedia.org/wiki/Operator-precedence_parser#Example_algorithm_to_parse_infix_notation","http://en.wikipedia.org/wiki/Operator-precedence_parser#Pseudo","http://en.wikipedia.org/wiki/Operator-pr…","http://en.wikipedia.org/wiki/Operator−precedence_parser","http://pl.wikipedia.org/wiki/Metoda_pierwsze%C5%84stwa_operator","http://tinyurl.com/28srjk","operator pierwszeństwo","operator precedence parser","operator precedence parsing","operator voorrang","operator-precedence parser","operator-precedence parsers","operator‐precedence parser","parser that exploits these relations","parsing regels","parsing regler","parsing rules","precedencia de los operadores","precedenza tra gli operatori","precedência de operador","prioridad de los operadores","priorité des opérateurs","provozovatel přednost","reglas de análisis","regole di analisi","the algorithm at the bottom of this wikipedia","yago-res:Operator-precedence parser","ưu tiên khai thác","оператор приоритет","оператора-преимущество анализатора","правила анализа","приоритет операторов","разбора первенства операторов","สำคัญผู้ประกอบการ","“Operator-precedence parser - Wikipedia, the free encyclopedia”, en","の優先順位Prologの","分析规则","構文解析規則は、","演算子優先順位パーサ","演算子順位パーサー","演算子順位ﾊﾟｰｻｰ","算符优先级解析法","运算符优先级式","運算符優先級","연산자 우선순위"],"name":"Operator-precedence parser","categories":["All articles with unsourced statements","Articles with example C code","Articles with unsourced statements from November 2010","Parsing algorithms"],"tag_line":"In computer science, an operator precedence parser is a bottom-up parser that interprets an operator-precedence grammar."}}
,{"_index":"throwtable","_type":"algorithm","_id":"shunting-yard-algorithm","_score":0,"_source":{"description":"In computer science, the shunting-yard algorithm is a method for parsing mathematical expressions specified in infix notation. It can be used to produce output in Reverse Polish notation (RPN) or as an abstract syntax tree (AST). The algorithm was invented by Edsger Dijkstra and named the \"shunting yard\" algorithm because its operation resembles that of a railroad shunting yard. Dijkstra first described the Shunting Yard Algorithm in the Mathematisch Centrum report MR 34/61.\nLike the evaluation of RPN, the shunting yard algorithm is stack-based. Infix expressions are the form of mathematical notation most people are used to, for instance 3+4 or 3+4*(2−1). For the conversion there are two text variables (strings), the input and the output. There is also a stack that holds operators not yet added to the output queue. To convert, the program reads each symbol in order and does something based on that symbol.\nThe shunting-yard algorithm has been later generalized into operator-precedence parsing.","alt_names":["Shunting yard algorithm","- Shunting yard algorithm :","-Yard algoritmo di smistamento","A simple conversion","Algorithme de manœuvre Yard","Algoritma Shunting Yard","Algoritmo Shunting Yard","Algoritmo di smistamento Yard","Algoritmo shunting yard","Algoritmo shunting yard - Wikipedia, la enciclopedia libre","Algorytm Yard Manewrowanie","Algorytm stoczni manewrowe","Cour de triage","De maniobras","Derivación de Dijkstra algoritmo de patio","Dijkstra's Shunting Yard","Dijkstra's Shunting Yard Algoirthm","Dijkstra's Shunting Yard Algorithm","Dijkstra's Shunting Yard algorithm","Dijkstra's Shunting yard","Dijkstra's Shunting-Yard algorithm","Dijkstra's rangering værftet algoritme","Dijkstra's shunting yard Algorithm","Dijkstra's shunting yard algorithm","Dijkstra's shunting-yard algorithm","Dijkstra's “Shunting-Yard Algorithm”","Dijkstra-Algorithmus Rangierbahnhof","Dijkstra的调度场算法","Dijkstrin algoritam","Dijkstrův algoritmus posunovací dvoře","Djikistra's 'shunting yard' algorithm","Edger Dijkstra's Shunting Yard algorithm","Fascio di smistamento","Help2","Hurf durf.","Idea 2 (len pre prevod na postfix)","Järnvägsalgoritmen","Järnvägsalgoritmen - Wikipedia","L'algorithme de cour de triage","L'algoritmo di cantiere di manovra","Learn about Shunting-yard algorithm>>>","Manewrowanie algorytm Yard","Manewrowanie-yard algorytm","Manobras Yard Algoritmo","Manovra Yard Algorithm","Patio de maniobras Algoritmo de","Patio de maniobras algoritmo","Posunovací Yard algoritmus","Posunovací-yard algoritmus","Pátio de manobras","Rangeerterrein algoritme","Rangering-yard algoritme","Rangierbahnhof Algorithm","Rangierbahnhof Algorithmus","Rangierbahnhof Algorithmus Dijkstra","Rangierbahnhof-Algorithmus","Rangieren-Yard-Algorithmus","Shunning Yard Algorithmus","Shunting -yard algorithm - Wikipedia, the free encyclopedia","Shunting Algorithm","Shunting Yard","Shunting Yard (調車場)演算法","Shunting Yard ALgorithm","Shunting Yard Algorithm","Shunting Yard Algorithm write up on Wikipedia","Shunting Yard Algorithm writeup on wikipedia","Shunting Yard Algorithm.","Shunting Yard Algorithmus","Shunting Yard Thuật toán","Shunting Yard algorithm","Shunting Yard algoritma","Shunting Yard parser","Shunting Yard-Algorithmus","Shunting algorithm","Shunting algorithm in detail","Shunting thuật toán Yard","Shunting yard Algorithmus","Shunting yard algorithm - Wikipedia, the free encyclopedia","Shunting yard algorithm Wikipedia the free encyclopedia","Shunting yard算法","Shunting 경시청 알고리즘","Shunting 경시청과","Shunting 야드 알고리즘","Shunting-Hall","Shunting-Yard","Shunting-Yard Algorithm","Shunting-Yard Algorithmus","Shunting-Yard algorithm","Shunting-Yard-Algorithmus","Shunting-yard","Shunting-yard (algoritmus)","Shunting-yard (algoritmus) - Wikipedie","Shunting-yard Algorithm","Shunting-yard algorithm","Shunting-yard algorithm - Wikipedia :: The free encyclopedia","Shunting-yard algorithm - Wikipedia, the free encyclopedia","Shunting-yard algorithm - Wikipedia, the free encyclopedia ...","Shunting-yard algorithm - Wikipedia, the free encyclopedia http","Shunting-yard algorithm.","Shunting-yard algoritmen","Shunting-yard algoritmus","Shunting-yard-Algorithmus","Shunting-yard-algoritmi","Shunting-yard_algorithm","Shunting_yard_algorithm","Shuntingyard algorithm","Shuntingyard von Dijkstra","Source Wikipedia.org Arcticle - Shunting-yard algorithm","The Shunting Yard Algorithm","The Shunting yard algorithm","The Shunting-Yard Algorithm","The algorithm in detail","The method from Wikipedia","Wikipedia article Algoritmo shunting yard","Wikipedia article Järnvägsalgoritmen","Wikipedia article Shunting yard algorithm","Wikipedia article Shunting-yard algorithm","Wikipedia article on Algoritmo shunting yard","Wikipedia article on Shunting yard algorithm","Wikipedia article on Shunting-yard algorithm","Wikipedia article on the Shunting Yard Algorithm for","Wikipedia on Dijkstra's shunting-yard algorithm","Wikipedia/Shunting-yard algorithm","Wikipedia: Shunting Yard Alg.","Wikipedia: Shunting Yard Algorithm","Yard Smistamento algoritmo","Yard de manoeuvre algorithme","Yardas algoritmo de maniobras","algoritmo Shunting Yard (Dijkstra)","algoritmo Shunting-Yard","algoritmo de cambio de vías","algoritmo de derivación","algoritmo de estação de triagem","algoritmo de maniobras Yard","algoritmo de patio de maniobras","algoritmo di manovra-cantiere","algoritmo di smistamento","algoritmo shunting yard","algoritmo smistamento","algorytm stoczni manewrowych","algorytmu manewrowych","algorytmu przetaczanie-stoczni","algorytmu stoczni manewrowego","convert it to reverse polish notation","cs:Shunting-yard (algoritmus)","di manovra algoritmo di Dijkstra cantiere","dvoře algoritmus posunu","en.wikipedia.org/...Shunting-yard_algorithm","en.wikipedia.org/wiki/Shunt...","en.wikipedia.org/wiki/Shunting-yard_a...","en.wikipedia.org/wiki/Shunting-yard_algorithm","en.wikipedia.org/wiki/Shunting_yard_algorithm","en:Shunting-yard_algorithm","fascio di smistamento Algorithm","halaman shunting algoritma","http://cs.wikipedia.org/wiki/Shunting-yard_%28algoritmus","http://cs.wikipedia.org/wiki/Shunting-yard_(algoritmus","http://de.wikipedia.org/wiki/Shunting-yard-Algorithmus","http://en.wikipedia....-yard_algorithm","http://en.wikipedia...._yard_algorithm","http://en.wikipedia.org/wiki/S[...]orithm#The_algorithm_in_detail","http://en.wikipedia.org/wiki/Shunting-y ... conversion","http://en.wikipedia.org/wiki/Shunting-yard_","http://en.wikipedia.org/wiki/Shunting-yard_algorithm","http://en.wikipedia.org/wiki/Shunting-yard_algorithm#C_example","http://en.wikipedia.org/wiki/Shunting-yard_algorithm.","http://en.wikipedia.org/wiki/Shunting-ya…","http://en.wikipedia.org/wiki/Shunting_yard_algor …","http://en.wikipedia.org/wiki/Shunting_yard_algorithm","http://en.wikipedia.org/wiki/Shunting_yard_algorithm#The_algorithm_in_detail","http://en.wikipedia.org/wiki/Shunting_yard_algorithm>","http://en.wikipedia.org/wiki/Shunting_ya…","http://en.wikipedia.org/wiki/​Shunting_yard_algorithm","http://es.wikipedia.org/wiki/Algoritmo_shunting_yard","infix-to-postfix algorithm","l'algoritmo di manovra-yard","luntata Wikipediasta","maniobras yardas algoritmo","manobras Yard Algorithm","manovra-cantiere Algoritmo","manœuvre algorithme de triage Dijkstra","manœuvre de triage algorithme","o tal algoritmo do Dijkstra","patio de maniobras algoritmo","patio de maniobras algoritmo de Dijkstra","posunování Yard","posunování-yard algoritmus","pro posunování Yard algoritmus","przetaczanie Algorytm Yard","przetaczanie Yard","przetaczanie-yard algorytm","railroad switching algorithm","rangeerterrein Algorithm","rangeerterrein algoritme","rangeerterrein algoritme Dijkstra","rangerbanegård","rangerbanegård Algoritme","rangerbanegård algoritme","rangerbanegård algoritmen","rangering-værftet algoritme","rangering-yard algoritme","shunt quintal algoritmo Dijkstra","shunting - यार्ड एल्गोरिथ्म","shunting Yard Algoritma","shunting algorithm","shunting algorithm bakuran","shunting yard algorithm","shunting yard algorithm @wikipedia","shunting yard algorithm,","shunting yard algorithm.","shunting yard-algorithm","shunting गज एल्गोरिथ्म","shunting यार्ड","shunting यार्ड एलगोरिदम","shunting 마당 알고리즘이","shunting-yard","shunting-yard algorithm","smistamento Yard","smistamento cortile algoritmo di Dijkstra","standard algorithm to convert an infix expression into","sv:Järnvägsalgoritmen","the shunting yard algorithm","this one seemed terribly easy","this wikipedia article on how to deal with","thuật toán sân shunting","ttp://en.wikipedia.org/wiki/Shunting_yard_algorithm","velmi triviálním způsobem","w stoczni manewrowych algorytm Dijkstra","wiki: Shunting-yard algorithm","wp:Shunting-yard_algorithm","yard algorithm","yardas algoritmo de maniobras","Алгоритм сортировочной станции","Алгоритм сортировочной станции — Википедия","Маневровый","Маневровый дворе алгоритм","Маневровый ярдов алгоритм","Сортировочная станция алгоритма","Ярд алгоритм маневровые","алгоритм дворе шунтирования","алгоритм сортировочной станции","алгоритм шунтирования","двор алгоритм маневровых","маневровые дворе алгоритм","сортировочная станция алгоритм","сортировочная станция алгоритм Дейкстры","сортировочной станции Дейкстры Алгоритм","การ แบ่ง บ้าน","การแบ่ง Yard Algorithm","ขั้น ตอน วิธี การ แบ่ง บ้าน","ขั้น ตอน วิธี การ แบ่ง หลา","“調度場演算法”","シャントヤードのアルゴリズムを","シャントヤードアルゴリズム","ダイクストラの操車場のアルゴリズムは、","使用分流","和调","操車場のアルゴリズム","操車場のアルゴリズムは、","操車場のアルゴリズムダイクストラは、","操車場アルゴリズム","操車場アルゴリズムを","旁路码算法","調車場的算法","調車場算法","调度场算法","调度场算法- 维基百科，自由的百科全书","调码的算法","调车场","调车场的Dijkstra算法","调车场的算法","调车场算法","알고리즘 Shunting 경시청"],"name":"Shunting-yard algorithm","categories":["All articles lacking in-text citations","Articles lacking in-text citations from August 2013","Dutch inventions","Parsing algorithms"],"tag_line":"In computer science, the shunting-yard algorithm is a method for parsing mathematical expressions specified in infix notation."}}
,{"_index":"throwtable","_type":"algorithm","_id":"simple-lr-parser","_score":0,"_source":{"description":"In computer science, a Simple LR or SLR parser is a type of LR parser with small parse tables and a relatively simple parser generator algorithm. As with other types of LR(1) parser, an SLR parser is quite efficient at finding the single correct bottom-up parse in a single left-to-right scan over the input stream, without guesswork or backtracking. The parser is mechanically generated from a formal grammar for the language.\nSLR and the more-general methods LALR parser and Canonical LR parser have identical methods and similar tables at parse time; they differ only in the mathematical grammar analysis algorithms used by the parser generator tool. SLR and LALR generators create tables of identical size and identical parser states. SLR generators accept fewer grammars than do LALR generators like yacc and Bison. Many computer languages don't readily fit the restrictions of SLR, as is. Bending the language's natural grammar into SLR grammar form requires more compromises and grammar hackery. So LALR generators have become much more widely used than SLR generators, despite being somewhat more complicated tools. SLR methods remain a useful learning step in college classes on compiler theory.\nSLR and LALR were both developed by Frank DeRemer as the first practical uses of Donald Knuth's LR parser theory. The tables created for real grammars by full LR methods were impractically large, larger than most computer memories of that decade, with 100 times or more parser states than the SLR and LALR methods.","alt_names":["- SLR parser :","- Simple LR parser :","-> Read the article about 'Simple LR parser'","...more on Wikipedia about Simple LR parser","Learn about Simple LR parser>>>","Parser SLR","Parser SLR - Wikipedia","SLR (Simple LR) parser","SLR Parser","SLR Parsing","SLR analizator - Википедија","SLR approach","SLR parser","SLR parser; it is used under the","SLR 法","SLR(1)","SLR(?)","SLR(???)","SLR1","SLR_parser","Simple LR (SLR) parser","Simple LR parser","Simple LR parser - Wikipedia, the free encyclopedia","Simple LR parser - Wikipedia, the free encyclopedia ...","Simple LR parser Wikipedia, the free ...","Simple LR parser on wikipedia.org","Simple LR parser – Wikipedia, the free encyclopedia","Simple LR parsers","Simple Lr Parser","Simple_LR_parser","What is algorithm of Simple LR parser","Wikipedia article SLR parser","Wikipedia article Simple LR parser","Wikipedia article on SLR parser","Wikipedia entry for Simple LR parser","Wikipedia l'articolo Simple LR parser","Wikipedia:Simple_LR_parser","Wikipediaで「単純LR法」を調べる","article Simple LR parser","en.wikipedia.org/...Simple_LR_parser","http://en.wikipedia.org/wiki/SLR_parser","http://en.wikipedia.org/wiki/Simple LR parser","http://en.wikipedia.org/wiki/Simple_LR_p","http://en.wikipedia.org/wiki/Simple_LR_parser","http://en.wikipedia.org/wiki/Simple_LR_pa…","http://en.wikipedia.org/wiki/Simple_LR_p…","http://it.wikipedia.org/wiki/Parser_SLR","http://pl.wikipedia.org/wiki/Parser_SLR","it:Parser SLR","ja:単純LR法","pl:Parser SLR","simple LR parser","simple LR parsers","simple general LR parser as described in the","sr:SLR analizator","محلل بسيط من اليسار إلى اليم...","محلل بسيط من اليسار إلى اليمين - ويكيبيديا، الموسوعة","単純LR法","単純LR法 - Wikipedia","単純LR法とは？ (Wikipediaへのリンク)"],"name":"Simple LR parser","categories":["All articles lacking sources","All articles with unsourced statements","Articles lacking sources from December 2012","Articles with unsourced statements from January 2015","Articles with unsourced statements from June 2012","Parsing algorithms"],"tag_line":"In computer science, a Simple LR or SLR parser is a type of LR parser with small parse tables and a relatively simple parser generator algorithm."}}
]
