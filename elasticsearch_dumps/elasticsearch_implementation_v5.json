[
{"_index":"throwtable","_type":"implementation","_id":"rosetta:color-quantization:J","_score":0,"_source":{"implementation":[{"content":"kmcL=:4 :0\n  C=. /:~ 256 #.inv ,y  NB. colors\n  G=. x (i.@] <.@* %) #C  NB. groups (initial)\n  Q=. _  NB. quantized list of colors (initial\n  whilst.-. Q-:&<.&(x&*)Q0 do.\n    Q0=. Q\n    Q=. /:~C (+/ % #)/.~ G\n    G=. (i. <./)\"1 C +/&.:*: .- |:Q\n  end.Q\n)","type":"code"},{"content":"   16 kmcL img\n7.52532 22.3347  0.650468\n8.20129 54.4678 0.0326828\n33.1132 69.8148  0.622265\n54.2232 125.682   2.67713\n56.7064 99.5008   3.04013\n61.2135  136.42    4.2015\n68.1246 140.576   6.37512\n74.6006 143.606   7.57854\n78.9101 150.792   10.2563\n89.5873 148.621   14.6202\n98.9523 154.005   25.7583\n114.957 159.697   47.6423\n145.816 178.136   33.8845\n164.969 199.742   67.0467\n179.849 207.594   109.973\n209.229  221.18   204.513","type":"code"}],"source":"rosetta","code_keywords":{"Token.Comment.Single":null},"algorithm":["color-quantization"],"language":"J"}}
,{"_index":"throwtable","_type":"implementation","_id":"rosetta:deepcopy:Aime","_score":0,"_source":{"implementation":[{"content":"list L1, L2;\n\n# Lists are heterogeneous:\nl_append(L1, 3);\nl_append(L1, \"deep\");\n\n# and may contain self references.\n# A self references in the last position:\nl_link(L1, -1, L1);\n\n# List may also contain mutual references.\n# Create a new list in the last position:\nl_n_list(L1, -1);\n# Add a reference to the top level list to the nested list:\nl_link(l_q_list(L1, -1), -1, L1);\n\n# There are no limitations to the deep copy method:\nl_copy(L2, L1);\n\n# Modify the string in the original list,\n# via the self reference in the 3rd position\nl_r_text(l_q_list(L1, 2), 1, \"copy\");\n\n# Show the string in the two lists:\no_text(l_query(L2, 1));\no_text(l_query(L1, 1));\no_byte('\\n');\n\n# And again, via the included self references:\no_text(l_query(l_query(L2, 2), 1));\no_text(l_query(l_query(L1, 2), 1));\no_byte('\\n');","type":"code"}],"source":"rosetta","code_keywords":{"Token.Comment.Single":null},"algorithm":["object-copying"],"language":"Aime"}}
,{"_index":"throwtable","_type":"implementation","_id":"rosetta:deepcopy:C#","_score":0,"_source":{"implementation":[{"content":"using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tclass MyClass : ICloneable\n\t\t{\n\t\t\tpublic MyClass() { f = new int[3]{2,3,5}; c = '1'; }\n\t\t\t\n\t\t\tpublic object Clone()\n\t\t\t{\t\t\t\t\n\t\t\t\tMyClass cpy = (MyClass) this.MemberwiseClone();\n\t\t\t\tcpy.f = (int[]) this.f.Clone();\t\t\t\n\t\t\t\treturn cpy;\n\t\t\t}\n\t\t\t\n\t\t\tpublic char c;\n\t\t\tpublic int[] f;\n\t\t}\n\t\t\n\t\tpublic static void Main( string[] args )\n\t\t{\n\t\t\tMyClass c1 = new MyClass();\n\t\t\tMyClass c2 = (MyClass) c1.Clone();\n\t\t}\n\t}\n}","type":"code"}],"source":"rosetta","code_keywords":{},"algorithm":["object-copying"],"language":"C#"}}
,{"_index":"throwtable","_type":"implementation","_id":"rosetta:color-quantization:Mathematica","_score":0,"_source":{"implementation":[{"content":"ColorQuantize[Import[\"http://rosettacode.org/mw/images/3/3f/Quantum_frog.png\"],16,Dithering->False]","type":"code"}],"source":"rosetta","code_keywords":{},"algorithm":["color-quantization"],"language":"Mathematica"}}
,{"_index":"throwtable","_type":"implementation","_id":"rosetta:deepcopy:AutoHotkey","_score":0,"_source":{"implementation":[{"content":"DeepCopy(Array, Objs=0)\n{\n    If !Objs\n        Objs := Object()\n    Obj := Array.Clone() ; produces a shallow copy in that any sub-objects are not cloned\n    Objs[&Array] := Obj ; Save this new array - & returns the address of Array in memory\n    For Key, Val in Obj\n        If (IsObject(Val)) ; If it is a subarray\n            Obj[Key] := Objs[&Val] ; If we already know of a reference to this array\n            ? Objs[&Val] ; Then point it to the new array (to prevent infinite recursion on self-references\n            : DeepCopy(Val,Objs) ; Otherwise, clone this sub-array\n    Return Obj\n}","type":"code"}],"source":"rosetta","code_keywords":{},"algorithm":["object-copying"],"language":"AutoHotkey"}}
,{"_index":"throwtable","_type":"implementation","_id":"rosetta:color-quantization:PureBasic","_score":0,"_source":{"implementation":[{"content":"\n; ColorQuantization.pb\n\nStructure bestA_ ; table for our histogram\nnn.i ; 16,32,...\nrc.i ; red   count within (0,1,...,255)/(number of colors)\ngc.i ; green count within (0,1,...,255)/(number of colors)\nbc.i ; blue  count within (0,1,...,255)/(number of colors)\nEndStructure\n\n; these two functions appear to be rather self-explanatory\nUsePNGImageDecoder()\nUsePNGImageEncoder()\n\nProcedure.i ColorQuantization(Filename$,ncol)\nProtected x,y,c\n\n; load our original image or leave the procedure\nIf not LoadImage(0,Filename$)      :ProcedureReturn 0:endif\n\n; we are not going to actually draw on the original image...\n; but we need to use the drawing library to load up\n; the pixel information into our arrays...\n; if we can't do that, what's the point of going any further?\n; so then we would be wise to just leave the procedure [happy fred?]\nIf not StartDrawing(ImageOutput(0)):ProcedureReturn 0:endif\n\niw=ImageWidth(0)\nih=ImageHeight(0)\n\ndim cA(iw,ih) ; color array to hold at a given (x,y)\ndim rA(iw,ih) ; red   array to hold at a given (x,y)\ndim gA(iw,ih) ; green array to hold at a given (x,y)\ndim bA(iw,ih) ; blue  array to hold at a given (x,y)\ndim tA(iw,ih) ; temp  array to hold at a given (x,y)\n\n; map each pixel from the original image to our arrays\n; don't overrun the ranges ie. use {ih-1,iw-1}\nfor y=0 to ih-1\n  for x=0 to iw-1\n  c = Point(x,y)\n  cA(x,y)=c\n  rA(x,y)=Red(c)\n  gA(x,y)=Green(c)\n  bA(x,y)=Blue(c)\n  next \nnext \n\nStopDrawing() ; don't forget to... StopDrawing()\n\nN=ih*iw\n; N is the total number if pixels\nif not N:ProcedureReturn 0:endif ; to avoid a division by zero\n\n; stuctured array ie. a table to hold the frequency distribution\ndim bestA.bestA_(ncol)\n\n; the \"best\" red,green,blue based upon frequency \ndim rbestA(ncol/3)\ndim gbestA(ncol/3)\ndim bbestA(ncol/3)\n\n; split the (0..255) range up\nxoff=256/ncol   ;256/16=16\nxrng=xoff       ;xrng=16\n\n; store these values in our table: bestA(i)\\nn= 16,32,...\nfor i=1 to ncol\nxrng+xoff\nbestA(i)\\nn=xrng\nnext \n\n; scan by row [y] \nfor y=0 to ih-1\n; scan by col [x] \nfor x=0 to iw-1\n\n; retrieve the rgb values from each pixel \nr=rA(x,y)\ng=gA(x,y)\nb=bA(x,y)\n\n; sum up the numbers that fall within our subdivisions of (0..255)\nfor i=1 to ncol\nif r>=bestA(i)\\nn and r<bestA(i+1)\\nn:bestA(i)\\rc+1:endif\nif g>=bestA(i)\\nn and g<bestA(i+1)\\nn:bestA(i)\\gc+1:endif\nif b>=bestA(i)\\nn and b<bestA(i+1)\\nn:bestA(i)\\bc+1:endif\nnext \nnext \nnext \n\n; option and type to: Sort our Structured Array\nopt=#PB_Sort_Descending\ntyp=#PB_Sort_Integer\n\n; sort to get most frequent reds\noff=OffsetOf(bestA_\\rc)\nSortStructuredArray(bestA(),opt, off, typ,1, ncol)\n\n; save the best [ for number of colors =16 this is int(16/3)=5 ] reds\nfor i=1 to ncol/3\nrbestA(i)=bestA(i)\\nn\nnext\n\n; sort to get most frequent greens\noff=OffsetOf(bestA_\\gc)\nSortStructuredArray(bestA(),opt, off, typ,1, ncol)\n\n; save the best [ for number of colors =16 this is int(16/3)=5 ] greens\nfor i=1 to ncol/3\ngbestA(i)=bestA(i)\\nn\nnext\n\n; sort to get most frequent blues\noff=OffsetOf(bestA_\\bc)\nSortStructuredArray(bestA(),opt, off, typ,1, ncol)\n\n; save the best [ for number of colors =16 this is int(16/3)=5 ] blues\nfor i=1 to ncol/3\nbbestA(i)=bestA(i)\\nn\nnext\n\n; reset the best low value to 15 and high value to 240\n; this helps to ensure there is some contrast when the statistics bunch up\n; ie. when a single color tends to predominate... such as perhaps green?\nrbestA(1)=15:rbestA(ncol/3)=240\ngbestA(1)=15:gbestA(ncol/3)=240\nbbestA(1)=15:bbestA(ncol/3)=240\n\n; make a copy of our original image or leave the procedure\nIf not CopyImage(0,1)              :ProcedureReturn 0:endif\n\n; draw on that copy of our original image or leave the procedure\nIf not StartDrawing(ImageOutput(1)):ProcedureReturn 0:endif\n\nfor y=0 to ih-1\nfor x=0 to iw-1\nc = Point(x,y)\n\n; get the rgb value from our arrays\nrt=rA(x,y)\ngt=gA(x,y)\nbt=bA(x,y)\n\n; given a particular red value say 123 at point x,y\n; which of our rbestA(i's) is closest?\n; then for green and blue?\n; ==============================\nr=255\nfor i=1 to ncol/3\nrdiff=abs(rbestA(i)-rt)\nif rdiff<=r:ri=i:r=rdiff:endif\nnext\n\ng=255\nfor i=1 to ncol/3\ngdiff=abs(gbestA(i)-gt)\nif gdiff<=g:gi=i:g=gdiff:endif\nnext\n\nb=255\nfor i=1 to ncol/3\nbdiff=abs(bbestA(i)-bt)\nif bdiff<=b:bi=i:b=bdiff:endif\nnext\n; ==============================\n\n\n; get the color value so we can plot it at that pixel\nColor=RGB(rbestA(ri),gbestA(gi),bbestA(bi))\n\n; plot it at that pixel\nPlot(x,y,Color)\n\n; save that info to tA(x,y) for our comparison image \ntA(x,y)=Color\n\nnext \nnext \nStopDrawing() ; don't forget to... StopDrawing()\n\n; create a comparison image of our original vs 16-color or leave the procedure\nIf not CreateImage(2,iw*2,ih)      :ProcedureReturn 0:endif\n; draw on that image both our original image and our 16-color image or leave the procedure\nIf not StartDrawing(ImageOutput(2)):ProcedureReturn 0:endif\n\n; plot original image\n; 0,0 .... 511,0\n; .\n; .\n; 511,0 .. 511,511\nfor y=0 to ih-1\n  for x=0 to iw-1\n  c = cA(x,y)\n  Plot(x,y,c)\n  next \n  next \n\n; plot 16-color image to the right of original image\n; 512,0 .... 1023,0\n; .\n; .\n; 512,511 .. 1023,511\nfor y=0 to ih-1\n  for x=0 to iw-1\n  c = tA(x,y)\n  Plot(x+iw,y,c)\n  next \n  next \n\nStopDrawing() ; don't forget to... StopDrawing()\n\n; save the single 16-color image\nSaveImage(1, \"_single_\"+str(ncol)+\"_\"+Filename$,#PB_ImagePlugin_PNG )\n\n; save the comparison image\nSaveImage(2, \"_compare_\"+str(ncol)+\"_\"+Filename$,#PB_ImagePlugin_PNG )\nProcedureReturn 1\nEndProcedure\n\nColorQuantization(\"Quantum_frog.png\",16)\n\n\n","type":"code"}],"source":"rosetta","code_keywords":{"Token.Comment.Single":null,"Token.Text":null},"algorithm":["color-quantization"],"language":"PureBasic"}}
,{"_index":"throwtable","_type":"implementation","_id":"rosetta:deepcopy:Babel","_score":0,"_source":{"implementation":[{"content":"((main {foo cp bs2gv <<})\n(foo (foo bar baz))\n(bar (foo bar baz))\n(baz (foo bar baz)))","type":"code"}],"source":"rosetta","code_keywords":{},"algorithm":["object-copying"],"language":"Babel"}}
,{"_index":"throwtable","_type":"implementation","_id":"rosetta:color-quantization:Racket","_score":0,"_source":{"implementation":[{"content":"\n#lang racket/base\n(require racket/class\n         racket/draw)\n\n;; This is an implementation of the Octree Quantization algorithm.  This implementation \n;; follows the sketch in:\n;;\n;; Dean Clark.  Color Quantization using Octrees.  Dr. Dobbs Portal, January 1, 1996.\n;; http://www.ddj.com/184409805\n;;\n;; This code is adapted from the color quantizer in the implementation of Racket's\n;; file/gif standard library.\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n;; To view an example of the quantizer, run the following test submodule\n;; in DrRacket:\n(module+ test\n  (require racket/block net/url)\n  \n  (define frog \n    (block\n      (define url (string->url \"http://rosettacode.org/mw/images/3/3f/Quantum_frog.png\"))\n      (define frog-ip (get-pure-port url))\n      (define bitmap (make-object bitmap% frog-ip))\n      (close-input-port frog-ip)\n      bitmap))\n\n  ;; Display the original:\n  (print frog)\n  ;; And the quantized version (16 colors):\n  (print (quantize-bitmap frog 16)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n;; quantize-bitmap: bitmap positive-number -> bitmap\n;; Given a bitmap, returns a new bitmap quantized to, at most, n colors.\n(define (quantize-bitmap bm n)\n  (let* ([width (send bm get-width)]\n         [height (send bm get-height)]\n         [len (* width height 4)]\n         [source-buffer (make-bytes len)]\n         [_ (send bm get-argb-pixels 0 0 width height source-buffer)]\n         [an-octree (make-octree-from-argb source-buffer n)]\n         [dest-buffer (make-bytes len)])\n    (let quantize-bitmap-loop ([i 0])\n      (when (< i len)\n        (let* ([i+1 (+ i 1)]\n               [i+2 (+ i 2)]\n               [i+3 (+ i 3)]\n               [a (bytes-ref source-buffer i)]\n               [r (bytes-ref source-buffer i+1)]\n               [g (bytes-ref source-buffer i+2)]\n               [b (bytes-ref source-buffer i+3)])\n          (cond\n            [(alpha-opaque? a)\n             (let-values ([(new-r new-g new-b)\n                           (octree-lookup an-octree r g b)])\n               (bytes-set! dest-buffer i 255)\n               (bytes-set! dest-buffer i+1 new-r)\n               (bytes-set! dest-buffer i+2 new-g)\n               (bytes-set! dest-buffer i+3 new-b))]\n            [else\n             (bytes-set! dest-buffer i 0)\n             (bytes-set! dest-buffer i+1 0)\n             (bytes-set! dest-buffer i+2 0)\n             (bytes-set! dest-buffer i+3 0)]))\n        (quantize-bitmap-loop (+ i 4))))\n    (let* ([new-bm (make-object bitmap% width height)]\n           [dc (make-object bitmap-dc% new-bm)])\n      (send dc set-argb-pixels 0 0 width height dest-buffer)\n      (send dc set-bitmap #f)\n      new-bm)))\n\n\n\n\n\n;; make-octree-from-argb: bytes positive-number -> octree\n;; Constructs an octree ready to quantize the colors from an-argb.\n(define (make-octree-from-argb an-argb n)\n  (unless (> n 0)\n    (raise-type-error 'make-octree-from-argb \"positive number\" n))\n  (let ([an-octree (new-octree)]\n        [len (bytes-length an-argb)])\n    (let make-octree-loop ([i 0])\n      (when (< i len)\n        (let ([a (bytes-ref an-argb i)]\n              [r (bytes-ref an-argb (+ i 1))]\n              [g (bytes-ref an-argb (+ i 2))]\n              [b (bytes-ref an-argb (+ i 3))])\n          (when (alpha-opaque? a)\n            (octree-insert-color! an-octree r g b)\n            (let reduction-loop ()\n              (when (> (octree-leaf-count an-octree) n)\n                (octree-reduce! an-octree)\n                (reduction-loop)))))\n        (make-octree-loop (+ i 4))))\n    (octree-finalize! an-octree)\n    an-octree))\n\n\n;; alpha-opaque? byte -> boolean\n;; Returns true if the alpha value is considered opaque.\n(define (alpha-opaque? a)\n  (>= a 128))\n\n\n\n;; The maximum level height of an octree.\n(define MAX-LEVEL 7)\n\n\n\n;; A color is a (vector byte byte byte)\n\n;; An octree is a:\n(define-struct octree (root            ; node\n                       leaf-count      ; number\n                       reduction-heads ; (vectorof (or/c node #f))\n                       palette)        ; (vectorof (or/c color #f))\n  #:mutable)\n;; reduction-heads is used to accelerate the search for a reduction candidate.\n\n\n;; A subtree node is a:\n(define-struct node (leaf?          ; bool\n                     npixels        ; number  -- number of pixels this subtree node represents\n                     redsum         ; number\n                     greensum       ; number\n                     bluesum        ; number\n                     children       ; (vectorof (or/c #f node))\n                     next           ; (or/c #f node)\n                     palette-index) ; (or/c #f byte?)\n  #:mutable)\n;; node-next is used to accelerate the search for a reduction candidate.\n\n\n;; new-octree: -> octree\n(define (new-octree)\n  (let* ([root-node (make-node #f ;; not a leaf\n                               0  ;; no pixels under us yet\n                               0  ;; red sum\n                               0  ;; green sum\n                               0  ;; blue sum\n                               (make-vector 8 #f) ;; no children so far\n                               #f ;; next\n                               #f ;; palette-index\n                               )]\n         [an-octree\n          (make-octree root-node\n                       0 ; no leaves so far\n                       (make-vector (add1 MAX-LEVEL) #f) ; no reductions so far\n                       (make-vector 256 #(0 0 0)))])        ; the palette\n    ;; Although we'll almost never reduce to this level, initialize the first\n    ;; reducible node to the root, for completeness sake.\n    (vector-set! (octree-reduction-heads an-octree) 0 root-node)\n    an-octree))\n\n\n;; rgb->index: natural-number byte byte byte -> octet\n;; Given a level and an (r,g,b) triplet, returns an octet that can be used\n;; as an index into our octree structure.\n(define (rgb->index level r g b)\n  (bitwise-ior (bitwise-and 4 (arithmetic-shift r (- level 5)))\n               (bitwise-and 2 (arithmetic-shift g (- level 6)))\n               (bitwise-and 1 (arithmetic-shift b (- level 7)))))\n\n\n;; octree-insert-color!: octree byte byte byte -> void\n;; Accumulates a new r,g,b triplet into the octree.\n(define (octree-insert-color! an-octree r g b)\n  (node-insert-color! (octree-root an-octree) an-octree r g b 0))\n\n\n;; node-insert-color!: node octree byte byte byte natural-number -> void\n;; Adds a color to the node subtree.  While we hit #f, we create new nodes.\n;; If we hit an existing leaf, we accumulate our color into it.\n(define (node-insert-color! a-node an-octree r g b level)\n  (let insert-color-loop ([a-node a-node]\n                          [level level])\n    (cond [(node-leaf? a-node)\n           ;; update the leaf with the new color\n           (set-node-npixels! a-node (add1 (node-npixels a-node)))\n           (set-node-redsum! a-node (+ (node-redsum a-node) r))\n           (set-node-greensum! a-node (+ (node-greensum a-node) g))\n           (set-node-bluesum! a-node (+ (node-bluesum a-node) b))]\n          [else\n           ;; create the child node if necessary\n           (let ([index (rgb->index level r g b)])\n             (unless (vector-ref (node-children a-node) index)\n               (let ([new-node (make-node (= level MAX-LEVEL) ; leaf?\n                                          0  ; npixels\n                                          0  ; redsum\n                                          0  ; greensum\n                                          0  ; bluesum\n                                          (make-vector 8 #f) ; no children yet\n                                          #f ; and no next node yet\n                                          #f ; or palette index\n                                          )])\n                 (vector-set! (node-children a-node) index new-node)\n                 (cond\n                   [(= level MAX-LEVEL)\n                    ;; If we added a leaf, mark it in the octree.\n                    (set-octree-leaf-count! an-octree\n                                            (add1 (octree-leaf-count an-octree)))]\n                   [else\n                    ;; Attach the node as a reducible node if it's interior.\n                    (set-node-next!\n                     new-node (vector-ref (octree-reduction-heads an-octree)\n                                          (add1 level)))\n                    (vector-set! (octree-reduction-heads an-octree) \n                                 (add1 level)\n                                 new-node)])))\n             ;; and recur on the child node.\n             (insert-color-loop (vector-ref (node-children a-node) index) \n                                (add1 level)))])))\n\n\n;; octree-reduce!: octree -> void\n;; Reduces one of the subtrees, collapsing the children into a single node.\n(define (octree-reduce! an-octree)\n  (node-reduce! (pop-reduction-candidate! an-octree) an-octree))\n\n\n;; node-reduce!: node octree -> void\n;; Reduces the interior node.\n(define (node-reduce! a-node an-octree)\n  (for ([child (in-vector (node-children a-node))]\n        #:when child)\n    (set-node-npixels! a-node (+ (node-npixels a-node)\n                                 (node-npixels child)))\n    (set-node-redsum! a-node (+ (node-redsum a-node)\n                                (node-redsum child)))\n    (set-node-greensum! a-node (+ (node-greensum a-node)\n                                  (node-greensum child)))\n    (set-node-bluesum! a-node (+ (node-bluesum a-node)\n                                 (node-bluesum child)))\n    (set-octree-leaf-count! an-octree (sub1 (octree-leaf-count an-octree))))\n  (set-node-leaf?! a-node #t)\n  (set-octree-leaf-count! an-octree (add1 (octree-leaf-count an-octree))))\n\n\n;; find-reduction-candidate!: octree -> node\n;; Returns a bottom-level interior node for reduction.  Also takes the\n;; candidate out of the conceptual queue of reduction candidates.\n(define (pop-reduction-candidate! an-octree)\n  (let loop ([i MAX-LEVEL])\n    (cond\n      [(vector-ref (octree-reduction-heads an-octree) i)\n       =>\n       (lambda (candidate-node)\n         (when (> i 0)\n           (vector-set! (octree-reduction-heads an-octree) i\n                        (node-next candidate-node)))\n         candidate-node)]\n      [else\n       (loop (sub1 i))])))\n\n\n;; octree-finalize!: octree -> void\n;; Finalization does a few things:\n;; * Walks through the octree and reduces any interior nodes with just one leaf child.\n;;   Optimizes future lookups.\n;; * Fills in the palette of the octree and the palette indexes of the leaf nodes.\n;; * Note: palette index 0 is always reserved for the transparent color.\n(define (octree-finalize! an-octree)\n  ;; Collapse one-leaf interior nodes.\n  (let loop ([a-node (octree-root an-octree)])\n    (for ([child (in-vector (node-children a-node))]\n          #:when (and child (not (node-leaf? child))))\n      (loop child)\n      (when (interior-node-one-leaf-child? a-node)\n        (node-reduce! a-node an-octree))))\n\n  ;; Attach palette entries.\n  (let ([current-palette-index 1])\n    (let loop ([a-node (octree-root an-octree)])\n      (cond [(node-leaf? a-node)\n             (let ([n (node-npixels a-node)])\n               (vector-set! (octree-palette an-octree) current-palette-index\n                            (vector (quotient (node-redsum a-node) n)\n                                    (quotient (node-greensum a-node) n)\n                                    (quotient (node-bluesum a-node) n)))\n               (set-node-palette-index! a-node current-palette-index)\n               (set! current-palette-index (add1 current-palette-index)))]\n            [else\n             (for ([child (in-vector (node-children a-node))]\n                   #:when child)\n               (loop child))]))))\n\n\n;; interior-node-one-leaf-child?: node -> boolean\n(define (interior-node-one-leaf-child? a-node)\n  (let ([child-list (filter values (vector->list (node-children a-node)))])\n    (and (= (length child-list) 1)\n         (node-leaf? (car child-list)))))\n\n\n;; octree-lookup: octree byte byte byte -> (values byte byte byte)\n;; Returns the palettized color.\n(define (octree-lookup an-octree r g b)\n  (let* ([index (node-lookup-index (octree-root an-octree) an-octree r g b 0)]\n         [vec (vector-ref (octree-palette an-octree) index)])\n    (values (vector-ref vec 0)\n            (vector-ref vec 1)\n            (vector-ref vec 2))))\n\n\n\n;; node-lookup-index: node byte byte byte natural-number -> byte\n;; Returns the palettized color index.\n(define (node-lookup-index a-node an-octree r g b level)\n  (let loop ([a-node a-node]\n             [level level])\n    (if (node-leaf? a-node)\n      (node-palette-index a-node)\n      (let ([child (vector-ref (node-children a-node) (rgb->index level r g b))])\n        (unless child\n          (error 'node-lookup-index\n                 \"color (~a, ~a, ~a) not previously inserted\"\n                 r g b))\n        (loop child (add1 level))))))\n","type":"code"}],"source":"rosetta","code_keywords":{"Token.Comment.Single":null},"algorithm":["color-quantization"],"language":"Racket"}}
,{"_index":"throwtable","_type":"implementation","_id":"rosetta:color-quantization:Haskell","_score":0,"_source":{"implementation":[{"content":"import qualified Data.ByteString.Lazy as BS\nimport qualified Data.Foldable as Fold\nimport qualified Data.List as List\nimport Data.Ord\nimport qualified Data.Sequence as Seq\nimport Data.Word\nimport System.Environment\n\nimport Codec.Picture\nimport Codec.Picture.Types\n\ntype Accessor = PixelRGB8 -> Pixel8\n\n-- Getters for pixel components, as the constructor does not\n-- provide any public ones.\nred, blue, green :: Accessor\nred   (PixelRGB8 r _ _) = r\ngreen (PixelRGB8 _ g _) = g\nblue  (PixelRGB8 _ _ b) = b\n\n-- Get all of the pixels in the image in list form.\ngetPixels :: Pixel a => Image a -> [a]\ngetPixels image =\n  [pixelAt image x y\n  | x <- [0..(imageWidth image - 1)]\n  , y <- [0..(imageHeight image - 1)]]\n\n-- Compute the color-space extents of a list of pixels.\nextents :: [PixelRGB8] -> (PixelRGB8, PixelRGB8)\nextents pixels = (extent minimum, extent maximum)\n  where\n    bound f g = f $ map g pixels\n    extent f  = PixelRGB8 (bound f red) (bound f green) (bound f blue)\n\n-- Compute the average value of a list of pixels.\naverage :: [PixelRGB8] -> PixelRGB8\naverage pixels = PixelRGB8 (avg red) (avg green) (avg blue)\n  where\n    len   = toInteger $ length pixels\n    avg c = fromIntegral $ (sum $ map (toInteger . c) pixels) `div` len\n\n-- Perform a componentwise pixel operation.\ncompwise :: (Word8 -> Word8 -> Word8) -> PixelRGB8 -> PixelRGB8 -> PixelRGB8\ncompwise f (PixelRGB8 ra ga ba) (PixelRGB8 rb gb bb) =\n  PixelRGB8 (f ra rb) (f ga gb) (f ba bb)\n\n-- Compute the absolute difference of two pixels.\ndiffPixel :: PixelRGB8 -> PixelRGB8 -> PixelRGB8\ndiffPixel = compwise (\\x y -> max x y - min x y)\n\n-- Compute the Euclidean distance squared between two pixels.\ndistPixel :: PixelRGB8 -> PixelRGB8 -> Integer\ndistPixel x y = (rr ^ 2) + (gg ^ 2) + (bb ^ 2) \n  where\n    PixelRGB8 r g b = diffPixel x y\n    rr              = toInteger r\n    gg              = toInteger g\n    bb              = toInteger b\n\n-- Determine the dimension of the longest axis of the extents.\nlongestAccessor :: (PixelRGB8, PixelRGB8) -> Accessor\nlongestAccessor (l, h) =\n  snd $ Fold.maximumBy (comparing fst) $ zip [r, g, b] [red, green, blue]\n  where\n    PixelRGB8 r g b = diffPixel h l\n\n-- Find the index of a pixel to its respective palette.\nnearestIdx :: PixelRGB8 -> [PixelRGB8] -> Int\nnearestIdx pixel px = ans\n  where\n    Just ans = List.findIndex (== near) px\n    near     = List.foldl1 comp px\n    comp a b = if distPixel a pixel <= distPixel b pixel then a else b\n\n-- Sort a list of pixels on its longest axis and then split by the mean.\n-- It is intentional that the mean is chosen by all dimensions\n-- instead of the given one.\nmeanSplit :: [PixelRGB8] -> Accessor -> ([PixelRGB8], [PixelRGB8])\nmeanSplit l f = List.splitAt index sorted\n  where\n    sorted = List.sortBy (comparing f) l\n    index  = nearestIdx (average l) sorted\n\n-- Perform the Median Cut algorithm on an image producing\n-- an index map image and its respective palette.\nmeanCutQuant :: Image PixelRGB8 -> Int -> (Image Pixel8, Palette)\nmeanCutQuant image numRegions = (indexmap, palette)\n  where\n    extentsP p   = (p, extents p)\n    regions      = map (\\(p, e) -> (average p, e))\n                   $ search $ Seq.singleton $ extentsP $ getPixels image\n    palette      = snd $ generateFoldImage (\\(x:xs) _ _ -> (xs, x))\n                   (map fst regions) numRegions 1\n    indexmap     = pixelMap\n                   (\\pixel -> fromIntegral $ nearestIdx pixel $ map fst regions)\n                   image\n    search queue =\n      case Seq.viewl queue of\n        (pixels, extent) Seq.:< queueB ->\n          let (left, right) = meanSplit pixels $ longestAccessor extent\n              queueC        = Fold.foldl (Seq.|>) queueB $ map extentsP [left, right]\n          in if Seq.length queueC >= numRegions\n             then List.take numRegions $ Fold.toList queueC\n             else search queueC\n        Seq.EmptyL                     -> error \"Queue should never be empty.\"\n\nquantizeIO :: FilePath -> FilePath -> Int -> IO ()\nquantizeIO path outpath numRegions = do\n  dynimage <- readImage path\n  case dynimage of\n    Left err                 -> putStrLn err\n    Right (ImageRGB8 image)  -> doImage image \n    Right (ImageRGBA8 image) -> doImage (pixelMap dropTransparency image)\n    _                        -> putStrLn \"Expecting RGB8 or RGBA8 image\"\n  where\n    doImage image = do\n      let (indexmap, palette) = meanCutQuant image numRegions\n      case encodePalettedPng palette indexmap of\n        Left err      -> putStrLn err\n        Right bstring -> BS.writeFile outpath bstring\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  prog <- getProgName\n  case args of\n    [path, outpath] -> quantizeIO path outpath 16\n    _               -> putStrLn $ \"Usage: \" ++ prog ++ \" <image-file> <out-file.png>\"","type":"code"}],"source":"rosetta","code_keywords":{"Token.Text":null},"algorithm":["color-quantization"],"language":"Haskell"}}
,{"_index":"throwtable","_type":"implementation","_id":"rosetta:color-quantization:OCaml","_score":0,"_source":{"implementation":[{"content":"let rem_from rem from =\n  List.filter ((<>) rem) from\n\nlet float_rgb (r,g,b) =  (* prevents int overflow *)\n  (float r, float g, float b)\n\nlet round x =\n  int_of_float (floor (x +. 0.5))\n\nlet int_rgb (r,g,b) =\n  (round r, round g, round b)\n\nlet rgb_add (r1,g1,b1) (r2,g2,b2) =\n  (r1 +. r2,\n   g1 +. g2,\n   b1 +. b2)\n\nlet rgb_mean px_list =\n  let n = float (List.length px_list) in\n  let r, g, b = List.fold_left rgb_add (0.0, 0.0, 0.0) px_list in\n  (r /. n, g /. n, b /. n)\n\nlet extrems lst =\n  let min_rgb = (infinity, infinity, infinity)\n  and max_rgb = (neg_infinity, neg_infinity, neg_infinity) in\n  List.fold_left (fun ((sr,sg,sb), (mr,mg,mb)) (r,g,b) ->\n    ((min sr r), (min sg g), (min sb b)),\n    ((max mr r), (max mg g), (max mb b))\n  ) (min_rgb, max_rgb) lst\n\nlet volume_and_dims lst =\n  let (sr,sg,sb), (br,bg,bb) = extrems lst in\n  let dr, dg, db = (br -. sr), (bg -. sg), (bb -. sb) in\n  (dr *. dg *. db),\n  (dr, dg, db)\n\nlet make_cluster pixel_list =\n  let vol, dims = volume_and_dims pixel_list in\n  let len = float (List.length pixel_list) in\n  (rgb_mean pixel_list, len *. vol, dims, pixel_list)\n\ntype axis = R | G | B\nlet largest_axis (r,g,b) =\n  match compare r g, compare r b with\n  | 1, 1 -> R\n  | -1, 1 -> G\n  | 1, -1 -> B\n  | _ ->\n      match compare g b with\n      | 1 -> G\n      | _ -> B\n\nlet subdivide ((mr,mg,mb), n_vol_prod, vol, pixels) =\n  let part_func =\n    match largest_axis vol with\n    | R -> (fun (r,_,_) -> r < mr)\n    | G -> (fun (_,g,_) -> g < mg)\n    | B -> (fun (_,_,b) -> b < mb)\n  in\n  let px1, px2 = List.partition part_func pixels in\n  (make_cluster px1, make_cluster px2)\n\nlet color_quant img n =\n  let width, height = get_dims img in\n  let clusters =\n    let lst = ref [] in\n    for x = 0 to pred width do\n      for y = 0 to pred height do\n        let rgb = float_rgb (get_pixel_unsafe img x y) in\n        lst := rgb :: !lst\n      done;\n    done;\n    ref [make_cluster !lst]\n  in\n  while (List.length !clusters) < n do\n    let dumb = (0.0,0.0,0.0) in\n    let unused = (dumb, neg_infinity, dumb, []) in\n    let select ((_,v1,_,_) as c1) ((_,v2,_,_) as c2) =\n      if v1 > v2 then c1 else c2\n    in\n    let cl = List.fold_left (fun c1 c2 -> select c1 c2) unused !clusters in\n    let cl1, cl2 = subdivide cl in\n    clusters := cl1 :: cl2 :: (rem_from cl !clusters)\n  done;\n  let module PxMap = Map.Make\n    (struct type t = float * float * float let compare = compare end) in\n  let m =\n    List.fold_left (fun m (mean, _, _, pixel_list) ->\n      let int_mean = int_rgb mean in\n      List.fold_left (fun m px -> PxMap.add px int_mean m) m pixel_list\n    ) PxMap.empty !clusters\n  in\n  let res = new_img ~width ~height in\n  for y = 0 to pred height do\n    for x = 0 to pred width do\n      let rgb = float_rgb (get_pixel_unsafe img x y) in\n      let mean_rgb = PxMap.find rgb m in\n      put_pixel_unsafe res mean_rgb x y;\n    done;\n  done;\n  (res)","type":"code"}],"source":"rosetta","code_keywords":{},"algorithm":["color-quantization"],"language":"OCaml"}}
,{"_index":"throwtable","_type":"implementation","_id":"rosetta:deepcopy:Common Lisp","_score":0,"_source":{"implementation":[{"content":"$ clisp -q\n[1]> (setf *print-circle* t)\nT\n[2]> (let ((a (cons 1 nil))) (setf (cdr a) a)) ;; create circular list\n#1=(1 . #1#)\n[3]> (read-from-string \"#1=(1 . #1#)\") ;; read it from a string\n#1=(1 . #1#) ;; a similar circular list is returned","type":"code"}],"source":"rosetta","code_keywords":{"Token.Comment.Single":null},"algorithm":["object-copying"],"language":"Common Lisp"}}
,{"_index":"throwtable","_type":"implementation","_id":"rosetta:color-quantization:C","_score":0,"_source":{"implementation":[{"content":"typedef struct oct_node_t oct_node_t, *oct_node;\nstruct oct_node_t{\n\t/* sum of all colors represented by this node. 64 bit in case of HUGE image */\n\tuint64_t r, g, b;\n\tint count, heap_idx;\n\toct_node kids[8], parent;\n\tunsigned char n_kids, kid_idx, flags, depth;\n};\n\n/* cmp function that decides the ordering in the heap.  This is how we determine\n   which octree node to fold next, the heart of the algorithm. */\ninline int cmp_node(oct_node a, oct_node b)\n{\n\tif (a->n_kids < b->n_kids) return -1;\n\tif (a->n_kids > b->n_kids) return 1;\n\n\tint ac = a->count * (1 + a->kid_idx) >> a->depth;\n\tint bc = b->count * (1 + b->kid_idx) >> b->depth;\n\treturn ac < bc ? -1 : ac > bc;\n}\n\n/* adding a color triple to octree */\noct_node node_insert(oct_node root, unsigned char *pix)\n{\n#\tdefine OCT_DEPTH 8\n\t/* 8: number of significant bits used for tree.  It's probably good enough\n\t   for most images to use a value of 5.  This affects how many nodes eventually\n\t   end up in the tree and heap, thus smaller values helps with both speed\n\t   and memory. */\n\n\tunsigned char i, bit, depth = 0;\n\tfor (bit = 1 << 7; ++depth < OCT_DEPTH; bit >>= 1) {\n\t\ti = !!(pix[1] & bit) * 4 + !!(pix[0] & bit) * 2 + !!(pix[2] & bit);\n\t\tif (!root->kids[i])\n\t\t\troot->kids[i] = node_new(i, depth, root);\n\n\t\troot = root->kids[i];\n\t}\n\n\troot->r += pix[0];\n\troot->g += pix[1];\n\troot->b += pix[2];\n\troot->count++;\n\treturn root;\n}\n\n/* remove a node in octree and add its count and colors to parent node. */\noct_node node_fold(oct_node p)\n{\n\tif (p->n_kids) abort();\n\toct_node q = p->parent;\n\tq->count += p->count;\n\n\tq->r += p->r;\n\tq->g += p->g;\n\tq->b += p->b;\n\tq->n_kids --;\n\tq->kids[p->kid_idx] = 0;\n\treturn q;\n}\n\n/* traverse the octree just like construction, but this time we replace the pixel\n   color with color stored in the tree node */\nvoid color_replace(oct_node root, unsigned char *pix)\n{\n\tunsigned char i, bit;\n\n\tfor (bit = 1 << 7; bit; bit >>= 1) {\n\t\ti = !!(pix[1] & bit) * 4 + !!(pix[0] & bit) * 2 + !!(pix[2] & bit);\n\t\tif (!root->kids[i]) break;\n\t\troot = root->kids[i];\n\t}\n\n\tpix[0] = root->r;\n\tpix[1] = root->g;\n\tpix[2] = root->b;\n}\n\n/* Building an octree and keep leaf nodes in a bin heap.  Afterwards remove first node\n   in heap and fold it into its parent node (which may now be added to heap), until heap\n   contains required number of colors. */\nvoid color_quant(image im, int n_colors)\n{\n\tint i;\n\tunsigned char *pix = im->pix;\n\tnode_heap heap = { 0, 0, 0 };\n\n\toct_node root = node_new(0, 0, 0), got;\n\tfor (i = 0; i < im->w * im->h; i++, pix += 3)\n\t\theap_add(&heap, node_insert(root, pix));\n\n\twhile (heap.n > n_colors + 1)\n\t\theap_add(&heap, node_fold(pop_heap(&heap)));\n\n\tdouble c;\n\tfor (i = 1; i < heap.n; i++) {\n\t\tgot = heap.buf[i];\n\t\tc = got->count;\n\t\tgot->r = got->r / c + .5;\n\t\tgot->g = got->g / c + .5;\n\t\tgot->b = got->b / c + .5;\n\t\tprintf(\"%2d | %3llu %3llu %3llu (%d pixels)\\n\",\n\t\t\ti, got->r, got->g, got->b, got->count);\n\t}\n\n\tfor (i = 0, pix = im->pix; i < im->w * im->h; i++, pix += 3)\n\t\tcolor_replace(root, pix);\n\n\tnode_free();\n\tfree(heap.buf);\n}","type":"code"}],"source":"rosetta","code_keywords":{"comment":"null"},"algorithm":["color-quantization"],"language":"C"}}
,{"_index":"throwtable","_type":"implementation","_id":"rosetta:color-quantization:D","_score":0,"_source":{"implementation":[{"type":"description","value":"Functional Version"},{"content":"import core.stdc.stdio, std.stdio, std.algorithm, std.typecons,\n       std.math, std.range, std.conv, std.string, bitmap;\n\nstruct Col { float r, g, b; }\nalias Cluster = Tuple!(Col, float, Col, Col[]);\nenum Axis { R, G, B }\n\nenum round = (in float x) pure nothrow @safe @nogc => cast(int)floor(x + 0.5);\n\nenum roundRGB = (in Col c) pure nothrow @safe @nogc =>\n    RGB(cast(ubyte)round(c.r),\n        cast(ubyte)round(c.g),\n        cast(ubyte)round(c.b));\n\nenum addRGB = (in Col c1, in Col c2) pure nothrow @safe @nogc =>\n    Col(c1.r + c2.r, c1.g + c2.g, c1.b + c2.b);\n\nCol meanRGB(in Col[] pxList) pure nothrow @safe @nogc {\n    immutable tot = reduce!addRGB(Col(0, 0, 0), pxList);\n    immutable n = pxList.length;\n    return Col(tot.r / n, tot.g / n, tot.b / n);\n}\n\nenum minC = (in Col c1, in Col c2) pure nothrow @safe @nogc =>\n    Col(min(c1.r, c2.r), min(c1.g, c2.g), min(c1.b, c2.b));\n\nenum maxC = (in Col c1, in Col c2) pure nothrow @safe @nogc =>\n    Col(max(c1.r, c2.r), max(c1.g, c2.g), max(c1.b, c2.b));\n\nTuple!(Col, Col) extrems(in Col[] lst) pure nothrow @safe @nogc {\n    enum FI = float.infinity;\n    auto mmRGB = typeof(return)(Col(FI, FI, FI), Col(-FI, -FI, -FI));\n    return reduce!(minC, maxC)(mmRGB, lst);\n}\n\nTuple!(float, Col) volumeAndDims(in Col[] lst) pure nothrow @safe @nogc {\n    immutable e = lst.extrems;\n    immutable r = Col(e[1].r - e[0].r,\n                      e[1].g - e[0].g,\n                      e[1].b - e[0].b);\n    return typeof(return)(r.r * r.g * r.b, r);\n}\n\nCluster makeCluster(Col[] pixelList) pure nothrow @safe @nogc {\n    immutable vol_dims = pixelList.volumeAndDims;\n    immutable int len = pixelList.length;\n    return typeof(return)(pixelList.meanRGB,\n                          len * vol_dims[0],\n                          vol_dims[1],\n                          pixelList);\n}\n\nenum fCmp = (in float a, in float b) pure nothrow @safe @nogc =>\n    (a > b) ? 1 : (a < b ? -1 : 0);\n\nAxis largestAxis(in Col c) pure nothrow @safe @nogc {\n    immutable int r1 = fCmp(c.r, c.g);\n    immutable int r2 = fCmp(c.r, c.b);\n    if (r1 ==  1 && r2 ==  1) return Axis.R;\n    if (r1 == -1 && r2 ==  1) return Axis.G;\n    if (r1 ==  1 && r2 == -1) return Axis.B;\n    return (fCmp(c.g, c.b) == 1) ? Axis.G : Axis.B;\n}\n\nTuple!(Cluster, Cluster) subdivide(in Col c, in float nVolProd,\n                                   in Col vol, Col[] pixels)\npure nothrow @safe @nogc {\n    Col[] px2;\n    final switch (largestAxis(vol)) {\n        case Axis.R: px2 = pixels.partition!(c1 => c1.r < c.r); break;\n        case Axis.G: px2 = pixels.partition!(c1 => c1.g < c.g); break;\n        case Axis.B: px2 = pixels.partition!(c1 => c1.b < c.b); break;\n    }\n    auto px1 = pixels[0 .. $ - px2.length];\n    return typeof(return)(px1.makeCluster, px2.makeCluster);\n}\n\nuint RGB2uint(in RGB c) pure nothrow @safe @nogc {\n    return c.r | (c.g << 8) | (c.b << 16);\n}\n\nenum uintToRGB = (in uint c) pure nothrow @safe @nogc =>\n    RGB(c & 0xFF, (c >> 8) & 0xFF, (c >> 16) & 0xFF);\n\nImage!RGB colorQuantize(in Image!RGB img, in int n) pure nothrow /*@safe*/ {\n    immutable width = img.nx;\n    immutable height = img.ny;\n\n    auto cols = new Col[width * height];\n    foreach (immutable i, ref c; img.image)\n        cols[i] = Col(c.tupleof);\n\n    immutable dumb = Col(0, 0, 0);\n    Cluster unused = Cluster(dumb, -float.infinity, dumb, (Col[]).init);\n\n    auto clusters = [cols.makeCluster];\n    while (clusters.length < n) {\n        // Cluster cl = clusters.reduce!(max!q{ a[1] })(unused);\n        Cluster cl = reduce!((c1, c2) => c1[1] > c2[1] ? c1 : c2)\n                            (unused, clusters);\n        clusters = [cl[].subdivide[]] ~\n            clusters.remove!(c => c == cl, SwapStrategy.unstable); //**\n    }\n\n    uint[uint] pixMap; // Faster than RGB[RGB].\n    ubyte[4] u4a, u4b;\n    foreach (const cluster; clusters) {\n        immutable ubyteMean = cluster[0].roundRGB.RGB2uint;\n        foreach (immutable col; cluster[3])\n            pixMap[col.roundRGB.RGB2uint] = ubyteMean;\n    }\n\n    auto result = new Image!RGB;\n    result.allocate(height, width);\n\n    foreach (immutable i, immutable p; img.image) {\n        immutable u3a = p.tupleof.RGB;\n        result.image[i] = pixMap[RGB2uint(u3a)].uintToRGB;\n    }\n\n    return result;\n}\n\nvoid main(in string[] args) {\n    string fileName;\n    int nCols;\n    switch (args.length) {\n        case 1:\n            fileName = \"quantum_frog.ppm\";\n            nCols = 16;\n            break;\n        case 3:\n            fileName = args[1];\n            nCols = args[2].to!int;\n            break;\n        default:\n            \"Usage: color_quantization image.ppm ncolors\".writeln;\n            return;\n    }\n\n    auto im = new Image!RGB;\n    im.loadPPM6(fileName);\n    const imq = colorQuantize(im, nCols);\n    imq.savePPM6(\"quantum_frog_quantized.ppm\");\n}","type":"code"},{"type":"description","value":"Imperative Version"},{"content":"import core.stdc.stdlib: malloc, calloc, realloc, free, abort;\nimport std.stdio: stderr, File;\nimport std.ascii: isWhite;\nimport std.math: abs;\nimport std.conv: to;\nimport std.string: split, strip;\nimport std.exception: enforce;\nimport std.array: empty;\nimport std.typetuple: TypeTuple;\n\nenum ON_INHEAP = 1;\n\nstruct Image {\n    uint w, h;\n    ubyte[0] pix;\n}\n\nImage* imageNew(in uint w, in uint h) nothrow @nogc\nin {\n    assert(w > 0 && h > 0);\n} out(result) {\n    assert(result != null);\n} body {\n    auto im = cast(Image*)malloc(Image.sizeof + w * h * 3);\n    im.w = w;\n    im.h = h;\n    return im;\n}\n\nImage* readPPM6(in string fileName)\nin {\n    assert(!fileName.empty);\n} out(result) {\n    assert(result != null);\n} body {\n    auto fIn = File(fileName, \"rb\");\n    enforce(fIn.readln.strip == \"P6\");\n\n    // Skip comments.\n    string line;\n    do {\n        line = fIn.readln;\n    } while (line.length && line[0] == '#');\n\n    const size = line.split.to!(uint[]);\n    enforce(size.length == 2);\n    //immutable size = line.split.to!(uint[2]);\n    auto img = imageNew(size[0], size[1]);\n    enforce(fIn.readln.strip == \"255\");\n    fIn.rawRead(img.pix.ptr[0 .. img.w * img.h * 3]);\n    return img;\n}\n\nvoid writePPM6(in Image* img, in string fileName)\nin {\n    assert(!fileName.empty);\n    assert(img != null);\n} body {\n    auto fOut = File(fileName, \"wb\");\n    fOut.writefln(\"P6\\n%d %d\\n255\", img.w, img.h);\n    fOut.rawWrite(img.pix.ptr[0 .. img.w * img.h * 3]);\n    fOut.close;\n}\n\nstruct OctreeNode {\n    long r, g, b; // Sum of all child node colors.\n    uint count, heapIdx;\n    ubyte nKids, kidIdx, flags, depth;\n    OctreeNode*[8] kids;\n    OctreeNode* parent;\n}\n\nstruct HeapNode {\n    uint alloc, n;\n    OctreeNode** buf;\n}\n\nint cmpOctreeNode(in OctreeNode* a, in OctreeNode* b)\npure nothrow @safe @nogc\nin {\n    assert(a != null);\n    assert(b != null);\n} out(result) {\n    assert(result == -1 || result == 0 || result == 1);\n} body {\n    if (a.nKids < b.nKids)\n        return -1;\n    if (a.nKids > b.nKids)\n        return 1;\n\n    immutable uint ac = a.count >> a.depth;\n    immutable uint bc = b.count >> b.depth;\n    return (ac < bc) ? -1 : (ac > bc);\n}\n\nvoid downHeap(HeapNode* h, OctreeNode* p) pure nothrow @nogc\nin {\n    assert(h != null);\n    assert(p != null);\n} body {\n    auto n = p.heapIdx;\n\n    while (true) {\n        uint m = n * 2;\n        if (m >= h.n)\n            break;\n        if (m + 1 < h.n && cmpOctreeNode(h.buf[m], h.buf[m + 1]) > 0)\n            m++;\n\n        if (cmpOctreeNode(p, h.buf[m]) <= 0)\n            break;\n\n        h.buf[n] = h.buf[m];\n        h.buf[n].heapIdx = n;\n        n = m;\n    }\n\n    h.buf[n] = p;\n    p.heapIdx = n;\n}\n\nvoid upHeap(HeapNode* h, OctreeNode* p) pure nothrow @nogc\nin {\n    assert(h != null);\n    assert(p != null);\n} body {\n    auto n = p.heapIdx;\n\n    while (n > 1) {\n        auto prev = h.buf[n / 2];\n        if (cmpOctreeNode(p, prev) >= 0)\n            break;\n\n        h.buf[n] = prev;\n        prev.heapIdx = n;\n        n /= 2;\n    }\n\n    h.buf[n] = p;\n    p.heapIdx = n;\n}\n\nvoid addHeap(HeapNode* h, OctreeNode* p) nothrow @nogc\nin {\n    assert(h != null);\n    assert(p != null);\n} body {\n    if ((p.flags & ON_INHEAP)) {\n        downHeap(h, p);\n        upHeap(h, p);\n        return;\n    }\n\n    p.flags |= ON_INHEAP;\n    if (!h.n)\n        h.n = 1;\n    if (h.n >= h.alloc) {\n        while (h.n >= h.alloc)\n            h.alloc += 1024;\n        h.buf = cast(OctreeNode**)realloc(h.buf, (OctreeNode*).sizeof * h.alloc);\n        assert(h.buf != null);\n    }\n\n    p.heapIdx = h.n;\n    h.buf[h.n++] = p;\n    upHeap(h, p);\n}\n\nOctreeNode* popHeap(HeapNode* h) pure nothrow @nogc\nin {\n    assert(h != null);\n} out(result) {\n    assert(result != null);\n} body {\n    if (h.n <= 1)\n        return null;\n\n    auto ret = h.buf[1];\n    h.buf[1] = h.buf[--h.n];\n\n    h.buf[h.n] = null;\n\n    h.buf[1].heapIdx = 1;\n    downHeap(h, h.buf[1]);\n\n    return ret;\n}\n\nOctreeNode* octreeNodeNew(in ubyte idx, in ubyte depth, OctreeNode* p,\n                          ref OctreeNode[] pool) nothrow @nogc\nout(result) {\n    assert(result != null);\n} body {\n    __gshared static uint len = 0;\n\n    if (len <= 1) {\n        OctreeNode* p2 = cast(OctreeNode*)calloc(OctreeNode.sizeof, 2048);\n        assert(p2 != null);\n        p2.parent = pool.ptr;\n        pool = p2[0 .. 2048];\n        len = 2047;\n    }\n\n    OctreeNode* x = pool.ptr + len--;\n    x.kidIdx = idx;\n    x.depth = depth;\n    x.parent = p;\n    if (p)\n        p.nKids++;\n    return x;\n}\n\nvoid octreeNodeFree(ref OctreeNode[] pool) nothrow @nogc\nout {\n    assert(pool.empty);\n} body {\n    auto poolPtr = pool.ptr;\n\n    while (poolPtr) {\n        auto p = poolPtr.parent;\n        free(poolPtr);\n        poolPtr = p;\n    }\n\n    pool = null;\n}\n\nOctreeNode* octreeNodeInsert(OctreeNode* root, in ubyte* pix, ref OctreeNode[] pool)\nnothrow @nogc\nin {\n    assert(root != null);\n    assert(pix != null);\n    assert(!pool.empty);\n} out(result) {\n    assert(result != null);\n} body {\n    ubyte depth = 0;\n\n    for (ubyte bit = (1 << 7); ++depth < 8; bit >>= 1) {\n        immutable ubyte i = !!(pix[1] & bit) * 4 +\n                            !!(pix[0] & bit) * 2 +\n                            !!(pix[2] & bit);\n        if (!root.kids[i])\n            root.kids[i] = octreeNodeNew(i, depth, root, pool);\n\n        root = root.kids[i];\n    }\n\n    root.r += pix[0];\n    root.g += pix[1];\n    root.b += pix[2];\n    root.count++;\n    return root;\n}\n\nOctreeNode* octreeNodeFold(OctreeNode* p) nothrow @nogc\nin {\n    assert(p != null);\n} out(result) {\n    assert(result != null);\n} body {\n    if (p.nKids)\n        abort();\n    auto q = p.parent;\n    q.count += p.count;\n\n    q.r += p.r;\n    q.g += p.g;\n    q.b += p.b;\n    q.nKids--;\n    q.kids[p.kidIdx] = null;\n    return q;\n}\n\nvoid colorReplace(OctreeNode* root, ubyte* pix) pure nothrow @nogc\nin {\n    assert(root != null);\n    assert(pix != null);\n} body {\n    for (ubyte bit = (1 << 7); bit; bit >>= 1) {\n        immutable i = !!(pix[1] & bit) * 4 +\n                      !!(pix[0] & bit) * 2 +\n                      !!(pix[2] & bit);\n        if (!root.kids[i])\n            break;\n        root = root.kids[i];\n    }\n\n    pix[0] = cast(ubyte)root.r;\n    pix[1] = cast(ubyte)root.g;\n    pix[2] = cast(ubyte)root.b;\n}\n\nvoid errorDiffuse(Image* im, HeapNode* h) nothrow @nogc\nin {\n    assert(im != null);\n    assert(h != null);\n} body {\n    OctreeNode* nearestColor(in int* v) nothrow @nogc\n    in {\n        assert(v != null);\n    } out(result) {\n        assert(result != null);\n    } body {\n        auto max = long.max;\n        typeof(return) on = null;\n\n        foreach (immutable uint i; 1 .. h.n) {\n            immutable diff = 3 * abs(h.buf[i].r - v[0]) +\n                             5 * abs(h.buf[i].g - v[1]) +\n                             2 * abs(h.buf[i].b - v[2]);\n            if (diff < max) {\n                max = diff;\n                on = h.buf[i];\n            }\n        }\n\n        return on;\n    }\n\n    uint pos(in uint i, in uint j) nothrow @safe @nogc {\n        return 3 * (i * im.w + j);\n    }\n\n    enum C10 = 7;\n    enum C01 = 5;\n    enum C11 = 2;\n    enum C00 = 1;\n    enum CTOTAL = C00 + C11 + C10 + C01;\n\n    auto npx = cast(int*)calloc(int.sizeof, im.h * im.w * 3);\n    assert(npx != null);\n    auto pix = im.pix.ptr;\n    alias triple = TypeTuple!(0, 1, 2);\n\n    for (auto px = npx, i = 0u; i < im.h; i++) {\n        for (uint j = 0; j < im.w; j++, pix += 3, px += 3) {\n            /*static*/ foreach (immutable k; triple)\n                px[k] = cast(int)pix[k] * CTOTAL;\n        }\n    }\n\n    static void clamp(ref int x) pure nothrow @safe @nogc {\n        if (x > 255) x = 255;\n        if (x < 0)   x = 0;\n    }\n\n    pix = im.pix.ptr;\n\n    for (auto px = npx, i = 0u; i < im.h; i++) {\n        for (uint j = 0; j < im.w; j++, pix += 3, px += 3) {\n            /*static*/ foreach (immutable k; triple)\n                px[k] /= CTOTAL;\n            /*static*/ foreach (immutable k; triple)\n                clamp(px[k]);\n\n            const nd = nearestColor(px);\n            uint[3] v = void;\n            v[0] = cast(uint)(px[0] - nd.r);\n            v[1] = cast(uint)(px[1] - nd.g);\n            v[2] = cast(uint)(px[2] - nd.b);\n\n            pix[0] = cast(ubyte)nd.r;\n            pix[1] = cast(ubyte)nd.g;\n            pix[2] = cast(ubyte)nd.b;\n\n            if (j < im.w - 1) {\n                /*static*/ foreach (immutable k; triple)\n                    npx[pos(i, j + 1) + k] += v[k] * C10;\n            }\n\n            if (i >= im.h - 1)\n                continue;\n\n            /*static*/ foreach (immutable k; triple)\n                npx[pos(i + 1, j) + k] += v[k] * C01;\n\n            if (j < im.w - 1) {\n                /*static*/ foreach (immutable k; triple)\n                    npx[pos(i + 1, j + 1) + k] += v[k] * C11;\n            }\n\n            if (j) {\n                /*static*/ foreach (immutable k; triple)\n                    npx[pos(i + 1, j - 1) + k] += v[k] * C00;\n            }\n        }\n    }\n\n    free(npx);\n}\n\nvoid colorQuant(Image* im, in uint nColors, in bool dither) nothrow @nogc\nin {\n    assert(im != null);\n    assert(nColors > 1);\n} body {\n    auto pix = im.pix.ptr;\n    HeapNode heap = { 0, 0, null };\n    OctreeNode[] pool;\n\n    auto root = octreeNodeNew(0, 0, null, pool);\n    for (uint i = 0; i < im.w * im.h; i++, pix += 3)\n        addHeap(&heap, octreeNodeInsert(root, pix, pool));\n\n    while (heap.n > nColors + 1)\n        addHeap(&heap, octreeNodeFold(popHeap(&heap)));\n\n    foreach (immutable i; 1 .. heap.n) {\n        auto got = heap.buf[i];\n        immutable double c = got.count;\n        got.r = cast(long)(got.r / c + 0.5);\n        got.g = cast(long)(got.g / c + 0.5);\n        got.b = cast(long)(got.b / c + 0.5);\n    }\n\n    if (dither)\n        errorDiffuse(im, &heap);\n    else {\n        uint i;\n        for (i = 0, pix = im.pix.ptr; i < im.w * im.h; i++, pix += 3)\n            colorReplace(root, pix);\n    }\n\n    pool.octreeNodeFree;\n    heap.buf.free;\n}\n\nint main(in string[] args) {\n    if (args.length < 3 || args.length > 4) {\n        stderr.writeln(\"Usage: quant ppmFile nColors [dith]\");\n        return 1;\n    }\n\n    immutable nColors = args[2].to!uint;\n    assert(nColors > 1);\n\n    auto im = readPPM6(args[1]);\n    immutable useDithering = (args.length == 4) ? (args[3] == \"dith\") : false;\n    immutable fileNameOut = useDithering ? \"outd.ppm\" : \"out.ppm\";\n\n    colorQuant(im, nColors, useDithering);\n    writePPM6(im, fileNameOut);\n\n    im.free;\n    return 0;\n}","type":"code"}],"source":"rosetta","code_keywords":{},"algorithm":["color-quantization"],"language":"D"}}
,{"_index":"throwtable","_type":"implementation","_id":"rosetta:color-quantization:Go","_score":0,"_source":{"implementation":[{"content":"package main\n\nimport (\n    \"container/heap\"\n    \"image\"\n    \"image/color\"\n    \"image/png\"\n    \"log\"\n    \"math\"\n    \"os\"\n    \"sort\"\n)\n\nfunc main() {\n    f, err := os.Open(\"Quantum_frog.png\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    img, err := png.Decode(f)\n    f.Close()\n    if err != nil {\n        log.Fatal(err)\n    }\n    fq, err := os.Create(\"frog256.png\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    err = png.Encode(fq, quant(img, 256))\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\n// Organize quatization in some logical steps.\nfunc quant(img image.Image, nq int) image.Image {\n    qz := newQuantizer(img, nq) // set up a work space\n    qz.cluster()                // cluster pixels by color\n    return qz.Paletted()        // generate paletted image from clusters\n}\n\n// A workspace with members that can be accessed by methods.\ntype quantizer struct {\n    img image.Image // original image\n    cs  []cluster   // len is the desired number of colors\n    px  []point     // list of all points in the image\n    ch  chValues    // buffer for computing median\n    eq  []point     // additional buffer used when splitting cluster\n}\n\ntype cluster struct {\n    px       []point // list of points in the cluster\n    widestCh int     // rx, gx, bx const for channel with widest value range\n    chRange  uint32  // value range (vmax-vmin) of widest channel\n}\n\ntype point struct{ x, y int }\ntype chValues []uint32\ntype queue []*cluster\n\nconst (\n    rx = iota\n    gx\n    bx\n)\n\nfunc newQuantizer(img image.Image, nq int) *quantizer {\n    b := img.Bounds()\n    npx := (b.Max.X - b.Min.X) * (b.Max.Y - b.Min.Y)\n    // Create work space.\n    qz := &quantizer{\n        img: img,\n        ch:  make(chValues, npx),\n        cs:  make([]cluster, nq),\n    }\n    // Populate initial cluster with all pixels from image.\n    c := &qz.cs[0]\n    px := make([]point, npx)\n    c.px = px\n    i := 0\n    for y := b.Min.Y; y < b.Max.Y; y++ {\n        for x := b.Min.X; x < b.Max.X; x++ {\n            px[i].x = x\n            px[i].y = y\n            i++\n        }\n    }\n    return qz\n}\n\nfunc (qz *quantizer) cluster() {\n    // Cluster by repeatedly splitting clusters.\n    // Use a heap as priority queue for picking clusters to split.\n    // The rule will be to spilt the cluster with the most pixels.\n    // Terminate when the desired number of clusters has been populated\n    // or when clusters cannot be further split.\n    pq := new(queue)\n    // Initial cluster.  populated at this point, but not analyzed.\n    c := &qz.cs[0]\n    for i := 1; ; {\n        qz.setColorRange(c)\n        // Cluster cannot be split if all pixels are the same color.\n        // Only enqueue clusters that can be split.\n        if c.chRange > 0 {\n            heap.Push(pq, c) // add new cluster to queue\n        }\n        // If no clusters have any color variation, mark the end of the\n        // cluster list and quit early.\n        if len(*pq) == 0 {\n            qz.cs = qz.cs[:i]\n            break\n        }\n        s := heap.Pop(pq).(*cluster) // get cluster to split\n        c = &qz.cs[i]                // set c to new cluster\n        i++\n        m := qz.Median(s)\n        qz.Split(s, c, m) // split s into c and s\n        // If that was the last cluster, we're done.\n        if i == len(qz.cs) {\n            break\n        }\n        qz.setColorRange(s)\n        if s.chRange > 0 {\n            heap.Push(pq, s) // return to queue\n        }\n    }\n}\n    \nfunc (q *quantizer) setColorRange(c *cluster) {\n    // Find extents of color values in each channel.\n    var maxR, maxG, maxB uint32\n    minR := uint32(math.MaxUint32)\n    minG := uint32(math.MaxUint32)\n    minB := uint32(math.MaxUint32) \n    for _, p := range c.px {\n        r, g, b, _ := q.img.At(p.x, p.y).RGBA()\n        if r < minR { \n            minR = r\n        }\n        if r > maxR {\n            maxR = r\n        }\n        if g < minG {\n            minG = g \n        }\n        if g > maxG {\n            maxG = g\n        }\n        if b < minB {\n            minB = b\n        }\n        if b > maxB {\n            maxB = b\n        }\n    }\n    // See which channel had the widest range.\n    s := gx\n    min := minG\n    max := maxG\n    if maxR-minR > max-min {\n        s = rx\n        min = minR\n        max = maxR\n    }\n    if maxB-minB > max-min {\n        s = bx\n        min = minB\n        max = maxB\n    }\n    c.widestCh = s\n    c.chRange = max - min // also store the range of that channel\n}\n\nfunc (q *quantizer) Median(c *cluster) uint32 {\n    px := c.px\n    ch := q.ch[:len(px)]\n    // Copy values from appropriate channel to buffer for computing median.\n    switch c.widestCh {\n    case rx:\n        for i, p := range c.px {\n            ch[i], _, _, _ = q.img.At(p.x, p.y).RGBA()\n        }\n    case gx:\n        for i, p := range c.px {\n            _, ch[i], _, _ = q.img.At(p.x, p.y).RGBA()\n        }\n    case bx:\n        for i, p := range c.px {\n            _, _, ch[i], _ = q.img.At(p.x, p.y).RGBA()\n        }\n    }\n    // Median algorithm.\n    sort.Sort(ch)\n    half := len(ch) / 2\n    m := ch[half]\n    if len(ch)%2 == 0 {\n        m = (m + ch[half-1]) / 2\n    }\n    return m\n}\n\nfunc (q *quantizer) Split(s, c *cluster, m uint32) {\n    px := s.px\n    var v uint32\n    i := 0\n    lt := 0\n    gt := len(px) - 1\n    eq := q.eq[:0] // reuse any existing buffer\n    for i <= gt {\n        // Get pixel value of appropriate channel.\n        r, g, b, _ := q.img.At(px[i].x, px[i].y).RGBA()\n        switch s.widestCh {\n        case rx:\n            v = r\n        case gx:\n            v = g\n        case bx:\n            v = b\n        } \n        // Categorize each pixel as either <, >, or == median.\n        switch {\n        case v < m:\n            px[lt] = px[i]\n            lt++\n            i++\n        case v > m:\n            px[gt], px[i] = px[i], px[gt]\n            gt--\n        default:\n            eq = append(eq, px[i])\n            i++\n        }\n    }\n    // Handle values equal to the median.\n    if len(eq) > 0 {\n        copy(px[lt:], eq) // move them back between the lt and gt values.\n        // Then, if the number of gt values is < the number of lt values,\n        // fix up i so that the split will include the eq values with\n        // the gt values.\n        if len(px)-i < lt {\n            i = lt\n        }\n        q.eq = eq // squirrel away (possibly expanded) buffer for reuse\n    }\n    // Split the pixel list.\n    s.px = px[:i]\n    c.px = px[i:]\n}   \n    \nfunc (qz *quantizer) Paletted() *image.Paletted {\n    cp := make(color.Palette, len(qz.cs))\n    pi := image.NewPaletted(qz.img.Bounds(), cp)\n    for i := range qz.cs {\n        px := qz.cs[i].px\n        // Average values in cluster to get palette color.\n        var rsum, gsum, bsum int64\n        for _, p := range px {\n            r, g, b, _ := qz.img.At(p.x, p.y).RGBA()\n            rsum += int64(r)\n            gsum += int64(g)\n            bsum += int64(b)\n        } \n        n64 := int64(len(px))\n        cp[i] = color.NRGBA64{\n            uint16(rsum / n64),\n            uint16(gsum / n64),\n            uint16(bsum / n64),\n            0xffff,\n        }\n        // set image pixels\n        for _, p := range px {\n            pi.SetColorIndex(p.x, p.y, uint8(i))\n        }\n    }\n    return pi\n}\n\n// Implement sort.Interface for sort in median algorithm.\nfunc (c chValues) Len() int           { return len(c) }\nfunc (c chValues) Less(i, j int) bool { return c[i] < c[j] }\nfunc (c chValues) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }\n\n// Implement heap.Interface for priority queue of clusters.\nfunc (q queue) Len() int { return len(q) }\n\n// Less implements rule to select cluster with greatest number of pixels.\nfunc (q queue) Less(i, j int) bool {\n    return len(q[j].px) < len(q[i].px)\n}\n\nfunc (q queue) Swap(i, j int) {\n    q[i], q[j] = q[j], q[i]\n}\nfunc (pq *queue) Push(x interface{}) {\n    c := x.(*cluster)\n    *pq = append(*pq, c)\n}\nfunc (pq *queue) Pop() interface{} {\n    q := *pq\n    n := len(q) - 1\n    c := q[n]\n    *pq = q[:n]\n    return c\n}","type":"code"}],"source":"rosetta","code_keywords":{},"algorithm":["color-quantization"],"language":"Go"}}
]
